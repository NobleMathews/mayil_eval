{
    "id": "psf__requests-1963",
    "repo_name": "testbed/psf__requests__2.3",
    "task_id": 82639360055332406,
    "title": "`Session.resolve_redirects` copies the original request for all subsequent requests, can cause incorrect method selection",
    "body": "Consider the following redirection chain:\n\n```\nPOST /do_something HTTP/1.1\nHost: server.example.com\n...\n\nHTTP/1.1 303 See Other\nLocation: /new_thing_1513\n\nGET /new_thing_1513\nHost: server.example.com\n...\n\nHTTP/1.1 307 Temporary Redirect\nLocation: //failover.example.com/new_thing_1513\n```\n\nThe intermediate 303 See Other has caused the POST to be converted to\na GET.  The subsequent 307 should preserve the GET.  However, because\n`Session.resolve_redirects` starts each iteration by copying the _original_\nrequest object, Requests will issue a POST!\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/psf__requests__2.3.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `rebuild_method` function in `requests/sessions.py` to handle the 307 Temporary Redirect status code correctly by preserving the original HTTP method.\n- Add an additional condition to check for the 307 status code and ensure the method is not changed if the original method is POST.\n\n```python\ndef rebuild_method(self, prepared_request, response):\n    \"\"\"When being redirected we may want to change the method of the request\n    based on certain specs or browser behavior.\n    \"\"\"\n    method = prepared_request.method\n\n    # https://tools.ietf.org/html/rfc7231#section-6.4.4\n    if response.status_code == codes.see_other and method != \"HEAD\":\n        method = \"GET\"\n\n    # Add check for 307 Temporary Redirect\n    # Preserve the method for 307 Temporary Redirect\n    if response.status_code == codes.temporary_redirect:\n        method = prepared_request.method\n\n    # Do what the browsers do, despite standards...\n    # First, turn 302s into GETs.\n    if response.status_code == codes.found and method != \"HEAD\":\n        method = \"GET\"\n\n    # Second, if a POST is responded to with a 301, turn it into a GET.\n    # This bizarre behaviour is explained in Issue 1704.\n    if response.status_code == codes.moved and method == \"POST\":\n        method = \"GET\"\n\n    prepared_request.method = method\n```\n\n- Ensure that the `resolve_redirects` method in `requests/sessions.py` calls `rebuild_method` after each redirect to apply the correct HTTP method for the subsequent request.\n\n### Code snippets to check\n\n-  \u2192 [requests](https://github.com/testbed/psf__requests__2.3/tree//requests)- [Lines 334 - 354](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L334-L354)\n\n This snippet contains the logic for changing the HTTP method during redirection, which is directly related to the issue of incorrect method selection after a redirect. \n\n\n   - [Lines 178 - 245](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L178-L245)\n\n This snippet includes the process of handling redirects and calling `rebuild_method`, which is relevant to the issue as it may be where the original request object is incorrectly copied for subsequent requests. \n\n\n   - [Lines 159 - 520](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L159-L520)\n\n This snippet defines the `resolve_redirects` method, which is likely where the issue originates as it handles the entire redirection process. \n\n\n   - [Lines 107 - 157](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L107-L157)\n\n This snippet contains the logic for getting the redirect target, which may be relevant to understand how the redirection URL is processed and could influence the method change logic.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005065,
        "snippet_processor": 0.06367,
        "issue_star_creation": 0.03662,
        "issue_star_solver": 0.06259,
        "bouncer": 0.0286
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711761554.945207,
        "relevant_snippets": [
            {
                "code": "def rebuild_method(self, prepared_request, response):\n        \"\"\"When being redirected we may want to change the method of the request\n        based on certain specs or browser behavior.\n        \"\"\"\n        method = prepared_request.method\n\n        # https://tools.ietf.org/html/rfc7231#section-6.4.4\n        if response.status_code == codes.see_other and method != \"HEAD\":\n            method = \"GET\"\n\n        # Do what the browsers do, despite standards...\n        # First, turn 302s into GETs.\n        if response.status_code == codes.found and method != \"HEAD\":\n            method = \"GET\"\n\n        # Second, if a POST is responded to with a 301, turn it into a GET.\n        # This bizarre behaviour is explained in Issue 1704.\n        if response.status_code == codes.moved and method == \"POST\":\n            method = \"GET\"\n\n        prepared_request.method = method",
                "filename": "requests/sessions.py",
                "start_index": 12385,
                "end_index": 13252,
                "start_line": 334,
                "end_line": 354,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)",
                "filename": "requests/sessions.py",
                "start_index": 5959,
                "end_index": 8935,
                "start_line": 178,
                "end_line": 245,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "class SessionRedirectMixin:",
                "filename": "requests/sessions.py",
                "start_index": 2965,
                "end_index": 2992,
                "start_line": 106,
                "end_line": 106,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "class Session(SessionRedirectMixin):",
                "filename": "requests/sessions.py",
                "start_index": 13255,
                "end_index": 13291,
                "start_line": 357,
                "end_line": 357,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "def rebuild_auth(self, prepared_request, response):\n        \"\"\"When being redirected we may want to strip authentication from the\n        request to avoid leaking credentials. This method intelligently removes\n        and reapplies authentication where possible to avoid credential loss.\n        \"\"\"\n        headers = prepared_request.headers\n        url = prepared_request.url\n\n        if \"Authorization\" in headers and self.should_strip_auth(\n            response.request.url, url\n        ):\n            # If we get redirected to a new host, we should strip out any\n            # authentication headers.\n            del headers[\"Authorization\"]\n\n        # .netrc might have more auth for us on our new host.\n        new_auth = get_netrc_auth(url) if self.trust_env else None\n        if new_auth is not None:\n            prepared_request.prepare_auth(new_auth)\n\n    def rebuild_proxies(self, prepared_request, proxies):\n        \"\"\"This method re-evaluates the proxy configuration by considering the\n        environment variables. If we are redirected to a URL covered by\n        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n        proxy keys for this URL (in case they were stripped by a previous\n        redirect).\n\n        This method also replaces the Proxy-Authorization header where\n        necessary.\n\n        :rtype: dict\n        \"\"\"\n        headers = prepared_request.headers\n        scheme = urlparse(prepared_request.url).scheme\n        new_proxies = resolve_proxies(prepared_request, proxies, self.trust_env)\n\n        if \"Proxy-Authorization\" in headers:\n            del headers[\"Proxy-Authorization\"]\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        # urllib3 handles proxy authorization for us in the standard adapter.\n        # Avoid appending this to TLS tunneled requests where it may be leaked.\n        if not scheme.startswith(\"https\") and username and password:\n            headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)\n\n        return new_proxies",
                "filename": "requests/sessions.py",
                "start_index": 10248,
                "end_index": 12379,
                "start_line": 283,
                "end_line": 332,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):",
                "filename": "requests/sessions.py",
                "start_index": 5469,
                "end_index": 5701,
                "start_line": 159,
                "end_line": 520,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "\"\"\"\nrequests.sessions\n~~~~~~~~~~~~~~~~~\n\nThis module provides a Session object to manage and persist settings across\nrequests (cookies, auth, proxies).\n\"\"\"\nimport os\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom datetime import timedelta\n\nfrom ._internal_utils import to_native_string\nfrom .adapters import HTTPAdapter\nfrom .auth import _basic_auth_str\nfrom .compat import Mapping, cookielib, urljoin, urlparse\nfrom .cookies import (\n    RequestsCookieJar,\n    cookiejar_from_dict,\n    extract_cookies_to_jar,\n    merge_cookies,\n)\nfrom .exceptions import (\n    ChunkedEncodingError,\n    ContentDecodingError,\n    InvalidSchema,\n    TooManyRedirects,\n)\nfrom .hooks import default_hooks, dispatch_hook\n\n# formerly defined here, reexposed here for backward compatibility\nfrom .models import (  # noqa: F401\n    DEFAULT_REDIRECT_LIMIT,\n    REDIRECT_STATI,\n    PreparedRequest,\n    Request,\n)\nfrom .status_codes import codes\nfrom .structures import CaseInsensitiveDict\nfrom .utils import (  # noqa: F401\n    DEFAULT_PORTS,\n    default_headers,\n    get_auth_from_url,\n    get_environ_proxies,\n    get_netrc_auth,\n    requote_uri,\n    resolve_proxies,\n    rewind_body,\n    should_bypass_proxies,\n    to_key_val_list,\n)\n\n# Preferred clock, based on which one is more accurate on a given system.\nif sys.platform == \"win32\":\n    preferred_clock = time.perf_counter\nelse:\n    preferred_clock = time.time\n\n\ndef merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"Determines appropriate setting for a given request, taking into account\n    the explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n\n    if session_setting is None:\n        return request_setting\n\n    if request_setting is None:\n        return session_setting\n\n    # Bypass if not a dictionary (e.g. verify)\n    if not (\n        isinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)\n    ):\n        return request_setting\n\n    merged_setting = dict_class(to_key_val_list(session_setting))\n    merged_setting.update(to_key_val_list(request_setting))\n\n    # Remove keys that are set to None. Extract keys first to avoid altering\n    # the dictionary during iteration.\n    none_keys = [k for (k, v) in merged_setting.items() if v is None]\n    for key in none_keys:\n        del merged_setting[key]\n\n    return merged_setting\n\n\ndef merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n    \"\"\"Properly merges both requests and session hooks.\n\n    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get(\"response\") == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get(\"response\") == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)",
                "filename": "requests/sessions.py",
                "start_index": 0,
                "end_index": 2962,
                "start_line": 1,
                "end_line": 103,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "def handle_redirect(self, r, **kwargs):\n        \"\"\"Reset num_401_calls counter on redirects.\"\"\"\n        if r.is_redirect:\n            self._thread_local.num_401_calls = 1\n\n    def handle_401(self, r, **kwargs):\n        \"\"\"\n        Takes the given response and tries digest-auth, if needed.\n\n        :rtype: requests.Response\n        \"\"\"\n\n        # If response is not 4xx, do not auth\n        # See https://github.com/psf/requests/issues/3772\n        if not 400 <= r.status_code < 500:\n            self._thread_local.num_401_calls = 1\n            return r\n\n        if self._thread_local.pos is not None:\n            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get(\"www-authenticate\", \"\")\n\n        if \"digest\" in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n            self._thread_local.num_401_calls += 1\n            pat = re.compile(r\"digest \", flags=re.IGNORECASE)\n            self._thread_local.chal = parse_dict_header(pat.sub(\"\", s_auth, count=1))\n\n            # Consume content and release the original connection\n            # to allow our new request to reuse the same one.\n            r.content\n            r.close()\n            prep = r.request.copy()\n            extract_cookies_to_jar(prep._cookies, r.request, r.raw)\n            prep.prepare_cookies(prep._cookies)\n\n            prep.headers[\"Authorization\"] = self.build_digest_header(\n                prep.method, prep.url\n            )\n            _r = r.connection.send(prep, **kwargs)\n            _r.history.append(r)\n            _r.request = prep\n\n            return _r\n\n        self._thread_local.num_401_calls = 1\n        return r\n\n    def __call__(self, r):\n        # Initialize per-thread state, if needed\n        self.init_per_thread_state()\n        # If we have a saved nonce, skip the 401\n        if self._thread_local.last_nonce:\n            r.headers[\"Authorization\"] = self.build_digest_header(r.method, r.url)\n        try:\n            self._thread_local.pos = r.body.tell()\n        except AttributeError:\n            # In the case of HTTPDigestAuth being reused and the body of\n            # the previous request was a file-like object, pos has the\n            # file position of the previous body. Ensure it's set to\n            # None.\n            self._thread_local.pos = None\n        r.register_hook(\"response\", self.handle_401)\n        r.register_hook(\"response\", self.handle_redirect)\n        self._thread_local.num_401_calls = 1\n\n        return r\n\n    def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),\n            ]\n        )\n\n    def __ne__(self, other):\n        return not self == other",
                "filename": "requests/auth.py",
                "start_index": 7314,
                "end_index": 10186,
                "start_line": 236,
                "end_line": 315,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp",
                "filename": "requests/sessions.py",
                "start_index": 8948,
                "end_index": 10242,
                "start_line": 246,
                "end_line": 281,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            },
            {
                "code": "def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:\n            location = resp.headers[\"location\"]\n            # Currently the underlying http module on py3 decode headers\n            # in latin1, but empirical evidence suggests that latin1 is very\n            # rarely used with non-ASCII characters in HTTP headers.\n            # It is more likely to get UTF8 header rather than latin1.\n            # This causes incorrect handling of UTF8 encoded location headers.\n            # To solve this, we re-encode the location in latin1.\n            location = location.encode(\"latin1\")\n            return to_native_string(location, \"utf8\")\n        return None\n\n    def should_strip_auth(self, old_url, new_url):\n        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n        # breaking backwards compatibility with older versions of requests\n        # that allowed any redirects on the same host.\n        if (\n            old_parsed.scheme == \"http\"\n            and old_parsed.port in (80, None)\n            and new_parsed.scheme == \"https\"\n            and new_parsed.port in (443, None)\n        ):\n            return False\n\n        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (\n            not changed_scheme\n            and old_parsed.port in default_port\n            and new_parsed.port in default_port\n        ):\n            return False\n\n        # Standard case: root URI must match\n        return changed_port or changed_scheme",
                "filename": "requests/sessions.py",
                "start_index": 2997,
                "end_index": 5463,
                "start_line": 107,
                "end_line": 157,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.3",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "requests/sessions.py": [
                {
                    "chunk": {
                        "code": "def rebuild_method(self, prepared_request, response):\n        \"\"\"When being redirected we may want to change the method of the request\n        based on certain specs or browser behavior.\n        \"\"\"\n        method = prepared_request.method\n\n        # https://tools.ietf.org/html/rfc7231#section-6.4.4\n        if response.status_code == codes.see_other and method != \"HEAD\":\n            method = \"GET\"\n\n        # Do what the browsers do, despite standards...\n        # First, turn 302s into GETs.\n        if response.status_code == codes.found and method != \"HEAD\":\n            method = \"GET\"\n\n        # Second, if a POST is responded to with a 301, turn it into a GET.\n        # This bizarre behaviour is explained in Issue 1704.\n        if response.status_code == codes.moved and method == \"POST\":\n            method = \"GET\"\n\n        prepared_request.method = method",
                        "filename": "requests/sessions.py",
                        "start_index": 12385,
                        "end_index": 13252,
                        "start_line": 334,
                        "end_line": 354,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the logic for changing the HTTP method during redirection, which is directly related to the issue of incorrect method selection after a redirect."
                },
                {
                    "chunk": {
                        "code": "prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)",
                        "filename": "requests/sessions.py",
                        "start_index": 5959,
                        "end_index": 8935,
                        "start_line": 178,
                        "end_line": 245,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the process of handling redirects and calling `rebuild_method`, which is relevant to the issue as it may be where the original request object is incorrectly copied for subsequent requests."
                },
                {
                    "chunk": {
                        "code": "def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):",
                        "filename": "requests/sessions.py",
                        "start_index": 5469,
                        "end_index": 5701,
                        "start_line": 159,
                        "end_line": 520,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the `resolve_redirects` method, which is likely where the issue originates as it handles the entire redirection process."
                },
                {
                    "chunk": {
                        "code": "def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:\n            location = resp.headers[\"location\"]\n            # Currently the underlying http module on py3 decode headers\n            # in latin1, but empirical evidence suggests that latin1 is very\n            # rarely used with non-ASCII characters in HTTP headers.\n            # It is more likely to get UTF8 header rather than latin1.\n            # This causes incorrect handling of UTF8 encoded location headers.\n            # To solve this, we re-encode the location in latin1.\n            location = location.encode(\"latin1\")\n            return to_native_string(location, \"utf8\")\n        return None\n\n    def should_strip_auth(self, old_url, new_url):\n        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n        # breaking backwards compatibility with older versions of requests\n        # that allowed any redirects on the same host.\n        if (\n            old_parsed.scheme == \"http\"\n            and old_parsed.port in (80, None)\n            and new_parsed.scheme == \"https\"\n            and new_parsed.port in (443, None)\n        ):\n            return False\n\n        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (\n            not changed_scheme\n            and old_parsed.port in default_port\n            and new_parsed.port in default_port\n        ):\n            return False\n\n        # Standard case: root URI must match\n        return changed_port or changed_scheme",
                        "filename": "requests/sessions.py",
                        "start_index": 2997,
                        "end_index": 5463,
                        "start_line": 107,
                        "end_line": 157,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the logic for getting the redirect target, which may be relevant to understand how the redirection URL is processed and could influence the method change logic."
                }
            ]
        },
        "solution_task": "- Modify the `rebuild_method` function in `requests/sessions.py` to handle the 307 Temporary Redirect status code correctly by preserving the original HTTP method.\n- Add an additional condition to check for the 307 status code and ensure the method is not changed if the original method is POST.\n\n```python\ndef rebuild_method(self, prepared_request, response):\n    \"\"\"When being redirected we may want to change the method of the request\n    based on certain specs or browser behavior.\n    \"\"\"\n    method = prepared_request.method\n\n    # https://tools.ietf.org/html/rfc7231#section-6.4.4\n    if response.status_code == codes.see_other and method != \"HEAD\":\n        method = \"GET\"\n\n    # Add check for 307 Temporary Redirect\n    # Preserve the method for 307 Temporary Redirect\n    if response.status_code == codes.temporary_redirect:\n        method = prepared_request.method\n\n    # Do what the browsers do, despite standards...\n    # First, turn 302s into GETs.\n    if response.status_code == codes.found and method != \"HEAD\":\n        method = \"GET\"\n\n    # Second, if a POST is responded to with a 301, turn it into a GET.\n    # This bizarre behaviour is explained in Issue 1704.\n    if response.status_code == codes.moved and method == \"POST\":\n        method = \"GET\"\n\n    prepared_request.method = method\n```\n\n- Ensure that the `resolve_redirects` method in `requests/sessions.py` calls `rebuild_method` after each redirect to apply the correct HTTP method for the subsequent request.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the problem described in the PROMPT. It suggests modifying the 'rebuild_method' function to handle the 307 Temporary Redirect status code correctly by preserving the original HTTP method, which is a direct response to the issue of the method being incorrectly changed to POST after a redirect. The RESPONSE also includes a code snippet that demonstrates how to implement the proposed solution, which is highly relevant and actionable. Additionally, the RESPONSE advises ensuring that the 'resolve_redirects' method calls 'rebuild_method' after each redirect, which is a crucial step in applying the correct HTTP method for subsequent requests. The RESPONSE also references specific code snippets from the Requests library that are relevant to the issue, providing a clear path for developers to investigate and apply the suggested changes.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711761622.5475168,
        "result": "- Modify the `rebuild_method` function in `requests/sessions.py` to handle the 307 Temporary Redirect status code correctly by preserving the original HTTP method.\n- Add an additional condition to check for the 307 status code and ensure the method is not changed if the original method is POST.\n\n```python\ndef rebuild_method(self, prepared_request, response):\n    \"\"\"When being redirected we may want to change the method of the request\n    based on certain specs or browser behavior.\n    \"\"\"\n    method = prepared_request.method\n\n    # https://tools.ietf.org/html/rfc7231#section-6.4.4\n    if response.status_code == codes.see_other and method != \"HEAD\":\n        method = \"GET\"\n\n    # Add check for 307 Temporary Redirect\n    # Preserve the method for 307 Temporary Redirect\n    if response.status_code == codes.temporary_redirect:\n        method = prepared_request.method\n\n    # Do what the browsers do, despite standards...\n    # First, turn 302s into GETs.\n    if response.status_code == codes.found and method != \"HEAD\":\n        method = \"GET\"\n\n    # Second, if a POST is responded to with a 301, turn it into a GET.\n    # This bizarre behaviour is explained in Issue 1704.\n    if response.status_code == codes.moved and method == \"POST\":\n        method = \"GET\"\n\n    prepared_request.method = method\n```\n\n- Ensure that the `resolve_redirects` method in `requests/sessions.py` calls `rebuild_method` after each redirect to apply the correct HTTP method for the subsequent request.\n\n### Code snippets to check\n\n-  \u2192 [requests](https://github.com/testbed/psf__requests__2.3/tree//requests)- [Lines 334 - 354](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L334-L354)\n\n This snippet contains the logic for changing the HTTP method during redirection, which is directly related to the issue of incorrect method selection after a redirect. \n\n\n   - [Lines 178 - 245](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L178-L245)\n\n This snippet includes the process of handling redirects and calling `rebuild_method`, which is relevant to the issue as it may be where the original request object is incorrectly copied for subsequent requests. \n\n\n   - [Lines 159 - 520](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L159-L520)\n\n This snippet defines the `resolve_redirects` method, which is likely where the issue originates as it handles the entire redirection process. \n\n\n   - [Lines 107 - 157](https://github.com/testbed/psf__requests__2.3/blob//requests/sessions.py#L107-L157)\n\n This snippet contains the logic for getting the redirect target, which may be relevant to understand how the redirection URL is processed and could influence the method change logic."
    }
}