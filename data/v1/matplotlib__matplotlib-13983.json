{
    "id": "matplotlib__matplotlib-13983",
    "repo_name": "testbed/matplotlib__matplotlib__3.0",
    "task_id": 2709809888251929994,
    "title": "Remove()ing a shared axes prevents the remaining axes from using unit-provided formatters",
    "body": "Consider\r\n```\r\nfrom pylab import *\r\nfrom datetime import date\r\n\r\nfig, axs = plt.subplots(1, 2, sharex=True)\r\naxs[1].remove()\r\naxs[0].plot([date(2000, 1, 1), date(2000, 2, 1)], [0, 1])\r\nplt.show()\r\n```\r\n\r\nOne gets\r\n![test](https://user-images.githubusercontent.com/1322974/48794454-4c3f5c00-ecfa-11e8-9e1f-83ff6015782c.png)\r\n\r\ni.e. the call to `axs[1].remove()` prevented the axs[0] from acquiring the correct tick formatter and locator.\r\n\r\nInterestingly, using `fig.delaxes(axs[1])` doesn't exhibit the same bug.\r\n\r\nLooks like the problem comes from\r\n```\r\n    def _remove_ax(self, ax):\r\n        def _reset_loc_form(axis):\r\n            axis.set_major_formatter(axis.get_major_formatter())\r\n            axis.set_major_locator(axis.get_major_locator())\r\n            axis.set_minor_formatter(axis.get_minor_formatter())\r\n            axis.set_minor_locator(axis.get_minor_locator())\r\n\r\n        def _break_share_link(ax, grouper):\r\n            siblings = grouper.get_siblings(ax)\r\n            if len(siblings) > 1:\r\n                grouper.remove(ax)\r\n                for last_ax in siblings:\r\n                    if ax is not last_ax:\r\n                        return last_ax\r\n            return None\r\n\r\n        self.delaxes(ax)\r\n        last_ax = _break_share_link(ax, ax._shared_y_axes)\r\n        if last_ax is not None:\r\n            _reset_loc_form(last_ax.yaxis)\r\n\r\n        last_ax = _break_share_link(ax, ax._shared_x_axes)\r\n        if last_ax is not None:\r\n            _reset_loc_form(last_ax.xaxis)\r\n```\r\nwhere the call to `set_major_formatter` (etc.), which basically call `formatter.set_axis(axis)` (to update the axis seen by the formatter) also make Matplotlib believe that we had a user-provided formatter (isDefault_majloc = False, etc.) which should not be overridden by the unit framework.\r\n\r\nmpl master (ca. 3.0.2)\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.0.git",
    "requested_commit": "",
    "mayil_response": "- Investigate if `axs[1].remove()` is calling `_remove_ax` and if `_remove_ax` is properly handling the tick formatter and locator for shared axes.\n- Ensure that `_remove_ax` calls `_reset_loc_form` for the remaining axes if they are sharing their x-axis or y-axis with the removed axis.\n- Check if `_remove_ax` or `remove` is correctly breaking the sharing link by calling `_break_share_link` for the axis that is being removed.\n- Verify that `isDefault_majloc` is being updated correctly after an axis is removed. If it is a shared axis, the flag should reflect the state of the remaining shared axes.\n- If the issue persists, consider overriding the `remove` method to manually reset the major and minor formatters and locators on the remaining axes that were sharing with the removed axis. Use `set_major_formatter`, `set_minor_formatter`, `set_major_locator`, and `set_minor_locator` with the values obtained from `get_major_formatter`, `get_minor_formatter`, `get_major_locator`, and `get_minor_locator` before the axis is removed.\n- After making changes, test the behavior with `axs[1].remove()` and compare it to `fig.delaxes(axs[1])` to ensure consistency in the behavior of tick formatter and locator acquisition.\n\n### Code snippets to check\n\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries) \u2192 [examples](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples) \u2192 [subplots_axes_and_figures](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples/subplots_axes_and_figures)- [Lines 1 - 57](https://github.com/testbed/matplotlib__matplotlib__3.0/blob//galleries/examples/subplots_axes_and_figures/shared_axis_demo.py#L1-L57)\n\n This snippet demonstrates the use of shared axes and the behavior of tick labels when axes are shared, which is directly related to the issue described.\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries) \u2192 [examples](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples) \u2192 [subplots_axes_and_figures](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples/subplots_axes_and_figures)- [Lines 105 - 205](https://github.com/testbed/matplotlib__matplotlib__3.0/blob//galleries/examples/subplots_axes_and_figures/subplots_demo.py#L105-L205)\n\n This snippet includes examples of sharing axes with subplots, which is relevant to the issue as it involves shared axes and the potential impact on tick formatters and locators.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000263,
        "snippet_processor": 0.07766,
        "issue_star_creation": 0.030279999999999998,
        "issue_star_solver": 0.07524,
        "bouncer": 0.02459
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711699390.5473468,
        "relevant_snippets": [
            {
                "code": "# FixedFormatter should only be used together with FixedLocator.\n# Otherwise, one cannot be sure where the labels will end up.\npositions = [0, 1, 2, 3, 4, 5]\nlabels = ['A', 'B', 'C', 'D', 'E', 'F']\naxs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions))\naxs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels))\n\nsetup(axs2[5], title=\"ScalarFormatter()\")\naxs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))\n\nsetup(axs2[6], title=\"PercentFormatter(xmax=5)\")\naxs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5))\n\nplt.show()",
                "filename": "galleries/examples/ticks/tick-formatters.py",
                "start_index": 2968,
                "end_index": 3542,
                "start_line": 92,
                "end_line": 105,
                "max_line": 105,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "We can of course fix this after the fact, but it does highlight a\n# weakness of hard-coding the ticks.  This example also changes the format\n# of the ticks:\n\nfig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\nticks = np.arange(0., 8.1, 2.)\n# list comprehension to get all tick labels...\ntickla = [f'{tick:1.2f}' for tick in ticks]\naxs[1].xaxis.set_ticks(ticks)\naxs[1].xaxis.set_ticklabels(tickla)\naxs[1].set_xlim(axs[0].get_xlim())\nplt.show()\n\n# %%\n# Tick Locators and Formatters\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#\n# Instead of making a list of all the ticklabels, we could have\n# used `matplotlib.ticker.StrMethodFormatter` (new-style ``str.format()``\n# format string) or `matplotlib.ticker.FormatStrFormatter` (old-style '%'\n# format string) and passed it to the ``ax.xaxis``.  A\n# `matplotlib.ticker.StrMethodFormatter` can also be created by passing a\n# ``str`` without having to explicitly create the formatter.\n\nfig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\nticks = np.arange(0., 8.1, 2.)\naxs[1].xaxis.set_ticks(ticks)\naxs[1].xaxis.set_major_formatter('{x:1.1f}')\naxs[1].set_xlim(axs[0].get_xlim())\nplt.show()\n\n# %%\n# And of course we could have used a non-default locator to set the\n# tick locations.  Note we still pass in the tick values, but the\n# x-limit fix used above is *not* needed.\n\nfig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\nlocator = matplotlib.ticker.FixedLocator(ticks)\naxs[1].xaxis.set_major_locator(locator)\naxs[1].xaxis.set_major_formatter('\u00b1{x}\u00b0')\nplt.show()\n\n# %%\n# The default formatter is the `matplotlib.ticker.MaxNLocator` called as\n# ``ticker.MaxNLocator(self, nbins='auto', steps=[1, 2, 2.5, 5, 10])``\n# The *steps* keyword contains a list of multiples that can be used for\n# tick values.  i.e. in this case, 2, 4, 6 would be acceptable ticks,\n# as would 20, 40, 60 or 0.2, 0.4, 0.6. However, 3, 6, 9 would not be\n# acceptable because 3 doesn't appear in the list of steps.\n#\n# ``nbins=auto`` uses an algorithm to determine how many ticks will\n# be acceptable based on how long the axis is.  The fontsize of the\n# ticklabel is taken into account, but the length of the tick string\n# is not (because it's not yet known.)  In the bottom row, the\n# ticklabels are quite large, so we set ``nbins=4`` to make the\n# labels fit in the right-hand plot.\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 5), tight_layout=True)\nfor n, ax in enumerate(axs.flat):\n    ax.plot(x1*10., y1)\n\nformatter = matplotlib.ticker.FormatStrFormatter('%1.1f')\nlocator = matplotlib.ticker.MaxNLocator(nbins='auto', steps=[1, 4, 10])\naxs[0, 1].xaxis.set_major_locator(locator)\naxs[0, 1].xaxis.set_major_formatter(formatter)\n\nformatter = matplotlib.ticker.FormatStrFormatter('%1.5f')\nlocator = matplotlib.ticker.AutoLocator()\naxs[1, 0].xaxis.set_major_formatter(formatter)\naxs[1, 0].xaxis.set_major_locator(locator)\n\nfo",
                "filename": "galleries/users_explain/text/text_intro.py",
                "start_index": 8938,
                "end_index": 11926,
                "start_line": 273,
                "end_line": 418,
                "max_line": 429,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n===========\nShared axis\n===========\n\nYou can share the x- or y-axis limits for one axis with another by\npassing an `~.axes.Axes` instance as a *sharex* or *sharey* keyword argument.\n\nChanging the axis limits on one axes will be reflected automatically\nin the other, and vice-versa, so when you navigate with the toolbar\nthe Axes will follow each other on their shared axis.  Ditto for\nchanges in the axis scaling (e.g., log vs. linear).  However, it is\npossible to have differences in tick labeling, e.g., you can selectively\nturn off the tick labels on one Axes.\n\nThe example below shows how to customize the tick labels on the\nvarious axes.  Shared axes share the tick locator, tick formatter,\nview limits, and transformation (e.g., log, linear).  But the ticklabels\nthemselves do not share properties.  This is a feature and not a bug,\nbecause you may want to make the tick labels smaller on the upper\naxes, e.g., in the example below.\n\nIf you want to turn off the ticklabels for a given Axes (e.g., on\nsubplot(211) or subplot(212)), you cannot do the standard trick::\n\n   setp(ax2, xticklabels=[])\n\nbecause this changes the tick Formatter, which is shared among all\nAxes.  But you can alter the visibility of the labels, which is a\nproperty::\n\n  setp(ax2.get_xticklabels(), visible=False)\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = np.sin(4 * np.pi * t)\n\nax1 = plt.subplot(311)\nplt.plot(t, s1)\nplt.tick_params('x', labelsize=6)\n\n# share x only\nax2 = plt.subplot(312, sharex=ax1)\nplt.plot(t, s2)\n# make these tick labels invisible\nplt.tick_params('x', labelbottom=False)\n\n# share x and y\nax3 = plt.subplot(313, sharex=ax1, sharey=ax1)\nplt.plot(t, s3)\nplt.xlim(0.01, 5.0)\nplt.show()",
                "filename": "galleries/examples/subplots_axes_and_figures/shared_axis_demo.py",
                "start_index": 0,
                "end_index": 1781,
                "start_line": 1,
                "end_line": 57,
                "max_line": 57,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n=================================\nDate tick locators and formatters\n=================================\n\nThis example illustrates the usage and effect of the various date locators and\nformatters.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (FR, MO, MONTHLY, SA, SU, TH, TU, WE,\n                              AutoDateFormatter, AutoDateLocator,\n                              ConciseDateFormatter, DateFormatter, DayLocator,\n                              HourLocator, MicrosecondLocator, MinuteLocator,\n                              MonthLocator, RRuleLocator, SecondLocator,\n                              WeekdayLocator, YearLocator, rrulewrapper)\nimport matplotlib.ticker as ticker\n\n\ndef plot_axis(ax, locator=None, xmax='2002-02-01', fmt=None, formatter=None):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(np.datetime64('2000-02-01'), np.datetime64(xmax))\n    if locator:\n        ax.xaxis.set_major_locator(eval(locator))\n        ax.xaxis.set_major_formatter(DateFormatter(fmt))\n    else:\n        ax.xaxis.set_major_formatter(eval(formatter))\n    ax.text(0.0, 0.2, locator or formatter, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n# %%\n# :ref:`date-locators`\n# --------------------\n\n\nlocators = [\n    # locator as str, xmax, fmt\n    ('AutoDateLocator(maxticks=8)', '2003-02-01', '%Y-%m'),\n    ('YearLocator(month=4)', '2003-02-01', '%Y-%m'),\n    ('MonthLocator(bymonth=[4, 8, 12])', '2003-02-01', '%Y-%m'),\n    ('DayLocator(interval=180)', '2003-02-01', '%Y-%m-%d'),\n    ('WeekdayLocator(byweekday=SU, interval=4)', '2000-07-01', '%a %Y-%m-%d'),\n    ('HourLocator(byhour=range(0, 24, 6))', '2000-02-04', '%H h'),\n    ('MinuteLocator(interval=15)', '2000-02-01 02:00', '%H:%M'),\n    ('SecondLocator(bysecond=(0, 30))', '2000-02-01 00:02', '%H:%M:%S'),\n    ('MicrosecondLocator(interval=1000)', '2000-02-01 00:00:00.005', '%S.%f'),\n    ('RRuleLocator(rrulewrapper(freq=MONTHLY, \\nbyweekday=(MO, TU, WE, TH, FR), '\n     'bysetpos=-1))', '2000-07-01', '%Y-%m-%d'),\n]\n\nfig, axs = plt.subplots(len(locators), 1, figsize=(8, len(locators) * .8),\n                        layout='constrained')\nfig.suptitle('Date Locators')\nfor ax, (locator, xmax, fmt) in zip(axs, locators):\n    plot_axis(ax, locator, xmax, fmt)\n\n# %%\n# :ref:`date-formatters`\n# ----------------------\n\nformatters = [\n    'AutoDateFormatter(ax.xaxis.get_major_locator())',\n    'ConciseDateFormatter(ax.xaxis.get_major_locator())',\n    'DateFormatter(\"%b %Y\")',\n]\n\nfig, axs = plt.subplots(len(formatters), 1, figsize=(8, len(formatters) * .8),\n                        layout='constrained')\nfig.suptitle('Date Formatters')\nfor ax, fmt in zip(axs, formatters):\n    plot_axis(ax, formatter=fmt)",
                "filename": "galleries/examples/ticks/date_formatters_locators.py",
                "start_index": 0,
                "end_index": 3001,
                "start_line": 1,
                "end_line": 77,
                "max_line": 100,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "axs[0].xaxis.set_major_locator(ticker.NullLocator())\naxs[0].xaxis.set_minor_locator(ticker.NullLocator())\n\n# Multiple Locator\nsetup(axs[1], title=\"MultipleLocator(0.5)\")\naxs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5))\naxs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1))\n\n# Fixed Locator\nsetup(axs[2], title=\"FixedLocator([0, 1, 5])\")\naxs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5]))\naxs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4)))\n\n# Linear Locator\nsetup(axs[3], title=\"LinearLocator(numticks=3)\")\naxs[3].xaxis.set_major_locator(ticker.LinearLocator(3))\naxs[3].xaxis.set_minor_locator(ticker.LinearLocator(31))\n\n# Index Locator\nsetup(axs[4], title=\"IndexLocator(base=0.5, offset=0.25)\")\naxs[4].plot(range(0, 5), [0]*5, color='white')\naxs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25))\n\n# Auto Locator\nsetup(axs[5], title=\"AutoLocator()\")\naxs[5].xaxis.set_major_locator(ticker.AutoLocator())\naxs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator())\n\n# MaxN Locator\nsetup(axs[6], title=\"MaxNLocator(n=4)\")\naxs[6].xaxis.set_major_locator(ticker.MaxNLocator(4))\naxs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40))\n\n# Log Locator\nsetup(axs[7], title=\"LogLocator(base=10, numticks=15)\")\naxs[7].set_xlim(10**3, 10**10)\naxs[7].set_xscale('log')\naxs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))\nplt.show()\n\n# %%\n#\n# Similarly, we can specify \"Formatters\" for the major and minor ticks on each\n# axis.\n#\n# The tick format is configured via the function `~.Axis.set_major_formatter`\n# or `~.Axis.set_minor_formatter`. It accepts:\n#\n# - a format string, which implicitly creates a `.StrMethodFormatter`.\n# - a function,  implicitly creates a `.FuncFormatter`.\n# - an instance of a `.Formatter` subclass. The most common are\n#\n#   - `.NullFormatter`: No labels on the ticks.\n#   - `.StrMethodFormatter`: Use string `str.format` method.\n#   - `.FormatStrFormatter`: Use %-style formatting.\n#   - `.FuncFormatter`: Define labels through a function.\n#   - `.FixedFormatter`: Set the label strings explicitly.\n#   - `.ScalarFormatter`: Default formatter for scalars: auto-pick the format string.\n#   - `.PercentFormatter`: Format labels as a percentage.\n#\n# See :ref:`formatters` for the complete list.",
                "filename": "galleries/users_explain/axes/axes_ticks.py",
                "start_index": 2989,
                "end_index": 5289,
                "start_line": 96,
                "end_line": 156,
                "max_line": 275,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "ax4.plot(x, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# Sharing axes\n# \"\"\"\"\"\"\"\"\"\"\"\"\n#\n# By default, each Axes is scaled individually. Thus, if the ranges are\n# different the tick values of the subplots do not align.\n\nfig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Axes values are scaled individually by default')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# You can use *sharex* or *sharey* to align the horizontal or vertical axis.\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nfig.suptitle('Aligning x-axis using sharex')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# Setting *sharex* or *sharey* to ``True`` enables global sharing across the\n# whole grid, i.e. also the y-axes of vertically stacked subplots have the\n# same scale when using ``sharey=True``.\n\nfig, axs = plt.subplots(3, sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# %%\n# For subplots that are sharing axes one set of tick labels is enough. Tick\n# labels of inner Axes are automatically removed by *sharex* and *sharey*.\n# Still there remains an unused empty space between the subplots.\n#\n# To precisely control the positioning of the subplots, one can explicitly\n# create a `.GridSpec` with `.Figure.add_gridspec`, and then call its\n# `~.GridSpecBase.subplots` method.  For example, we can reduce the height\n# between vertical subplots using ``add_gridspec(hspace=0)``.\n#\n# `.label_outer` is a handy method to remove labels and ticks from subplots\n# that are not at the edge of the grid.\n\nfig = plt.figure()\ngs = fig.add_gridspec(3, hspace=0)\naxs = gs.subplots(sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# Hide x labels and tick labels for all but bottom plot.\nfor ax in axs:\n    ax.label_outer()\n\n# %%\n# Apart from ``True`` and ``False``, both *sharex* and *sharey* accept the\n# values 'row' and 'col' to share the values only per row or column.\n\nfig = plt.figure()\ngs = fig.add_gridspec(2, 2, hspace=0, wspace=0)\n(ax1, ax2), (ax3, ax4) = gs.subplots(sharex='col', sharey='row')\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x + 1, -y, 'tab:green')\nax4.plot(x + 2, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# If you want a more complex sharing structure, you can first create the\n# grid of axes with no sharing, and then call `.axes.Axes.sharex` or\n# `.axes.Axes.sharey` to add sharing info a posteriori.\n\nfig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title(\"main\")\naxs[1, 0].plot(x, y**2)\naxs[1, 0].set_title(\"shares x with main\")\naxs[1, 0].sharex(axs[0, 0])\naxs[0, 1].plot(x + 1, y + 1)\naxs[0, 1].set_title(\"unrelated\")\naxs[1, 1].plot(x + 2, y + 2)\naxs[1, 1].set_title(\"also unrelated\")\nfig.tight_layout()\n\n# %%\n# Polar axes\n# \"\"\"\"\"\"\"\"\"\"\n#",
                "filename": "galleries/examples/subplots_axes_and_figures/subplots_demo.py",
                "start_index": 2986,
                "end_index": 5917,
                "start_line": 105,
                "end_line": 205,
                "max_line": 211,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n================\nDate tick labels\n================\n\nMatplotlib date plotting is done by converting date instances into\ndays since an epoch (by default 1970-01-01T00:00:00). The\n:mod:`matplotlib.dates` module provides the converter functions `.date2num`\nand `.num2date` that convert `datetime.datetime` and `numpy.datetime64`\nobjects to and from Matplotlib's internal representation.  These data\ntypes are registered with the unit conversion mechanism described in\n:mod:`matplotlib.units`, so the conversion happens automatically for the user.\nThe registration process also sets the default tick ``locator`` and\n``formatter`` for the axis to be `~.matplotlib.dates.AutoDateLocator` and\n`~.matplotlib.dates.AutoDateFormatter`.\n\nAn alternative formatter is the `~.dates.ConciseDateFormatter`,\nused in the second ``Axes`` below (see\n:doc:`/gallery/ticks/date_concise_formatter`), which often removes the need to\nrotate the tick labels. The last ``Axes`` formats the dates manually, using\n`~.dates.DateFormatter` to format the dates using the format strings documented\nat `datetime.date.strftime`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.dates as mdates\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column.\ndata = cbook.get_sample_data('goog.npz')['price_data']\n\nfig, axs = plt.subplots(3, 1, figsize=(6.4, 7), layout='constrained')\n# common to all three:\nfor ax in axs:\n    ax.plot('date', 'adj_close', data=data)\n    # Major ticks every half year, minor ticks every month,\n    ax.xaxis.set_major_locator(mdates.MonthLocator(bymonth=(1, 7)))\n    ax.xaxis.set_minor_locator(mdates.MonthLocator())\n    ax.grid(True)\n    ax.set_ylabel(r'Price [\\$]')\n\n# different formats:\nax = axs[0]\nax.set_title('DefaultFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\n\nax = axs[1]\nax.set_title('ConciseFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\nax.xaxis.set_major_formatter(\n    mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\nax = axs[2]\nax.set_title('Manual DateFormatter', loc='left', y=0.85, x=0.02,\n             fontsize='medium')\n# Text in the x-axis will be displayed in 'YYYY-mm' format.\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%b'))\n# Rotates and right-aligns the x labels so they don't crowd each other.\nfor label in ax.get_xticklabels(which='major'):\n    label.set(rotation=30, horizontalalignment='right')\n\nplt.show()",
                "filename": "galleries/examples/text_labels_and_annotations/date.py",
                "start_index": 0,
                "end_index": 2611,
                "start_line": 1,
                "end_line": 64,
                "max_line": 64,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n=====================================\nCustom tick formatter for time series\n=====================================\n\n.. redirect-from:: /gallery/text_labels_and_annotations/date_index_formatter\n.. redirect-from:: /gallery/ticks/date_index_formatter2\n\nWhen plotting daily data, e.g., financial time series, one often wants\nto leave out days on which there is no data, for instance weekends, so that\nthe data are plotted at regular intervals without extra spaces for the days\nwith no data.\nThe example shows how to use an 'index formatter' to achieve the desired plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nfrom matplotlib.dates import DateFormatter, DayLocator\nimport matplotlib.lines as ml\nfrom matplotlib.ticker import Formatter\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column (``r.date``).\nr = cbook.get_sample_data('goog.npz')['price_data'].view(np.recarray)\nr = r[:9]  # get the first 9 days\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 6), layout='constrained')\nfig.get_layout_engine().set(hspace=0.15)\n\n# First we'll do it the default way, with gaps on weekends\nax1.plot(r.date, r.adj_close, 'o-')\n\n# Highlight gaps in daily data\ngaps = np.flatnonzero(np.diff(r.date) > np.timedelta64(1, 'D'))\nfor gap in r[['date', 'adj_close']][np.stack((gaps, gaps + 1)).T]:\n    ax1.plot(gap.date, gap.adj_close, 'w--', lw=2)\nax1.legend(handles=[ml.Line2D([], [], ls='--', label='Gaps in daily data')])\n\nax1.set_title(\"Plot y at x Coordinates\")\nax1.xaxis.set_major_locator(DayLocator())\nax1.xaxis.set_major_formatter(DateFormatter('%a'))\n\n\n# Next we'll write a custom index formatter. Below we will plot\n# the data against an index that goes from 0, 1,  ... len(data).  Instead of\n# formatting the tick marks as integers, we format as times.\ndef format_date(x, _):\n    try:\n        # convert datetime64 to datetime, and use datetime's strftime:\n        return r.date[round(x)].item().strftime('%a')\n    except IndexError:\n        pass\n\n# Create an index plot (x defaults to range(len(y)) if omitted)\nax2.plot(r.adj_close, 'o-')\n\nax2.set_title(\"Plot y at Index Coordinates Using Custom Formatter\")\nax2.xaxis.set_major_formatter(format_date)  # internally creates FuncFormatter\n\n# %%\n# Instead of passing a function into `.Axis.set_major_formatter` you can use\n# any other callable, e.g. an instance of a class that implements __call__:\n\n\nclass MyFormatter(Formatter):\n    def __init__(self, dates, fmt='%a'):\n        self.dates = dates\n        self.fmt = fmt\n\n    def __call__(self, x, pos=0):\n        \"\"\"Return the label for time x at position pos.\"\"\"\n        try:\n            return self.dates[round(x)].item().strftime(self.fmt)\n        except IndexError:\n            pass\n\n\nax2.xaxis.set_major_formatter(MyFormatter(r.date, '%a'))\n\nplt.show()",
                "filename": "galleries/examples/ticks/date_index_formatter.py",
                "start_index": 0,
                "end_index": 3001,
                "start_line": 1,
                "end_line": 84,
                "max_line": 84,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n.. _user_axes_ticks:\n\n==========\nAxis Ticks\n==========\n\nThe x and y Axis on each Axes have default tick \"locators\" and \"formatters\"\nthat depend on the scale being used (see :ref:`user_axes_scales`).  It is\npossible to customize the ticks and tick labels with either high-level methods\nlike `~.axes.Axes.set_xticks` or set the locators and formatters directly on\nthe axis.\n\nManual location and formats\n===========================\n\nThe simplest method to customize the tick locations and formats is to use\n`~.axes.Axes.set_xticks` and `~.axes.Axes.set_yticks`.  These can be used on\neither the major or the minor ticks.\n\"\"\"\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport matplotlib.ticker as ticker\n\n\nfig, axs = plt.subplots(2, 1, figsize=(5.4, 5.4), layout='constrained')\nx = np.arange(100)\nfor nn, ax in enumerate(axs):\n    ax.plot(x, x)\n    if nn == 1:\n        ax.set_title('Manual ticks')\n        ax.set_yticks(np.arange(0, 100.1, 100/3))\n        xticks = np.arange(0.50, 101, 20)\n        xlabels = [f'\\\\${x:1.2f}' for x in xticks]\n        ax.set_xticks(xticks, labels=xlabels)\n    else:\n        ax.set_title('Automatic ticks')\n\n# %%\n#\n# Note that the length of the ``labels`` argument must have the same length as\n# the array used to specify the ticks.\n#\n# By default `~.axes.Axes.set_xticks` and `~.axes.Axes.set_yticks` act on the\n# major ticks of an Axis, however it is possible to add minor ticks:\n\nfig, axs = plt.subplots(2, 1, figsize=(5.4, 5.4), layout='constrained')\nx = np.arange(100)\nfor nn, ax in enumerate(axs):\n    ax.plot(x, x)\n    if nn == 1:\n        ax.set_title('Manual ticks')\n        ax.set_yticks(np.arange(0, 100.1, 100/3))\n        ax.set_yticks(np.arange(0, 100.1, 100/30), minor=True)\n    else:\n        ax.set_title('Automatic ticks')\n\n\n# %%\n#\n# Locators and Formatters\n# =======================\n#\n# Manually setting the ticks as above works well for specific final plots, but\n# does not adapt as the user interacts with the axes.   At a lower level,\n# Matplotlib has ``Locators`` that are meant to automatically choose ticks\n# depending on the current view limits of the axis, and ``Formatters`` that are\n# meant to format the tick labels automatically.\n#\n# The full list of locators provided by Matplotlib are listed at\n# :ref:`locators`, and the formatters at :ref:`formatters`.\n\n\n# %%\n\ndef setup(ax, title):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig, axs = plt.subplots(8, 1, layout='constrained')\n\n# Null Locator\nsetup(axs[0], title=\"NullLocator()\")",
                "filename": "galleries/users_explain/axes/axes_ticks.py",
                "start_index": 0,
                "end_index": 2988,
                "start_line": 1,
                "end_line": 95,
                "max_line": 275,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n===========\nBroken Axis\n===========\n\nBroken axis example, where the y-axis will have a portion cut out.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\npts = np.random.rand(30)*.2\n# Now let's make two outlier points which are far away from everything.\npts[[3, 14]] += .8\n\n# If we were to simply plot pts, we'd lose most of the interesting\n# details due to the outliers. So let's 'break' or 'cut-out' the y-axis\n# into two portions - use the top (ax1) for the outliers, and the bottom\n# (ax2) for the details of the majority of our data\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nfig.subplots_adjust(hspace=0.05)  # adjust space between axes\n\n# plot the same data on both axes\nax1.plot(pts)\nax2.plot(pts)\n\n# zoom-in / limit the view to different portions of the data\nax1.set_ylim(.78, 1.)  # outliers only\nax2.set_ylim(0, .22)  # most of the data\n\n# hide the spines between ax and ax2\nax1.spines.bottom.set_visible(False)\nax2.spines.top.set_visible(False)\nax1.xaxis.tick_top()\nax1.tick_params(labeltop=False)  # don't put tick labels at the top\nax2.xaxis.tick_bottom()\n\n# Now, let's turn towards the cut-out slanted lines.\n# We create line objects in axes coordinates, in which (0,0), (0,1),\n# (1,0), and (1,1) are the four corners of the axes.\n# The slanted lines themselves are markers at those locations, such that the\n# lines keep their angle and position, independent of the axes size or scale\n# Finally, we need to disable clipping.\n\nd = .5  # proportion of vertical to horizontal extent of the slanted line\nkwargs = dict(marker=[(-1, -d), (1, d)], markersize=12,\n              linestyle=\"none\", color='k', mec='k', mew=1, clip_on=False)\nax1.plot([0, 1], [0, 0], transform=ax1.transAxes, **kwargs)\nax2.plot([0, 1], [1, 1], transform=ax2.transAxes, **kwargs)\n\n\nplt.show()",
                "filename": "galleries/examples/subplots_axes_and_figures/broken_axis.py",
                "start_index": 0,
                "end_index": 1821,
                "start_line": 1,
                "end_line": 54,
                "max_line": 54,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.0",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "galleries/examples/subplots_axes_and_figures/shared_axis_demo.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\n===========\nShared axis\n===========\n\nYou can share the x- or y-axis limits for one axis with another by\npassing an `~.axes.Axes` instance as a *sharex* or *sharey* keyword argument.\n\nChanging the axis limits on one axes will be reflected automatically\nin the other, and vice-versa, so when you navigate with the toolbar\nthe Axes will follow each other on their shared axis.  Ditto for\nchanges in the axis scaling (e.g., log vs. linear).  However, it is\npossible to have differences in tick labeling, e.g., you can selectively\nturn off the tick labels on one Axes.\n\nThe example below shows how to customize the tick labels on the\nvarious axes.  Shared axes share the tick locator, tick formatter,\nview limits, and transformation (e.g., log, linear).  But the ticklabels\nthemselves do not share properties.  This is a feature and not a bug,\nbecause you may want to make the tick labels smaller on the upper\naxes, e.g., in the example below.\n\nIf you want to turn off the ticklabels for a given Axes (e.g., on\nsubplot(211) or subplot(212)), you cannot do the standard trick::\n\n   setp(ax2, xticklabels=[])\n\nbecause this changes the tick Formatter, which is shared among all\nAxes.  But you can alter the visibility of the labels, which is a\nproperty::\n\n  setp(ax2.get_xticklabels(), visible=False)\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = np.sin(4 * np.pi * t)\n\nax1 = plt.subplot(311)\nplt.plot(t, s1)\nplt.tick_params('x', labelsize=6)\n\n# share x only\nax2 = plt.subplot(312, sharex=ax1)\nplt.plot(t, s2)\n# make these tick labels invisible\nplt.tick_params('x', labelbottom=False)\n\n# share x and y\nax3 = plt.subplot(313, sharex=ax1, sharey=ax1)\nplt.plot(t, s3)\nplt.xlim(0.01, 5.0)\nplt.show()",
                        "filename": "galleries/examples/subplots_axes_and_figures/shared_axis_demo.py",
                        "start_index": 0,
                        "end_index": 1781,
                        "start_line": 1,
                        "end_line": 57,
                        "max_line": 57,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet demonstrates the use of shared axes and the behavior of tick labels when axes are shared, which is directly related to the issue described."
                }
            ],
            "galleries/examples/subplots_axes_and_figures/subplots_demo.py": [
                {
                    "chunk": {
                        "code": "ax4.plot(x, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# Sharing axes\n# \"\"\"\"\"\"\"\"\"\"\"\"\n#\n# By default, each Axes is scaled individually. Thus, if the ranges are\n# different the tick values of the subplots do not align.\n\nfig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Axes values are scaled individually by default')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# You can use *sharex* or *sharey* to align the horizontal or vertical axis.\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nfig.suptitle('Aligning x-axis using sharex')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# Setting *sharex* or *sharey* to ``True`` enables global sharing across the\n# whole grid, i.e. also the y-axes of vertically stacked subplots have the\n# same scale when using ``sharey=True``.\n\nfig, axs = plt.subplots(3, sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# %%\n# For subplots that are sharing axes one set of tick labels is enough. Tick\n# labels of inner Axes are automatically removed by *sharex* and *sharey*.\n# Still there remains an unused empty space between the subplots.\n#\n# To precisely control the positioning of the subplots, one can explicitly\n# create a `.GridSpec` with `.Figure.add_gridspec`, and then call its\n# `~.GridSpecBase.subplots` method.  For example, we can reduce the height\n# between vertical subplots using ``add_gridspec(hspace=0)``.\n#\n# `.label_outer` is a handy method to remove labels and ticks from subplots\n# that are not at the edge of the grid.\n\nfig = plt.figure()\ngs = fig.add_gridspec(3, hspace=0)\naxs = gs.subplots(sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# Hide x labels and tick labels for all but bottom plot.\nfor ax in axs:\n    ax.label_outer()\n\n# %%\n# Apart from ``True`` and ``False``, both *sharex* and *sharey* accept the\n# values 'row' and 'col' to share the values only per row or column.\n\nfig = plt.figure()\ngs = fig.add_gridspec(2, 2, hspace=0, wspace=0)\n(ax1, ax2), (ax3, ax4) = gs.subplots(sharex='col', sharey='row')\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x + 1, -y, 'tab:green')\nax4.plot(x + 2, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# If you want a more complex sharing structure, you can first create the\n# grid of axes with no sharing, and then call `.axes.Axes.sharex` or\n# `.axes.Axes.sharey` to add sharing info a posteriori.\n\nfig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title(\"main\")\naxs[1, 0].plot(x, y**2)\naxs[1, 0].set_title(\"shares x with main\")\naxs[1, 0].sharex(axs[0, 0])\naxs[0, 1].plot(x + 1, y + 1)\naxs[0, 1].set_title(\"unrelated\")\naxs[1, 1].plot(x + 2, y + 2)\naxs[1, 1].set_title(\"also unrelated\")\nfig.tight_layout()\n\n# %%\n# Polar axes\n# \"\"\"\"\"\"\"\"\"\"\n#",
                        "filename": "galleries/examples/subplots_axes_and_figures/subplots_demo.py",
                        "start_index": 2986,
                        "end_index": 5917,
                        "start_line": 105,
                        "end_line": 205,
                        "max_line": 211,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes examples of sharing axes with subplots, which is relevant to the issue as it involves shared axes and the potential impact on tick formatters and locators."
                }
            ]
        },
        "solution_task": "- Investigate if `axs[1].remove()` is calling `_remove_ax` and if `_remove_ax` is properly handling the tick formatter and locator for shared axes.\n- Ensure that `_remove_ax` calls `_reset_loc_form` for the remaining axes if they are sharing their x-axis or y-axis with the removed axis.\n- Check if `_remove_ax` or `remove` is correctly breaking the sharing link by calling `_break_share_link` for the axis that is being removed.\n- Verify that `isDefault_majloc` is being updated correctly after an axis is removed. If it is a shared axis, the flag should reflect the state of the remaining shared axes.\n- If the issue persists, consider overriding the `remove` method to manually reset the major and minor formatters and locators on the remaining axes that were sharing with the removed axis. Use `set_major_formatter`, `set_minor_formatter`, `set_major_locator`, and `set_minor_locator` with the values obtained from `get_major_formatter`, `get_minor_formatter`, `get_major_locator`, and `get_minor_locator` before the axis is removed.\n- After making changes, test the behavior with `axs[1].remove()` and compare it to `fig.delaxes(axs[1])` to ensure consistency in the behavior of tick formatter and locator acquisition.",
        "bouncer_response": {
            "score": 8,
            "criteria": "RESPONSE that are highly relevant, offering clear and comprehensive guidance or solutions for the described bug, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a detailed and structured approach to investigating and potentially resolving the bug related to shared axes and unit-provided formatters. It suggests verifying the behavior of the `_remove_ax` function, ensuring that the tick formatter and locator are handled correctly, and checking the state of `isDefault_majloc`. Additionally, it proposes a potential solution by overriding the `remove` method if necessary and testing the changes for consistency. The RESPONSE also includes code snippets that could be relevant to the issue. However, it does not directly address the specific problem with the `isDefault_majloc` flag being incorrectly set, which is a key part of the bug described in the PROMPT. Therefore, while the RESPONSE is highly relevant and provides a comprehensive approach, it falls short of a perfect score because it does not fully address the core issue with `isDefault_majloc`.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711699512.441654,
        "result": "- Investigate if `axs[1].remove()` is calling `_remove_ax` and if `_remove_ax` is properly handling the tick formatter and locator for shared axes.\n- Ensure that `_remove_ax` calls `_reset_loc_form` for the remaining axes if they are sharing their x-axis or y-axis with the removed axis.\n- Check if `_remove_ax` or `remove` is correctly breaking the sharing link by calling `_break_share_link` for the axis that is being removed.\n- Verify that `isDefault_majloc` is being updated correctly after an axis is removed. If it is a shared axis, the flag should reflect the state of the remaining shared axes.\n- If the issue persists, consider overriding the `remove` method to manually reset the major and minor formatters and locators on the remaining axes that were sharing with the removed axis. Use `set_major_formatter`, `set_minor_formatter`, `set_major_locator`, and `set_minor_locator` with the values obtained from `get_major_formatter`, `get_minor_formatter`, `get_major_locator`, and `get_minor_locator` before the axis is removed.\n- After making changes, test the behavior with `axs[1].remove()` and compare it to `fig.delaxes(axs[1])` to ensure consistency in the behavior of tick formatter and locator acquisition.\n\n### Code snippets to check\n\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries) \u2192 [examples](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples) \u2192 [subplots_axes_and_figures](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples/subplots_axes_and_figures)- [Lines 1 - 57](https://github.com/testbed/matplotlib__matplotlib__3.0/blob//galleries/examples/subplots_axes_and_figures/shared_axis_demo.py#L1-L57)\n\n This snippet demonstrates the use of shared axes and the behavior of tick labels when axes are shared, which is directly related to the issue described.\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries) \u2192 [examples](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples) \u2192 [subplots_axes_and_figures](https://github.com/testbed/matplotlib__matplotlib__3.0/tree//galleries/examples/subplots_axes_and_figures)- [Lines 105 - 205](https://github.com/testbed/matplotlib__matplotlib__3.0/blob//galleries/examples/subplots_axes_and_figures/subplots_demo.py#L105-L205)\n\n This snippet includes examples of sharing axes with subplots, which is relevant to the issue as it involves shared axes and the potential impact on tick formatters and locators."
    }
}