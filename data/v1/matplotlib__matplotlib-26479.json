{
    "id": "matplotlib__matplotlib-26479",
    "repo_name": "testbed/matplotlib__matplotlib__3.7",
    "task_id": 1614879890620212006,
    "title": "Postscript backend gives wrong page sizes",
    "body": "### Bug report\r\n\r\n**Bug summary**\r\n\r\nWhen creating a Figure of exactly A4 size, the PS backend chooses \"letter\" as document type, leading to additional borders of the output in x direction and undesired cropping in y direction.\r\n\r\n**Code for reproduction**\r\n\r\n```python\r\nimport matplotlib as mpl\r\nmpl.use(\"PS\")\r\n\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\n# Use \"exact\" A4 paper size in inches as used in PS backend.\r\n\r\n# In fact, it is wrong, because it is rounded to only two digits,\r\n# where actually the ISO standardized values (ISO 216) are given\r\n# in millimeters.\r\n\r\nA4_SIZE_IN = (8.27, 11.69)\r\n\r\ndef get_empty_page(figsize):\r\n    fig, ax = plt.subplots(\r\n        subplot_kw={\r\n            \"position\": (0, 0, 1, 1),\r\n            \"autoscale_on\": False,\r\n            \"xmargin\": 0,\r\n            \"ymargin\": 0,\r\n        },\r\n        figsize=figsize\r\n    )\r\n    fig.dpi = 72\r\n    ax.tick_params(direction=\"in\")\r\n    ax.set_axis_off()  # turns off ticks, labels, frame, grid\r\n    return fig, ax\r\n\r\nfig, ax = get_empty_page(figsize=A4_SIZE_IN)\r\n\r\n# Put blue circles exactly in the corners of the figure.\r\n# They shall appear as quarter circles in the output.\r\nax.plot([0, 1], [1, 0], \"bo\", ms=100)\r\n\r\nfig.savefig(\"size_wo_papertype.ps\")\r\nfig.savefig(\"size_w_papertype.ps\", papertype=\"a4\")\r\n```\r\n\r\n**Actual outcome**\r\n\r\nWhen not specifying the papertype explicitly, the PS backend chooses \"letter\" format as can be seen from the resulting postscript output. It should, instead, choose A4 format. When specifying the papertype explicitly, the output looks fine.\r\n\r\n\r\n**Expected outcome**\r\n\r\nThe PS backend should choose A4 format if the Figure is exactly this size. Anyway, nothing should ever be cropped off the Figure. If the Figure does not fit one papertype, the next larger one should be chosen.\r\nI also do not understand why the output of the PS backend is restricted to a handfull of explicit paper sizes in the first place. Postscript does well support arbitrary page sizes. Can someone explain why matplotlib chose to only support the given sizes? This is not transparent to the user, who expects to get output of exactly the size of his/her desired Figure object.\r\n\r\n**Matplotlib version**\r\n  * Operating system: Ubuntu 19.04\r\n  * Matplotlib version: 3.1.1\r\n  * Matplotlib backend: PS\r\n  * Python version: 3.7.4\r\n  * Jupyter version: 1.0.0\r\n  * Other libraries: \r\n\r\nMatplotlib was installed via conda.\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.7.git",
    "requested_commit": "",
    "mayil_response": "- Check if the `papertype` parameter is being passed to the `savefig` function. If not, the backend will use the default paper size from `rcParams` or infer it from the figure size.\n- Ensure that the `papersize` dictionary in `backend_ps.py` includes the 'a4' key with the correct dimensions `(8.27, 11.69)`.\n- Verify that the `_get_papertype` function correctly identifies the 'a4' paper size for the given figure dimensions.\n- If the 'a4' size is not being selected by default, consider setting the default `papertype` in the `rcParams` to 'a4' if that is the desired behavior.\n- If the issue persists, explicitly set the `papertype` to 'a4' when calling `savefig` as a workaround.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib/backends)- [Lines 1 - 92](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L1-L92)\n\n This snippet defines the paper sizes and the function '_get_papertype' which is likely involved in the issue of selecting the wrong paper size. \n\n\n   - [Lines 807 - 854](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L807-L854)\n\n This snippet contains the '_print_ps' method which handles the printing to PostScript format and includes logic for determining the paper type if not specified. \n\n\n   - [Lines 215 - 1081](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L215-L1081)\n\n This snippet is part of the '_print_ps' method implementation and includes the logic for handling the paper type and orientation, which is relevant to the issue. \n\n\n   - [Lines 911 - 968](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L911-L968)\n\n This snippet is involved in the actual writing of the PostScript file headers, which includes the paper size information. \n\n\n   - [Lines 1186 - 1241](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L1186-L1241)\n\n This snippet includes the 'xpdf_distill' function which is used for distilling the PostScript file and may be relevant if the issue is related to the distillation process.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002305,
        "snippet_processor": 0.06133,
        "issue_star_solver": 0.06913,
        "issue_star_creation": 0.02505,
        "bouncer": 0.02653
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711695549.353771,
        "relevant_snippets": [
            {
                "code": "\"\"\"\nA PostScript backend, which can produce both PostScript .ps and .eps.\n\"\"\"\n\nimport codecs\nimport datetime\nfrom enum import Enum\nimport functools\nfrom io import StringIO\nimport itertools\nimport logging\nimport os\nimport pathlib\nimport shutil\nfrom tempfile import TemporaryDirectory\nimport time\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook, _path, _text_helpers\nfrom matplotlib._afm import AFM\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase, RendererBase)\nfrom matplotlib.cbook import is_writable_file_like, file_requires_unicode\nfrom matplotlib.font_manager import get_font\nfrom matplotlib.ft2font import LOAD_NO_SCALE, FT2Font\nfrom matplotlib._ttconv import convert_ttf_to_ps\nfrom matplotlib._mathtext_data import uni2type1\nfrom matplotlib.path import Path\nfrom matplotlib.texmanager import TexManager\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\nfrom . import _backend_pdf_ps\n\n\n_log = logging.getLogger(__name__)\ndebugPS = False\n\n\n@_api.deprecated(\"3.7\")\nclass PsBackendHelper:\n    def __init__(self):\n        self._cached = {}\n\n\n@_api.caching_module_getattr\nclass __getattr__:\n    # module-level deprecations\n    ps_backend_helper = _api.deprecated(\"3.7\", obj_type=\"\")(\n        property(lambda self: PsBackendHelper()))\n    psDefs = _api.deprecated(\"3.8\", obj_type=\"\")(property(lambda self: _psDefs))\n\n\npapersize = {'letter': (8.5, 11),\n             'legal': (8.5, 14),\n             'ledger': (11, 17),\n             'a0': (33.11, 46.81),\n             'a1': (23.39, 33.11),\n             'a2': (16.54, 23.39),\n             'a3': (11.69, 16.54),\n             'a4': (8.27, 11.69),\n             'a5': (5.83, 8.27),\n             'a6': (4.13, 5.83),\n             'a7': (2.91, 4.13),\n             'a8': (2.05, 2.91),\n             'a9': (1.46, 2.05),\n             'a10': (1.02, 1.46),\n             'b0': (40.55, 57.32),\n             'b1': (28.66, 40.55),\n             'b2': (20.27, 28.66),\n             'b3': (14.33, 20.27),\n             'b4': (10.11, 14.33),\n             'b5': (7.16, 10.11),\n             'b6': (5.04, 7.16),\n             'b7': (3.58, 5.04),\n             'b8': (2.51, 3.58),\n             'b9': (1.76, 2.51),\n             'b10': (1.26, 1.76)}\n\n\ndef _get_papertype(w, h):\n    for key, (pw, ph) in sorted(papersize.items(), reverse=True):\n        if key.startswith('l'):\n            continue\n        if w < pw and h < ph:\n            return key\n    return 'a0'\n\n\ndef _nums_to_str(*args, sep=\" \"):\n    return sep.join(f\"{arg:1.3f}\".rstrip(\"0\").rstrip(\".\") for arg in args)",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 0,
                "end_index": 2621,
                "start_line": 1,
                "end_line": 92,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    def _print_ps(\n            self, fmt, outfile, *,\n            metadata=None, papertype=None, orientation='portrait',\n            bbox_inches_restore=None, **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.fromtimestamp(\n                int(source_date_epoch),\n                datetime.timezone.utc).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['figure', 'auto', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype,\n                bbox_inches_restore=bbox_inches_restore, **kwargs)",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 27430,
                "end_index": 29353,
                "start_line": 807,
                "end_line": 854,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n%%LanguageLevel: 3\n{dsc_comments}\n{get_bbox_header(bbox)[0]}\n%%EndComments\n%%BeginProlog\n/mpldict {len(_psDefs)} dict def\nmpldict begin\n{\"\".join(_psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n0 0 {_nums_to_str(width*72, height*72)} rectclip\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps or papertype == 'figure':\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                if papertype == 'auto':\n                    _api.warn_deprecated(\"3.8\", name=\"papertype='auto'\",\n                                         addendum=\"Pass an explicit paper type, or \"\n                                         \"omit the *papertype* argument entirely.\")\n                    papertype = _get_papertype(width, height)\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmppath, outfile)",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 36196,
                "end_index": 38415,
                "start_line": 215,
                "end_line": 1081,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "class RendererPS(_backend_pdf_ps.RendererPDFPSBase):",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 7303,
                "end_index": 7355,
                "start_line": 244,
                "end_line": 244,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "name: Bug Report\ndescription: Report a bug or issue with Matplotlib.\ntitle: \"[Bug]: \"\nbody:\n  - type: textarea\n    id: summary\n    attributes:\n      label: Bug summary\n      description:  Describe the bug in 1-2 short sentences\n      placeholder:\n      value:\n    validations:\n      required: true\n  - type: textarea\n    id: reproduction\n    attributes:\n      label: Code for reproduction\n      description: |\n        If possible, please provide a minimum self-contained example.\n      placeholder: Paste your code here. This field is automatically formatted as Python code.\n      render: python\n    validations:\n      required: true\n  - type: textarea\n    id: actual\n    attributes:\n      label: Actual outcome\n      description: |\n        Paste the output produced by the code provided above, e.g.\n        console output, images/videos produced by the code, any relevant screenshots/screencasts, etc.\n    validations:\n      required: true\n  - type: textarea\n    id: expected\n    attributes:\n      label: Expected outcome\n      description: Describe (or provide a visual example of) the expected outcome from the code snippet.\n    validations:\n      required: true\n  - type: textarea\n    id: details\n    attributes:\n      label: Additional information\n      description: |\n        - What are the conditions under which this bug happens? input parameters, edge cases, etc?\n        - Has this worked in earlier versions?\n        - Do you know why this bug is happening?\n        - Do you maybe even know a fix?\n  - type: input\n    id: operating-system\n    attributes:\n      label: Operating system\n      description: Windows, OS/X, Arch, Debian, Ubuntu, etc.\n  - type: input\n    id: matplotlib-version\n    attributes:\n      label: Matplotlib Version\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.__version__)`\"\n    validations:\n      required: true\n  - type: input\n    id: matplotlib-backend\n    attributes:\n      label: Matplotlib Backend\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.get_backend())`\"\n  - type: input\n    id: python-version\n    attributes:\n      label: Python version\n      description: \"In console: `python --version`\"\n  - type: input\n    id: jupyter-version\n    attributes:\n      label: Jupyter version\n      description: \"In console: `jupyter notebook --version` or `jupyter lab --version`\"\n  - type: dropdown\n    id: install\n    attributes:\n      label: Installation\n      description: How did you install matplotlib?\n      options:\n        - pip\n        - conda\n        - Linux package manager\n        - from source (.tar.gz)\n        - git checkout",
                "filename": ".github/ISSUE_TEMPLATE/bug_report.yml",
                "start_index": 0,
                "end_index": 2631,
                "start_line": 1,
                "end_line": 86,
                "max_line": 86,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(\"%!PS-Adobe-3.0\", file=fh)\n                if papertype != 'figure':\n                    print(f\"%%DocumentPaperSizes: {papertype}\", file=fh)\n                print(\"%%Pages: 1\", file=fh)\n            print(f\"%%LanguageLevel: 3\\n\"\n                  f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"{get_bbox_header(bbox)[0]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(_psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(_psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(chars) > 255:\n                        fonttype = 42\n                    fh.flush()\n                    if fonttype == 3:\n                        fh.write(_font_to_ps_type3(font_path, chars))\n                    else:  # Type 42 only.\n                        _font_to_ps_type42(font_path, chars, fh)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(f\"0 0 {_nums_to_str(width*72, height*72)} rectclip\", file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 31530,
                "end_index": 33898,
                "start_line": 911,
                "end_line": 968,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. This distiller is preferred, generating high-level postscript\n    output that treats text as text.\n    \"\"\"\n    mpl._get_executable_info(\"gs\")  # Effectively checks for ps2pdf.\n    mpl._get_executable_info(\"pdftops\")\n\n    if eps:\n        paper_option = [\"-dEPSCrop\"]\n    elif ptype == \"figure\":\n        # The bbox will have its lower-left corner at (0, 0), so upper-right\n        # corner corresponds with paper size.\n        paper_option = [f\"-dDEVICEWIDTHPOINTS#{bbox[2]}\",\n                        f\"-dDEVICEHEIGHTPOINTS#{bbox[3]}\"]\n    else:\n        paper_option = [f\"-sPAPERSIZE#{ptype}\"]\n\n    with TemporaryDirectory() as tmpdir:\n        tmppdf = pathlib.Path(tmpdir, \"tmp.pdf\")\n        tmpps = pathlib.Path(tmpdir, \"tmp.ps\")\n        # Pass options as `-foo#bar` instead of `-foo=bar` to keep Windows\n        # happy (https://ghostscript.com/doc/9.56.1/Use.htm#MS_Windows).\n        cbook._check_and_log_subprocess(\n            [\"ps2pdf\",\n             \"-dAutoFilterColorImages#false\",\n             \"-dAutoFilterGrayImages#false\",\n             \"-sAutoRotatePages#None\",\n             \"-sGrayImageFilter#FlateEncode\",\n             \"-sColorImageFilter#FlateEncode\",\n             *paper_option,\n             tmpfile, tmppdf], _log)\n        cbook._check_and_log_subprocess(\n            [\"pdftops\", \"-paper\", \"match\", \"-level3\", tmppdf, tmpps], _log)\n        shutil.move(tmpps, tmpfile)\n    if eps:\n        pstoeps(tmpfile)\n\n\ndef get_bbox_header(lbrt, rotated=False):\n    \"\"\"\n    Return a postscript header string for the given bbox lbrt=(l, b, r, t).\n    Optionally, return rotate command.\n    \"\"\"\n\n    l, b, r, t = lbrt\n    if rotated:\n        rotate = f\"{l+r:.2f} {0:.2f} translate\\n90 rotate\"\n    else:\n        rotate = \"\"\n    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r), np.ceil(t))\n    hires_bbox_info = f'%%HiResBoundingBox: {l:.6f} {b:.6f} {r:.6f} {t:.6f}'\n\n    return '\\n'.join([bbox_info, hires_bbox_info]), rotate",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 42518,
                "end_index": 44707,
                "start_line": 1186,
                "end_line": 1241,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "_psDefs = [\n    # name proc  *_d*  -\n    # Note that this cannot be bound to /d, because when embedding a Type3 font\n    # we may want to define a \"d\" glyph using \"/d{...} d\" which would locally\n    # overwrite the definition.\n    \"/_d { bind def } bind def\",\n    # x y  *m*  -\n    \"/m { moveto } _d\",\n    # x y  *l*  -\n    \"/l { lineto } _d\",\n    # x y  *r*  -\n    \"/r { rlineto } _d\",\n    # x1 y1 x2 y2 x y *c*  -\n    \"/c { curveto } _d\",\n    # *cl*  -\n    \"/cl { closepath } _d\",\n    # *ce*  -\n    \"/ce { closepath eofill } _d\",\n    # wx wy llx lly urx ury  *setcachedevice*  -\n    \"/sc { setcachedevice } _d\",\n]\n\n\n@_Backend.export\nclass _BackendPS(_Backend):\n    backend_version = 'Level II'\n    FigureCanvas = FigureCanvasPS",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 47512,
                "end_index": 48241,
                "start_line": 1320,
                "end_line": 1346,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "class RendererPDFPSBase(RendererBase):\n    # The following attributes must be defined by the subclasses:\n    # - _afm_font_dir\n    # - _use_afm_rc_name\n\n    def __init__(self, width, height):\n        super().__init__()\n        self.width = width\n        self.height = height\n\n    def flipy(self):\n        # docstring inherited\n        return False  # y increases from bottom to top.\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True  # PDF and PS support arbitrary image scaling.\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        # Decide whether to composite image based on rcParam value.\n        return not mpl.rcParams[\"image.composite_image\"]\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width * 72.0, self.height * 72.0\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        if ismath == \"TeX\":\n            return super().get_text_width_height_descent(s, prop, ismath)\n        elif ismath:\n            parse = self._text2path.mathtext_parser.parse(s, 72, prop)\n            return parse.width, parse.height, parse.depth\n        elif mpl.rcParams[self._use_afm_rc_name]:\n            font = self._get_font_afm(prop)\n            l, b, w, h, d = font.get_str_bbox_and_descent(s)\n            scale = prop.get_size_in_points() / 1000\n            w *= scale\n            h *= scale\n            d *= scale\n            return w, h, d\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0.0, flags=ft2font.LOAD_NO_HINTING)\n            w, h = font.get_width_height()\n            d = font.get_descent()\n            scale = 1 / 64\n            w *= scale\n            h *= scale\n            d *= scale\n            return w, h, d\n\n    def _get_font_afm(self, prop):\n        fname = font_manager.findfont(\n            prop, fontext=\"afm\", directory=self._afm_font_dir)\n        return _cached_get_afm_from_fname(fname)\n\n    def _get_font_ttf(self, prop):\n        fnames = font_manager.fontManager._find_fonts_by_props(prop)\n        font = font_manager.get_font(fnames)\n        font.clear()\n        font.set_size(prop.get_size_in_points(), 72)\n        return font",
                "filename": "lib/matplotlib/backends/_backend_pdf_ps.py",
                "start_index": 2204,
                "end_index": 4441,
                "start_line": 82,
                "end_line": 145,
                "max_line": 145,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "if __name__ == '__main__':\n    from argparse import ArgumentParser\n    import itertools\n\n    parser = ArgumentParser()\n    parser.add_argument(\"filename\")\n    parser.add_argument(\"dpi\", nargs=\"?\", type=float, default=None)\n    args = parser.parse_args()\n    with Dvi(args.filename, args.dpi) as dvi:\n        fontmap = PsfontsMap(find_tex_file('pdftex.map'))\n        for page in dvi:\n            print(f\"=== new page === \"\n                  f\"(w: {page.width}, h: {page.height}, d: {page.descent})\")\n            for font, group in itertools.groupby(\n                    page.text, lambda text: text.font):\n                print(f\"font: {font.texname.decode('latin-1')!r}\\t\"\n                      f\"scale: {font._scale / 2 ** 20}\")\n                print(\"x\", \"y\", \"glyph\", \"chr\", \"w\", \"(glyphs)\", sep=\"\\t\")\n                for text in group:\n                    print(text.x, text.y, text.glyph,\n                          chr(text.glyph) if chr(text.glyph).isprintable()\n                          else \".\",\n                          text.width, sep=\"\\t\")\n            if page.boxes:\n                print(\"x\", \"y\", \"h\", \"w\", \"\", \"(boxes)\", sep=\"\\t\")\n                for box in page.boxes:\n                    print(box.x, box.y, box.height, box.width, sep=\"\\t\")",
                "filename": "lib/matplotlib/dviread.py",
                "start_index": 40699,
                "end_index": 41957,
                "start_line": 1123,
                "end_line": 1149,
                "max_line": 1149,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "lib/matplotlib/backends/backend_ps.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\nA PostScript backend, which can produce both PostScript .ps and .eps.\n\"\"\"\n\nimport codecs\nimport datetime\nfrom enum import Enum\nimport functools\nfrom io import StringIO\nimport itertools\nimport logging\nimport os\nimport pathlib\nimport shutil\nfrom tempfile import TemporaryDirectory\nimport time\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook, _path, _text_helpers\nfrom matplotlib._afm import AFM\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase, RendererBase)\nfrom matplotlib.cbook import is_writable_file_like, file_requires_unicode\nfrom matplotlib.font_manager import get_font\nfrom matplotlib.ft2font import LOAD_NO_SCALE, FT2Font\nfrom matplotlib._ttconv import convert_ttf_to_ps\nfrom matplotlib._mathtext_data import uni2type1\nfrom matplotlib.path import Path\nfrom matplotlib.texmanager import TexManager\nfrom matplotlib.transforms import Affine2D\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\nfrom . import _backend_pdf_ps\n\n\n_log = logging.getLogger(__name__)\ndebugPS = False\n\n\n@_api.deprecated(\"3.7\")\nclass PsBackendHelper:\n    def __init__(self):\n        self._cached = {}\n\n\n@_api.caching_module_getattr\nclass __getattr__:\n    # module-level deprecations\n    ps_backend_helper = _api.deprecated(\"3.7\", obj_type=\"\")(\n        property(lambda self: PsBackendHelper()))\n    psDefs = _api.deprecated(\"3.8\", obj_type=\"\")(property(lambda self: _psDefs))\n\n\npapersize = {'letter': (8.5, 11),\n             'legal': (8.5, 14),\n             'ledger': (11, 17),\n             'a0': (33.11, 46.81),\n             'a1': (23.39, 33.11),\n             'a2': (16.54, 23.39),\n             'a3': (11.69, 16.54),\n             'a4': (8.27, 11.69),\n             'a5': (5.83, 8.27),\n             'a6': (4.13, 5.83),\n             'a7': (2.91, 4.13),\n             'a8': (2.05, 2.91),\n             'a9': (1.46, 2.05),\n             'a10': (1.02, 1.46),\n             'b0': (40.55, 57.32),\n             'b1': (28.66, 40.55),\n             'b2': (20.27, 28.66),\n             'b3': (14.33, 20.27),\n             'b4': (10.11, 14.33),\n             'b5': (7.16, 10.11),\n             'b6': (5.04, 7.16),\n             'b7': (3.58, 5.04),\n             'b8': (2.51, 3.58),\n             'b9': (1.76, 2.51),\n             'b10': (1.26, 1.76)}\n\n\ndef _get_papertype(w, h):\n    for key, (pw, ph) in sorted(papersize.items(), reverse=True):\n        if key.startswith('l'):\n            continue\n        if w < pw and h < ph:\n            return key\n    return 'a0'\n\n\ndef _nums_to_str(*args, sep=\" \"):\n    return sep.join(f\"{arg:1.3f}\".rstrip(\"0\").rstrip(\".\") for arg in args)",
                        "filename": "lib/matplotlib/backends/backend_ps.py",
                        "start_index": 0,
                        "end_index": 2621,
                        "start_line": 1,
                        "end_line": 92,
                        "max_line": 1346,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the paper sizes and the function '_get_papertype' which is likely involved in the issue of selecting the wrong paper size."
                },
                {
                    "chunk": {
                        "code": "fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    def _print_ps(\n            self, fmt, outfile, *,\n            metadata=None, papertype=None, orientation='portrait',\n            bbox_inches_restore=None, **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.fromtimestamp(\n                int(source_date_epoch),\n                datetime.timezone.utc).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['figure', 'auto', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype,\n                bbox_inches_restore=bbox_inches_restore, **kwargs)",
                        "filename": "lib/matplotlib/backends/backend_ps.py",
                        "start_index": 27430,
                        "end_index": 29353,
                        "start_line": 807,
                        "end_line": 854,
                        "max_line": 1346,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the '_print_ps' method which handles the printing to PostScript format and includes logic for determining the paper type if not specified."
                },
                {
                    "chunk": {
                        "code": "with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n%%LanguageLevel: 3\n{dsc_comments}\n{get_bbox_header(bbox)[0]}\n%%EndComments\n%%BeginProlog\n/mpldict {len(_psDefs)} dict def\nmpldict begin\n{\"\".join(_psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n0 0 {_nums_to_str(width*72, height*72)} rectclip\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps or papertype == 'figure':\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                if papertype == 'auto':\n                    _api.warn_deprecated(\"3.8\", name=\"papertype='auto'\",\n                                         addendum=\"Pass an explicit paper type, or \"\n                                         \"omit the *papertype* argument entirely.\")\n                    papertype = _get_papertype(width, height)\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmppath, outfile)",
                        "filename": "lib/matplotlib/backends/backend_ps.py",
                        "start_index": 36196,
                        "end_index": 38415,
                        "start_line": 215,
                        "end_line": 1081,
                        "max_line": 1346,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the '_print_ps' method implementation and includes the logic for handling the paper type and orientation, which is relevant to the issue."
                },
                {
                    "chunk": {
                        "code": "def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(\"%!PS-Adobe-3.0\", file=fh)\n                if papertype != 'figure':\n                    print(f\"%%DocumentPaperSizes: {papertype}\", file=fh)\n                print(\"%%Pages: 1\", file=fh)\n            print(f\"%%LanguageLevel: 3\\n\"\n                  f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"{get_bbox_header(bbox)[0]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(_psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(_psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(chars) > 255:\n                        fonttype = 42\n                    fh.flush()\n                    if fonttype == 3:\n                        fh.write(_font_to_ps_type3(font_path, chars))\n                    else:  # Type 42 only.\n                        _font_to_ps_type42(font_path, chars, fh)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(f\"0 0 {_nums_to_str(width*72, height*72)} rectclip\", file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()",
                        "filename": "lib/matplotlib/backends/backend_ps.py",
                        "start_index": 31530,
                        "end_index": 33898,
                        "start_line": 911,
                        "end_line": 968,
                        "max_line": 1346,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is involved in the actual writing of the PostScript file headers, which includes the paper size information."
                },
                {
                    "chunk": {
                        "code": "def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. This distiller is preferred, generating high-level postscript\n    output that treats text as text.\n    \"\"\"\n    mpl._get_executable_info(\"gs\")  # Effectively checks for ps2pdf.\n    mpl._get_executable_info(\"pdftops\")\n\n    if eps:\n        paper_option = [\"-dEPSCrop\"]\n    elif ptype == \"figure\":\n        # The bbox will have its lower-left corner at (0, 0), so upper-right\n        # corner corresponds with paper size.\n        paper_option = [f\"-dDEVICEWIDTHPOINTS#{bbox[2]}\",\n                        f\"-dDEVICEHEIGHTPOINTS#{bbox[3]}\"]\n    else:\n        paper_option = [f\"-sPAPERSIZE#{ptype}\"]\n\n    with TemporaryDirectory() as tmpdir:\n        tmppdf = pathlib.Path(tmpdir, \"tmp.pdf\")\n        tmpps = pathlib.Path(tmpdir, \"tmp.ps\")\n        # Pass options as `-foo#bar` instead of `-foo=bar` to keep Windows\n        # happy (https://ghostscript.com/doc/9.56.1/Use.htm#MS_Windows).\n        cbook._check_and_log_subprocess(\n            [\"ps2pdf\",\n             \"-dAutoFilterColorImages#false\",\n             \"-dAutoFilterGrayImages#false\",\n             \"-sAutoRotatePages#None\",\n             \"-sGrayImageFilter#FlateEncode\",\n             \"-sColorImageFilter#FlateEncode\",\n             *paper_option,\n             tmpfile, tmppdf], _log)\n        cbook._check_and_log_subprocess(\n            [\"pdftops\", \"-paper\", \"match\", \"-level3\", tmppdf, tmpps], _log)\n        shutil.move(tmpps, tmpfile)\n    if eps:\n        pstoeps(tmpfile)\n\n\ndef get_bbox_header(lbrt, rotated=False):\n    \"\"\"\n    Return a postscript header string for the given bbox lbrt=(l, b, r, t).\n    Optionally, return rotate command.\n    \"\"\"\n\n    l, b, r, t = lbrt\n    if rotated:\n        rotate = f\"{l+r:.2f} {0:.2f} translate\\n90 rotate\"\n    else:\n        rotate = \"\"\n    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r), np.ceil(t))\n    hires_bbox_info = f'%%HiResBoundingBox: {l:.6f} {b:.6f} {r:.6f} {t:.6f}'\n\n    return '\\n'.join([bbox_info, hires_bbox_info]), rotate",
                        "filename": "lib/matplotlib/backends/backend_ps.py",
                        "start_index": 42518,
                        "end_index": 44707,
                        "start_line": 1186,
                        "end_line": 1241,
                        "max_line": 1346,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the 'xpdf_distill' function which is used for distilling the PostScript file and may be relevant if the issue is related to the distillation process."
                }
            ]
        },
        "solution_task": "- Check if the `papertype` parameter is being passed to the `savefig` function. If not, the backend will use the default paper size from `rcParams` or infer it from the figure size.\n- Ensure that the `papersize` dictionary in `backend_ps.py` includes the 'a4' key with the correct dimensions `(8.27, 11.69)`.\n- Verify that the `_get_papertype` function correctly identifies the 'a4' paper size for the given figure dimensions.\n- If the 'a4' size is not being selected by default, consider setting the default `papertype` in the `rcParams` to 'a4' if that is the desired behavior.\n- If the issue persists, explicitly set the `papertype` to 'a4' when calling `savefig` as a workaround.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a series of actionable steps that are directly relevant to the issue described in the PROMPT. It suggests checking if the 'papertype' parameter is being passed correctly, ensuring the 'papersize' dictionary includes the correct dimensions for 'a4', and verifying the function responsible for identifying paper size. It also recommends setting the default 'papertype' in 'rcParams' or explicitly setting it when calling 'savefig' as a workaround. Additionally, the RESPONSE provides specific code snippets from the Matplotlib repository that are likely involved in the issue, which could be very helpful for someone trying to debug the problem. The RESPONSE does not address the question about why Matplotlib restricts output to specific paper sizes, which is part of the PROMPT, hence the score is not a perfect 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711695700.492935,
        "result": "- Check if the `papertype` parameter is being passed to the `savefig` function. If not, the backend will use the default paper size from `rcParams` or infer it from the figure size.\n- Ensure that the `papersize` dictionary in `backend_ps.py` includes the 'a4' key with the correct dimensions `(8.27, 11.69)`.\n- Verify that the `_get_papertype` function correctly identifies the 'a4' paper size for the given figure dimensions.\n- If the 'a4' size is not being selected by default, consider setting the default `papertype` in the `rcParams` to 'a4' if that is the desired behavior.\n- If the issue persists, explicitly set the `papertype` to 'a4' when calling `savefig` as a workaround.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib/backends)- [Lines 1 - 92](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L1-L92)\n\n This snippet defines the paper sizes and the function '_get_papertype' which is likely involved in the issue of selecting the wrong paper size. \n\n\n   - [Lines 807 - 854](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L807-L854)\n\n This snippet contains the '_print_ps' method which handles the printing to PostScript format and includes logic for determining the paper type if not specified. \n\n\n   - [Lines 215 - 1081](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L215-L1081)\n\n This snippet is part of the '_print_ps' method implementation and includes the logic for handling the paper type and orientation, which is relevant to the issue. \n\n\n   - [Lines 911 - 968](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L911-L968)\n\n This snippet is involved in the actual writing of the PostScript file headers, which includes the paper size information. \n\n\n   - [Lines 1186 - 1241](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_ps.py#L1186-L1241)\n\n This snippet includes the 'xpdf_distill' function which is used for distilling the PostScript file and may be relevant if the issue is related to the distillation process."
    }
}