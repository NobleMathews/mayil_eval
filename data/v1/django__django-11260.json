{
    "id": "django__django-11260",
    "repo_name": "testbed/django__django__3.0",
    "task_id": 3754565684509620835,
    "title": "inspectdb generates unique ForeignKey instead of OneToOneField.",
    "body": "Description\n\t \n\t\t(last modified by Mariusz Felisiak)\n\t \ninspectdb generates unique ForeignKey instead of OneToOneField that caused raising fields.W342 warnings.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.0.git",
    "requested_commit": "",
    "mayil_response": "To address the issue where `inspectdb` is generating `ForeignKey` with a unique constraint instead of `OneToOneField`, and causing `fields.W342` warnings, you should:\n\n- Locate the `inspectdb` command implementation within the Django codebase. This is typically found in the `django/core/management/commands/inspectdb.py` file.\n- Modify the logic that determines when to generate a `ForeignKey` versus a `OneToOneField`. Specifically, look for the part of the code that inspects the database schema to identify unique constraints on foreign key columns.\n- Adjust the condition to generate a `OneToOneField` instead of a `ForeignKey` when a unique constraint is detected on the foreign key column.\n- Ensure that the `unique` argument is set to `True` when initializing a `OneToOneField`, as shown in the `OneToOneField` class definition in the provided code snippet.\n- Remove or adjust the logic that triggers the `fields.W342` warning when a `ForeignKey` with a unique constraint is encountered, as this should now be handled by the `OneToOneField` logic.\n- Test the changes with a database schema that should trigger the creation of a `OneToOneField` to ensure that the `inspectdb` command now correctly generates `OneToOneField` without raising `fields.W342` warnings.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [db](https://github.com/testbed/django__django__3.0/tree//django/db) \u2192 [models](https://github.com/testbed/django__django__3.0/tree//django/db/models) \u2192 [fields](https://github.com/testbed/django__django__3.0/tree//django/db/models/fields)- [Lines 1217 - 1976](https://github.com/testbed/django__django__3.0/blob//django/db/models/fields/related.py#L1217-L1976)\n\n This snippet defines the OneToOneField class and its unique constraint, which is directly related to the issue of inspectdb generating a unique ForeignKey instead of a OneToOneField.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00019,
        "snippet_processor": 0.022180000000000002,
        "issue_star_creation": 0.03171,
        "issue_star_solver": 0.06452000000000001,
        "bouncer": 0.01938
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711729323.220623,
        "relevant_snippets": [
            {
                "code": "class ReverseOneToOneDescriptor:",
                "filename": "django/db/models/fields/related_descriptors.py",
                "start_index": 16366,
                "end_index": 16398,
                "start_line": 388,
                "end_line": 388,
                "max_line": 1506,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "class OneToOneField(ForeignKey):\n    \"\"\"\n    A OneToOneField is essentially the same as a ForeignKey, with the exception\n    that it always carries a \"unique\" constraint with it and the reverse\n    relation always returns the object pointed to (since there will only ever\n    be one), rather than returning a list.\n    \"\"\"\n\n    # Field flags\n    many_to_many = False\n    many_to_one = False\n    one_to_many = False\n    one_to_one = True\n\n    related_accessor_class = ReverseOneToOneDescriptor\n    forward_related_accessor_class = ForwardOneToOneDescriptor\n    rel_class = OneToOneRel\n\n    description = _(\"One-to-one relationship\")\n\n    def __init__(self, to, on_delete, to_field=None, **kwargs):\n        kwargs[\"unique\"] = True\n        super().__init__(to, on_delete, to_field=to_field, **kwargs)\n\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        if \"unique\" in kwargs:\n            del kwargs[\"unique\"]\n        return name, path, args, kwargs\n\n    def formfield(self, **kwargs):\n        if self.remote_field.parent_link:\n            return None\n        return super().formfield(**kwargs)\n\n    def save_form_data(self, instance, data):\n        if isinstance(data, self.remote_field.model):\n            setattr(instance, self.name, data)\n        else:\n            setattr(instance, self.attname, data)\n            # Remote field object must be cleared otherwise Model.save()\n            # will reassign attname using the related object pk.\n            if data is None:\n                setattr(instance, self.name, data)\n\n    def _check_unique(self, **kwargs):\n        # Override ForeignKey since check isn't applicable here.\n        return []",
                "filename": "django/db/models/fields/related.py",
                "start_index": 44860,
                "end_index": 46544,
                "start_line": 1217,
                "end_line": 1976,
                "max_line": 2005,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "seen_from = sum(\n                    from_model == getattr(field.remote_field, \"model\", None)\n                    for field in self.remote_field.through._meta.fields\n                )\n                seen_to = sum(\n                    to_model == getattr(field.remote_field, \"model\", None)\n                    for field in self.remote_field.through._meta.fields\n                )\n\n                if seen_from > 1 and not self.remote_field.through_fields:\n                    errors.append(\n                        checks.Error(\n                            (\n                                \"The model is used as an intermediate model by \"\n                                \"'%s', but it has more than one foreign key \"\n                                \"from '%s', which is ambiguous. You must specify \"\n                                \"which foreign key Django should use via the \"\n                                \"through_fields keyword argument.\"\n                            )\n                            % (self, from_model_name),\n                            hint=(\n                                \"If you want to create a recursive relationship, \"\n                                'use ManyToManyField(\"%s\", through=\"%s\").'\n                            )\n                            % (\n                                RECURSIVE_RELATIONSHIP_CONSTANT,\n                                relationship_model_name,\n                            ),\n                            obj=self,\n                            id=\"fields.E334\",\n                        )\n                    )\n\n                if seen_to > 1 and not self.remote_field.through_fields:\n                    errors.append(\n                        checks.Error(\n                            \"The model is used as an intermediate model by \"\n                            \"'%s', but it has more than one foreign key \"\n                            \"to '%s', which is ambiguous. You must specify \"\n                            \"which foreign key Django should use via the \"\n                            \"through_fields keyword argument.\" % (self, to_model_name),\n                            hint=(\n                                \"If you want to create a recursive relationship, \"\n                                'use ManyToManyField(\"%s\", through=\"%s\").'\n                            )\n                            % (\n                                RECURSIVE_RELATIONSHIP_CONSTANT,\n                                relationship_model_name,\n                            ),\n                            obj=self,\n                            id=\"fields.E335\",\n                        )\n                    )",
                "filename": "django/db/models/fields/related.py",
                "start_index": 55506,
                "end_index": 58155,
                "start_line": 1529,
                "end_line": 1777,
                "max_line": 2005,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "if self_referential:\n                seen_self = sum(\n                    from_model == getattr(field.remote_field, \"model\", None)\n                    for field in self.remote_field.through._meta.fields\n                )\n\n                if seen_self > 2 and not self.remote_field.through_fields:\n                    errors.append(\n                        checks.Error(\n                            \"The model is used as an intermediate model by \"\n                            \"'%s', but it has more than two foreign keys \"\n                            \"to '%s', which is ambiguous. You must specify \"\n                            \"which two foreign keys Django should use via the \"\n                            \"through_fields keyword argument.\"\n                            % (self, from_model_name),\n                            hint=(\n                                \"Use through_fields to specify which two foreign keys \"\n                                \"Django should use.\"\n                            ),\n                            obj=self.remote_field.through,\n                            id=\"fields.E333\",\n                        )\n                    )",
                "filename": "django/db/models/fields/related.py",
                "start_index": 54255,
                "end_index": 55411,
                "start_line": 1503,
                "end_line": 1777,
                "max_line": 2005,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "if not (\n                connection.features.supports_covering_indexes\n                or \"supports_covering_indexes\" in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.include\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        \"%s does not support unique constraints with non-key \"\n                        \"columns.\" % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id=\"models.W039\",\n                    )\n                )\n            if not (\n                connection.features.supports_expression_indexes\n                or \"supports_expression_indexes\" in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint)\n                and constraint.contains_expressions\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        \"%s does not support unique constraints on \"\n                        \"expressions.\" % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id=\"models.W044\",\n                    )\n                )\n            if not (\n                connection.features.supports_nulls_distinct_unique_constraints\n                or (\n                    \"supports_nulls_distinct_unique_constraints\"\n                    in cls._meta.required_db_features\n                )\n            ) and any(\n                isinstance(constraint, UniqueConstraint)\n                and constraint.nulls_distinct is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        \"%s does not support unique constraints with \"\n                        \"nulls distinct.\" % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id=\"models.W047\",\n                    )\n                )",
                "filename": "django/db/models/base.py",
                "start_index": 95015,
                "end_index": 97737,
                "start_line": 1646,
                "end_line": 2551,
                "max_line": 2607,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "class ForwardManyToOneDescriptor:",
                "filename": "django/db/models/fields/related_descriptors.py",
                "start_index": 4589,
                "end_index": 4622,
                "start_line": 115,
                "end_line": 115,
                "max_line": 1506,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def _check_table_uniqueness(self, **kwargs):\n        if (\n            isinstance(self.remote_field.through, str)\n            or not self.remote_field.through._meta.managed\n        ):\n            return []\n        registered_tables = {\n            model._meta.db_table: model\n            for model in self.opts.apps.get_models(include_auto_created=True)\n            if model != self.remote_field.through and model._meta.managed\n        }\n        m2m_db_table = self.m2m_db_table()\n        model = registered_tables.get(m2m_db_table)\n        # The second condition allows multiple m2m relations on a model if\n        # some point to a through model that proxies another through model.\n        if (\n            model\n            and model._meta.concrete_model\n            != self.remote_field.through._meta.concrete_model\n        ):\n            if model._meta.auto_created:\n\n                def _get_field_name(model):\n                    for field in model._meta.auto_created._meta.many_to_many:\n                        if field.remote_field.through is model:\n                            return field.name\n\n                opts = model._meta.auto_created._meta\n                clashing_obj = \"%s.%s\" % (opts.label, _get_field_name(model))\n            else:\n                clashing_obj = model._meta.label\n            if settings.DATABASE_ROUTERS:\n                error_class, error_id = checks.Warning, \"fields.W344\"\n                error_hint = (\n                    \"You have configured settings.DATABASE_ROUTERS. Verify \"\n                    \"that the table of %r is correctly routed to a separate \"\n                    \"database.\" % clashing_obj\n                )\n            else:\n                error_class, error_id = checks.Error, \"fields.E340\"\n                error_hint = None\n            return [\n                error_class(\n                    \"The field's intermediary table '%s' clashes with the \"\n                    \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n                    obj=self,\n                    hint=error_hint,\n                    id=error_id,\n                )\n            ]\n        return []",
                "filename": "django/db/models/fields/related.py",
                "start_index": 63010,
                "end_index": 65146,
                "start_line": 1693,
                "end_line": 1976,
                "max_line": 2005,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "import warnings\n\nfrom django.db.models import CharField, EmailField, TextField\nfrom django.test.utils import ignore_warnings\nfrom django.utils.deprecation import RemovedInDjango51Warning\n\n__all__ = [\"CICharField\", \"CIEmailField\", \"CIText\", \"CITextField\"]\n\n\n# RemovedInDjango51Warning.\nclass CIText:\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"django.contrib.postgres.fields.CIText mixin is deprecated.\",\n            RemovedInDjango51Warning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n    def get_internal_type(self):\n        return \"CI\" + super().get_internal_type()\n\n    def db_type(self, connection):\n        return \"citext\"\n\n\nclass CICharField(CIText, CharField):\n    system_check_deprecated_details = {\n        \"msg\": (\n            \"django.contrib.postgres.fields.CICharField is deprecated. Support for it \"\n            \"(except in historical migrations) will be removed in Django 5.1.\"\n        ),\n        \"hint\": (\n            'Use CharField(db_collation=\"\u2026\") with a case-insensitive non-deterministic '\n            \"collation instead.\"\n        ),\n        \"id\": \"fields.W905\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        with ignore_warnings(category=RemovedInDjango51Warning):\n            super().__init__(*args, **kwargs)\n\n\nclass CIEmailField(CIText, EmailField):\n    system_check_deprecated_details = {\n        \"msg\": (\n            \"django.contrib.postgres.fields.CIEmailField is deprecated. Support for it \"\n            \"(except in historical migrations) will be removed in Django 5.1.\"\n        ),\n        \"hint\": (\n            'Use EmailField(db_collation=\"\u2026\") with a case-insensitive '\n            \"non-deterministic collation instead.\"\n        ),\n        \"id\": \"fields.W906\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        with ignore_warnings(category=RemovedInDjango51Warning):\n            super().__init__(*args, **kwargs)\n\n\nclass CITextField(CIText, TextField):\n    system_check_deprecated_details = {\n        \"msg\": (\n            \"django.contrib.postgres.fields.CITextField is deprecated. Support for it \"\n            \"(except in historical migrations) will be removed in Django 5.1.\"\n        ),\n        \"hint\": (\n            'Use TextField(db_collation=\"\u2026\") with a case-insensitive non-deterministic '\n            \"collation instead.\"\n        ),\n        \"id\": \"fields.W907\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        with ignore_warnings(category=RemovedInDjango51Warning):\n            super().__init__(*args, **kwargs)",
                "filename": "django/contrib/postgres/fields/citext.py",
                "start_index": 0,
                "end_index": 2542,
                "start_line": 1,
                "end_line": 78,
                "max_line": 78,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "if (\n            (old_field.primary_key and new_field.primary_key)\n            or (old_field.unique and new_field.unique)\n        ) and old_type != new_type:\n            for _, rel in _related_non_m2m_objects(new_temp_field, new_field):\n                if rel.field.db_constraint:\n                    self.execute(\n                        self._create_fk_sql(rel.related_model, rel.field, \"_fk\")\n                    )",
                "filename": "django/db/backends/oracle/schema.py",
                "start_index": 7113,
                "end_index": 7530,
                "start_line": 160,
                "end_line": 168,
                "max_line": 252,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def _unique_should_be_added(self, old_field, new_field):\n        return (\n            not new_field.primary_key\n            and new_field.unique\n            and (not old_field.unique or old_field.primary_key)\n        )\n\n    def _rename_field_sql(self, table, old_field, new_field, new_type):\n        return self.sql_rename_column % {\n            \"table\": self.quote_name(table),\n            \"old_column\": self.quote_name(old_field.column),\n            \"new_column\": self.quote_name(new_field.column),\n            \"type\": new_type,\n        }\n\n    def _create_fk_sql(self, model, field, suffix):\n        table = Table(model._meta.db_table, self.quote_name)\n        name = self._fk_constraint_name(model, field, suffix)\n        column = Columns(model._meta.db_table, [field.column], self.quote_name)\n        to_table = Table(field.target_field.model._meta.db_table, self.quote_name)\n        to_column = Columns(\n            field.target_field.model._meta.db_table,\n            [field.target_field.column],\n            self.quote_name,\n        )\n        deferrable = self.connection.ops.deferrable_sql()\n        return Statement(\n            self.sql_create_fk,\n            table=table,\n            name=name,\n            column=column,\n            to_table=to_table,\n            to_column=to_column,\n            deferrable=deferrable,\n        )\n\n    def _fk_constraint_name(self, model, field, suffix):\n        def create_fk_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        return ForeignKeyName(\n            model._meta.db_table,\n            [field.column],\n            split_identifier(field.target_field.model._meta.db_table)[1],\n            [field.target_field.column],\n            suffix,\n            create_fk_name,\n        )\n\n    def _delete_fk_sql(self, model, name):\n        return self._delete_constraint_sql(self.sql_delete_fk, model, name)\n\n    def _deferrable_constraint_sql(self, deferrable):\n        if deferrable is None:\n            return \"\"\n        if deferrable == Deferrable.DEFERRED:\n            return \" DEFERRABLE INITIALLY DEFERRED\"\n        if deferrable == Deferrable.IMMEDIATE:\n            return \" DEFERRABLE INITIALLY IMMEDIATE\"\n\n    def _unique_index_nulls_distinct_sql(self, nulls_distinct):\n        if nulls_distinct is False:\n            return \" NULLS NOT DISTINCT\"\n        elif nulls_distinct is True:\n            return \" NULLS DISTINCT\"\n        return \"\"",
                "filename": "django/db/backends/base/schema.py",
                "start_index": 66633,
                "end_index": 69081,
                "start_line": 1628,
                "end_line": 1693,
                "max_line": 1967,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/db/models/fields/related.py": [
                {
                    "chunk": {
                        "code": "class OneToOneField(ForeignKey):\n    \"\"\"\n    A OneToOneField is essentially the same as a ForeignKey, with the exception\n    that it always carries a \"unique\" constraint with it and the reverse\n    relation always returns the object pointed to (since there will only ever\n    be one), rather than returning a list.\n    \"\"\"\n\n    # Field flags\n    many_to_many = False\n    many_to_one = False\n    one_to_many = False\n    one_to_one = True\n\n    related_accessor_class = ReverseOneToOneDescriptor\n    forward_related_accessor_class = ForwardOneToOneDescriptor\n    rel_class = OneToOneRel\n\n    description = _(\"One-to-one relationship\")\n\n    def __init__(self, to, on_delete, to_field=None, **kwargs):\n        kwargs[\"unique\"] = True\n        super().__init__(to, on_delete, to_field=to_field, **kwargs)\n\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        if \"unique\" in kwargs:\n            del kwargs[\"unique\"]\n        return name, path, args, kwargs\n\n    def formfield(self, **kwargs):\n        if self.remote_field.parent_link:\n            return None\n        return super().formfield(**kwargs)\n\n    def save_form_data(self, instance, data):\n        if isinstance(data, self.remote_field.model):\n            setattr(instance, self.name, data)\n        else:\n            setattr(instance, self.attname, data)\n            # Remote field object must be cleared otherwise Model.save()\n            # will reassign attname using the related object pk.\n            if data is None:\n                setattr(instance, self.name, data)\n\n    def _check_unique(self, **kwargs):\n        # Override ForeignKey since check isn't applicable here.\n        return []",
                        "filename": "django/db/models/fields/related.py",
                        "start_index": 44860,
                        "end_index": 46544,
                        "start_line": 1217,
                        "end_line": 1976,
                        "max_line": 2005,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the OneToOneField class and its unique constraint, which is directly related to the issue of inspectdb generating a unique ForeignKey instead of a OneToOneField."
                }
            ]
        },
        "solution_task": "To address the issue where `inspectdb` is generating `ForeignKey` with a unique constraint instead of `OneToOneField`, and causing `fields.W342` warnings, you should:\n\n- Locate the `inspectdb` command implementation within the Django codebase. This is typically found in the `django/core/management/commands/inspectdb.py` file.\n- Modify the logic that determines when to generate a `ForeignKey` versus a `OneToOneField`. Specifically, look for the part of the code that inspects the database schema to identify unique constraints on foreign key columns.\n- Adjust the condition to generate a `OneToOneField` instead of a `ForeignKey` when a unique constraint is detected on the foreign key column.\n- Ensure that the `unique` argument is set to `True` when initializing a `OneToOneField`, as shown in the `OneToOneField` class definition in the provided code snippet.\n- Remove or adjust the logic that triggers the `fields.W342` warning when a `ForeignKey` with a unique constraint is encountered, as this should now be handled by the `OneToOneField` logic.\n- Test the changes with a database schema that should trigger the creation of a `OneToOneField` to ensure that the `inspectdb` command now correctly generates `OneToOneField` without raising `fields.W342` warnings.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and structured approach to resolving the issue with `inspectdb` generating a unique `ForeignKey` instead of a `OneToOneField`. It gives specific locations in the Django codebase to look for the implementation of the `inspectdb` command and suggests modifications to the logic that determines when to generate a `ForeignKey` versus a `OneToOneField`. The RESPONSE also includes a recommendation to adjust the condition for generating a `OneToOneField` when a unique constraint is detected, which is directly related to the problem described in the PROMPT. Additionally, it advises on handling the `fields.W342` warning and testing the changes, which are essential steps in the bug resolution process. The RESPONSE also provides a link to the relevant code snippet, which is useful for the developer to reference. The reason for not giving a score of 10 is that the RESPONSE could have included more detailed steps or examples of the code changes required, which would have made it even more actionable.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711729526.329526,
        "result": "To address the issue where `inspectdb` is generating `ForeignKey` with a unique constraint instead of `OneToOneField`, and causing `fields.W342` warnings, you should:\n\n- Locate the `inspectdb` command implementation within the Django codebase. This is typically found in the `django/core/management/commands/inspectdb.py` file.\n- Modify the logic that determines when to generate a `ForeignKey` versus a `OneToOneField`. Specifically, look for the part of the code that inspects the database schema to identify unique constraints on foreign key columns.\n- Adjust the condition to generate a `OneToOneField` instead of a `ForeignKey` when a unique constraint is detected on the foreign key column.\n- Ensure that the `unique` argument is set to `True` when initializing a `OneToOneField`, as shown in the `OneToOneField` class definition in the provided code snippet.\n- Remove or adjust the logic that triggers the `fields.W342` warning when a `ForeignKey` with a unique constraint is encountered, as this should now be handled by the `OneToOneField` logic.\n- Test the changes with a database schema that should trigger the creation of a `OneToOneField` to ensure that the `inspectdb` command now correctly generates `OneToOneField` without raising `fields.W342` warnings.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [db](https://github.com/testbed/django__django__3.0/tree//django/db) \u2192 [models](https://github.com/testbed/django__django__3.0/tree//django/db/models) \u2192 [fields](https://github.com/testbed/django__django__3.0/tree//django/db/models/fields)- [Lines 1217 - 1976](https://github.com/testbed/django__django__3.0/blob//django/db/models/fields/related.py#L1217-L1976)\n\n This snippet defines the OneToOneField class and its unique constraint, which is directly related to the issue of inspectdb generating a unique ForeignKey instead of a OneToOneField."
    }
}