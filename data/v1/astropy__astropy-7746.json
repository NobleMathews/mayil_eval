{
    "id": "astropy__astropy-7746",
    "repo_name": "testbed/astropy__astropy__1.3",
    "task_id": 4546227369870658600,
    "title": "Issue when passing empty lists/arrays to WCS transformations",
    "body": "The following should not fail but instead should return empty lists/arrays:\r\n\r\n```\r\nIn [1]: from astropy.wcs import WCS\r\n\r\nIn [2]: wcs = WCS('2MASS_h.fits')\r\n\r\nIn [3]: wcs.wcs_pix2world([], [], 0)\r\n---------------------------------------------------------------------------\r\nInconsistentAxisTypesError                Traceback (most recent call last)\r\n<ipython-input-3-e2cc0e97941a> in <module>()\r\n----> 1 wcs.wcs_pix2world([], [], 0)\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in wcs_pix2world(self, *args, **kwargs)\r\n   1352         return self._array_converter(\r\n   1353             lambda xy, o: self.wcs.p2s(xy, o)['world'],\r\n-> 1354             'output', *args, **kwargs)\r\n   1355     wcs_pix2world.__doc__ = \"\"\"\r\n   1356         Transforms pixel coordinates to world coordinates by doing\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1267                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1268 \r\n-> 1269             return _return_list_of_arrays(axes, origin)\r\n   1270 \r\n   1271         raise TypeError(\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1223             if ra_dec_order and sky == 'input':\r\n   1224                 xy = self._denormalize_sky(xy)\r\n-> 1225             output = func(xy, origin)\r\n   1226             if ra_dec_order and sky == 'output':\r\n   1227                 output = self._normalize_sky(output)\r\n\r\n~/Dropbox/Code/Astropy/astropy/astropy/wcs/wcs.py in <lambda>(xy, o)\r\n   1351             raise ValueError(\"No basic WCS settings were created.\")\r\n   1352         return self._array_converter(\r\n-> 1353             lambda xy, o: self.wcs.p2s(xy, o)['world'],\r\n   1354             'output', *args, **kwargs)\r\n   1355     wcs_pix2world.__doc__ = \"\"\"\r\n\r\nInconsistentAxisTypesError: ERROR 4 in wcsp2s() at line 2646 of file cextern/wcslib/C/wcs.c:\r\nncoord and/or nelem inconsistent with the wcsprm.\r\n```\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__1.3.git",
    "requested_commit": "",
    "mayil_response": "The issue is related to calling `wcs.wcs_pix2world([], [], 0)` which results in an `InconsistentAxisTypesError`. This error is raised within the `wcslib` C library, indicating that the Python wrapper may not be handling empty input lists correctly before passing them to the C library.\n\nTo resolve the issue:\n\n- Modify the `wcs_pix2world` method in `astropy/wcs/wcs.py` to check for empty input lists and return empty lists without calling the C library functions if the inputs are empty.\n- Ensure that the `wcs_pix2world` method can handle empty lists as input and return empty lists as output.\n\nHere is a possible solution:\n\n```python\n# In astropy/wcs/wcs.py, modify the wcs_pix2world method:\n\ndef wcs_pix2world(self, *args, **kwargs):\n    if self.wcs is None:\n        raise ValueError(\"No basic WCS settings were created.\")\n    \n    # Check if the input lists are empty and return empty lists immediately\n    if all(len(arg) == 0 for arg in args):\n        return []\n\n    return self._array_converter(\n        lambda xy, o: self.wcs.p2s(xy, o)[\"world\"], \"output\", *args, **kwargs\n    )\n```\n\nThis change ensures that if empty lists are passed to `wcs_pix2world`, it will return empty lists immediately without invoking the WCSLIB C functions, thus avoiding the `InconsistentAxisTypesError`.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs/src)- [Lines 203 - 481](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/src/astropy_wcs.c#L203-L481)\n\n This snippet contains the 'Wcs_all_pix2world' function which is directly related to the transformation from pixel to world coordinates, and it checks for the dimensions of the input array which is relevant to the issue of handling empty arrays.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs)- [Lines 2461 - 2554](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/wcs.py#L2461-L2554)\n\n This snippet from 'wcs.py' includes the 'wcs_world2pix' method which is the inverse of the operation causing the issue. It may contain logic that needs to be mirrored or adapted for the 'wcs_pix2world' method to handle empty arrays correctly. \n\n\n   - [Lines 1567 - 3796](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/wcs.py#L1567-L3796)\n\n This snippet includes the 'all_pix2world' method which is a higher-level function that calls the transformation from pixel to world coordinates. It is relevant as it may need to be modified to handle empty arrays correctly.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs/src)- [Lines 45 - 1461](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/src/wcslib_wrap.c#L45-L1461)\n\n This snippet contains the 'wcsp2s' function call which is part of the WCS transformation process and handles the conversion from pixel to sky coordinates. It is relevant because the error traceback indicates an issue within this function when empty arrays are passed.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs/src)- [Lines 147 - 241](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/src/pyutil.c#L147-L241)\n\n This snippet contains functions 'wcsprm_c2python' and 'wcsprm_python2c' which handle the conversion of undefined values to NaN and vice versa. It is relevant because the issue may be related to how empty or undefined values are handled in the WCS transformation process.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002895,
        "snippet_processor": 0.10317000000000001,
        "issue_star_creation": 0.01988,
        "issue_star_solver": 0.07297000000000001,
        "bouncer": 0.023039999999999998
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711737693.605022,
        "relevant_snippets": [
            {
                "code": "static PyObject*\nWcs_all_pix2world(\n    Wcs* self,\n    PyObject* args,\n    PyObject* kwds) {\n\n  int            naxis      = 2;\n  PyObject*      pixcrd_obj = NULL;\n  int            origin     = 1;\n  PyArrayObject* pixcrd     = NULL;\n  PyArrayObject* world      = NULL;\n  int            status     = -1;\n  const char*    keywords[] = {\n    \"pixcrd\", \"origin\", NULL };\n\n  if (!PyArg_ParseTupleAndKeywords(\n          args, kwds, \"Oi:all_pix2world\", (char **)keywords,\n          &pixcrd_obj, &origin)) {\n    return NULL;\n  }\n\n  naxis = self->x.wcs->naxis;\n\n  pixcrd = (PyArrayObject*)PyArray_ContiguousFromAny(pixcrd_obj, NPY_DOUBLE, 2, 2);\n  if (pixcrd == NULL) {\n    return NULL;\n  }\n\n  if (PyArray_DIM(pixcrd, 1) < naxis) {\n    PyErr_Format(\n      PyExc_RuntimeError,\n      \"Input array must be 2-dimensional, where the second dimension >= %d\",\n      naxis);\n    goto exit;\n  }\n\n  world = (PyArrayObject*)PyArray_SimpleNew(2, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (world == NULL) {\n    goto exit;\n  }\n\n  /* Make the call */\n  Py_BEGIN_ALLOW_THREADS\n  preoffset_array(pixcrd, origin);\n  wcsprm_python2c(self->x.wcs);\n  status = pipeline_all_pixel2world(&self->x,\n                                    (unsigned int)PyArray_DIM(pixcrd, 0),\n                                    (unsigned int)PyArray_DIM(pixcrd, 1),\n                                    (double*)PyArray_DATA(pixcrd),\n                                    (double*)PyArray_DATA(world));\n  wcsprm_c2python(self->x.wcs);\n  unoffset_array(pixcrd, origin);\n  Py_END_ALLOW_THREADS\n  /* unoffset_array(world, origin); */\n\n exit:\n  Py_XDECREF(pixcrd);\n\n  if (status == 0 || status == 8) {\n    return (PyObject*)world;\n  } else {\n    Py_XDECREF(world);\n    if (status == -1) {\n      PyErr_SetString(\n        PyExc_ValueError,\n        \"Wrong number of dimensions in input array.  Expected 2.\");\n      return NULL;\n    } else {\n      if (status == -1) {\n        /* exception already set */\n        return NULL;\n      } else {\n        wcserr_to_python_exc(self->x.err);\n        return NULL;\n      }\n    }\n  }\n}\n\n/*@null@*/",
                "filename": "astropy/wcs/src/astropy_wcs.c",
                "start_index": 5150,
                "end_index": 7218,
                "start_line": 203,
                "end_line": 481,
                "max_line": 886,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "def wcs_world2pix(self, *args, **kwargs):\n        if self.wcs is None:\n            raise ValueError(\"No basic WCS settings were created.\")\n        return self._array_converter(\n            lambda xy, o: self.wcs.s2p(xy, o)[\"pixcrd\"], \"input\", *args, **kwargs\n        )\n\n    wcs_world2pix.__doc__ = f\"\"\"\n        Transforms world coordinates to pixel coordinates, using only\n        the basic `wcslib`_ WCS transformation.  No `SIP`_ or\n        `distortion paper`_ table lookup transformation is applied.\n\n        Parameters\n        ----------\n        {docstrings.TWO_OR_MORE_ARGS('naxis', 8)}\n\n            For a transformation that is not two-dimensional, the\n            two-argument form must be used.\n\n        {docstrings.RA_DEC_ORDER(8)}\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('pixel coordinates', 8)}\n\n        Notes\n        -----\n        The order of the axes for the input world array is determined by\n        the ``CTYPEia`` keywords in the FITS header, therefore it may\n        not always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp` and `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        SingularMatrixError\n            Linear transformation matrix is singular.\n\n        InconsistentAxisTypesError\n            Inconsistent or unrecognized coordinate axis types.\n\n        ValueError\n            Invalid parameter value.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n\n        ValueError\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n        \"\"\"\n\n    def pix2foc(self, *args):\n        return self._array_converter(self._pix2foc, None, *args)\n\n    pix2foc.__doc__ = f\"\"\"\n        Convert pixel coordinates to focal plane coordinates using the\n        `SIP`_ polynomial distortion convention and `distortion\n        paper`_ table-lookup correction.\n\n        The output is in absolute pixel coordinates, not relative to\n        ``CRPIX``.\n\n        Parameters\n        ----------\n\n        {docstrings.TWO_OR_MORE_ARGS('2', 8)}\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('focal coordinates', 8)}\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n        \"\"\"\n\n    def p4_pix2foc(self, *args):\n        return self._array_converter(self._p4_pix2foc, None, *args)",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 93731,
                "end_index": 96510,
                "start_line": 2461,
                "end_line": 2554,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "if (wcs->types[i] == 2200) {\n      // Convert celestial coordinates; do we have a CUBEFACE axis?\n      if (wcs->cubeface != -1) {\n        // Separation between faces.\n        double offset;\n        if (wcsprj->r0 == 0.0) {\n          offset = 90.0;\n        } else {\n          offset = wcsprj->r0*PI/2.0;\n        }\n\n        // Lay out faces in a plane.\n        img = imgcrd;\n        int *statp = stat;\n        int bits = (1 << i) | (1 << wcs->lat);\n        for (int k = 0; k < ncoord; k++, statp++) {\n          int face = (int)(*(img+wcs->cubeface) + 0.5);\n          if (fabs(*(img+wcs->cubeface) - face) > 1e-10) {\n            *statp |= bits;\n            status = wcserr_set(WCS_ERRMSG(WCSERR_BAD_PIX));\n\n          } else {\n            *statp = 0;\n\n            switch (face) {\n            case 0:\n              *(img+wcs->lat) += offset;\n              break;\n            case 1:\n              break;\n            case 2:\n              *(img+i) += offset;\n              break;\n            case 3:\n              *(img+i) += offset*2;\n              break;\n            case 4:\n              *(img+i) += offset*3;\n              break;\n            case 5:\n              *(img+wcs->lat) -= offset;\n              break;\n            default:\n              *statp |= bits;\n              status = wcserr_set(WCS_ERRMSG(WCSERR_BAD_PIX));\n            }\n          }\n\n          img += nelem;\n        }\n      }\n\n      // Check for constant x and/or y.\n      int iso_x = 0;\n      int iso_y = 0;\n      int nx = ncoord;\n      int ny = 0;\n\n      if (ncoord > 1) {\n        if ((iso_x = wcsutil_allEq(ncoord, nelem, imgcrd+i))) {\n          nx = 1;\n          ny = ncoord;\n        }\n        if ((iso_y = wcsutil_allEq(ncoord, nelem, imgcrd+wcs->lat))) {\n          ny = 1;\n        }\n      }\n\n      // Transform projection plane coordinates to celestial coordinates.\n      int istat = celx2s(wcscel, nx, ny, nelem, nelem, imgcrd+i,\n                         imgcrd+wcs->lat, phi, theta, world+i,\n                         world+wcs->lat, istatp);\n      if (istat) {\n        status = wcserr_set(WCS_ERRMSG(wcs_celerr[istat]));\n        if (status != WCSERR_BAD_PIX) {\n          goto cleanup;\n        }\n      }\n\n      // If x and y were both constant, replicate values.\n      if (iso_x && iso_y) {\n        wcsutil_setAll(ncoord, nelem, world+i);\n        wcsutil_setAll(ncoord, nelem, world+wcs->lat);\n        wcsutil_setAll(ncoord, 1, phi);\n        wcsutil_setAll(ncoord, 1, theta);\n        wcsutil_setAli(ncoord, 1, istatp);\n      }\n\n      // WCSERR_BAD_PIX stat[] vector accounting.\n      if (istat) {\n        int bits = (1 << i) | (1 << wcs->lat);\n        wcsutil_setBit(ncoord, istatp, bits, stat);\n      }\n\n    } else",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 94754,
                "end_index": 97443,
                "start_line": 3395,
                "end_line": 4598,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "Notes\n        -----\n        The order of the axes for the input world array is determined by\n        the ``CTYPEia`` keywords in the FITS header, therefore it may\n        not always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp`, and\n        `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        Using the method of fixed-point iterations approximations we\n        iterate starting with the initial approximation, which is\n        computed using the non-distortion-aware\n        :py:meth:`wcs_world2pix` (or equivalent).\n\n        The :py:meth:`all_world2pix` function uses a vectorized\n        implementation of the method of consecutive approximations and\n        therefore it is highly efficient (>30x) when *all* data points\n        that need to be converted from sky coordinates to image\n        coordinates are passed at *once*. Therefore, it is advisable,\n        whenever possible, to pass as input a long array of all points\n        that need to be converted to :py:meth:`all_world2pix` instead\n        of calling :py:meth:`all_world2pix` for each data point. Also\n        see the note to the ``adaptive`` parameter.\n\n        Raises\n        ------\n        NoConvergence\n            The method did not converge to a\n            solution to the required accuracy within a specified\n            number of maximum iterations set by the ``maxiter``\n            parameter. To turn off this exception, set ``quiet`` to\n            `True`. Indices of the points for which the requested\n            accuracy was not achieved (if any) will be listed in the\n            ``slow_conv`` attribute of the\n            raised :py:class:`NoConvergence` exception object.\n\n            See :py:class:`NoConvergence` documentation for\n            more details.\n\n        MemoryError\n            Memory allocation failed.\n\n        SingularMatrixError\n            Linear transformation matrix is singular.\n\n        InconsistentAxisTypesError\n            Inconsistent or unrecognized coordinate axis types.\n\n        ValueError\n            Invalid parameter value.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n\n        ValueError\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n\n        Examples\n        --------\n        >>> import astropy.io.fits as fits\n        >>> import astropy.wcs as wcs\n        >>> import numpy as np\n        >>> import os\n\n        >>> filename = os.path.join(wcs.__path__[0], 'tests/data/j94f05bgq_flt.fits')\n        >>> hdulist = fits.open(filename)\n        >>> w = wcs.WCS(hdulist[('sci',1)].header, hdulist)\n        >>> hdulist.close()\n\n        >>> ra, dec = w.all_pix2world([1,2,3], [1,1,1], 1)\n        >>> print(ra)  # doctest: +FLOAT_CMP\n        [ 5.52645627  5.52649663  5.52653698]\n        >>> print(dec)  # doctest: +FLOAT_CMP\n        [-72.05171757 -72.05171276 -72.05170795]\n        >>> radec = w.all_pix2world([[1,1], [2,1], [3,1]], 1)\n        >>> print(radec)  # doctest: +FLOAT_CMP\n        [[  5.52645627 -72.05171757]\n         [  5.52649663 -72.05171276]\n         [  5.52653698 -72.05170795]]\n        >>> x, y = w.all_world2pix(ra, dec, 1)\n        >>> print(x)  # doctest: +FLOAT_CMP\n        [ 1.00000238  2.00000237  3.00000236]\n        >>> print(y)  # doctest: +FLOAT_CMP\n        [ 0.99999996  0.99999997  0.99999997]\n        >>> xy = w.all_world2pix(radec, 1)\n        >>> print(xy)  # doctest: +FLOAT_CMP\n        [[ 1.00000238  0.99999996]\n         [ 2.00000237  0.99999997]\n         [ 3.00000236  0.99999997]]\n        >>> xy = w.all_world2pix(radec, 1, maxiter=3,\n        ...                      tolerance=1.0e-10, quiet=False)\n        Traceback (most recent call last):\n        ...\n        NoConvergence: 'WCS.all_world2pix' failed to converge to the\n        requested accuracy. After 3 iterations, the solution is\n        diverging at least for one input point.\n\n        >>> # Now try to use some diverging data:\n        >>> divradec = w.all_pix2world([[1.0, 1.0],\n        ...                             [10000.0, 50000.0],\n        ...                             [3.0, 1.0]], 1)\n        >>> print(divradec)  # doctest: +FLOAT_CMP\n        [[  5.52645627 -72.05171757]\n         [  7.15976932 -70.8140779 ]\n         [  5.52653698 -72.05170795]]\n\n        >>> # First, turn detect_divergence on:\n        >>> try:  # doctest: +FLOAT_CMP\n        ...   xy = w.all_world2pix(divradec, 1, maxiter=20,\n        ...                        tolerance=1.0e-4, adaptive=False,\n        ...                        detect_divergence=True,\n        ...                        quiet=False)\n        ... except wcs.wcs.NoConvergence as e:\n        ...   print(\"Indices of diverging points: {{",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 86424,
                "end_index": 91388,
                "start_line": 377,
                "end_line": 2436,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "{\n\n  int            naxis      = 2;\n  int            ncoord     = 0;\n  int            nelem      = 0;\n  PyObject*      pixcrd_obj = NULL;\n  int            origin     = 1;\n  PyArrayObject* pixcrd     = NULL;\n  PyArrayObject* imgcrd     = NULL;\n  PyArrayObject* phi        = NULL;\n  PyArrayObject* theta      = NULL;\n  PyArrayObject* world      = NULL;\n  PyArrayObject* stat       = NULL;\n  PyObject*      result     = NULL;\n  int            status     = 0;\n  const char*    keywords[] = {\n    \"pixcrd\", \"origin\", NULL };\n\n  if (!PyArg_ParseTupleAndKeywords(\n          args, kwds, \"Oi:p2s\", (char **)keywords,\n          &pixcrd_obj, &origin)) {\n    return NULL;\n  }\n\n  naxis = self->x.naxis;\n\n  pixcrd = (PyArrayObject*)PyArray_ContiguousFromAny\n    (pixcrd_obj, NPY_DOUBLE, 2, 2);\n  if (pixcrd == NULL) {\n    return NULL;\n  }\n\n  if (PyArray_DIM(pixcrd, 1) < naxis) {\n    PyErr_Format(\n      PyExc_RuntimeError,\n      \"Input array must be 2-dimensional, where the second dimension >= %d\",\n      naxis);\n    goto exit;\n  }\n\n  /* Now we allocate a bunch of numpy arrays to store the results in.\n   */\n  imgcrd = (PyArrayObject*)PyArray_SimpleNew(\n      2, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (imgcrd == NULL) {\n    goto exit;\n  }\n\n  phi = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (phi == NULL) {\n    goto exit;\n  }\n\n  theta = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (theta == NULL) {\n    goto exit;\n  }\n\n  world = (PyArrayObject*)PyArray_SimpleNew(\n      2, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (world == NULL) {\n    goto exit;\n  }\n\n  stat = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(pixcrd), NPY_INT);\n  if (stat == NULL) {\n    goto exit;\n  }\n\n  /* Make the call */\n  Py_BEGIN_ALLOW_THREADS\n  ncoord = PyArray_DIM(pixcrd, 0);\n  nelem = PyArray_DIM(pixcrd, 1);\n  preoffset_array(pixcrd, origin);\n  wcsprm_python2c(&self->x);\n  status = wcsp2s(\n      &self->x,\n      ncoord,\n      nelem,\n      (double*)PyArray_DATA(pixcrd),\n      (double*)PyArray_DATA(imgcrd),\n      (double*)PyArray_DATA(phi),\n      (double*)PyArray_DATA(theta),\n      (double*)PyArray_DATA(world),\n      (int*)PyArray_DATA(stat));\n  wcsprm_c2python(&self->x);\n  unoffset_array(pixcrd, origin);\n  /* unoffset_array(world, origin); */\n  unoffset_array(imgcrd, origin);\n  if (status == 8) {\n    set_invalid_to_nan(\n        ncoord, nelem, (double*)PyArray_DATA(imgcrd), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, 1, (double*)PyArray_DATA(phi), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, 1, (double*)PyArray_DATA(theta), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, nelem, (double*)PyArray_DATA(world), (int*)PyArray_DATA(stat));\n  }\n  Py_END_ALLOW_THREADS\n\n  if (status == 0 || status == 8)",
                "filename": "astropy/wcs/src/wcslib_wrap.c",
                "start_index": 30842,
                "end_index": 33672,
                "start_line": 45,
                "end_line": 1461,
                "max_line": 4296,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "{\n\n  int            naxis     = 2;\n  int            ncoord    = 0;\n  int            nelem     = 0;\n  PyObject*      world_obj = NULL;\n  int            origin    = 1;\n  PyArrayObject* world     = NULL;\n  PyArrayObject* phi       = NULL;\n  PyArrayObject* theta     = NULL;\n  PyArrayObject* imgcrd    = NULL;\n  PyArrayObject* pixcrd    = NULL;\n  PyArrayObject* stat      = NULL;\n  PyObject*      result    = NULL;\n  int            status    = -1;\n  const char*    keywords[] = {\n    \"world\", \"origin\", NULL };\n\n  if (!PyArg_ParseTupleAndKeywords(\n          args, kwds, \"Oi:s2p\", (char **)keywords,\n          &world_obj, &origin)) {\n    return NULL;\n  }\n\n  naxis = self->x.naxis;\n\n  world = (PyArrayObject*)PyArray_ContiguousFromAny(\n      world_obj, NPY_DOUBLE, 2, 2);\n  if (world == NULL) {\n    return NULL;\n  }\n\n  if (PyArray_DIM(world, 1) < naxis) {\n    PyErr_Format(\n      PyExc_RuntimeError,\n      \"Input array must be 2-dimensional, where the second dimension >= %d\",\n      naxis);\n    goto exit;\n  }\n\n  /* Now we allocate a bunch of numpy arrays to store the\n   * results in.\n   */\n  phi = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(world), NPY_DOUBLE);\n  if (phi == NULL) {\n    goto exit;\n  }\n\n  theta = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(world), NPY_DOUBLE);\n  if (phi == NULL) {\n    goto exit;\n  }\n\n  imgcrd = (PyArrayObject*)PyArray_SimpleNew(\n      2, PyArray_DIMS(world), NPY_DOUBLE);\n  if (theta == NULL) {\n    goto exit;\n  }\n\n  pixcrd = (PyArrayObject*)PyArray_SimpleNew(\n      2, PyArray_DIMS(world), NPY_DOUBLE);\n  if (pixcrd == NULL) {\n    goto exit;\n  }\n\n  stat = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(world), NPY_INT);\n  if (stat == NULL) {\n    goto exit;\n  }\n\n  /* Make the call */\n  Py_BEGIN_ALLOW_THREADS\n  ncoord = (int)PyArray_DIM(world, 0);\n  nelem = (int)PyArray_DIM(world, 1);\n  /* preoffset_array(world, origin); */\n  wcsprm_python2c(&self->x);\n  status = wcss2p(\n      &self->x,\n      ncoord,\n      nelem,\n      (double*)PyArray_DATA(world),\n      (double*)PyArray_DATA(phi),\n      (double*)PyArray_DATA(theta),\n      (double*)PyArray_DATA(imgcrd),\n      (double*)PyArray_DATA(pixcrd),\n      (int*)PyArray_DATA(stat));\n  wcsprm_c2python(&self->x);\n  /* unoffset_array(world, origin); */\n  unoffset_array(pixcrd, origin);\n  unoffset_array(imgcrd, origin);\n  if (status == 9) {\n    set_invalid_to_nan(\n        ncoord, 1, (double*)PyArray_DATA(phi), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, 1, (double*)PyArray_DATA(theta), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, nelem, (double*)PyArray_DATA(imgcrd), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, nelem, (double*)PyArray_DATA(pixcrd), (int*)PyArray_DATA(stat));\n  }\n  Py_END_ALLOW_THREADS\n\n  if (status == 0 || status == 9)",
                "filename": "astropy/wcs/src/wcslib_wrap.c",
                "start_index": 34571,
                "end_index": 37398,
                "start_line": 45,
                "end_line": 1604,
                "max_line": 4296,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "/* wcslib represents undefined values using its own special constant,\n   UNDEFINED.  To be consistent with the Pythonic way of doing things,\n   it's nicer to represent undefined values using NaN.  Unfortunately,\n   in order to get nice mutable arrays in Python, Python must be able\n   to edit the wcsprm values directly.  The solution is to store NaNs\n   in the struct \"canonically\", but convert those NaNs to/from\n   UNDEFINED around every call into a wcslib function.  It's not as\n   computationally expensive as it sounds, as all these arrays are\n   quite small.\n*/\n\nstatic INLINE void\nwcsprm_fix_values(\n    struct wcsprm* x,\n    value_fixer_t value_fixer) {\n\n  unsigned int naxis = (unsigned int)x->naxis;\n\n  value_fixer(x->cd, naxis * naxis);\n  value_fixer(x->cdelt, naxis);\n  value_fixer(x->crder, naxis);\n  value_fixer(x->crota, naxis);\n  value_fixer(x->crpix, naxis);\n  value_fixer(x->crval, naxis);\n  value_fixer(x->csyer, naxis);\n  value_fixer(&x->equinox, 1);\n  value_fixer(&x->latpole, 1);\n  value_fixer(&x->lonpole, 1);\n  value_fixer(&x->mjdavg, 1);\n  value_fixer(&x->mjdobs, 1);\n  value_fixer(x->obsgeo, 6);\n  value_fixer(&x->cel.phi0, 1);\n  value_fixer(&x->restfrq, 1);\n  value_fixer(&x->restwav, 1);\n  value_fixer(&x->cel.theta0, 1);\n  value_fixer(&x->velangl, 1);\n  value_fixer(&x->velosys, 1);\n  value_fixer(&x->zsource, 1);\n  value_fixer(x->czphs, naxis);\n  value_fixer(x->cperi, naxis);\n  value_fixer(x->mjdref, 2);\n  value_fixer(&x->mjdbeg, 1);\n  value_fixer(&x->mjdend, 1);\n  value_fixer(&x->jepoch, 1);\n  value_fixer(&x->bepoch, 1);\n  value_fixer(&x->tstart, 1);\n  value_fixer(&x->tstop, 1);\n  value_fixer(&x->xposure, 1);\n  value_fixer(&x->timsyer, 1);\n  value_fixer(&x->timrder, 1);\n  value_fixer(&x->timedel, 1);\n  value_fixer(&x->timepixr, 1);\n  value_fixer(&x->timeoffs, 1);\n  value_fixer(&x->telapse, 1);\n}\n\nvoid\nwcsprm_c2python(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &undefined2nan);\n  }\n}\n\nvoid\nwcsprm_python2c(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &nan2undefined);\n  }\n}\n\n/***************************************************************************\n * Exceptions                                                              *\n ***************************************************************************/\n\nPyObject* WcsExc_Wcs;\nPyObject* WcsExc_SingularMatrix;\nPyObject* WcsExc_InconsistentAxisTypes;\nPyObject* WcsExc_InvalidTransform;\nPyObject* WcsExc_InvalidCoordinate;\nPyObject* WcsExc_NoSolution;\nPyObject* WcsExc_InvalidSubimageSpecification;\nPyObject* WcsExc_NonseparableSubimageCoordinateSystem;\nPyObject* WcsExc_NoWcsKeywordsFound;\nPyObject* WcsExc_InvalidTabularParameters;\nPyObject* WcsExc_InvalidPrjParameters;\n\n/* This is an array mapping the wcs status codes to Python exception\n * types.  The exception string is stored as part of wcslib itself in\n * wcs_errmsg.\n */\nPyObject** wcs_errexc[14];",
                "filename": "astropy/wcs/src/pyutil.c",
                "start_index": 2647,
                "end_index": 5571,
                "start_line": 147,
                "end_line": 241,
                "max_line": 957,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "{\n\n  static const char* function = \"pipeline_all_pixel2world\";\n\n  const double*   wcs_input  = NULL;\n  double*         wcs_output = NULL;\n  int             has_det2im;\n  int             has_sip;\n  int             has_p4;\n  int             has_wcs;\n  int             status     = 1;\n  struct wcserr **err;\n\n  /* Temporary buffer for performing WCS calculations */\n  unsigned char*     buffer = NULL;\n  unsigned char*     mem = NULL;\n  /*@null@*/ double* tmp;\n  /*@null@*/ double* imgcrd;\n  /*@null@*/ double* phi;\n  /*@null@*/ double* theta;\n  /*@null@*/ int*    stat;\n\n  if (pipeline == NULL || pixcrd == NULL || world == NULL) {\n    return WCSERR_NULL_POINTER;\n  }\n\n  err = &(pipeline->err);\n\n  has_det2im = pipeline->det2im[0] != NULL || pipeline->det2im[1] != NULL;\n  has_sip    = pipeline->sip != NULL;\n  has_p4     = pipeline->cpdis[0] != NULL || pipeline->cpdis[1] != NULL;\n  has_wcs    = pipeline->wcs != NULL;\n\n  if (has_det2im || has_sip || has_p4) {\n    if (nelem != 2) {\n      status = wcserr_set(\n        PIP_ERRMSG(WCSERR_BAD_COORD_TRANS),\n        \"Data must be 2-dimensional when Paper IV lookup table or SIP transform is present.\");\n      goto exit;\n    }\n  }\n\n  if (has_wcs) {\n    if (ncoord < 1) {\n      status = wcserr_set(\n        PIP_ERRMSG(WCSERR_BAD_PIX),\n        \"The number of coordinates must be > 0\");\n      goto exit;\n    }\n\n    buffer = mem = malloc(\n        ncoord * nelem * sizeof(double) + /* imgcrd */\n        ncoord * sizeof(double) +         /* phi */\n        ncoord * sizeof(double) +         /* theta */\n        ncoord * nelem * sizeof(double) + /* tmp */\n        ncoord * nelem * sizeof(int)      /* stat */\n        );\n\n    if (buffer == NULL) {\n      status = wcserr_set(\n        PIP_ERRMSG(WCSERR_MEMORY), \"Memory allocation failed\");\n      goto exit;\n    }\n\n    imgcrd = (double *)mem;\n    mem += ncoord * nelem * sizeof(double);\n\n    phi = (double *)mem;\n    mem += ncoord * sizeof(double);\n\n    theta = (double *)mem;\n    mem += ncoord * sizeof(double);\n\n    tmp = (double *)mem;\n    mem += ncoord * nelem * sizeof(double);\n\n    stat = (int *)mem;\n    /* mem += ncoord * nelem * sizeof(int); */\n\n    if (has_det2im || has_sip || has_p4) {\n      status = pipeline_pix2foc(pipeline, ncoord, nelem, pixcrd, tmp);\n      if (status != 0) {\n        goto exit;\n      }\n\n      wcs_input = tmp;\n      wcs_output = world;\n    } else {\n      wcs_input = pixcrd;\n      wcs_output = world;\n    }\n\n    if ((status = wcsp2s(pipeline->wcs, (int)ncoord, (int)nelem, wcs_input, imgcrd,\n                         phi, theta, wcs_output, stat))) {\n      if (pipeline->err == NULL) {\n        pipeline->err = calloc(1, sizeof(struct wcserr));\n      }\n      wcserr_copy(pipeline->wcs->err, pipeline->err);\n    }\n\n    if (status == 8) {\n      set_invalid_to_nan((int)ncoord, (int)nelem, wcs_output, stat);\n    }\n  } else {\n    if (has_det2im || has_sip || has_p4) {\n      status = pipeline_pix2foc(pipeline, ncoord, nelem, pixcrd, world);\n    }\n  }\n\n exit:\n  free(buffer);",
                "filename": "astropy/wcs/src/pipeline.c",
                "start_index": 1243,
                "end_index": 4232,
                "start_line": 17,
                "end_line": 169,
                "max_line": 271,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "def all_pix2world(self, *args, **kwargs):\n        return self._array_converter(self._all_pix2world, \"output\", *args, **kwargs)\n\n    all_pix2world.__doc__ = f\"\"\"\n        Transforms pixel coordinates to world coordinates.\n\n        Performs all of the following in series:\n\n            - Detector to image plane correction (if present in the\n              FITS file)\n\n            - `SIP`_ distortion correction (if present in the FITS\n              file)\n\n            - `distortion paper`_ table-lookup correction (if present\n              in the FITS file)\n\n            - `wcslib`_ \"core\" WCS transformation\n\n        Parameters\n        ----------\n        {docstrings.TWO_OR_MORE_ARGS('naxis', 8)}\n\n            For a transformation that is not two-dimensional, the\n            two-argument form must be used.\n\n        {docstrings.RA_DEC_ORDER(8)}\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('sky coordinates, in degrees', 8)}\n\n        Notes\n        -----\n        The order of the axes for the result is determined by the\n        ``CTYPEia`` keywords in the FITS header, therefore it may not\n        always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp` and `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        SingularMatrixError\n            Linear transformation matrix is singular.\n\n        InconsistentAxisTypesError\n            Inconsistent or unrecognized coordinate axis types.\n\n        ValueError\n            Invalid parameter value.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n\n        ValueError\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n        \"\"\"\n\n    def wcs_pix2world(self, *args, **kwargs):\n        if self.wcs is None:\n            raise ValueError(\"No basic WCS settings were created.\")\n        return self._array_converter(\n            lambda xy, o: self.wcs.p2s(xy, o)[\"world\"], \"output\", *args, **kwargs\n        )",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 56692,
                "end_index": 59004,
                "start_line": 1567,
                "end_line": 3796,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "if (wcs->types[i] == 2200) {\n      // Celestial coordinates; check for constant lng and/or lat.\n      int isolng = 0;\n      int isolat = 0;\n      int nlng = ncoord;\n      int nlat = 0;\n\n      if (ncoord > 1) {\n        if ((isolng = wcsutil_allEq(ncoord, nelem, world+i))) {\n          nlng = 1;\n          nlat = ncoord;\n        }\n        if ((isolat = wcsutil_allEq(ncoord, nelem, world+wcs->lat))) {\n          nlat = 1;\n        }\n      }\n\n      // Transform celestial coordinates to projection plane coordinates.\n      int istat = cels2x(wcscel, nlng, nlat, nelem, nelem, world+i,\n                         world+wcs->lat, phi, theta, imgcrd+i,\n                         imgcrd+wcs->lat, istatp);\n      if (istat) {\n        status = wcserr_set(WCS_ERRMSG(wcs_celerr[istat]));\n        if (status != WCSERR_BAD_WORLD) {\n          goto cleanup;\n        }\n      }\n\n      // If lng and lat were both constant, replicate values.\n      if (isolng && isolat) {\n        wcsutil_setAll(ncoord, nelem, imgcrd+i);\n        wcsutil_setAll(ncoord, nelem, imgcrd+wcs->lat);\n        wcsutil_setAll(ncoord, 1, phi);\n        wcsutil_setAll(ncoord, 1, theta);\n        wcsutil_setAli(ncoord, 1, istatp);\n      }\n\n      // WCSERR_BAD_WORLD stat[] vector accounting.\n      if (istat) {\n        int bits = (1 << i) | (1 << wcs->lat);\n        wcsutil_setBit(ncoord, istatp, bits, stat);\n      }\n\n      // Do we have a CUBEFACE axis?\n      if (wcs->cubeface != -1) {\n        // Separation between faces.\n        double offset;\n        if (wcsprj->r0 == 0.0) {\n          offset = 90.0;\n        } else {\n          offset = wcsprj->r0*PI/2.0;\n        }\n\n        // Stack faces in a cube.\n        register double *img = imgcrd;\n        for (int k = 0; k < ncoord; k++) {\n          if (*(img+wcs->lat) < -0.5*offset) {\n            *(img+wcs->lat) += offset;\n            *(img+wcs->cubeface) = 5.0;\n          } else if (*(img+wcs->lat) > 0.5*offset) {\n            *(img+wcs->lat) -= offset;\n            *(img+wcs->cubeface) = 0.0;\n          } else if (*(img+i) > 2.5*offset) {\n            *(img+i) -= 3.0*offset;\n            *(img+wcs->cubeface) = 4.0;\n          } else if (*(img+i) > 1.5*offset) {\n            *(img+i) -= 2.0*offset;\n            *(img+wcs->cubeface) = 3.0;\n          } else if (*(img+i) > 0.5*offset) {\n            *(img+i) -= offset;\n            *(img+wcs->cubeface) = 2.0;\n          } else {\n            *(img+wcs->cubeface) = 1.0;\n          }\n\n          img += nelem;\n        }\n      }\n\n    } else",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 101008,
                "end_index": 103492,
                "start_line": 3395,
                "end_line": 4598,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "astropy/wcs/src/astropy_wcs.c": [
                {
                    "chunk": {
                        "code": "static PyObject*\nWcs_all_pix2world(\n    Wcs* self,\n    PyObject* args,\n    PyObject* kwds) {\n\n  int            naxis      = 2;\n  PyObject*      pixcrd_obj = NULL;\n  int            origin     = 1;\n  PyArrayObject* pixcrd     = NULL;\n  PyArrayObject* world      = NULL;\n  int            status     = -1;\n  const char*    keywords[] = {\n    \"pixcrd\", \"origin\", NULL };\n\n  if (!PyArg_ParseTupleAndKeywords(\n          args, kwds, \"Oi:all_pix2world\", (char **)keywords,\n          &pixcrd_obj, &origin)) {\n    return NULL;\n  }\n\n  naxis = self->x.wcs->naxis;\n\n  pixcrd = (PyArrayObject*)PyArray_ContiguousFromAny(pixcrd_obj, NPY_DOUBLE, 2, 2);\n  if (pixcrd == NULL) {\n    return NULL;\n  }\n\n  if (PyArray_DIM(pixcrd, 1) < naxis) {\n    PyErr_Format(\n      PyExc_RuntimeError,\n      \"Input array must be 2-dimensional, where the second dimension >= %d\",\n      naxis);\n    goto exit;\n  }\n\n  world = (PyArrayObject*)PyArray_SimpleNew(2, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (world == NULL) {\n    goto exit;\n  }\n\n  /* Make the call */\n  Py_BEGIN_ALLOW_THREADS\n  preoffset_array(pixcrd, origin);\n  wcsprm_python2c(self->x.wcs);\n  status = pipeline_all_pixel2world(&self->x,\n                                    (unsigned int)PyArray_DIM(pixcrd, 0),\n                                    (unsigned int)PyArray_DIM(pixcrd, 1),\n                                    (double*)PyArray_DATA(pixcrd),\n                                    (double*)PyArray_DATA(world));\n  wcsprm_c2python(self->x.wcs);\n  unoffset_array(pixcrd, origin);\n  Py_END_ALLOW_THREADS\n  /* unoffset_array(world, origin); */\n\n exit:\n  Py_XDECREF(pixcrd);\n\n  if (status == 0 || status == 8) {\n    return (PyObject*)world;\n  } else {\n    Py_XDECREF(world);\n    if (status == -1) {\n      PyErr_SetString(\n        PyExc_ValueError,\n        \"Wrong number of dimensions in input array.  Expected 2.\");\n      return NULL;\n    } else {\n      if (status == -1) {\n        /* exception already set */\n        return NULL;\n      } else {\n        wcserr_to_python_exc(self->x.err);\n        return NULL;\n      }\n    }\n  }\n}\n\n/*@null@*/",
                        "filename": "astropy/wcs/src/astropy_wcs.c",
                        "start_index": 5150,
                        "end_index": 7218,
                        "start_line": 203,
                        "end_line": 481,
                        "max_line": 886,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'Wcs_all_pix2world' function which is directly related to the transformation from pixel to world coordinates, and it checks for the dimensions of the input array which is relevant to the issue of handling empty arrays."
                }
            ],
            "astropy/wcs/wcs.py": [
                {
                    "chunk": {
                        "code": "def wcs_world2pix(self, *args, **kwargs):\n        if self.wcs is None:\n            raise ValueError(\"No basic WCS settings were created.\")\n        return self._array_converter(\n            lambda xy, o: self.wcs.s2p(xy, o)[\"pixcrd\"], \"input\", *args, **kwargs\n        )\n\n    wcs_world2pix.__doc__ = f\"\"\"\n        Transforms world coordinates to pixel coordinates, using only\n        the basic `wcslib`_ WCS transformation.  No `SIP`_ or\n        `distortion paper`_ table lookup transformation is applied.\n\n        Parameters\n        ----------\n        {docstrings.TWO_OR_MORE_ARGS('naxis', 8)}\n\n            For a transformation that is not two-dimensional, the\n            two-argument form must be used.\n\n        {docstrings.RA_DEC_ORDER(8)}\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('pixel coordinates', 8)}\n\n        Notes\n        -----\n        The order of the axes for the input world array is determined by\n        the ``CTYPEia`` keywords in the FITS header, therefore it may\n        not always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp` and `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        SingularMatrixError\n            Linear transformation matrix is singular.\n\n        InconsistentAxisTypesError\n            Inconsistent or unrecognized coordinate axis types.\n\n        ValueError\n            Invalid parameter value.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n\n        ValueError\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n        \"\"\"\n\n    def pix2foc(self, *args):\n        return self._array_converter(self._pix2foc, None, *args)\n\n    pix2foc.__doc__ = f\"\"\"\n        Convert pixel coordinates to focal plane coordinates using the\n        `SIP`_ polynomial distortion convention and `distortion\n        paper`_ table-lookup correction.\n\n        The output is in absolute pixel coordinates, not relative to\n        ``CRPIX``.\n\n        Parameters\n        ----------\n\n        {docstrings.TWO_OR_MORE_ARGS('2', 8)}\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('focal coordinates', 8)}\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n        \"\"\"\n\n    def p4_pix2foc(self, *args):\n        return self._array_converter(self._p4_pix2foc, None, *args)",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 93731,
                        "end_index": 96510,
                        "start_line": 2461,
                        "end_line": 2554,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from 'wcs.py' includes the 'wcs_world2pix' method which is the inverse of the operation causing the issue. It may contain logic that needs to be mirrored or adapted for the 'wcs_pix2world' method to handle empty arrays correctly."
                },
                {
                    "chunk": {
                        "code": "def all_pix2world(self, *args, **kwargs):\n        return self._array_converter(self._all_pix2world, \"output\", *args, **kwargs)\n\n    all_pix2world.__doc__ = f\"\"\"\n        Transforms pixel coordinates to world coordinates.\n\n        Performs all of the following in series:\n\n            - Detector to image plane correction (if present in the\n              FITS file)\n\n            - `SIP`_ distortion correction (if present in the FITS\n              file)\n\n            - `distortion paper`_ table-lookup correction (if present\n              in the FITS file)\n\n            - `wcslib`_ \"core\" WCS transformation\n\n        Parameters\n        ----------\n        {docstrings.TWO_OR_MORE_ARGS('naxis', 8)}\n\n            For a transformation that is not two-dimensional, the\n            two-argument form must be used.\n\n        {docstrings.RA_DEC_ORDER(8)}\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('sky coordinates, in degrees', 8)}\n\n        Notes\n        -----\n        The order of the axes for the result is determined by the\n        ``CTYPEia`` keywords in the FITS header, therefore it may not\n        always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp` and `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        Raises\n        ------\n        MemoryError\n            Memory allocation failed.\n\n        SingularMatrixError\n            Linear transformation matrix is singular.\n\n        InconsistentAxisTypesError\n            Inconsistent or unrecognized coordinate axis types.\n\n        ValueError\n            Invalid parameter value.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n\n        ValueError\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n        \"\"\"\n\n    def wcs_pix2world(self, *args, **kwargs):\n        if self.wcs is None:\n            raise ValueError(\"No basic WCS settings were created.\")\n        return self._array_converter(\n            lambda xy, o: self.wcs.p2s(xy, o)[\"world\"], \"output\", *args, **kwargs\n        )",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 56692,
                        "end_index": 59004,
                        "start_line": 1567,
                        "end_line": 3796,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the 'all_pix2world' method which is a higher-level function that calls the transformation from pixel to world coordinates. It is relevant as it may need to be modified to handle empty arrays correctly."
                }
            ],
            "astropy/wcs/src/wcslib_wrap.c": [
                {
                    "chunk": {
                        "code": "{\n\n  int            naxis      = 2;\n  int            ncoord     = 0;\n  int            nelem      = 0;\n  PyObject*      pixcrd_obj = NULL;\n  int            origin     = 1;\n  PyArrayObject* pixcrd     = NULL;\n  PyArrayObject* imgcrd     = NULL;\n  PyArrayObject* phi        = NULL;\n  PyArrayObject* theta      = NULL;\n  PyArrayObject* world      = NULL;\n  PyArrayObject* stat       = NULL;\n  PyObject*      result     = NULL;\n  int            status     = 0;\n  const char*    keywords[] = {\n    \"pixcrd\", \"origin\", NULL };\n\n  if (!PyArg_ParseTupleAndKeywords(\n          args, kwds, \"Oi:p2s\", (char **)keywords,\n          &pixcrd_obj, &origin)) {\n    return NULL;\n  }\n\n  naxis = self->x.naxis;\n\n  pixcrd = (PyArrayObject*)PyArray_ContiguousFromAny\n    (pixcrd_obj, NPY_DOUBLE, 2, 2);\n  if (pixcrd == NULL) {\n    return NULL;\n  }\n\n  if (PyArray_DIM(pixcrd, 1) < naxis) {\n    PyErr_Format(\n      PyExc_RuntimeError,\n      \"Input array must be 2-dimensional, where the second dimension >= %d\",\n      naxis);\n    goto exit;\n  }\n\n  /* Now we allocate a bunch of numpy arrays to store the results in.\n   */\n  imgcrd = (PyArrayObject*)PyArray_SimpleNew(\n      2, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (imgcrd == NULL) {\n    goto exit;\n  }\n\n  phi = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (phi == NULL) {\n    goto exit;\n  }\n\n  theta = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (theta == NULL) {\n    goto exit;\n  }\n\n  world = (PyArrayObject*)PyArray_SimpleNew(\n      2, PyArray_DIMS(pixcrd), NPY_DOUBLE);\n  if (world == NULL) {\n    goto exit;\n  }\n\n  stat = (PyArrayObject*)PyArray_SimpleNew(\n      1, PyArray_DIMS(pixcrd), NPY_INT);\n  if (stat == NULL) {\n    goto exit;\n  }\n\n  /* Make the call */\n  Py_BEGIN_ALLOW_THREADS\n  ncoord = PyArray_DIM(pixcrd, 0);\n  nelem = PyArray_DIM(pixcrd, 1);\n  preoffset_array(pixcrd, origin);\n  wcsprm_python2c(&self->x);\n  status = wcsp2s(\n      &self->x,\n      ncoord,\n      nelem,\n      (double*)PyArray_DATA(pixcrd),\n      (double*)PyArray_DATA(imgcrd),\n      (double*)PyArray_DATA(phi),\n      (double*)PyArray_DATA(theta),\n      (double*)PyArray_DATA(world),\n      (int*)PyArray_DATA(stat));\n  wcsprm_c2python(&self->x);\n  unoffset_array(pixcrd, origin);\n  /* unoffset_array(world, origin); */\n  unoffset_array(imgcrd, origin);\n  if (status == 8) {\n    set_invalid_to_nan(\n        ncoord, nelem, (double*)PyArray_DATA(imgcrd), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, 1, (double*)PyArray_DATA(phi), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, 1, (double*)PyArray_DATA(theta), (int*)PyArray_DATA(stat));\n    set_invalid_to_nan(\n        ncoord, nelem, (double*)PyArray_DATA(world), (int*)PyArray_DATA(stat));\n  }\n  Py_END_ALLOW_THREADS\n\n  if (status == 0 || status == 8)",
                        "filename": "astropy/wcs/src/wcslib_wrap.c",
                        "start_index": 30842,
                        "end_index": 33672,
                        "start_line": 45,
                        "end_line": 1461,
                        "max_line": 4296,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'wcsp2s' function call which is part of the WCS transformation process and handles the conversion from pixel to sky coordinates. It is relevant because the error traceback indicates an issue within this function when empty arrays are passed."
                }
            ],
            "astropy/wcs/src/pyutil.c": [
                {
                    "chunk": {
                        "code": "/* wcslib represents undefined values using its own special constant,\n   UNDEFINED.  To be consistent with the Pythonic way of doing things,\n   it's nicer to represent undefined values using NaN.  Unfortunately,\n   in order to get nice mutable arrays in Python, Python must be able\n   to edit the wcsprm values directly.  The solution is to store NaNs\n   in the struct \"canonically\", but convert those NaNs to/from\n   UNDEFINED around every call into a wcslib function.  It's not as\n   computationally expensive as it sounds, as all these arrays are\n   quite small.\n*/\n\nstatic INLINE void\nwcsprm_fix_values(\n    struct wcsprm* x,\n    value_fixer_t value_fixer) {\n\n  unsigned int naxis = (unsigned int)x->naxis;\n\n  value_fixer(x->cd, naxis * naxis);\n  value_fixer(x->cdelt, naxis);\n  value_fixer(x->crder, naxis);\n  value_fixer(x->crota, naxis);\n  value_fixer(x->crpix, naxis);\n  value_fixer(x->crval, naxis);\n  value_fixer(x->csyer, naxis);\n  value_fixer(&x->equinox, 1);\n  value_fixer(&x->latpole, 1);\n  value_fixer(&x->lonpole, 1);\n  value_fixer(&x->mjdavg, 1);\n  value_fixer(&x->mjdobs, 1);\n  value_fixer(x->obsgeo, 6);\n  value_fixer(&x->cel.phi0, 1);\n  value_fixer(&x->restfrq, 1);\n  value_fixer(&x->restwav, 1);\n  value_fixer(&x->cel.theta0, 1);\n  value_fixer(&x->velangl, 1);\n  value_fixer(&x->velosys, 1);\n  value_fixer(&x->zsource, 1);\n  value_fixer(x->czphs, naxis);\n  value_fixer(x->cperi, naxis);\n  value_fixer(x->mjdref, 2);\n  value_fixer(&x->mjdbeg, 1);\n  value_fixer(&x->mjdend, 1);\n  value_fixer(&x->jepoch, 1);\n  value_fixer(&x->bepoch, 1);\n  value_fixer(&x->tstart, 1);\n  value_fixer(&x->tstop, 1);\n  value_fixer(&x->xposure, 1);\n  value_fixer(&x->timsyer, 1);\n  value_fixer(&x->timrder, 1);\n  value_fixer(&x->timedel, 1);\n  value_fixer(&x->timepixr, 1);\n  value_fixer(&x->timeoffs, 1);\n  value_fixer(&x->telapse, 1);\n}\n\nvoid\nwcsprm_c2python(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &undefined2nan);\n  }\n}\n\nvoid\nwcsprm_python2c(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &nan2undefined);\n  }\n}\n\n/***************************************************************************\n * Exceptions                                                              *\n ***************************************************************************/\n\nPyObject* WcsExc_Wcs;\nPyObject* WcsExc_SingularMatrix;\nPyObject* WcsExc_InconsistentAxisTypes;\nPyObject* WcsExc_InvalidTransform;\nPyObject* WcsExc_InvalidCoordinate;\nPyObject* WcsExc_NoSolution;\nPyObject* WcsExc_InvalidSubimageSpecification;\nPyObject* WcsExc_NonseparableSubimageCoordinateSystem;\nPyObject* WcsExc_NoWcsKeywordsFound;\nPyObject* WcsExc_InvalidTabularParameters;\nPyObject* WcsExc_InvalidPrjParameters;\n\n/* This is an array mapping the wcs status codes to Python exception\n * types.  The exception string is stored as part of wcslib itself in\n * wcs_errmsg.\n */\nPyObject** wcs_errexc[14];",
                        "filename": "astropy/wcs/src/pyutil.c",
                        "start_index": 2647,
                        "end_index": 5571,
                        "start_line": 147,
                        "end_line": 241,
                        "max_line": 957,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains functions 'wcsprm_c2python' and 'wcsprm_python2c' which handle the conversion of undefined values to NaN and vice versa. It is relevant because the issue may be related to how empty or undefined values are handled in the WCS transformation process."
                }
            ]
        },
        "solution_task": "The issue is related to calling `wcs.wcs_pix2world([], [], 0)` which results in an `InconsistentAxisTypesError`. This error is raised within the `wcslib` C library, indicating that the Python wrapper may not be handling empty input lists correctly before passing them to the C library.\n\nTo resolve the issue:\n\n- Modify the `wcs_pix2world` method in `astropy/wcs/wcs.py` to check for empty input lists and return empty lists without calling the C library functions if the inputs are empty.\n- Ensure that the `wcs_pix2world` method can handle empty lists as input and return empty lists as output.\n\nHere is a possible solution:\n\n```python\n# In astropy/wcs/wcs.py, modify the wcs_pix2world method:\n\ndef wcs_pix2world(self, *args, **kwargs):\n    if self.wcs is None:\n        raise ValueError(\"No basic WCS settings were created.\")\n    \n    # Check if the input lists are empty and return empty lists immediately\n    if all(len(arg) == 0 for arg in args):\n        return []\n\n    return self._array_converter(\n        lambda xy, o: self.wcs.p2s(xy, o)[\"world\"], \"output\", *args, **kwargs\n    )\n```\n\nThis change ensures that if empty lists are passed to `wcs_pix2world`, it will return empty lists immediately without invoking the WCSLIB C functions, thus avoiding the `InconsistentAxisTypesError`.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSE must provide precise, actionable guidance and directly address all aspects of the described bug to facilitate its resolution.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem of the WCS transformation failing when empty lists are passed. It suggests modifying the 'wcs_pix2world' method to check for empty input lists and return empty lists without calling the C library functions if the inputs are empty. This directly addresses the issue described in the PROMPT. Additionally, the RESPONSE provides a code snippet that can be used to implement the suggested fix, which is highly relevant and actionable. The RESPONSE also includes references to specific code snippets within the Astropy repository that should be checked for related logic and potential modifications, which is valuable for a comprehensive resolution of the issue. The only reason it does not score a 10 is that it does not explicitly mention the need to add unit tests to ensure the fix works as intended and to prevent regressions in the future.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711737786.2470741,
        "result": "The issue is related to calling `wcs.wcs_pix2world([], [], 0)` which results in an `InconsistentAxisTypesError`. This error is raised within the `wcslib` C library, indicating that the Python wrapper may not be handling empty input lists correctly before passing them to the C library.\n\nTo resolve the issue:\n\n- Modify the `wcs_pix2world` method in `astropy/wcs/wcs.py` to check for empty input lists and return empty lists without calling the C library functions if the inputs are empty.\n- Ensure that the `wcs_pix2world` method can handle empty lists as input and return empty lists as output.\n\nHere is a possible solution:\n\n```python\n# In astropy/wcs/wcs.py, modify the wcs_pix2world method:\n\ndef wcs_pix2world(self, *args, **kwargs):\n    if self.wcs is None:\n        raise ValueError(\"No basic WCS settings were created.\")\n    \n    # Check if the input lists are empty and return empty lists immediately\n    if all(len(arg) == 0 for arg in args):\n        return []\n\n    return self._array_converter(\n        lambda xy, o: self.wcs.p2s(xy, o)[\"world\"], \"output\", *args, **kwargs\n    )\n```\n\nThis change ensures that if empty lists are passed to `wcs_pix2world`, it will return empty lists immediately without invoking the WCSLIB C functions, thus avoiding the `InconsistentAxisTypesError`.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs/src)- [Lines 203 - 481](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/src/astropy_wcs.c#L203-L481)\n\n This snippet contains the 'Wcs_all_pix2world' function which is directly related to the transformation from pixel to world coordinates, and it checks for the dimensions of the input array which is relevant to the issue of handling empty arrays.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs)- [Lines 2461 - 2554](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/wcs.py#L2461-L2554)\n\n This snippet from 'wcs.py' includes the 'wcs_world2pix' method which is the inverse of the operation causing the issue. It may contain logic that needs to be mirrored or adapted for the 'wcs_pix2world' method to handle empty arrays correctly. \n\n\n   - [Lines 1567 - 3796](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/wcs.py#L1567-L3796)\n\n This snippet includes the 'all_pix2world' method which is a higher-level function that calls the transformation from pixel to world coordinates. It is relevant as it may need to be modified to handle empty arrays correctly.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs/src)- [Lines 45 - 1461](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/src/wcslib_wrap.c#L45-L1461)\n\n This snippet contains the 'wcsp2s' function call which is part of the WCS transformation process and handles the conversion from pixel to sky coordinates. It is relevant because the error traceback indicates an issue within this function when empty arrays are passed.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/wcs/src)- [Lines 147 - 241](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/wcs/src/pyutil.c#L147-L241)\n\n This snippet contains functions 'wcsprm_c2python' and 'wcsprm_python2c' which handle the conversion of undefined values to NaN and vice versa. It is relevant because the issue may be related to how empty or undefined values are handled in the WCS transformation process."
    }
}