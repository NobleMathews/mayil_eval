{
    "id": "sympy__sympy-24723",
    "repo_name": "testbed/sympy__sympy__1.12",
    "task_id": 2255194183080027573,
    "title": "Stats: Matrix Normal Distribution returns wrong probability density function",
    "body": "As explained on the [Wikipedia page](https://en.wikipedia.org/wiki/Matrix_normal_distribution), the PDF of Matrix Normal Distribution is as follows: \r\n\r\n![image](https://user-images.githubusercontent.com/96943731/218960673-dd1df75e-8130-4c1c-847a-57e5178cdef2.png)\r\n\r\nWhen initializing a matrix Normal Distribution in Sympy with simple parameters (as mentioned in the docs), the PDF you get is:\r\n\r\n```\r\n>>> from sympy import MatrixSymbol\r\n>>> from sympy.stats import density, MatrixNormal\r\n>>> M = MatrixNormal('M', [[1, 2]], [1], [[1, 0], [0, 1]])\r\n>>> X = MatrixSymbol('X', 1, 2)\r\n>>> density(M)(X).doit()\r\n\r\n       \u239b\u239b\u23a1-1\u23a4    T\u239e                \u239e\r\n   -tr \u239c\u239c\u23a2  \u23a5 + X \u239f \u22c5([-1  -2] + X)\u239f\r\n       \u239d\u239d\u23a3-2\u23a6     \u23a0                \u23a0\r\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n                  2\r\n2\u212f\r\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n                 \u03c0\r\n\r\n```\r\n\r\n\r\nWhereas the actual PDF should be:\r\n\r\n```\r\n\r\n       \u239b\u239b\u23a1-1\u23a4    T\u239e                \u239e\r\n   -tr \u239c\u239c\u23a2  \u23a5 + X \u239f \u22c5([-1  -2] + X)\u239f\r\n       \u239d\u239d\u23a3-2\u23a6     \u23a0                \u23a0\r\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n                  2\r\n\u212f\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n                 2\u03c0\r\n\r\n```\r\nReferences:\r\nhttps://en.wikipedia.org/wiki/Matrix_normal_distribution\r\nThe difference is in the constant of the PDF and should be a simple issue to solve.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sympy__sympy__1.12.git",
    "requested_commit": "",
    "mayil_response": "- Locate the `MultivariateNormal` class in the `sympy/stats/joint_rv_types.py` file.\n- Identify the `pdf` method within the `MultivariateNormal` class.\n- Correct the normalization constant in the PDF formula according to the correct PDF formula provided in the issue description.\n- Ensure that the constant term in the PDF uses the correct expression involving `e` (Euler's number) and `pi` (\u03c0), as per the discrepancy noted (2\u212f vs \u212f and 2\u03c0).\n- If the `pdf` method is not explicitly shown in the provided snippets, it may be necessary to search the codebase for the `MultivariateNormal` class definition and then make the appropriate changes to the `pdf` method.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.12/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.12/tree//sympy/stats)- [Lines 1 - 78](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/joint_rv_types.py#L1-L78)\n\n This snippet defines the JointRV function and the process of creating a joint random variable, which is relevant to the issue as the problem is with the PDF of a matrix normal distribution, a type of joint distribution. \n\n\n   - [Lines 160 - 222](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/joint_rv_types.py#L160-L222)\n\n This snippet contains the definition of the MultivariateTDistribution class and its PDF method, which is similar to the matrix normal distribution and may share common code or logic that could be causing the issue. \n\n\n   - [Lines 301 - 372](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/joint_rv_types.py#L301-L372)\n\n This snippet defines the MultivariateBetaDistribution class and its PDF method. While not directly related to the matrix normal distribution, it may contain logic or patterns that are shared with the implementation of the matrix normal distribution's PDF.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.12/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.12/tree//sympy/stats)- [Lines 393 - 436](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/rv.py#L393-L436)\n\n This snippet includes the compute_density method of the RandomMatrixPSpace class, which is directly involved in computing the density function for random matrix symbols, and thus is likely relevant to the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000437,
        "snippet_processor": 0.08967000000000001,
        "issue_star_creation": 0.026609999999999998,
        "issue_star_solver": 0.06778,
        "bouncer": 0.026189999999999998
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711743124.845561,
        "relevant_snippets": [
            {
                "code": "from __future__ import print_function, division\n\nfrom sympy import Basic\nfrom sympy.stats.rv import PSpace, _symbol_converter, RandomMatrixSymbol\n\nclass RandomMatrixPSpace(PSpace):\n    \"\"\"\n    Represents probability space for\n    random matrices. It contains the mechanics\n    for handling the API calls for random matrices.\n    \"\"\"\n    def __new__(cls, sym, model=None):\n        sym = _symbol_converter(sym)\n        return Basic.__new__(cls, sym, model)\n\n    model = property(lambda self: self.args[1])\n\n    def compute_density(self, expr, *args):\n        rms = expr.atoms(RandomMatrixSymbol)\n        if len(rms) > 2 or (not isinstance(expr, RandomMatrixSymbol)):\n            raise NotImplementedError(\"Currently, no algorithm has been \"\n                    \"implemented to handle general expressions containing \"\n                    \"multiple random matrices.\")\n        return self.model.density(expr)",
                "filename": "sympy/stats/random_matrix.py",
                "start_index": 0,
                "end_index": 903,
                "start_line": 1,
                "end_line": 24,
                "max_line": 24,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, besselk, gamma, Interval,\n                   Range, factorial, Mul, Integer,\n                   Add, rf, Eq, Piecewise, ones, Symbol, Pow, Rational, Sum,\n                   Intersection, Matrix, symbols, Product, IndexedBase)\nfrom sympy.matrices import ImmutableMatrix, MatrixSymbol\nfrom sympy.matrices.expressions.determinant import det\nfrom sympy.stats.joint_rv import (JointDistribution, JointPSpace,\n    JointDistributionHandmade, MarginalDistribution)\nfrom sympy.stats.rv import _value_check, random_symbols\n\n__all__ = ['JointRV',\n'Dirichlet',\n'GeneralizedMultivariateLogGamma',\n'GeneralizedMultivariateLogGammaOmega',\n'Multinomial',\n'MultivariateBeta',\n'MultivariateEwens',\n'MultivariateT',\n'NegativeMultinomial',\n'NormalGamma'\n]\n\ndef multivariate_rv(cls, sym, *args):\n    args = list(map(sympify, args))\n    dist = cls(*args)\n    args = dist.args\n    dist.check(*args)\n    return JointPSpace(sym, dist).value\n\ndef JointRV(symbol, pdf, _set=None):\n    \"\"\"\n    Create a Joint Random Variable where each of its component is conitinuous,\n    given the following:\n\n    -- a symbol\n    -- a PDF in terms of indexed symbols of the symbol given\n    as the first argument\n\n    NOTE: As of now, the set for each component for a `JointRV` is\n    equal to the set of all integers, which can not be changed.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, exp, pi, Indexed, S\n    >>> from sympy.stats import density\n    >>> from sympy.stats.joint_rv_types import JointRV\n\n    >>> x1, x2 = (Indexed('x', i) for i in (1, 2))\n    >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)\n\n    >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution\n    >>> density(N1)(1, 2)\n    exp(-2)/(2*pi)\n\n    Returns\n    =======\n\n    A RandomSymbol.\n\n    \"\"\"\n    #TODO: Add support for sets provided by the user\n    symbol = sympify(symbol)\n    syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)\n        and i.base == IndexedBase(symbol))\n    syms = tuple(sorted(syms, key = lambda index: index.args[1]))\n    _set = S.Reals**len(syms)\n    pdf = Lambda(syms, pdf)\n    dist = JointDistributionHandmade(pdf, _set)\n    jrv = JointPSpace(symbol, dist).value\n    rvs = random_symbols(pdf)\n    if len(rvs) != 0:\n        dist = MarginalDistribution(dist, (jrv,))\n        return JointPSpace(symbol, dist).value\n    return jrv\n\n#-------------------------------------------------------------------------------\n# Multivariate Normal distribution ---------------------------------------------------------",
                "filename": "sympy/stats/joint_rv_types.py",
                "start_index": 0,
                "end_index": 2567,
                "start_line": 1,
                "end_line": 78,
                "max_line": 753,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "class MultivariateTDistribution(JointDistribution):\n    _argnames = ('mu', 'shape_mat', 'dof')\n    is_Continuous=True\n\n    @property\n    def set(self):\n        k = self.mu.shape[0]\n        return S.Reals**k\n\n    @staticmethod\n    def check(mu, sigma, v):\n        _value_check(mu.shape[0] == sigma.shape[0],\n                     \"Size of the location vector and shape matrix are incorrect.\")\n        # check if covariance matrix is positive definite or not.\n        if not isinstance(sigma, MatrixSymbol):\n            _value_check(sigma.is_positive_definite,\n                         \"The shape matrix must be positive definite. \")\n\n    def pdf(self, *args):\n        mu, sigma = self.mu, self.shape_mat\n        v = S(self.dof)\n        k = S(mu.shape[0])\n        sigma_inv = sigma.inv()\n        args = ImmutableMatrix(args)\n        x = args - mu\n        return gamma((k + v)/2)/(gamma(v/2)*(v*pi)**(k/2)*sqrt(det(sigma)))\\\n        *(1 + 1/v*(x.transpose()*sigma_inv*x)[0])**((-v - k)/2)\n\ndef MultivariateT(syms, mu, sigma, v):\n    \"\"\"\n    Creates a joint random variable with multivariate T-distribution.\n\n    Parameters\n    ==========\n\n    syms: A symbol/str\n        For identifying the random variable.\n    mu: A list/matrix\n        Representing the location vector\n    sigma: The shape matrix for the distribution\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, MultivariateT\n    >>> from sympy import Symbol\n\n    >>> x = Symbol(\"x\")\n    >>> X = MultivariateT(\"x\", [1, 1], [[1, 0], [0, 1]], 2)\n\n    >>> density(X)(1, 2)\n    2/(9*pi)\n\n    Returns\n    =======\n\n    A random symbol\n    \"\"\"\n    return multivariate_rv(MultivariateTDistribution, syms, mu, sigma, v)\n\n\n#-------------------------------------------------------------------------------\n# Multivariate Normal Gamma distribution ---------------------------------------------------------",
                "filename": "sympy/stats/joint_rv_types.py",
                "start_index": 5481,
                "end_index": 7345,
                "start_line": 160,
                "end_line": 222,
                "max_line": 753,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "def main():\n    a = Symbol(\"a\", real=True)\n    b = Symbol(\"b\", real=True)\n    c = Symbol(\"c\", real=True)\n\n    p = (a, b, c)\n\n    assert u(p, 1).D*u(p, 2) == Matrix(1, 1, [0])\n    assert u(p, 2).D*u(p, 1) == Matrix(1, 1, [0])\n\n    p1, p2, p3 = [Symbol(x, real=True) for x in [\"p1\", \"p2\", \"p3\"]]\n    pp1, pp2, pp3 = [Symbol(x, real=True) for x in [\"pp1\", \"pp2\", \"pp3\"]]\n    k1, k2, k3 = [Symbol(x, real=True) for x in [\"k1\", \"k2\", \"k3\"]]\n    kp1, kp2, kp3 = [Symbol(x, real=True) for x in [\"kp1\", \"kp2\", \"kp3\"]]\n\n    p = (p1, p2, p3)\n    pp = (pp1, pp2, pp3)\n\n    k = (k1, k2, k3)\n    kp = (kp1, kp2, kp3)\n\n    mu = Symbol(\"mu\")\n\n    e = (pslash(p) + m*ones(4))*(pslash(k) - m*ones(4))\n    f = pslash(p) + m*ones(4)\n    g = pslash(p) - m*ones(4)\n\n    xprint('Tr(f*g)', Tr(f*g))\n\n    M0 = [(v(pp, 1).D*mgamma(mu)*u(p, 1))*(u(k, 1).D*mgamma(mu, True) *\n                                                 v(kp, 1)) for mu in range(4)]\n    M = M0[0] + M0[1] + M0[2] + M0[3]\n    M = M[0]\n    if not isinstance(M, Basic):\n        raise TypeError(\"Invalid type of variable\")\n\n    d = Symbol(\"d\", real=True)  # d=E+m\n\n    xprint('M', M)\n    print(\"-\"*40)\n    M = ((M.subs(E, d - m)).expand()*d**2).expand()\n    xprint('M2', 1 / (E + m)**2*M)\n    print(\"-\"*40)\n    x, y = M.as_real_imag()\n    xprint('Re(M)', x)\n    xprint('Im(M)', y)\n    e = x**2 + y**2\n    xprint('abs(M)**2', e)\n    print(\"-\"*40)\n    xprint('Expand(abs(M)**2)', e.expand())\n\nif __name__ == \"__main__\":\n    main()",
                "filename": "examples/advanced/qft.py",
                "start_index": 1931,
                "end_index": 3400,
                "start_line": 85,
                "end_line": 137,
                "max_line": 137,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "def entropy(expr, condition=None, **kwargs):\n    \"\"\"\n    Calculuates entropy of a probability distribution\n\n    Parameters\n    ==========\n\n    expression : the random expression whose entropy is to be calculated\n    condition : optional, to specify conditions on random expression\n    b: base of the logarithm, optional\n       By default, it is taken as Euler's number\n\n    Returns\n    =======\n\n    result : Entropy of the expression, a constant\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Normal, Die, entropy\n    >>> X = Normal('X', 0, 1)\n    >>> entropy(X)\n    log(2)/2 + 1/2 + log(pi)/2\n\n    >>> D = Die('D', 4)\n    >>> entropy(D)\n    log(4)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Entropy_(information_theory)\n    .. [2] https://www.crmarsh.com/static/pdf/Charles_Marsh_Continuous_Entropy.pdf\n    .. [3] http://www.math.uconn.edu/~kconrad/blurbs/analysis/entropypost.pdf\n    \"\"\"\n    pdf = density(expr, condition, **kwargs)\n    base = kwargs.get('b', exp(1))\n    if hasattr(pdf, 'dict'):\n            return sum([-prob*log(prob, base) for prob in pdf.dict.values()])\n    return expectation(-log(pdf(expr), base))\n\ndef covariance(X, Y, condition=None, **kwargs):\n    \"\"\"\n    Covariance of two random expressions\n\n    The expectation that the two variables will rise and fall together\n\n    Covariance(X,Y) = E( (X-E(X)) * (Y-E(Y)) )\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Exponential, covariance\n    >>> from sympy import Symbol\n\n    >>> rate = Symbol('lambda', positive=True, real=True, finite=True)\n    >>> X = Exponential('X', rate)\n    >>> Y = Exponential('Y', rate)\n\n    >>> covariance(X, X)\n    lambda**(-2)\n    >>> covariance(X, Y)\n    0\n    >>> covariance(X, Y + rate*X)\n    1/lambda\n    \"\"\"\n    return expectation(\n        (X - expectation(X, condition, **kwargs)) *\n        (Y - expectation(Y, condition, **kwargs)),\n        condition, **kwargs)\n\n\ndef correlation(X, Y, condition=None, **kwargs):\n    \"\"\"\n    Correlation of two random expressions, also known as correlation\n    coefficient or Pearson's correlation\n\n    The normalized expectation that the two variables will rise\n    and fall together\n\n    Correlation(X,Y) = E( (X-E(X)) * (Y-E(Y)) / (sigma(X) * sigma(Y)) )\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Exponential, correlation\n    >>> from sympy import Symbol\n\n    >>> rate = Symbol('lambda', positive=True, real=True, finite=True)\n    >>> X = Exponential('X', rate)\n    >>> Y = Exponential('Y', rate)\n\n    >>> correlation(X, X)\n    1\n    >>> correlation(X, Y)\n    0\n    >>> correlation(X, Y + rate*X)\n    1/sqrt(1 + lambda**(-2))\n    \"\"\"\n    return covariance(X, Y, condition, **kwargs)/(std(X, condition, **kwargs)\n     * std(Y, condition, **kwargs))",
                "filename": "sympy/stats/rv_interface.py",
                "start_index": 2217,
                "end_index": 4984,
                "start_line": 84,
                "end_line": 185,
                "max_line": 460,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "# conceal the implicit import from the code quality tester\nfrom sympy import (exp, gamma, integrate, oo, pi, sqrt, Symbol, symbols,\n        besseli, laplace_transform, fourier_transform, mellin_transform,\n        inverse_fourier_transform, inverse_laplace_transform,\n        inverse_mellin_transform)\n\nLT = laplace_transform\nFT = fourier_transform\nMT = mellin_transform\nIFT = inverse_fourier_transform\nILT = inverse_laplace_transform\nIMT = inverse_mellin_transform\n\nfrom sympy.abc import x, y\nnu, beta, rho = symbols('nu beta rho')\n\napos, bpos, cpos, dpos, posk, p = symbols('a b c d k p', positive=True)\nk = Symbol('k', real=True)\nnegk = Symbol('k', negative=True)\n\nmu1, mu2 = symbols('mu1 mu2', real=True, nonzero=True, finite=True)\nsigma1, sigma2 = symbols('sigma1 sigma2', real=True, nonzero=True,\n                         finite=True, positive=True)\nrate = Symbol('lambda', real=True, positive=True, finite=True)\n\n\ndef normal(x, mu, sigma):\n    return 1/sqrt(2*pi*sigma**2)*exp(-(x - mu)**2/2/sigma**2)\n\n\ndef exponential(x, rate):\n    return rate*exp(-rate*x)\nalpha, beta = symbols('alpha beta', positive=True)\nbetadist = x**(alpha - 1)*(1 + x)**(-alpha - beta)*gamma(alpha + beta) \\\n    /gamma(alpha)/gamma(beta)\nkint = Symbol('k', integer=True, positive=True)\nchi = 2**(1 - kint/2)*x**(kint - 1)*exp(-x**2/2)/gamma(kint/2)\nchisquared = 2**(-k/2)/gamma(k/2)*x**(k/2 - 1)*exp(-x/2)\ndagum = apos*p/x*(x/bpos)**(apos*p)/(1 + x**apos/bpos**apos)**(p + 1)\nd1, d2 = symbols('d1 d2', positive=True)\nf = sqrt(((d1*x)**d1 * d2**d2)/(d1*x + d2)**(d1 + d2))/x \\\n    /gamma(d1/2)/gamma(d2/2)*gamma((d1 + d2)/2)\nnupos, sigmapos = symbols('nu sigma', positive=True)\nrice = x/sigmapos**2*exp(-(x**2 + nupos**2)/2/sigmapos**2)*besseli(0, x*\n                         nupos/sigmapos**2)\nmu = Symbol('mu', real=True)\nlaplace = exp(-abs(x - mu)/bpos)/2/bpos\n\nu = Symbol('u', polar=True)\ntpos = Symbol('t', positive=True)\n\n\ndef E(expr):\n    integrate(expr*exponential(x, rate)*normal(y, mu1, sigma1),\n                     (x, 0, oo), (y, -oo, oo), meijerg=True)\n    integrate(expr*exponential(x, rate)*normal(y, mu1, sigma1),\n                     (y, -oo, oo), (x, 0, oo), meijerg=True)",
                "filename": "sympy/benchmarks/bench_meijerint.py",
                "start_index": 0,
                "end_index": 2171,
                "start_line": 1,
                "end_line": 57,
                "max_line": 255,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "def probability(self, condition, **kwargs):\n        cond_inv = False\n        if isinstance(condition, Ne):\n            condition = Eq(condition.args[0], condition.args[1])\n            cond_inv = True\n        expr = condition.lhs - condition.rhs\n        rvs = random_symbols(expr)\n        dens = self.compute_density(expr)\n        if any([pspace(rv).is_Continuous for rv in rvs]):\n            from sympy.stats.crv import SingleContinuousPSpace\n            from sympy.stats.crv_types import ContinuousDistributionHandmade\n            if expr in self.values:\n                # Marginalize all other random symbols out of the density\n                randomsymbols = tuple(set(self.values) - frozenset([expr]))\n                symbols = tuple(rs.symbol for rs in randomsymbols)\n                pdf = self.domain.integrate(self.pdf, symbols, **kwargs)\n                return Lambda(expr.symbol, pdf)\n            dens = ContinuousDistributionHandmade(dens)\n            z = Dummy('z', real=True)\n            space = SingleContinuousPSpace(z, dens)\n            result = space.probability(condition.__class__(space.value, 0))\n        else:\n            from sympy.stats.drv import SingleDiscretePSpace\n            from sympy.stats.drv_types import DiscreteDistributionHandmade\n            dens = DiscreteDistributionHandmade(dens)\n            z = Dummy('z', integer=True)\n            space = SingleDiscretePSpace(z, dens)\n            result = space.probability(condition.__class__(space.value, 0))\n        return result if not cond_inv else S.One - result\n\n    def compute_density(self, expr, **kwargs):\n        rvs = random_symbols(expr)\n        if any(pspace(rv).is_Continuous for rv in rvs):\n            z = Dummy('z', real=True)\n            expr = self.compute_expectation(DiracDelta(expr - z),\n             **kwargs)\n        else:\n            z = Dummy('z', integer=True)\n            expr = self.compute_expectation(KroneckerDelta(expr, z),\n             **kwargs)\n        return Lambda(z, expr)\n\n    def compute_cdf(self, expr, **kwargs):\n        raise ValueError(\"CDF not well defined on multivariate expressions\")",
                "filename": "sympy/stats/rv.py",
                "start_index": 10889,
                "end_index": 12998,
                "start_line": 393,
                "end_line": 436,
                "max_line": 1499,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "def MultivariateEwens(syms, n, theta):\n    \"\"\"\n    Creates a discrete random variable with Multivariate Ewens\n    Distribution.\n\n    The density of the said distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    n: positive integer of class Integer,\n            size of the sample or the integer whose partitions are considered\n    theta: mutation rate, must be positive real number.\n\n    Returns\n    =======\n\n    A RandomSymbol.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density\n    >>> from sympy.stats.joint_rv import marginal_distribution\n    >>> from sympy.stats.joint_rv_types import MultivariateEwens\n    >>> from sympy import Symbol\n    >>> a1 = Symbol('a1', positive=True)\n    >>> a2 = Symbol('a2', positive=True)\n    >>> ed = MultivariateEwens('E', 2, 1)\n    >>> density(ed)(a1, a2)\n    Piecewise((2**(-a2)/(factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))\n    >>> marginal_distribution(ed, ed[0])(a1)\n    Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula\n    .. [2] http://www.stat.rutgers.edu/home/hcrane/Papers/STS529.pdf\n\n    \"\"\"\n    return multivariate_rv(MultivariateEwensDistribution, syms, n, theta)\n\n#-------------------------------------------------------------------------------\n# Generalized Multivariate Log Gamma distribution ---------------------------------------------------------\n\nclass GeneralizedMultivariateLogGammaDistribution(JointDistribution):\n\n    _argnames = ('delta', 'v', 'lamda', 'mu')\n    is_Continuous=True\n\n    def check(self, delta, v, l, mu):\n        _value_check((delta >= 0, delta <= 1), \"delta must be in range [0, 1].\")\n        _value_check((v > 0), \"v must be positive\")\n        for lk in l:\n            _value_check((lk > 0), \"lamda must be a positive vector.\")\n        for muk in mu:\n            _value_check((muk > 0), \"mu must be a positive vector.\")\n        _value_check(len(l) > 1,\"the distribution should have at least\"\n                                \" two random variables.\")\n\n    @property\n    def set(self):\n        return S.Reals**len(self.lamda)\n\n    def pdf(self, *y):\n        from sympy.functions.special.gamma_functions import gamma\n        d, v, l, mu = self.delta, self.v, self.lamda, self.mu\n        n = Symbol('n', negative=False, integer=True)\n        k = len(l)\n        sterm1 = Pow((1 - d), n)/\\\n                ((gamma(v + n)**(k - 1))*gamma(v)*gamma(n + 1))\n        sterm2 = Mul.fromiter([mui*li**(-v - n) for mui, li in zip(mu, l)])\n        term1 = sterm1 * sterm2\n        sterm3 = (v + n) * sum([mui * yi for mui, yi in zip(mu, y)])\n        sterm4 = sum([exp(mui * yi)/li for (mui, yi, li) in zip(mu, y, l)])\n        term2 = exp(sterm3 - sterm4)\n        return Pow(d, v) * Sum(term1 * term2, (n, 0, S.Infinity))",
                "filename": "sympy/stats/joint_rv_types.py",
                "start_index": 13790,
                "end_index": 16623,
                "start_line": 417,
                "end_line": 494,
                "max_line": 753,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "from __future__ import print_function, division\nfrom sympy.sets import FiniteSet\nfrom sympy import sqrt, log, exp, FallingFactorial, Rational, Eq, Dummy, piecewise_fold, solveset\nfrom .rv import (probability, expectation, density, where, given, pspace, cdf,\n                 characteristic_function, sample, sample_iter, random_symbols, independent, dependent,\n                 sampling_density, moment_generating_function, quantile)\n\n\n__all__ = ['P', 'E', 'H', 'density', 'where', 'given', 'sample', 'cdf',\n        'characteristic_function', 'pspace', 'sample_iter', 'variance', 'std',\n        'skewness', 'kurtosis', 'covariance', 'dependent', 'entropy', 'median',\n        'independent', 'random_symbols', 'correlation', 'factorial_moment',\n        'moment', 'cmoment', 'sampling_density', 'moment_generating_function',\n        'smoment', 'quantile']\n\n\n\ndef moment(X, n, c=0, condition=None, **kwargs):\n    \"\"\"\n    Return the nth moment of a random expression about c i.e. E((X-c)**n)\n    Default value of c is 0.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Die, moment, E\n    >>> X = Die('X', 6)\n    >>> moment(X, 1, 6)\n    -5/2\n    >>> moment(X, 2)\n    91/6\n    >>> moment(X, 1) == E(X)\n    True\n    \"\"\"\n    return expectation((X - c)**n, condition, **kwargs)\n\n\ndef variance(X, condition=None, **kwargs):\n    \"\"\"\n    Variance of a random expression\n\n    Expectation of (X-E(X))**2\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Die, E, Bernoulli, variance\n    >>> from sympy import simplify, Symbol\n\n    >>> X = Die('X', 6)\n    >>> p = Symbol('p')\n    >>> B = Bernoulli('B', p, 1, 0)\n\n    >>> variance(2*X)\n    35/3\n\n    >>> simplify(variance(B))\n    p*(1 - p)\n    \"\"\"\n    return cmoment(X, 2, condition, **kwargs)\n\n\ndef standard_deviation(X, condition=None, **kwargs):\n    \"\"\"\n    Standard Deviation of a random expression\n\n    Square root of the Expectation of (X-E(X))**2\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Bernoulli, std\n    >>> from sympy import Symbol, simplify\n\n    >>> p = Symbol('p')\n    >>> B = Bernoulli('B', p, 1, 0)\n\n    >>> simplify(std(B))\n    sqrt(p*(1 - p))\n    \"\"\"\n    return sqrt(variance(X, condition, **kwargs))\nstd = standard_deviation",
                "filename": "sympy/stats/rv_interface.py",
                "start_index": 0,
                "end_index": 2215,
                "start_line": 1,
                "end_line": 82,
                "max_line": 460,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            },
            {
                "code": "class MultivariateBetaDistribution(JointDistribution):\n\n    _argnames = ('alpha',)\n    is_Continuous = True\n\n    @staticmethod\n    def check(alpha):\n        _value_check(len(alpha) >= 2, \"At least two categories should be passed.\")\n        for a_k in alpha:\n            _value_check((a_k > 0) != False, \"Each concentration parameter\"\n                                            \" should be positive.\")\n\n    @property\n    def set(self):\n        k = len(self.alpha)\n        return Interval(0, 1)**k\n\n    def pdf(self, *syms):\n        alpha = self.alpha\n        B = Mul.fromiter(map(gamma, alpha))/gamma(Add(*alpha))\n        return Mul.fromiter([sym**(a_k - 1) for a_k, sym in zip(alpha, syms)])/B\n\ndef MultivariateBeta(syms, *alpha):\n    \"\"\"\n    Creates a continuous random variable with Dirichlet/Multivariate Beta\n    Distribution.\n\n    The density of the dirichlet distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    alpha: positive real numbers signifying concentration numbers.\n\n    Returns\n    =======\n\n    A RandomSymbol.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density\n    >>> from sympy.stats.joint_rv import marginal_distribution\n    >>> from sympy.stats.joint_rv_types import MultivariateBeta\n    >>> from sympy import Symbol\n    >>> a1 = Symbol('a1', positive=True)\n    >>> a2 = Symbol('a2', positive=True)\n    >>> B = MultivariateBeta('B', [a1, a2])\n    >>> C = MultivariateBeta('C', a1, a2)\n    >>> x = Symbol('x')\n    >>> y = Symbol('y')\n    >>> density(B)(x, y)\n    x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))\n    >>> marginal_distribution(C, C[0])(x)\n    x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution\n    .. [2] http://mathworld.wolfram.com/DirichletDistribution.html\n\n    \"\"\"\n    if not isinstance(alpha[0], list):\n        alpha = (list(alpha),)\n    return multivariate_rv(MultivariateBetaDistribution, syms, alpha[0])\n\nDirichlet = MultivariateBeta\n\n#-------------------------------------------------------------------------------\n# Multivariate Ewens distribution ---------------------------------------------------------",
                "filename": "sympy/stats/joint_rv_types.py",
                "start_index": 9849,
                "end_index": 12044,
                "start_line": 301,
                "end_line": 372,
                "max_line": 753,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.12",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sympy/stats/joint_rv_types.py": [
                {
                    "chunk": {
                        "code": "from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, besselk, gamma, Interval,\n                   Range, factorial, Mul, Integer,\n                   Add, rf, Eq, Piecewise, ones, Symbol, Pow, Rational, Sum,\n                   Intersection, Matrix, symbols, Product, IndexedBase)\nfrom sympy.matrices import ImmutableMatrix, MatrixSymbol\nfrom sympy.matrices.expressions.determinant import det\nfrom sympy.stats.joint_rv import (JointDistribution, JointPSpace,\n    JointDistributionHandmade, MarginalDistribution)\nfrom sympy.stats.rv import _value_check, random_symbols\n\n__all__ = ['JointRV',\n'Dirichlet',\n'GeneralizedMultivariateLogGamma',\n'GeneralizedMultivariateLogGammaOmega',\n'Multinomial',\n'MultivariateBeta',\n'MultivariateEwens',\n'MultivariateT',\n'NegativeMultinomial',\n'NormalGamma'\n]\n\ndef multivariate_rv(cls, sym, *args):\n    args = list(map(sympify, args))\n    dist = cls(*args)\n    args = dist.args\n    dist.check(*args)\n    return JointPSpace(sym, dist).value\n\ndef JointRV(symbol, pdf, _set=None):\n    \"\"\"\n    Create a Joint Random Variable where each of its component is conitinuous,\n    given the following:\n\n    -- a symbol\n    -- a PDF in terms of indexed symbols of the symbol given\n    as the first argument\n\n    NOTE: As of now, the set for each component for a `JointRV` is\n    equal to the set of all integers, which can not be changed.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, exp, pi, Indexed, S\n    >>> from sympy.stats import density\n    >>> from sympy.stats.joint_rv_types import JointRV\n\n    >>> x1, x2 = (Indexed('x', i) for i in (1, 2))\n    >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)\n\n    >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution\n    >>> density(N1)(1, 2)\n    exp(-2)/(2*pi)\n\n    Returns\n    =======\n\n    A RandomSymbol.\n\n    \"\"\"\n    #TODO: Add support for sets provided by the user\n    symbol = sympify(symbol)\n    syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)\n        and i.base == IndexedBase(symbol))\n    syms = tuple(sorted(syms, key = lambda index: index.args[1]))\n    _set = S.Reals**len(syms)\n    pdf = Lambda(syms, pdf)\n    dist = JointDistributionHandmade(pdf, _set)\n    jrv = JointPSpace(symbol, dist).value\n    rvs = random_symbols(pdf)\n    if len(rvs) != 0:\n        dist = MarginalDistribution(dist, (jrv,))\n        return JointPSpace(symbol, dist).value\n    return jrv\n\n#-------------------------------------------------------------------------------\n# Multivariate Normal distribution ---------------------------------------------------------",
                        "filename": "sympy/stats/joint_rv_types.py",
                        "start_index": 0,
                        "end_index": 2567,
                        "start_line": 1,
                        "end_line": 78,
                        "max_line": 753,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the JointRV function and the process of creating a joint random variable, which is relevant to the issue as the problem is with the PDF of a matrix normal distribution, a type of joint distribution."
                },
                {
                    "chunk": {
                        "code": "class MultivariateTDistribution(JointDistribution):\n    _argnames = ('mu', 'shape_mat', 'dof')\n    is_Continuous=True\n\n    @property\n    def set(self):\n        k = self.mu.shape[0]\n        return S.Reals**k\n\n    @staticmethod\n    def check(mu, sigma, v):\n        _value_check(mu.shape[0] == sigma.shape[0],\n                     \"Size of the location vector and shape matrix are incorrect.\")\n        # check if covariance matrix is positive definite or not.\n        if not isinstance(sigma, MatrixSymbol):\n            _value_check(sigma.is_positive_definite,\n                         \"The shape matrix must be positive definite. \")\n\n    def pdf(self, *args):\n        mu, sigma = self.mu, self.shape_mat\n        v = S(self.dof)\n        k = S(mu.shape[0])\n        sigma_inv = sigma.inv()\n        args = ImmutableMatrix(args)\n        x = args - mu\n        return gamma((k + v)/2)/(gamma(v/2)*(v*pi)**(k/2)*sqrt(det(sigma)))\\\n        *(1 + 1/v*(x.transpose()*sigma_inv*x)[0])**((-v - k)/2)\n\ndef MultivariateT(syms, mu, sigma, v):\n    \"\"\"\n    Creates a joint random variable with multivariate T-distribution.\n\n    Parameters\n    ==========\n\n    syms: A symbol/str\n        For identifying the random variable.\n    mu: A list/matrix\n        Representing the location vector\n    sigma: The shape matrix for the distribution\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, MultivariateT\n    >>> from sympy import Symbol\n\n    >>> x = Symbol(\"x\")\n    >>> X = MultivariateT(\"x\", [1, 1], [[1, 0], [0, 1]], 2)\n\n    >>> density(X)(1, 2)\n    2/(9*pi)\n\n    Returns\n    =======\n\n    A random symbol\n    \"\"\"\n    return multivariate_rv(MultivariateTDistribution, syms, mu, sigma, v)\n\n\n#-------------------------------------------------------------------------------\n# Multivariate Normal Gamma distribution ---------------------------------------------------------",
                        "filename": "sympy/stats/joint_rv_types.py",
                        "start_index": 5481,
                        "end_index": 7345,
                        "start_line": 160,
                        "end_line": 222,
                        "max_line": 753,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the definition of the MultivariateTDistribution class and its PDF method, which is similar to the matrix normal distribution and may share common code or logic that could be causing the issue."
                },
                {
                    "chunk": {
                        "code": "class MultivariateBetaDistribution(JointDistribution):\n\n    _argnames = ('alpha',)\n    is_Continuous = True\n\n    @staticmethod\n    def check(alpha):\n        _value_check(len(alpha) >= 2, \"At least two categories should be passed.\")\n        for a_k in alpha:\n            _value_check((a_k > 0) != False, \"Each concentration parameter\"\n                                            \" should be positive.\")\n\n    @property\n    def set(self):\n        k = len(self.alpha)\n        return Interval(0, 1)**k\n\n    def pdf(self, *syms):\n        alpha = self.alpha\n        B = Mul.fromiter(map(gamma, alpha))/gamma(Add(*alpha))\n        return Mul.fromiter([sym**(a_k - 1) for a_k, sym in zip(alpha, syms)])/B\n\ndef MultivariateBeta(syms, *alpha):\n    \"\"\"\n    Creates a continuous random variable with Dirichlet/Multivariate Beta\n    Distribution.\n\n    The density of the dirichlet distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    alpha: positive real numbers signifying concentration numbers.\n\n    Returns\n    =======\n\n    A RandomSymbol.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density\n    >>> from sympy.stats.joint_rv import marginal_distribution\n    >>> from sympy.stats.joint_rv_types import MultivariateBeta\n    >>> from sympy import Symbol\n    >>> a1 = Symbol('a1', positive=True)\n    >>> a2 = Symbol('a2', positive=True)\n    >>> B = MultivariateBeta('B', [a1, a2])\n    >>> C = MultivariateBeta('C', a1, a2)\n    >>> x = Symbol('x')\n    >>> y = Symbol('y')\n    >>> density(B)(x, y)\n    x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))\n    >>> marginal_distribution(C, C[0])(x)\n    x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution\n    .. [2] http://mathworld.wolfram.com/DirichletDistribution.html\n\n    \"\"\"\n    if not isinstance(alpha[0], list):\n        alpha = (list(alpha),)\n    return multivariate_rv(MultivariateBetaDistribution, syms, alpha[0])\n\nDirichlet = MultivariateBeta\n\n#-------------------------------------------------------------------------------\n# Multivariate Ewens distribution ---------------------------------------------------------",
                        "filename": "sympy/stats/joint_rv_types.py",
                        "start_index": 9849,
                        "end_index": 12044,
                        "start_line": 301,
                        "end_line": 372,
                        "max_line": 753,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the MultivariateBetaDistribution class and its PDF method. While not directly related to the matrix normal distribution, it may contain logic or patterns that are shared with the implementation of the matrix normal distribution's PDF."
                }
            ],
            "sympy/stats/rv.py": [
                {
                    "chunk": {
                        "code": "def probability(self, condition, **kwargs):\n        cond_inv = False\n        if isinstance(condition, Ne):\n            condition = Eq(condition.args[0], condition.args[1])\n            cond_inv = True\n        expr = condition.lhs - condition.rhs\n        rvs = random_symbols(expr)\n        dens = self.compute_density(expr)\n        if any([pspace(rv).is_Continuous for rv in rvs]):\n            from sympy.stats.crv import SingleContinuousPSpace\n            from sympy.stats.crv_types import ContinuousDistributionHandmade\n            if expr in self.values:\n                # Marginalize all other random symbols out of the density\n                randomsymbols = tuple(set(self.values) - frozenset([expr]))\n                symbols = tuple(rs.symbol for rs in randomsymbols)\n                pdf = self.domain.integrate(self.pdf, symbols, **kwargs)\n                return Lambda(expr.symbol, pdf)\n            dens = ContinuousDistributionHandmade(dens)\n            z = Dummy('z', real=True)\n            space = SingleContinuousPSpace(z, dens)\n            result = space.probability(condition.__class__(space.value, 0))\n        else:\n            from sympy.stats.drv import SingleDiscretePSpace\n            from sympy.stats.drv_types import DiscreteDistributionHandmade\n            dens = DiscreteDistributionHandmade(dens)\n            z = Dummy('z', integer=True)\n            space = SingleDiscretePSpace(z, dens)\n            result = space.probability(condition.__class__(space.value, 0))\n        return result if not cond_inv else S.One - result\n\n    def compute_density(self, expr, **kwargs):\n        rvs = random_symbols(expr)\n        if any(pspace(rv).is_Continuous for rv in rvs):\n            z = Dummy('z', real=True)\n            expr = self.compute_expectation(DiracDelta(expr - z),\n             **kwargs)\n        else:\n            z = Dummy('z', integer=True)\n            expr = self.compute_expectation(KroneckerDelta(expr, z),\n             **kwargs)\n        return Lambda(z, expr)\n\n    def compute_cdf(self, expr, **kwargs):\n        raise ValueError(\"CDF not well defined on multivariate expressions\")",
                        "filename": "sympy/stats/rv.py",
                        "start_index": 10889,
                        "end_index": 12998,
                        "start_line": 393,
                        "end_line": 436,
                        "max_line": 1499,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the compute_density method of the RandomMatrixPSpace class, which is directly involved in computing the density function for random matrix symbols, and thus is likely relevant to the issue."
                }
            ]
        },
        "solution_task": "- Locate the `MultivariateNormal` class in the `sympy/stats/joint_rv_types.py` file.\n- Identify the `pdf` method within the `MultivariateNormal` class.\n- Correct the normalization constant in the PDF formula according to the correct PDF formula provided in the issue description.\n- Ensure that the constant term in the PDF uses the correct expression involving `e` (Euler's number) and `pi` (\u03c0), as per the discrepancy noted (2\u212f vs \u212f and 2\u03c0).\n- If the `pdf` method is not explicitly shown in the provided snippets, it may be necessary to search the codebase for the `MultivariateNormal` class definition and then make the appropriate changes to the `pdf` method.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable step-by-step guide to locate and fix the issue with the probability density function (PDF) of the Matrix Normal Distribution in the Sympy library. It correctly identifies the need to locate the `MultivariateNormal` class and the `pdf` method within it, and to correct the normalization constant in the PDF formula. The RESPONSE also provides guidance on ensuring the constant term uses the correct expression involving Euler's number and pi, directly addressing the discrepancy noted in the PROMPT. Additionally, the RESPONSE includes links to code snippets that may be relevant to the issue, which could be helpful for someone trying to locate the source of the bug. However, the RESPONSE could be improved by explicitly stating that the `MatrixNormal` class should be the focus rather than the `MultivariateNormal` class, as the PROMPT is about the Matrix Normal Distribution. This slight misalignment prevents the RESPONSE from scoring higher.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711743824.8514009,
        "result": "- Locate the `MultivariateNormal` class in the `sympy/stats/joint_rv_types.py` file.\n- Identify the `pdf` method within the `MultivariateNormal` class.\n- Correct the normalization constant in the PDF formula according to the correct PDF formula provided in the issue description.\n- Ensure that the constant term in the PDF uses the correct expression involving `e` (Euler's number) and `pi` (\u03c0), as per the discrepancy noted (2\u212f vs \u212f and 2\u03c0).\n- If the `pdf` method is not explicitly shown in the provided snippets, it may be necessary to search the codebase for the `MultivariateNormal` class definition and then make the appropriate changes to the `pdf` method.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.12/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.12/tree//sympy/stats)- [Lines 1 - 78](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/joint_rv_types.py#L1-L78)\n\n This snippet defines the JointRV function and the process of creating a joint random variable, which is relevant to the issue as the problem is with the PDF of a matrix normal distribution, a type of joint distribution. \n\n\n   - [Lines 160 - 222](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/joint_rv_types.py#L160-L222)\n\n This snippet contains the definition of the MultivariateTDistribution class and its PDF method, which is similar to the matrix normal distribution and may share common code or logic that could be causing the issue. \n\n\n   - [Lines 301 - 372](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/joint_rv_types.py#L301-L372)\n\n This snippet defines the MultivariateBetaDistribution class and its PDF method. While not directly related to the matrix normal distribution, it may contain logic or patterns that are shared with the implementation of the matrix normal distribution's PDF.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.12/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.12/tree//sympy/stats)- [Lines 393 - 436](https://github.com/testbed/sympy__sympy__1.12/blob//sympy/stats/rv.py#L393-L436)\n\n This snippet includes the compute_density method of the RandomMatrixPSpace class, which is directly involved in computing the density function for random matrix symbols, and thus is likely relevant to the issue."
    }
}