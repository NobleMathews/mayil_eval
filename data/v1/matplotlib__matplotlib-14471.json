{
    "id": "matplotlib__matplotlib-14471",
    "repo_name": "testbed/matplotlib__matplotlib__3.1",
    "task_id": 1503966206266123870,
    "title": "Existing FigureCanvasQT objects destroyed by call to plt.figure",
    "body": "### Bug report\r\n\r\n**Bug summary**\r\n\r\nFor a number of years, I have been maintaining an interactive application that embeds subclassed FigureCanvasQT objects within a PyQt application. Up until Matplotlib v3.0.3., it was possible to create standard Matplotlib PyQt figures, i.e., using `plt.figure` within an embedded IPython shell, that coexist with the subclassed canvas objects. Now in Matplotlib v3.1.0, a call to `plt.figure()` destroys all the other canvas objects. \r\n\r\nUnfortunately, I cannot debug this within Visual Studio since I am currently unable to install Matplotlib from the source. By going through the `new_figure_manager` code line by line, I can confirm that the windows are destroyed when calling `FigureCanvasQT.__init__(figure)`, but not when calling `FigureCanvasBase.__init__(figure)`, but I can't work out what triggers the destruction of the other windows. I presume the subclassed canvasses are not being registered somewhere, and `pyplot` assumes they are no longer active, but I am hoping someone will show me where to look. This may not be a Matplotlib bug, but it's certainly an unwelcome side effect in my application.\r\n\r\n**Code for reproduction**\r\nIf you have `nexpy` installed (`pip install nexpy`) and launch it, you can reproduce this from within the embedded IPython shell with the following, which creates a new subclassed window and then attempts to open a regular `pyplot` window.:\r\n\r\n```\r\nIn [1]: new_window=NXPlotView()\r\nIn [2]: plt.get_fignums()\r\nOut[2]: [1, 2]\r\nIn [3]: plt.figure()\r\n```\r\nThere are two figure numbers, because NeXpy automatically creates a window with a figure number of 1 when it is launched.\r\n\r\n**Actual outcome**\r\n\r\nA new window with an updated figure number is created but all other windows not created by `pyplot`  are destroyed.\r\n\r\n```\r\nIn [4]: plt.get_fignums()\r\nOut[4]: [3]\r\n```\r\n\r\n**Expected outcome**\r\n\r\nIn Matplotlib v3.0.3, a new `pyplot` window is created by the PyQt5 backend without destroying anything else.\r\n\r\n```\r\nIn [4]: plt.get_fignums()\r\nOut[4]: [1, 2, 3]\r\n```\r\n\r\n**Matplotlib version**\r\n  * Operating system: Mac OS v10.14.5\r\n  * Matplotlib version: 3.1.0\r\n  * Matplotlib backend: Qt5Agg\r\n  * Python version: 3.7.2\r\n  * Jupyter version (if applicable): 1.0.0\r\n  * Other libraries: \r\n\r\n<!--Please tell us how you installed matplotlib and python e.g., from source, pip, conda-->\r\n<!--If you installed from conda, please specify which channel you used if not the default-->\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.1.git",
    "requested_commit": "",
    "mayil_response": "Based on the provided information, the issue seems to be related to the destruction of subclassed `FigureCanvasQT` objects upon calling `plt.figure()` after upgrading Matplotlib from v3.0.3 to v3.1.0. To address this issue:\n\n- Review the Matplotlib change log between versions 3.0.3 and 3.1.0 to identify any changes related to `FigureCanvasQT`, `plt.figure()`, or the Qt5Agg backend that could affect the destruction of canvas objects.\n- Ensure that subclassed `FigureCanvasQT` objects are properly registered with Matplotlib's figure manager. This may involve overriding the `new_figure_manager` method in the `NXPlotView` class to handle the creation and registration of new figures.\n- If the issue is related to the interaction between `plt.figure()` and existing canvas objects, consider manually managing figure creation and canvas association instead of relying on `plt.figure()` to implicitly handle this.\n- Verify that the PyQt application is correctly maintaining references to the subclassed `FigureCanvasQT` objects to prevent premature garbage collection.\n- If necessary, subclass `FigureCanvasQT` and override the `__init__` method to include any additional setup or registration steps that may have been affected by the version change.\n- Test the application with the embedded IPython shell to ensure that the creation of new Matplotlib PyQt figures does not interfere with existing figures.\n\nIf the issue persists after these steps, consider creating a minimal reproducible example and submitting a bug report to the Matplotlib development team, including the specific details of the issue and the steps taken to diagnose and attempt to resolve it.\n\n### Code snippets to check\n\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//galleries) \u2192 [examples](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//galleries/examples) \u2192 [user_interfaces](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//galleries/examples/user_interfaces)- [Lines 1 - 72](https://github.com/testbed/matplotlib__matplotlib__3.1/blob//galleries/examples/user_interfaces/embedding_in_qt_sgskip.py#L1-L72)\n\n This snippet shows an example of embedding Matplotlib canvases in a PyQt application, which is relevant to the issue as it may contain similar patterns of canvas creation and management.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//lib/matplotlib/backends)- [Lines 972 - 1022](https://github.com/testbed/matplotlib__matplotlib__3.1/blob//lib/matplotlib/backends/backend_qt.py#L972-L1022)\n\n This snippet is from the backend Qt implementation in Matplotlib, which is directly related to the issue as it involves the Qt backend and potentially the handling of canvas objects.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000464,
        "snippet_processor": 0.06309000000000001,
        "issue_star_creation": 0.022949999999999998,
        "issue_star_solver": 0.0524,
        "bouncer": 0.0245
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711699267.530817,
        "relevant_snippets": [
            {
                "code": "name: Bug Report\ndescription: Report a bug or issue with Matplotlib.\ntitle: \"[Bug]: \"\nbody:\n  - type: textarea\n    id: summary\n    attributes:\n      label: Bug summary\n      description:  Describe the bug in 1-2 short sentences\n      placeholder:\n      value:\n    validations:\n      required: true\n  - type: textarea\n    id: reproduction\n    attributes:\n      label: Code for reproduction\n      description: |\n        If possible, please provide a minimum self-contained example.\n      placeholder: Paste your code here. This field is automatically formatted as Python code.\n      render: python\n    validations:\n      required: true\n  - type: textarea\n    id: actual\n    attributes:\n      label: Actual outcome\n      description: |\n        Paste the output produced by the code provided above, e.g.\n        console output, images/videos produced by the code, any relevant screenshots/screencasts, etc.\n    validations:\n      required: true\n  - type: textarea\n    id: expected\n    attributes:\n      label: Expected outcome\n      description: Describe (or provide a visual example of) the expected outcome from the code snippet.\n    validations:\n      required: true\n  - type: textarea\n    id: details\n    attributes:\n      label: Additional information\n      description: |\n        - What are the conditions under which this bug happens? input parameters, edge cases, etc?\n        - Has this worked in earlier versions?\n        - Do you know why this bug is happening?\n        - Do you maybe even know a fix?\n  - type: input\n    id: operating-system\n    attributes:\n      label: Operating system\n      description: Windows, OS/X, Arch, Debian, Ubuntu, etc.\n  - type: input\n    id: matplotlib-version\n    attributes:\n      label: Matplotlib Version\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.__version__)`\"\n    validations:\n      required: true\n  - type: input\n    id: matplotlib-backend\n    attributes:\n      label: Matplotlib Backend\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.get_backend())`\"\n  - type: input\n    id: python-version\n    attributes:\n      label: Python version\n      description: \"In console: `python --version`\"\n  - type: input\n    id: jupyter-version\n    attributes:\n      label: Jupyter version\n      description: \"In console: `jupyter notebook --version` or `jupyter lab --version`\"\n  - type: dropdown\n    id: install\n    attributes:\n      label: Installation\n      description: How did you install matplotlib?\n      options:\n        - pip\n        - conda\n        - Linux package manager\n        - from source (.tar.gz)\n        - git checkout",
                "filename": ".github/ISSUE_TEMPLATE/bug_report.yml",
                "start_index": 0,
                "end_index": 2631,
                "start_line": 1,
                "end_line": 86,
                "max_line": 86,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\n===============\nEmbedding in Qt\n===============\n\nSimple Qt application embedding Matplotlib canvases.  This program will work\nequally well using any Qt binding (PyQt6, PySide6, PyQt5, PySide2).  The\nbinding can be selected by setting the :envvar:`QT_API` environment variable to\nthe binding name, or by first importing it.\n\"\"\"\n\nimport sys\nimport time\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_qtagg import FigureCanvas\nfrom matplotlib.backends.backend_qtagg import \\\n    NavigationToolbar2QT as NavigationToolbar\nfrom matplotlib.backends.qt_compat import QtWidgets\nfrom matplotlib.figure import Figure\n\n\nclass ApplicationWindow(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self._main = QtWidgets.QWidget()\n        self.setCentralWidget(self._main)\n        layout = QtWidgets.QVBoxLayout(self._main)\n\n        static_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        # Ideally one would use self.addToolBar here, but it is slightly\n        # incompatible between PyQt6 and other bindings, so we just add the\n        # toolbar as a plain widget instead.\n        layout.addWidget(NavigationToolbar(static_canvas, self))\n        layout.addWidget(static_canvas)\n\n        dynamic_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        layout.addWidget(dynamic_canvas)\n        layout.addWidget(NavigationToolbar(dynamic_canvas, self))\n\n        self._static_ax = static_canvas.figure.subplots()\n        t = np.linspace(0, 10, 501)\n        self._static_ax.plot(t, np.tan(t), \".\")\n\n        self._dynamic_ax = dynamic_canvas.figure.subplots()\n        t = np.linspace(0, 10, 101)\n        # Set up a Line2D.\n        self._line, = self._dynamic_ax.plot(t, np.sin(t + time.time()))\n        self._timer = dynamic_canvas.new_timer(50)\n        self._timer.add_callback(self._update_canvas)\n        self._timer.start()\n\n    def _update_canvas(self):\n        t = np.linspace(0, 10, 101)\n        # Shift the sinusoid as a function of time.\n        self._line.set_data(t, np.sin(t + time.time()))\n        self._line.figure.canvas.draw()\n\n\nif __name__ == \"__main__\":\n    # Check whether there is already a running QApplication (e.g., if running\n    # from an IDE).\n    qapp = QtWidgets.QApplication.instance()\n    if not qapp:\n        qapp = QtWidgets.QApplication(sys.argv)\n\n    app = ApplicationWindow()\n    app.show()\n    app.activateWindow()\n    app.raise_()\n    qapp.exec()",
                "filename": "galleries/examples/user_interfaces/embedding_in_qt_sgskip.py",
                "start_index": 0,
                "end_index": 2411,
                "start_line": 1,
                "end_line": 72,
                "max_line": 72,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "import ctypes\n\nfrom .backend_cairo import cairo, FigureCanvasCairo\nfrom .backend_qt import _BackendQT, FigureCanvasQT\nfrom .qt_compat import QT_API, QtCore, QtGui\n\n\nclass FigureCanvasQTCairo(FigureCanvasCairo, FigureCanvasQT):\n    def draw(self):\n        if hasattr(self._renderer.gc, \"ctx\"):\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        super().draw()\n\n    def paintEvent(self, event):\n        width = int(self.device_pixel_ratio * self.width())\n        height = int(self.device_pixel_ratio * self.height())\n        if (width, height) != self._renderer.get_canvas_width_height():\n            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n            self._renderer.set_context(cairo.Context(surface))\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        buf = self._renderer.gc.ctx.get_target().get_data()\n        if QT_API == \"PyQt6\":\n            from PyQt6 import sip\n            ptr = int(sip.voidptr(buf))\n        else:\n            ptr = buf\n        qimage = QtGui.QImage(\n            ptr, width, height,\n            QtGui.QImage.Format.Format_ARGB32_Premultiplied)\n        # Adjust the buf reference count to work around a memory leak bug in\n        # QImage under PySide.\n        if QT_API == \"PySide2\" and QtCore.__version_info__ < (5, 12):\n            ctypes.c_long.from_address(id(buf)).value = 1\n        qimage.setDevicePixelRatio(self.device_pixel_ratio)\n        painter = QtGui.QPainter(self)\n        painter.eraseRect(event.rect())\n        painter.drawImage(0, 0, qimage)\n        self._draw_rect_callback(painter)\n        painter.end()\n\n\n@_BackendQT.export\nclass _BackendQTCairo(_BackendQT):\n    FigureCanvas = FigureCanvasQTCairo",
                "filename": "lib/matplotlib/backends/backend_qtcairo.py",
                "start_index": 0,
                "end_index": 1769,
                "start_line": 1,
                "end_line": 46,
                "max_line": 46,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "import numpy as np\n\nfrom .. import cbook, transforms\nfrom . import backend_agg, backend_gtk3\nfrom .backend_gtk3 import Gtk, _BackendGTK3\n\nimport cairo  # Presence of cairo is already checked by _backend_gtk.\n\n\nclass FigureCanvasGTK3Agg(backend_agg.FigureCanvasAgg,\n                          backend_gtk3.FigureCanvasGTK3):\n    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._bbox_queue = []\n\n    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        w = allocation.width * scale\n        h = allocation.height * scale\n\n        if not len(self._bbox_queue):\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            bbox_queue = [transforms.Bbox([[0, 0], [w, h]])]\n        else:\n            bbox_queue = self._bbox_queue\n\n        for bbox in bbox_queue:\n            x = int(bbox.x0)\n            y = h - int(bbox.y1)\n            width = int(bbox.x1) - int(bbox.x0)\n            height = int(bbox.y1) - int(bbox.y0)\n\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                np.asarray(self.copy_from_bbox(bbox)))\n            image = cairo.ImageSurface.create_for_data(\n                buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n            image.set_device_scale(scale, scale)\n            ctx.set_source_surface(image, x / scale, y / scale)\n            ctx.paint()\n\n        if len(self._bbox_queue):\n            self._bbox_queue = []\n\n        return False\n\n    def blit(self, bbox=None):\n        # If bbox is None, blit the entire canvas to gtk. Otherwise\n        # blit only the area defined by the bbox.\n        if bbox is None:\n            bbox = self.figure.bbox\n\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        x = int(bbox.x0 / scale)\n        y = allocation.height - int(bbox.y1 / scale)\n        width = (int(bbox.x1) - int(bbox.x0)) // scale\n        height = (int(bbox.y1) - int(bbox.y0)) // scale\n\n        self._bbox_queue.append(bbox)\n        self.queue_draw_area(x, y, width, height)\n\n\n@_BackendGTK3.export\nclass _BackendGTK3Cairo(_BackendGTK3):\n    FigureCanvas = FigureCanvasGTK3Agg",
                "filename": "lib/matplotlib/backends/backend_gtk3agg.py",
                "start_index": 0,
                "end_index": 2316,
                "start_line": 1,
                "end_line": 69,
                "max_line": 69,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\n================\npyplot with GTK3\n================\n\nAn example of how to use pyplot to manage your figure windows, but modify the\nGUI by accessing the underlying GTK widgets.\n\"\"\"\n\nimport matplotlib\n\nmatplotlib.use('GTK3Agg')  # or 'GTK3Cairo'\nimport gi\n\nimport matplotlib.pyplot as plt\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], 'ro-', label='easy as 1 2 3')\nax.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared')\nax.legend()\n\nmanager = fig.canvas.manager\n# you can access the window or vbox attributes this way\ntoolbar = manager.toolbar\nvbox = manager.vbox\n\n# now let's add a button to the toolbar\nbutton = Gtk.Button(label='Click me')\nbutton.show()\nbutton.connect('clicked', lambda button: print('hi mom'))\n\ntoolitem = Gtk.ToolItem()\ntoolitem.show()\ntoolitem.set_tooltip_text('Click me for fun and profit')\ntoolitem.add(button)\n\npos = 8  # where to insert this in the toolbar\ntoolbar.insert(toolitem, pos)\n\n# now let's add a widget to the vbox\nlabel = Gtk.Label()\nlabel.set_markup('Drag mouse over axes for position')\nlabel.show()\nvbox.pack_start(label, False, False, 0)\nvbox.reorder_child(toolbar, -1)\n\n\ndef update(event):\n    if event.xdata is None:\n        label.set_markup('Drag mouse over axes for position')\n    else:\n        label.set_markup(\n            f'<span color=\"#ef0000\">x,y=({event.xdata}, {event.ydata})</span>')\n\n\nfig.canvas.mpl_connect('motion_notify_event', update)\n\nplt.show()",
                "filename": "galleries/examples/user_interfaces/pylab_with_gtk3_sgskip.py",
                "start_index": 0,
                "end_index": 1472,
                "start_line": 1,
                "end_line": 61,
                "max_line": 61,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\n=================\nEmbedding in GTK3\n=================\n\nDemonstrate adding a FigureCanvasGTK3Agg widget to a Gtk.ScrolledWindow using\nGTK3 accessed via pygobject.\n\"\"\"\n\nimport gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nwin = Gtk.Window()\nwin.connect(\"delete-event\", Gtk.main_quit)\nwin.set_default_size(400, 300)\nwin.set_title(\"Embedding in GTK3\")\n\nfig = Figure(figsize=(5, 4), dpi=100)\nax = fig.add_subplot()\nt = np.arange(0.0, 3.0, 0.01)\ns = np.sin(2*np.pi*t)\nax.plot(t, s)\n\nsw = Gtk.ScrolledWindow()\nwin.add(sw)\n# A scrolled window border goes outside the scrollbars and viewport\nsw.set_border_width(10)\n\ncanvas = FigureCanvas(fig)  # a Gtk.DrawingArea\ncanvas.set_size_request(800, 600)\nsw.add(canvas)\n\nwin.show_all()\nGtk.main()",
                "filename": "galleries/examples/user_interfaces/embedding_in_gtk3_sgskip.py",
                "start_index": 0,
                "end_index": 905,
                "start_line": 1,
                "end_line": 42,
                "max_line": 42,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\n=======================\nMatplotlib with Glade 3\n=======================\n\"\"\"\n\nfrom pathlib import Path\n\nimport gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass Window1Signals:\n    def on_window1_destroy(self, widget):\n        Gtk.main_quit()\n\n\ndef main():\n    builder = Gtk.Builder()\n    builder.add_objects_from_file(\n        str(Path(__file__).parent / \"mpl_with_glade3.glade\"),\n        (\"window1\", \"\"))\n    builder.connect_signals(Window1Signals())\n    window = builder.get_object(\"window1\")\n    sw = builder.get_object(\"scrolledwindow1\")\n\n    # Start of Matplotlib specific code\n    figure = Figure(figsize=(8, 6), dpi=71)\n    axis = figure.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    axis.plot(t, s)\n\n    axis.set_xlabel('time [s]')\n    axis.set_ylabel('voltage [V]')\n\n    canvas = FigureCanvas(figure)  # a Gtk.DrawingArea\n    canvas.set_size_request(800, 600)\n    sw.add(canvas)\n    # End of Matplotlib specific code\n\n    window.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()",
                "filename": "galleries/examples/user_interfaces/mpl_with_glade3_sgskip.py",
                "start_index": 0,
                "end_index": 1211,
                "start_line": 1,
                "end_line": 54,
                "max_line": 54,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "class FigureManagerMac(_macosx.FigureManager, FigureManagerBase):\n    _toolbar2_class = NavigationToolbar2Mac\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        _macosx.FigureManager.__init__(self, canvas)\n        icon_path = str(cbook._get_data_path('images/matplotlib.pdf'))\n        _macosx.FigureManager.set_icon(icon_path)\n        FigureManagerBase.__init__(self, canvas, num)\n        self._set_window_mode(mpl.rcParams.get(\"macosx.window_mode\", \"system\"))\n        if self.toolbar is not None:\n            self.toolbar.update()\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()\n\n    def _close_button_pressed(self):\n        Gcf.destroy(self)\n        self.canvas.flush_events()\n\n    def destroy(self):\n        # We need to clear any pending timers that never fired, otherwise\n        # we get a memory leak from the timer callbacks holding a reference\n        while self.canvas._timers:\n            timer = self.canvas._timers.pop()\n            timer.stop()\n        super().destroy()\n\n    @classmethod\n    def start_main_loop(cls):\n        # Set up a SIGINT handler to allow terminating a plot via CTRL-C.\n        # The logic is largely copied from qt_compat._maybe_allow_interrupt; see its\n        # docstring for details.  Parts are implemented by wake_on_fd_write in ObjC.\n\n        old_sigint_handler = signal.getsignal(signal.SIGINT)\n        if old_sigint_handler in (None, signal.SIG_IGN, signal.SIG_DFL):\n            _macosx.show()\n            return\n\n        handler_args = None\n        wsock, rsock = socket.socketpair()\n        wsock.setblocking(False)\n        rsock.setblocking(False)\n        old_wakeup_fd = signal.set_wakeup_fd(wsock.fileno())\n        _macosx.wake_on_fd_write(rsock.fileno())\n\n        def handle(*args):\n            nonlocal handler_args\n            handler_args = args\n            _macosx.stop()\n\n        signal.signal(signal.SIGINT, handle)\n        try:\n            _macosx.show()\n        finally:\n            wsock.close()\n            rsock.close()\n            signal.set_wakeup_fd(old_wakeup_fd)\n            signal.signal(signal.SIGINT, old_sigint_handler)\n            if handler_args is not None:\n                old_sigint_handler(*handler_args)\n\n    def show(self):\n        if not self._shown:\n            self._show()\n            self._shown = True\n        if mpl.rcParams[\"figure.raise_window\"]:\n            self._raise()\n\n\n@_Backend.export\nclass _BackendMac(_Backend):\n    FigureCanvas = FigureCanvasMac\n    FigureManager = FigureManagerMac\n    mainloop = FigureManagerMac.start_main_loop",
                "filename": "lib/matplotlib/backends/backend_macosx.py",
                "start_index": 5440,
                "end_index": 8036,
                "start_line": 141,
                "end_line": 215,
                "max_line": 215,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "@backend_tools._register_tool_class(FigureCanvasQT)\nclass SaveFigureQt(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass RubberbandQt(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass HelpQt(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass ToolCopyToClipboardQT(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        QtWidgets.QApplication.instance().clipboard().setPixmap(pixmap)\n\n\nFigureManagerQT._toolbar2_class = NavigationToolbar2QT\nFigureManagerQT._toolmanager_toolbar_class = ToolbarQt\n\n\n@_Backend.export\nclass _BackendQT(_Backend):\n    backend_version = __version__\n    FigureCanvas = FigureCanvasQT\n    FigureManager = FigureManagerQT\n    mainloop = FigureManagerQT.start_main_loop",
                "filename": "lib/matplotlib/backends/backend_qt.py",
                "start_index": 37948,
                "end_index": 39372,
                "start_line": 972,
                "end_line": 1022,
                "max_line": 1022,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            },
            {
                "code": "class CanvasFrame(wx.Frame):\n    def __init__(self, parent, title):\n        super().__init__(parent, -1, title, size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.change_plot(0)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.add_buttonbar()\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.add_toolbar()  # comment this out for no toolbar\n\n        menuBar = wx.MenuBar()\n\n        # File Menu\n        menu = wx.Menu()\n        m_exit = menu.Append(\n            wx.ID_EXIT, \"E&xit\\tAlt-X\", \"Exit this simple sample\")\n        menuBar.Append(menu, \"&File\")\n        self.Bind(wx.EVT_MENU, self.OnClose, m_exit)\n\n        if IS_WIN:\n            # Equation Menu\n            menu = wx.Menu()\n            for i, (mt, func) in enumerate(functions):\n                bm = mathtext_to_wxbitmap(mt)\n                item = wx.MenuItem(menu, 1000 + i, \" \")\n                item.SetBitmap(bm)\n                menu.Append(item)\n                self.Bind(wx.EVT_MENU, self.OnChangePlot, item)\n            menuBar.Append(menu, \"&Functions\")\n\n        self.SetMenuBar(menuBar)\n\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n    def add_buttonbar(self):\n        self.button_bar = wx.Panel(self)\n        self.button_bar_sizer = wx.BoxSizer(wx.HORIZONTAL)\n        self.sizer.Add(self.button_bar, 0, wx.LEFT | wx.TOP | wx.GROW)\n\n        for i, (mt, func) in enumerate(functions):\n            bm = mathtext_to_wxbitmap(mt)\n            button = wx.BitmapButton(self.button_bar, 1000 + i, bm)\n            self.button_bar_sizer.Add(button, 1, wx.GROW)\n            self.Bind(wx.EVT_BUTTON, self.OnChangePlot, button)\n\n        self.button_bar.SetSizer(self.button_bar_sizer)\n\n    def add_toolbar(self):\n        \"\"\"Copied verbatim from embedding_wx2.py\"\"\"\n        self.toolbar = NavigationToolbar2Wx(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n\n    def OnChangePlot(self, event):\n        self.change_plot(event.GetId() - 1000)\n\n    def change_plot(self, plot_number):\n        t = np.arange(1.0, 3.0, 0.01)\n        s = functions[plot_number][1](t)\n        self.axes.clear()\n        self.axes.plot(t, s)\n        self.canvas.draw()\n\n    def OnClose(self, event):\n        self.Destroy()\n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        frame = CanvasFrame(None, \"wxPython mathtext demo app\")\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == \"__main__\":\n    app = MyApp()\n    app.MainLoop()",
                "filename": "galleries/examples/user_interfaces/mathtext_wx_sgskip.py",
                "start_index": 1264,
                "end_index": 4109,
                "start_line": 45,
                "end_line": 133,
                "max_line": 133,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.1",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "galleries/examples/user_interfaces/embedding_in_qt_sgskip.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\n===============\nEmbedding in Qt\n===============\n\nSimple Qt application embedding Matplotlib canvases.  This program will work\nequally well using any Qt binding (PyQt6, PySide6, PyQt5, PySide2).  The\nbinding can be selected by setting the :envvar:`QT_API` environment variable to\nthe binding name, or by first importing it.\n\"\"\"\n\nimport sys\nimport time\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_qtagg import FigureCanvas\nfrom matplotlib.backends.backend_qtagg import \\\n    NavigationToolbar2QT as NavigationToolbar\nfrom matplotlib.backends.qt_compat import QtWidgets\nfrom matplotlib.figure import Figure\n\n\nclass ApplicationWindow(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self._main = QtWidgets.QWidget()\n        self.setCentralWidget(self._main)\n        layout = QtWidgets.QVBoxLayout(self._main)\n\n        static_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        # Ideally one would use self.addToolBar here, but it is slightly\n        # incompatible between PyQt6 and other bindings, so we just add the\n        # toolbar as a plain widget instead.\n        layout.addWidget(NavigationToolbar(static_canvas, self))\n        layout.addWidget(static_canvas)\n\n        dynamic_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        layout.addWidget(dynamic_canvas)\n        layout.addWidget(NavigationToolbar(dynamic_canvas, self))\n\n        self._static_ax = static_canvas.figure.subplots()\n        t = np.linspace(0, 10, 501)\n        self._static_ax.plot(t, np.tan(t), \".\")\n\n        self._dynamic_ax = dynamic_canvas.figure.subplots()\n        t = np.linspace(0, 10, 101)\n        # Set up a Line2D.\n        self._line, = self._dynamic_ax.plot(t, np.sin(t + time.time()))\n        self._timer = dynamic_canvas.new_timer(50)\n        self._timer.add_callback(self._update_canvas)\n        self._timer.start()\n\n    def _update_canvas(self):\n        t = np.linspace(0, 10, 101)\n        # Shift the sinusoid as a function of time.\n        self._line.set_data(t, np.sin(t + time.time()))\n        self._line.figure.canvas.draw()\n\n\nif __name__ == \"__main__\":\n    # Check whether there is already a running QApplication (e.g., if running\n    # from an IDE).\n    qapp = QtWidgets.QApplication.instance()\n    if not qapp:\n        qapp = QtWidgets.QApplication(sys.argv)\n\n    app = ApplicationWindow()\n    app.show()\n    app.activateWindow()\n    app.raise_()\n    qapp.exec()",
                        "filename": "galleries/examples/user_interfaces/embedding_in_qt_sgskip.py",
                        "start_index": 0,
                        "end_index": 2411,
                        "start_line": 1,
                        "end_line": 72,
                        "max_line": 72,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows an example of embedding Matplotlib canvases in a PyQt application, which is relevant to the issue as it may contain similar patterns of canvas creation and management."
                }
            ],
            "lib/matplotlib/backends/backend_qt.py": [
                {
                    "chunk": {
                        "code": "@backend_tools._register_tool_class(FigureCanvasQT)\nclass SaveFigureQt(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass RubberbandQt(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass HelpQt(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())\n\n\n@backend_tools._register_tool_class(FigureCanvasQT)\nclass ToolCopyToClipboardQT(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        QtWidgets.QApplication.instance().clipboard().setPixmap(pixmap)\n\n\nFigureManagerQT._toolbar2_class = NavigationToolbar2QT\nFigureManagerQT._toolmanager_toolbar_class = ToolbarQt\n\n\n@_Backend.export\nclass _BackendQT(_Backend):\n    backend_version = __version__\n    FigureCanvas = FigureCanvasQT\n    FigureManager = FigureManagerQT\n    mainloop = FigureManagerQT.start_main_loop",
                        "filename": "lib/matplotlib/backends/backend_qt.py",
                        "start_index": 37948,
                        "end_index": 39372,
                        "start_line": 972,
                        "end_line": 1022,
                        "max_line": 1022,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is from the backend Qt implementation in Matplotlib, which is directly related to the issue as it involves the Qt backend and potentially the handling of canvas objects."
                }
            ]
        },
        "solution_task": "Based on the provided information, the issue seems to be related to the destruction of subclassed `FigureCanvasQT` objects upon calling `plt.figure()` after upgrading Matplotlib from v3.0.3 to v3.1.0. To address this issue:\n\n- Review the Matplotlib change log between versions 3.0.3 and 3.1.0 to identify any changes related to `FigureCanvasQT`, `plt.figure()`, or the Qt5Agg backend that could affect the destruction of canvas objects.\n- Ensure that subclassed `FigureCanvasQT` objects are properly registered with Matplotlib's figure manager. This may involve overriding the `new_figure_manager` method in the `NXPlotView` class to handle the creation and registration of new figures.\n- If the issue is related to the interaction between `plt.figure()` and existing canvas objects, consider manually managing figure creation and canvas association instead of relying on `plt.figure()` to implicitly handle this.\n- Verify that the PyQt application is correctly maintaining references to the subclassed `FigureCanvasQT` objects to prevent premature garbage collection.\n- If necessary, subclass `FigureCanvasQT` and override the `__init__` method to include any additional setup or registration steps that may have been affected by the version change.\n- Test the application with the embedded IPython shell to ensure that the creation of new Matplotlib PyQt figures does not interfere with existing figures.\n\nIf the issue persists after these steps, consider creating a minimal reproducible example and submitting a bug report to the Matplotlib development team, including the specific details of the issue and the steps taken to diagnose and attempt to resolve it.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a structured approach to diagnosing and potentially resolving the issue with the subclassed `FigureCanvasQT` objects being destroyed upon calling `plt.figure()`. It suggests reviewing the Matplotlib change log for relevant changes, ensuring proper registration of subclassed objects, considering manual management of figure creation, verifying reference maintenance to prevent garbage collection, and subclassing with overridden methods if necessary. Additionally, the RESPONSE provides links to code snippets that could be relevant to the issue. However, it does not directly address the specific cause of the destruction of the subclassed canvases, which would be necessary for a higher score. The RESPONSE is also missing a direct suggestion to compare the `FigureCanvasQT.__init__` implementations between the two versions to pinpoint the exact change causing the issue.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711699353.3079538,
        "result": "Based on the provided information, the issue seems to be related to the destruction of subclassed `FigureCanvasQT` objects upon calling `plt.figure()` after upgrading Matplotlib from v3.0.3 to v3.1.0. To address this issue:\n\n- Review the Matplotlib change log between versions 3.0.3 and 3.1.0 to identify any changes related to `FigureCanvasQT`, `plt.figure()`, or the Qt5Agg backend that could affect the destruction of canvas objects.\n- Ensure that subclassed `FigureCanvasQT` objects are properly registered with Matplotlib's figure manager. This may involve overriding the `new_figure_manager` method in the `NXPlotView` class to handle the creation and registration of new figures.\n- If the issue is related to the interaction between `plt.figure()` and existing canvas objects, consider manually managing figure creation and canvas association instead of relying on `plt.figure()` to implicitly handle this.\n- Verify that the PyQt application is correctly maintaining references to the subclassed `FigureCanvasQT` objects to prevent premature garbage collection.\n- If necessary, subclass `FigureCanvasQT` and override the `__init__` method to include any additional setup or registration steps that may have been affected by the version change.\n- Test the application with the embedded IPython shell to ensure that the creation of new Matplotlib PyQt figures does not interfere with existing figures.\n\nIf the issue persists after these steps, consider creating a minimal reproducible example and submitting a bug report to the Matplotlib development team, including the specific details of the issue and the steps taken to diagnose and attempt to resolve it.\n\n### Code snippets to check\n\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//galleries) \u2192 [examples](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//galleries/examples) \u2192 [user_interfaces](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//galleries/examples/user_interfaces)- [Lines 1 - 72](https://github.com/testbed/matplotlib__matplotlib__3.1/blob//galleries/examples/user_interfaces/embedding_in_qt_sgskip.py#L1-L72)\n\n This snippet shows an example of embedding Matplotlib canvases in a PyQt application, which is relevant to the issue as it may contain similar patterns of canvas creation and management.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.1/tree//lib/matplotlib/backends)- [Lines 972 - 1022](https://github.com/testbed/matplotlib__matplotlib__3.1/blob//lib/matplotlib/backends/backend_qt.py#L972-L1022)\n\n This snippet is from the backend Qt implementation in Matplotlib, which is directly related to the issue as it involves the Qt backend and potentially the handling of canvas objects."
    }
}