{
    "id": "sphinx-doc__sphinx-9931",
    "repo_name": "testbed/sphinx-doc__sphinx__4.4",
    "task_id": 4924411264680941247,
    "title": "autodoc add_module_names equivalent for arguments",
    "body": "The `add_module_names = False` configuration seems to only affect the class/function/attribute header names.\r\nThe type hints are still always rendered as fully qualified names.\r\n\r\n`mypackage/mymodule.py`:\r\n```python\r\nclass MyClass:\r\n    \"\"\"Whatever 1.\"\"\"\r\n    pass\r\n\r\n\r\ndef foo(arg: MyClass):\r\n    \"\"\"Whatever 2.\"\"\"\r\n    pass\r\n```\r\n\r\n`conf.py`:\r\n```python\r\n# ...\r\nadd_module_names = False\r\n# ...\r\n```\r\n\r\n`index.rst`:\r\n```rst\r\nmypackage.mymodule module\r\n=========================\r\n\r\n.. automodule:: mypackage.mymodule\r\n   :members:\r\n   :undoc-members:\r\n   :show-inheritance:\r\n```\r\n\r\nExpected documentation:\r\n```\r\nfoo(arg: MyClass)\r\n    Whatever 2.\r\n```\r\n\r\nActual documentation:\r\n```\r\nfoo(arg: mypackage.mymodule.MyClass)\r\n    Whatever 2.\r\n```\r\n\r\n## Describe the solution you'd like\r\n\r\nI would be OK with any of the following:\r\n```python\r\nadd_module_names = False # now affects type annotations too\r\n# or\r\nadd_type_module_names = False # new sphinx config option (name up for debate)\r\n# or\r\nautodoc_add_module_names = False # new autodoc config option (name up for debate)\r\n```\r\n\r\n## Describe alternatives you've considered\r\n\r\nThere's a [StackOverflow post](https://stackoverflow.com/questions/51394955/sphinx-remove-module-prefix-for-args-in-automodule) which suggests using the `autodoc_docstring_signature` option to manually specify the function signature. This is not really a viable solution in my opinion.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__4.4.git",
    "requested_commit": "",
    "mayil_response": "Based on the provided information, the issue is that the `add_module_names` configuration option in Sphinx does not affect the rendering of fully qualified names in type hints. The user expects type hints not to show fully qualified names in the generated documentation.\n\nTo address this issue, you can modify the `stringify_annotation` function in `sphinx/util/typing.py` to respect the `add_module_names` configuration option when generating the string representation of type hints. Here's a potential solution:\n\n- Modify the `stringify_annotation` function in `sphinx/util/typing.py` to check the `add_module_names` configuration option and adjust the `module_prefix` accordingly.\n- If `add_module_names` is `False`, set `module_prefix` to an empty string to prevent fully qualified names from being displayed in type hints.\n\nHere's a code snippet that demonstrates how you might implement this:\n\n```python\n# sphinx/util/typing.py\n\nfrom sphinx.config import Config  # Make sure to import Config\n\ndef stringify_annotation(annotation, mode):\n    # ... existing code ...\n\n    # Retrieve the add_module_names setting from the Sphinx configuration\n    config = Config.read()  # You may need to adjust how you access the config\n    add_module_names = config.get('add_module_names', True)\n\n    # Modify the module_prefix based on the add_module_names setting\n    if not add_module_names:\n        module_prefix = ''\n    else:\n        # existing logic to set module_prefix\n        # ...\n\n    # ... existing code that uses module_prefix ...\n```\n\nPlease note that the way you access the Sphinx configuration (`Config.read()`) may vary depending on the context in which `stringify_annotation` is called. You may need to pass the configuration object to this function from the calling context.\n\nThis solution assumes that the `add_module_names` configuration option should globally affect the rendering of module names in type hints. If more granular control is desired, you might need to introduce a new configuration option specifically for type hints, as suggested by the user (e.g., `add_type_module_names`).\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx/util)- [Lines 287 - 344](https://github.com/testbed/sphinx-doc__sphinx__4.4/blob//sphinx/util/typing.py#L287-L344)\n\n This snippet contains logic for handling the stringification of annotations, which is relevant to the issue of type hints being rendered with fully qualified names.\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx/util)- [Lines 436 - 522](https://github.com/testbed/sphinx-doc__sphinx__4.4/blob//sphinx/util/inspect.py#L436-L522)\n\n This snippet deals with type aliases and could be relevant when considering how type hints are displayed in the documentation.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000254,
        "snippet_processor": 0.05448,
        "issue_star_creation": 0.02164,
        "issue_star_solver": 0.058,
        "bouncer": 0.024370000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711701901.841664,
        "relevant_snippets": [
            {
                "code": "class TypeAliasForwardRef:\n    \"\"\"Pseudo typing class for autodoc_type_aliases.\n\n    This avoids the error on evaluating the type inside `get_type_hints()`.\n    \"\"\"\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n    def __call__(self) -> None:\n        # Dummy method to imitate special typing classes\n        pass\n\n    def __eq__(self, other: Any) -> bool:\n        return self.name == other\n\n    def __hash__(self) -> int:\n        return hash(self.name)\n\n    def __repr__(self) -> str:\n        return self.name\n\n\nclass TypeAliasModule:\n    \"\"\"Pseudo module class for autodoc_type_aliases.\"\"\"\n\n    def __init__(self, modname: str, mapping: dict[str, str]) -> None:\n        self.__modname = modname\n        self.__mapping = mapping\n\n        self.__module: ModuleType | None = None\n\n    def __getattr__(self, name: str) -> Any:\n        fullname = '.'.join(filter(None, [self.__modname, name]))\n        if fullname in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[fullname])\n        else:\n            prefix = fullname + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(fullname, nested)\n            else:\n                # no sub modules or classes found.\n                try:\n                    # return the real submodule if exists\n                    return import_module(fullname)\n                except ImportError:\n                    # return the real class\n                    if self.__module is None:\n                        self.__module = import_module(self.__modname)\n\n                    return getattr(self.__module, name)\n\n\nclass TypeAliasNamespace(Dict[str, Any]):\n    \"\"\"Pseudo namespace class for autodoc_type_aliases.\n\n    This enables to look up nested modules and classes like `mod1.mod2.Class`.\n    \"\"\"\n\n    def __init__(self, mapping: dict[str, str]) -> None:\n        self.__mapping = mapping\n\n    def __getitem__(self, key: str) -> Any:\n        if key in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[key])\n        else:\n            prefix = key + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(key, nested)\n            else:\n                raise KeyError\n\n\ndef _should_unwrap(subject: Callable) -> bool:\n    \"\"\"Check the function should be unwrapped on getting signature.\"\"\"\n    __globals__ = getglobals(subject)\n    if (__globals__.get('__name__') == 'contextlib' and\n            __globals__.get('__file__') == contextlib.__file__):\n        # contextmanger should be unwrapped\n        return True\n\n    return False",
                "filename": "sphinx/util/inspect.py",
                "start_index": 13767,
                "end_index": 16641,
                "start_line": 436,
                "end_line": 522,
                "max_line": 817,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "\"\"\"Add external links to module code in Python object descriptions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom docutils import nodes\nfrom docutils.nodes import Node\n\nimport sphinx\nfrom sphinx import addnodes\nfrom sphinx.application import Sphinx\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import _\n\n\nclass LinkcodeError(SphinxError):\n    category = \"linkcode error\"\n\n\ndef doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n\n    resolve_target = getattr(env.config, 'linkcode_resolve', None)\n    if not callable(env.config.linkcode_resolve):\n        raise LinkcodeError(\n            \"Function `linkcode_resolve` is not given in conf.py\")\n\n    domain_keys = {\n        'py': ['module', 'fullname'],\n        'c': ['names'],\n        'cpp': ['names'],\n        'js': ['object', 'fullname'],\n    }\n\n    for objnode in list(doctree.findall(addnodes.desc)):\n        domain = objnode.get('domain')\n        uris: set[str] = set()\n        for signode in objnode:\n            if not isinstance(signode, addnodes.desc_signature):\n                continue\n\n            # Convert signode to a specified format\n            info = {}\n            for key in domain_keys.get(domain, []):\n                value = signode.get(key)\n                if not value:\n                    value = ''\n                info[key] = value\n            if not info:\n                continue\n\n            # Call user code to resolve the link\n            uri = resolve_target(domain, info)\n            if not uri:\n                # no source\n                continue\n\n            if uri in uris or not uri:\n                # only one link per name, please\n                continue\n            uris.add(uri)\n\n            inline = nodes.inline('', _('[source]'), classes=['viewcode-link'])\n            onlynode = addnodes.only(expr='html')\n            onlynode += nodes.reference('', '', inline, internal=False, refuri=uri)\n            signode += onlynode\n\n\ndef setup(app: Sphinx) -> dict[str, Any]:\n    app.connect('doctree-read', doctree_read)\n    app.add_config_value('linkcode_resolve', None, '')\n    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}",
                "filename": "sphinx/ext/linkcode.py",
                "start_index": 0,
                "end_index": 2202,
                "start_line": 1,
                "end_line": 73,
                "max_line": 73,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "\"\"\"Extension that adds an autosummary:: directive.\n\nThe directive can be used to generate function/method/attribute/etc. summary\nlists, similar to those output eg. by Epydoc and other API doc generation tools.\n\nAn :autolink: role is also provided.\n\nautosummary directive\n---------------------\n\nThe autosummary directive has the form::\n\n    .. autosummary::\n       :nosignatures:\n       :toctree: generated/\n\n       module.function_1\n       module.function_2\n       ...\n\nand it generates an output table (containing signatures, optionally)\n\n    ========================  =============================================\n    module.function_1(args)   Summary line from the docstring of function_1\n    module.function_2(args)   Summary line from the docstring\n    ...\n    ========================  =============================================\n\nIf the :toctree: option is specified, files matching the function names\nare inserted to the toctree with the given prefix:\n\n    generated/module.function_1\n    generated/module.function_2\n    ...\n\nNote: The file names contain the module:: or currentmodule:: prefixes.\n\n.. seealso:: autosummary_generate.py\n\n\nautolink role\n-------------\n\nThe autolink role functions as ``:obj:`` when the name referred can be\nresolved to a Python object, and otherwise it becomes simple emphasis.\nThis can be used as the default role to make links 'smart'.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\nimport os\nimport posixpath\nimport re\nimport sys\nfrom inspect import Parameter\nfrom os import path\nfrom types import ModuleType\nfrom typing import Any, List, Sequence, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Node, system_message\nfrom docutils.parsers.rst import directives\nfrom docutils.parsers.rst.states import RSTStateMachine, Struct, state_classes\nfrom docutils.statemachine import StringList\n\nimport sphinx\nfrom sphinx import addnodes\nfrom sphinx.application import Sphinx\nfrom sphinx.config import Config\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.ext.autodoc import INSTANCEATTR, Documenter\nfrom sphinx.ext.autodoc.directive import DocumenterBridge, Options\nfrom sphinx.ext.autodoc.importer import import_module\nfrom sphinx.ext.autodoc.mock import mock\nfrom sphinx.extension import Extension\nfrom sphinx.locale import __\nfrom sphinx.project import Project\nfrom sphinx.pycode import ModuleAnalyzer, PycodeError\nfrom sphinx.registry import SphinxComponentRegistry\nfrom sphinx.util import logging, rst\nfrom sphinx.util.docutils import (\n    NullReporter,\n    SphinxDirective,\n    SphinxRole,\n    new_document,\n    switch_source_input,\n)\nfrom sphinx.util.inspect import getmro, signature_from_str\nfrom sphinx.util.matching import Matcher\nfrom sphinx.util.typing import OptionSpec\nfrom sphinx.writers.html import HTML5Translator\n\nlogger = logging.getLogger(__name__)\n\n\nperiods_re = re.compile(r'\\.(?:\\s+)')\nliteral_re = re.compile(r'::\\s*$')\n\nWELL_KNOWN_ABBREVIATIONS = ('et al.', ' i.e.',)",
                "filename": "sphinx/ext/autosummary/__init__.py",
                "start_index": 0,
                "end_index": 2962,
                "start_line": 1,
                "end_line": 100,
                "max_line": 841,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "# -- autosummary_toc node ------------------------------------------------------\n\nclass autosummary_toc(nodes.comment):\n    pass\n\n\ndef autosummary_toc_visit_html(self: nodes.NodeVisitor, node: autosummary_toc) -> None:\n    \"\"\"Hide autosummary toctree list in HTML output.\"\"\"\n    raise nodes.SkipNode\n\n\ndef autosummary_noop(self: nodes.NodeVisitor, node: Node) -> None:\n    pass\n\n\n# -- autosummary_table node ----------------------------------------------------\n\nclass autosummary_table(nodes.comment):\n    pass\n\n\ndef autosummary_table_visit_html(self: HTML5Translator, node: autosummary_table) -> None:\n    \"\"\"Make the first column of the table non-breaking.\"\"\"\n    try:\n        table = cast(nodes.table, node[0])\n        tgroup = cast(nodes.tgroup, table[0])\n        tbody = cast(nodes.tbody, tgroup[-1])\n        rows = cast(List[nodes.row], tbody)\n        for row in rows:\n            col1_entry = cast(nodes.entry, row[0])\n            par = cast(nodes.paragraph, col1_entry[0])\n            for j, subnode in enumerate(list(par)):\n                if isinstance(subnode, nodes.Text):\n                    new_text = subnode.astext().replace(\" \", \"\\u00a0\")\n                    par[j] = nodes.Text(new_text)\n    except IndexError:\n        pass\n\n\n# -- autodoc integration -------------------------------------------------------\n\nclass FakeApplication:\n    def __init__(self) -> None:\n        self.doctreedir = None\n        self.events = None\n        self.extensions: dict[str, Extension] = {}\n        self.srcdir = None\n        self.config = Config()\n        self.project = Project(None, None)\n        self.registry = SphinxComponentRegistry()\n\n\nclass FakeDirective(DocumenterBridge):\n    def __init__(self) -> None:\n        settings = Struct(tab_width=8)\n        document = Struct(settings=settings)\n        app = FakeApplication()\n        app.config.add('autodoc_class_signature', 'mixed', True, None)\n        env = BuildEnvironment(app)  # type: ignore\n        state = Struct(document=document)\n        super().__init__(env, None, Options(), 0, state)",
                "filename": "sphinx/ext/autosummary/__init__.py",
                "start_index": 2965,
                "end_index": 5016,
                "start_line": 103,
                "end_line": 163,
                "max_line": 841,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Description of a general Python object.\n\n    :cvar allow_nesting: Class is an object that allows for nested namespaces\n    :vartype allow_nesting: bool\n    \"\"\"\n    option_spec: OptionSpec = {\n        'noindex': directives.flag,\n        'noindexentry': directives.flag,\n        'nocontentsentry': directives.flag,\n        'module': directives.unchanged,\n        'canonical': directives.unchanged,\n        'annotation': directives.unchanged,\n    }\n\n    doc_field_types = [\n        PyTypedField('parameter', label=_('Parameters'),\n                     names=('param', 'parameter', 'arg', 'argument',\n                            'keyword', 'kwarg', 'kwparam'),\n                     typerolename='class', typenames=('paramtype', 'type'),\n                     can_collapse=True),\n        PyTypedField('variable', label=_('Variables'),\n                     names=('var', 'ivar', 'cvar'),\n                     typerolename='class', typenames=('vartype',),\n                     can_collapse=True),\n        PyGroupedField('exceptions', label=_('Raises'), rolename='exc',\n                       names=('raises', 'raise', 'exception', 'except'),\n                       can_collapse=True),\n        Field('returnvalue', label=_('Returns'), has_arg=False,\n              names=('returns', 'return')),\n        PyField('returntype', label=_('Return type'), has_arg=False,\n                names=('rtype',), bodyrolename='class'),\n    ]\n\n    allow_nesting = False\n\n    def get_signature_prefix(self, sig: str) -> list[nodes.Node]:\n        \"\"\"May return a prefix to put before the object name in the\n        signature.\n        \"\"\"\n        return []\n\n    def needs_arglist(self) -> bool:\n        \"\"\"May return true if an empty argument list is to be generated even if\n        the document contains none.\n        \"\"\"\n        return False",
                "filename": "sphinx/domains/python.py",
                "start_index": 17615,
                "end_index": 19437,
                "start_line": 1,
                "end_line": 915,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "class PyModule(SphinxDirective):\n    \"\"\"\n    Directive to mark description of a new module.\n    \"\"\"\n\n    has_content = True\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: OptionSpec = {\n        'platform': lambda x: x,\n        'synopsis': lambda x: x,\n        'noindex': directives.flag,\n        'nocontentsentry': directives.flag,\n        'deprecated': directives.flag,\n    }\n\n    def run(self) -> list[Node]:\n        domain = cast(PythonDomain, self.env.get_domain('py'))\n\n        modname = self.arguments[0].strip()\n        noindex = 'noindex' in self.options\n        self.env.ref_context['py:module'] = modname\n\n        content_node: Element = nodes.section()\n        # necessary so that the child nodes get the right source/line set\n        content_node.document = self.state.document\n        nested_parse_with_titles(self.state, self.content, content_node, self.content_offset)\n\n        ret: list[Node] = []\n        if not noindex:\n            # note module to the domain\n            node_id = make_id(self.env, self.state.document, 'module', modname)\n            target = nodes.target('', '', ids=[node_id], ismod=True)\n            self.set_source_info(target)\n            self.state.document.note_explicit_target(target)\n\n            domain.note_module(modname,\n                               node_id,\n                               self.options.get('synopsis', ''),\n                               self.options.get('platform', ''),\n                               'deprecated' in self.options)\n            domain.note_object(modname, 'module', node_id, location=target)\n\n            # the platform and synopsis aren't printed; in fact, they are only\n            # used in the modindex currently\n            ret.append(target)\n            indextext = f'{pairindextypes[\"module\"]}; {modname}'\n            inode = addnodes.index(entries=[('pair', indextext, node_id, '', None)])\n            ret.append(inode)\n        ret.extend(content_node.children)\n        return ret\n\n\nclass PyCurrentModule(SphinxDirective):\n    \"\"\"\n    This directive is just to tell Sphinx that we're documenting\n    stuff in module foo, but links to module foo won't lead here.\n    \"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: OptionSpec = {}\n\n    def run(self) -> list[Node]:\n        modname = self.arguments[0].strip()\n        if modname == 'None':\n            self.env.ref_context.pop('py:module', None)\n        else:\n            self.env.ref_context['py:module'] = modname\n        return []",
                "filename": "sphinx/domains/python.py",
                "start_index": 39086,
                "end_index": 41712,
                "start_line": 1014,
                "end_line": 1349,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "if annotation_qualname or (annotation_module_is_typing and not annotation_forward_arg):\n        if mode == 'smart':\n            module_prefix = '~' + module_prefix\n        if annotation_module_is_typing and mode == 'fully-qualified-except-typing':\n            module_prefix = ''\n    else:\n        module_prefix = ''\n\n    if annotation_module_is_typing:\n        if annotation_forward_arg:\n            # handle ForwardRefs\n            qualname = annotation_forward_arg\n        else:\n            _name = getattr(annotation, '_name', '')\n            if _name:\n                qualname = _name\n            elif annotation_qualname:\n                qualname = annotation_qualname\n            else:\n                qualname = stringify_annotation(\n                    annotation.__origin__, 'fully-qualified-except-typing',\n                ).replace('typing.', '')  # ex. Union\n    elif annotation_qualname:\n        qualname = annotation_qualname\n    elif hasattr(annotation, '__origin__'):\n        # instantiated generic provided by a user\n        qualname = stringify_annotation(annotation.__origin__, mode)\n    elif UnionType and isinstance(annotation, UnionType):  # types.UnionType (for py3.10+)\n        qualname = 'types.UnionType'\n    else:\n        # we weren't able to extract the base type, appending arguments would\n        # only make them appear twice\n        return repr(annotation)\n\n    annotation_args = getattr(annotation, '__args__', None)\n    if annotation_args:\n        if not isinstance(annotation_args, (list, tuple)):\n            # broken __args__ found\n            pass\n        elif qualname in {'Optional', 'Union', 'types.UnionType'}:\n            return ' | '.join(stringify_annotation(a, mode) for a in annotation_args)\n        elif qualname == 'Callable':\n            args = ', '.join(stringify_annotation(a, mode) for a in annotation_args[:-1])\n            returns = stringify_annotation(annotation_args[-1], mode)\n            return f'{module_prefix}Callable[[{args}], {returns}]'\n        elif qualname == 'Literal':\n            args = ', '.join(repr(a) for a in annotation_args)\n            return f'{module_prefix}Literal[{args}]'\n        elif str(annotation).startswith('typing.Annotated'):  # for py39+\n            return stringify_annotation(annotation_args[0], mode)\n        elif all(is_system_TypeVar(a) for a in annotation_args):\n            # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])\n            return module_prefix + qualname\n        else:\n            args = ', '.join(stringify_annotation(a, mode) for a in annotation_args)\n            return f'{module_prefix}{qualname}[{args}]'\n\n    return module_prefix + qualname",
                "filename": "sphinx/util/typing.py",
                "start_index": 11752,
                "end_index": 14430,
                "start_line": 287,
                "end_line": 344,
                "max_line": 361,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "\"\"\"Add links to module code in Python object descriptions.\"\"\"\n\nfrom __future__ import annotations\n\nimport posixpath\nimport traceback\nfrom os import path\nfrom typing import Any, Generator, Iterable, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node\n\nimport sphinx\nfrom sphinx import addnodes\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.builders.html import StandaloneHTMLBuilder\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.pycode import ModuleAnalyzer\nfrom sphinx.transforms.post_transforms import SphinxPostTransform\nfrom sphinx.util import get_full_modname, logging\nfrom sphinx.util.display import status_iterator\nfrom sphinx.util.nodes import make_refnode\n\nlogger = logging.getLogger(__name__)\n\n\nOUTPUT_DIRNAME = '_modules'\n\n\nclass viewcode_anchor(Element):\n    \"\"\"Node for viewcode anchors.\n\n    This node will be processed in the resolving phase.\n    For viewcode supported builders, they will be all converted to the anchors.\n    For not supported builders, they will be removed.\n    \"\"\"\n\n\ndef _get_full_modname(app: Sphinx, modname: str, attribute: str) -> str | None:\n    try:\n        return get_full_modname(modname, attribute)\n    except AttributeError:\n        # sphinx.ext.viewcode can't follow class instance attribute\n        # then AttributeError logging output only verbose mode.\n        logger.verbose(\"Didn't find %s in %s\", attribute, modname)\n        return None\n    except Exception as e:\n        # sphinx.ext.viewcode follow python domain directives.\n        # because of that, if there are no real modules exists that specified\n        # by py:function or other directives, viewcode emits a lot of warnings.\n        # It should be displayed only verbose mode.\n        logger.verbose(traceback.format_exc().rstrip())\n        logger.verbose('viewcode can\\'t import %s, failed with error \"%s\"', modname, e)\n        return None\n\n\ndef is_supported_builder(builder: Builder) -> bool:\n    if builder.format != 'html':\n        return False\n    if builder.name == 'singlehtml':\n        return False\n    if builder.name.startswith('epub') and not builder.config.viewcode_enable_epub:\n        return False\n    return True",
                "filename": "sphinx/ext/viewcode.py",
                "start_index": 0,
                "end_index": 2246,
                "start_line": 1,
                "end_line": 221,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "display_name = name\n            if name.startswith('~'):\n                name = name[1:]\n                display_name = name.split('.')[-1]\n\n            try:\n                real_name, obj, parent, modname = self.import_by_name(name, prefixes=prefixes)\n            except ImportExceptionGroup as exc:\n                errors = list({f\"* {type(e).__name__}: {e}\" for e in exc.exceptions})\n                logger.warning(__('autosummary: failed to import %s.\\nPossible hints:\\n%s'),\n                               name, '\\n'.join(errors), location=self.get_location())\n                continue\n\n            self.bridge.result = StringList()  # initialize for each documenter\n            full_name = real_name\n            if not isinstance(obj, ModuleType):\n                # give explicitly separated module name, so that members\n                # of inner classes can be documented\n                full_name = modname + '::' + full_name[len(modname) + 1:]\n            # NB. using full_name here is important, since Documenters\n            #     handle module prefixes slightly differently\n            documenter = self.create_documenter(self.env.app, obj, parent, full_name)\n            if not documenter.parse_name():\n                logger.warning(__('failed to parse name %s'), real_name,\n                               location=self.get_location())\n                items.append((display_name, '', '', real_name))\n                continue\n            if not documenter.import_object():\n                logger.warning(__('failed to import object %s'), real_name,\n                               location=self.get_location())\n                items.append((display_name, '', '', real_name))\n                continue\n\n            # try to also get a source code analyzer for attribute docs\n            try:\n                documenter.analyzer = ModuleAnalyzer.for_module(\n                    documenter.get_real_modname())\n                # parse right now, to get PycodeErrors on parsing (results will\n                # be cached anyway)\n                documenter.analyzer.find_attr_docs()\n            except PycodeError as err:\n                logger.debug('[autodoc] module analyzer failed: %s', err)\n                # no source file -- e.g. for builtin and C modules\n                documenter.analyzer = None\n\n            # -- Grab the signature\n\n            try:\n                sig = documenter.format_signature(show_annotation=False)\n            except TypeError:\n                # the documenter does not support ``show_annotation`` option\n                sig = documenter.format_signature()\n\n            if not sig:\n                sig = ''\n            else:\n                max_chars = max(10, max_item_chars - len(display_name))\n                sig = mangle_signature(sig, max_chars=max_chars)\n\n            # -- Grab the summary\n\n            # bodge for ModuleDocumenter\n            documenter._extra_indent = ''  # type: ignore[attr-defined]\n\n            documenter.add_content(None)",
                "filename": "sphinx/ext/autosummary/__init__.py",
                "start_index": 10578,
                "end_index": 13571,
                "start_line": 309,
                "end_line": 373,
                "max_line": 841,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            },
            {
                "code": "def get_module_attrs(members: Any) -> tuple[list[str], list[str]]:\n        \"\"\"Find module attributes with docstrings.\"\"\"\n        attrs, public = [], []\n        try:\n            analyzer = ModuleAnalyzer.for_module(name)\n            attr_docs = analyzer.find_attr_docs()\n            for namespace, attr_name in attr_docs:\n                if namespace == '' and attr_name in members:\n                    attrs.append(attr_name)\n                    if not attr_name.startswith('_'):\n                        public.append(attr_name)\n        except PycodeError:\n            pass    # give up if ModuleAnalyzer fails to parse code\n        return public, attrs\n\n    def get_modules(\n            obj: Any,\n            skip: Sequence[str],\n            public_members: Sequence[str] | None = None) -> tuple[list[str], list[str]]:\n        items: list[str] = []\n        public: list[str] = []\n        for _, modname, _ispkg in pkgutil.iter_modules(obj.__path__):\n\n            if modname in skip:\n                # module was overwritten in __init__.py, so not accessible\n                continue\n            fullname = name + '.' + modname\n            try:\n                module = import_module(fullname)\n                if module and hasattr(module, '__sphinx_mock__'):\n                    continue\n            except ImportError:\n                pass\n\n            items.append(fullname)\n            if public_members is not None:\n                if modname in public_members:\n                    public.append(fullname)\n            else:\n                if not modname.startswith('_'):\n                    public.append(fullname)\n        return public, items\n\n    ns: dict[str, Any] = {}\n    ns.update(context)",
                "filename": "sphinx/ext/autosummary/generate.py",
                "start_index": 10102,
                "end_index": 11803,
                "start_line": 288,
                "end_line": 332,
                "max_line": 704,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                "sha": ""
            }
        ],
        "classification": "other",
        "snippet_processor_task": {
            "sphinx/util/typing.py": [
                {
                    "chunk": {
                        "code": "if annotation_qualname or (annotation_module_is_typing and not annotation_forward_arg):\n        if mode == 'smart':\n            module_prefix = '~' + module_prefix\n        if annotation_module_is_typing and mode == 'fully-qualified-except-typing':\n            module_prefix = ''\n    else:\n        module_prefix = ''\n\n    if annotation_module_is_typing:\n        if annotation_forward_arg:\n            # handle ForwardRefs\n            qualname = annotation_forward_arg\n        else:\n            _name = getattr(annotation, '_name', '')\n            if _name:\n                qualname = _name\n            elif annotation_qualname:\n                qualname = annotation_qualname\n            else:\n                qualname = stringify_annotation(\n                    annotation.__origin__, 'fully-qualified-except-typing',\n                ).replace('typing.', '')  # ex. Union\n    elif annotation_qualname:\n        qualname = annotation_qualname\n    elif hasattr(annotation, '__origin__'):\n        # instantiated generic provided by a user\n        qualname = stringify_annotation(annotation.__origin__, mode)\n    elif UnionType and isinstance(annotation, UnionType):  # types.UnionType (for py3.10+)\n        qualname = 'types.UnionType'\n    else:\n        # we weren't able to extract the base type, appending arguments would\n        # only make them appear twice\n        return repr(annotation)\n\n    annotation_args = getattr(annotation, '__args__', None)\n    if annotation_args:\n        if not isinstance(annotation_args, (list, tuple)):\n            # broken __args__ found\n            pass\n        elif qualname in {'Optional', 'Union', 'types.UnionType'}:\n            return ' | '.join(stringify_annotation(a, mode) for a in annotation_args)\n        elif qualname == 'Callable':\n            args = ', '.join(stringify_annotation(a, mode) for a in annotation_args[:-1])\n            returns = stringify_annotation(annotation_args[-1], mode)\n            return f'{module_prefix}Callable[[{args}], {returns}]'\n        elif qualname == 'Literal':\n            args = ', '.join(repr(a) for a in annotation_args)\n            return f'{module_prefix}Literal[{args}]'\n        elif str(annotation).startswith('typing.Annotated'):  # for py39+\n            return stringify_annotation(annotation_args[0], mode)\n        elif all(is_system_TypeVar(a) for a in annotation_args):\n            # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])\n            return module_prefix + qualname\n        else:\n            args = ', '.join(stringify_annotation(a, mode) for a in annotation_args)\n            return f'{module_prefix}{qualname}[{args}]'\n\n    return module_prefix + qualname",
                        "filename": "sphinx/util/typing.py",
                        "start_index": 11752,
                        "end_index": 14430,
                        "start_line": 287,
                        "end_line": 344,
                        "max_line": 361,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains logic for handling the stringification of annotations, which is relevant to the issue of type hints being rendered with fully qualified names."
                }
            ],
            "sphinx/util/inspect.py": [
                {
                    "chunk": {
                        "code": "class TypeAliasForwardRef:\n    \"\"\"Pseudo typing class for autodoc_type_aliases.\n\n    This avoids the error on evaluating the type inside `get_type_hints()`.\n    \"\"\"\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n    def __call__(self) -> None:\n        # Dummy method to imitate special typing classes\n        pass\n\n    def __eq__(self, other: Any) -> bool:\n        return self.name == other\n\n    def __hash__(self) -> int:\n        return hash(self.name)\n\n    def __repr__(self) -> str:\n        return self.name\n\n\nclass TypeAliasModule:\n    \"\"\"Pseudo module class for autodoc_type_aliases.\"\"\"\n\n    def __init__(self, modname: str, mapping: dict[str, str]) -> None:\n        self.__modname = modname\n        self.__mapping = mapping\n\n        self.__module: ModuleType | None = None\n\n    def __getattr__(self, name: str) -> Any:\n        fullname = '.'.join(filter(None, [self.__modname, name]))\n        if fullname in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[fullname])\n        else:\n            prefix = fullname + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(fullname, nested)\n            else:\n                # no sub modules or classes found.\n                try:\n                    # return the real submodule if exists\n                    return import_module(fullname)\n                except ImportError:\n                    # return the real class\n                    if self.__module is None:\n                        self.__module = import_module(self.__modname)\n\n                    return getattr(self.__module, name)\n\n\nclass TypeAliasNamespace(Dict[str, Any]):\n    \"\"\"Pseudo namespace class for autodoc_type_aliases.\n\n    This enables to look up nested modules and classes like `mod1.mod2.Class`.\n    \"\"\"\n\n    def __init__(self, mapping: dict[str, str]) -> None:\n        self.__mapping = mapping\n\n    def __getitem__(self, key: str) -> Any:\n        if key in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[key])\n        else:\n            prefix = key + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(key, nested)\n            else:\n                raise KeyError\n\n\ndef _should_unwrap(subject: Callable) -> bool:\n    \"\"\"Check the function should be unwrapped on getting signature.\"\"\"\n    __globals__ = getglobals(subject)\n    if (__globals__.get('__name__') == 'contextlib' and\n            __globals__.get('__file__') == contextlib.__file__):\n        # contextmanger should be unwrapped\n        return True\n\n    return False",
                        "filename": "sphinx/util/inspect.py",
                        "start_index": 13767,
                        "end_index": 16641,
                        "start_line": 436,
                        "end_line": 522,
                        "max_line": 817,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.4",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet deals with type aliases and could be relevant when considering how type hints are displayed in the documentation."
                }
            ]
        },
        "solution_task": "Based on the provided information, the issue is that the `add_module_names` configuration option in Sphinx does not affect the rendering of fully qualified names in type hints. The user expects type hints not to show fully qualified names in the generated documentation.\n\nTo address this issue, you can modify the `stringify_annotation` function in `sphinx/util/typing.py` to respect the `add_module_names` configuration option when generating the string representation of type hints. Here's a potential solution:\n\n- Modify the `stringify_annotation` function in `sphinx/util/typing.py` to check the `add_module_names` configuration option and adjust the `module_prefix` accordingly.\n- If `add_module_names` is `False`, set `module_prefix` to an empty string to prevent fully qualified names from being displayed in type hints.\n\nHere's a code snippet that demonstrates how you might implement this:\n\n```python\n# sphinx/util/typing.py\n\nfrom sphinx.config import Config  # Make sure to import Config\n\ndef stringify_annotation(annotation, mode):\n    # ... existing code ...\n\n    # Retrieve the add_module_names setting from the Sphinx configuration\n    config = Config.read()  # You may need to adjust how you access the config\n    add_module_names = config.get('add_module_names', True)\n\n    # Modify the module_prefix based on the add_module_names setting\n    if not add_module_names:\n        module_prefix = ''\n    else:\n        # existing logic to set module_prefix\n        # ...\n\n    # ... existing code that uses module_prefix ...\n```\n\nPlease note that the way you access the Sphinx configuration (`Config.read()`) may vary depending on the context in which `stringify_annotation` is called. You may need to pass the configuration object to this function from the calling context.\n\nThis solution assumes that the `add_module_names` configuration option should globally affect the rendering of module names in type hints. If more granular control is desired, you might need to introduce a new configuration option specifically for type hints, as suggested by the user (e.g., `add_type_module_names`).",
        "bouncer_response": {
            "score": 7,
            "criteria": "RESPONSES that are highly relevant, offering clear and comprehensive guidance or solutions for the described bug, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the issue described in the PROMPT. It suggests modifying the 'stringify_annotation' function in 'sphinx/util/typing.py' to respect the 'add_module_names' configuration option, which is directly related to the problem of fully qualified names appearing in type hints. The RESPONSE includes a code snippet demonstrating how to implement the proposed solution, which is highly relevant and actionable. Additionally, the RESPONSE provides links to code snippets in the Sphinx repository that could be relevant to the issue, which could be useful for further investigation. However, the RESPONSE does not address the alternative solutions mentioned in the PROMPT, such as introducing a new configuration option specifically for type hints, which would have made the RESPONSE more comprehensive.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711702029.368289,
        "result": "Based on the provided information, the issue is that the `add_module_names` configuration option in Sphinx does not affect the rendering of fully qualified names in type hints. The user expects type hints not to show fully qualified names in the generated documentation.\n\nTo address this issue, you can modify the `stringify_annotation` function in `sphinx/util/typing.py` to respect the `add_module_names` configuration option when generating the string representation of type hints. Here's a potential solution:\n\n- Modify the `stringify_annotation` function in `sphinx/util/typing.py` to check the `add_module_names` configuration option and adjust the `module_prefix` accordingly.\n- If `add_module_names` is `False`, set `module_prefix` to an empty string to prevent fully qualified names from being displayed in type hints.\n\nHere's a code snippet that demonstrates how you might implement this:\n\n```python\n# sphinx/util/typing.py\n\nfrom sphinx.config import Config  # Make sure to import Config\n\ndef stringify_annotation(annotation, mode):\n    # ... existing code ...\n\n    # Retrieve the add_module_names setting from the Sphinx configuration\n    config = Config.read()  # You may need to adjust how you access the config\n    add_module_names = config.get('add_module_names', True)\n\n    # Modify the module_prefix based on the add_module_names setting\n    if not add_module_names:\n        module_prefix = ''\n    else:\n        # existing logic to set module_prefix\n        # ...\n\n    # ... existing code that uses module_prefix ...\n```\n\nPlease note that the way you access the Sphinx configuration (`Config.read()`) may vary depending on the context in which `stringify_annotation` is called. You may need to pass the configuration object to this function from the calling context.\n\nThis solution assumes that the `add_module_names` configuration option should globally affect the rendering of module names in type hints. If more granular control is desired, you might need to introduce a new configuration option specifically for type hints, as suggested by the user (e.g., `add_type_module_names`).\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx/util)- [Lines 287 - 344](https://github.com/testbed/sphinx-doc__sphinx__4.4/blob//sphinx/util/typing.py#L287-L344)\n\n This snippet contains logic for handling the stringification of annotations, which is relevant to the issue of type hints being rendered with fully qualified names.\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__4.4/tree//sphinx/util)- [Lines 436 - 522](https://github.com/testbed/sphinx-doc__sphinx__4.4/blob//sphinx/util/inspect.py#L436-L522)\n\n This snippet deals with type aliases and could be relevant when considering how type hints are displayed in the documentation."
    }
}