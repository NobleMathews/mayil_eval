{
    "id": "matplotlib__matplotlib-24604",
    "repo_name": "testbed/matplotlib__matplotlib__3.6",
    "task_id": 6230508638924503071,
    "title": "[ENH]: gridspec_mosaic",
    "body": "### Problem\n\nTrying to combine subplot_mosaic with axes using various different projections (e.g. one rectilinear axes and one polar axes and one 3d axes) has been requested a few times (once in the original subplot_mosaic thread IIRC, and in #20392 too), and it's something I would recently have been happy to have, too.\r\n\r\nPushing projections directly into subplot_mosaic seems ripe for API bloat, but perhaps another solution would be to add `figure.gridspec_mosaic(...)` which takes the same arguments as subplot_mosaic, but returns a dict of *subplotspecs*, such that one can do something like\r\n```\r\nspecs = fig.gridspec_mosaic(...)\r\nd = {\r\n    \"foo\": fig.add_subplot(specs[\"foo\"], projection=...),\r\n    \"bar\": fig.add_subplot(specs[\"bar\"], projection=...),\r\n    ...\r\n}\r\n```\r\nAs a side point, I do find the repetition of `fig` in each call to add_subplot a bit jarring (as the underlying gridspec is bound to the figure, so that information is actually redundant).  Back in #13280 I had proposed to add SubplotSpec.add_subplot() (adding to the figure to which the gridspec is bound), which would allow one to write, here,\r\n```\r\nspecs = fig.gridspec_mosaic(...)\r\nd = {\r\n    \"foo\": specs[\"foo\"].add_subplot(projection=...),\r\n    \"bar\": specs[\"bar\"].add_subplot(projection=...),\r\n    ...\r\n}\r\n```\r\nbut that idea got shot down back then and even if we decide not to revisit it, even the first form would be nice to have.\r\n\r\nThoughts?\n\n### Proposed solution\n\n_No response_\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.6.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature request for `gridspec_mosaic`, you can follow these steps:\n\n- Modify the `Figure` class to include a new method `gridspec_mosaic`.\n- This method should accept the same arguments as `subplot_mosaic` but return a dictionary of `SubplotSpec` instances instead of `Axes` instances.\n- Users can then create `Axes` with different projections by calling `add_subplot` on the `Figure` with the `SubplotSpec` and the desired projection.\n\nHere's a high-level overview of the implementation:\n\n```python\nfrom matplotlib.figure import Figure\nfrom matplotlib.gridspec import GridSpec\n\nclass Figure(Figure):\n    def gridspec_mosaic(self, mosaic, *, gridspec_kw=None, **kwargs):\n        # Create a GridSpec instance\n        mosaic = _make_array(mosaic)\n        rows, cols = mosaic.shape\n        gs = GridSpec(rows, cols, figure=self, **gridspec_kw)\n        \n        # Create a dictionary of SubplotSpecs from the mosaic layout\n        specs = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n        \n        # Return the dictionary of SubplotSpecs\n        return specs\n\n# Usage example\nfig = plt.figure()\nspecs = fig.gridspec_mosaic([\n    [\"foo\", \"bar\"],\n    [\"baz\", \"qux\"],\n])\naxes_dict = {\n    \"foo\": fig.add_subplot(specs[\"foo\"], projection='rectilinear'),\n    \"bar\": fig.add_subplot(specs[\"bar\"], projection='polar'),\n    \"baz\": fig.add_subplot(specs[\"baz\"], projection='3d'),\n    \"qux\": fig.add_subplot(specs[\"qux\"])  # Default projection\n}\n```\n\nIn this example, `_make_array`, `_do_layout`, and `_identify_keys_and_nested` are internal helper functions used by the existing `subplot_mosaic` method to parse the mosaic layout and create the grid. You would need to reuse or adapt these functions for `gridspec_mosaic`.\n\nThis is a high-level overview, and the actual implementation may require more details, such as handling edge cases and integrating with the existing Matplotlib codebase. The `gridspec_kw` argument allows users to pass additional keyword arguments to the `GridSpec` constructor, providing further customization of the grid layout.\n\nFor further research, you may want to look into the following:\n- The `matplotlib.gridspec.GridSpec` class for creating grid layouts.\n- The `matplotlib.figure.Figure.add_subplot` method for adding axes to a figure.\n- The internal implementation of `subplot_mosaic` to understand how to parse and layout the mosaic pattern.\n\n### Code snippets to check\n\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//galleries) \u2192 [users_explain](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//galleries/users_explain) \u2192 [axes](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//galleries/users_explain/axes)- [Lines 1 - 383](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//galleries/users_explain/axes/mosaic.py#L1-L383)\n\n This snippet provides a comprehensive overview of the subplot_mosaic functionality, which is directly related to the issue of combining different projections within a mosaic layout. \n\n\n   - [Lines 213 - 383](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//galleries/users_explain/axes/mosaic.py#L213-L383)\n\n This snippet demonstrates the use of subplot_mosaic with the 'projection' parameter, which is relevant to the issue as it shows how different projections can be applied to subplots within a mosaic.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 2113 - 2130](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/figure.py#L2113-L2130)\n\n This snippet from the figure.py file contains the implementation of subplot_mosaic, which is relevant to the issue as any enhancements or changes to support different projections would likely involve modifications to this function. \n\n\n   - [Lines 1823 - 1826](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/figure.py#L1823-L1826)\n\n This snippet shows the signature of the subplot_mosaic method, which is relevant to the issue as it may need to be modified to support the proposed gridspec_mosaic functionality.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00021999999999999998,
        "snippet_processor": 0.05729,
        "issue_star_creation": 0.01959,
        "issue_star_solver": 0.06142,
        "bouncer": 0.029140000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711697415.4817321,
        "relevant_snippets": [
            {
                "code": "\"\"\"\n.. redirect-from:: /tutorials/provisional/mosaic\n.. redirect-from:: /gallery/subplots_axes_and_figures/mosaic\n\n.. _mosaic:\n\n========================================================\nComplex and semantic figure composition (subplot_mosaic)\n========================================================\n\nLaying out Axes in a Figure in a non-uniform grid can be both tedious\nand verbose.  For dense, even grids we have `.Figure.subplots` but for\nmore complex layouts, such as Axes that span multiple columns / rows\nof the layout or leave some areas of the Figure blank, you can use\n`.gridspec.GridSpec` (see :ref:`arranging_axes`) or\nmanually place your axes.  `.Figure.subplot_mosaic` aims to provide an\ninterface to visually lay out your axes (as either ASCII art or nested\nlists) to streamline this process.\n\nThis interface naturally supports naming your axes.\n`.Figure.subplot_mosaic` returns a dictionary keyed on the\nlabels used to lay out the Figure.  By returning data structures with\nnames, it is easier to write plotting code that is independent of the\nFigure layout.\n\n\nThis is inspired by a `proposed MEP\n<https://github.com/matplotlib/matplotlib/pull/4384>`__ and the\n`patchwork <https://github.com/thomasp85/patchwork>`__ library for R.\nWhile we do not implement the operator overloading style, we do\nprovide a Pythonic API for specifying (nested) Axes layouts.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Helper function used for visualization in the following examples\ndef identify_axes(ax_dict, fontsize=48):\n    \"\"\"\n    Helper to identify the Axes in the examples below.\n\n    Draws the label in a large font in the center of the Axes.\n\n    Parameters\n    ----------\n    ax_dict : dict[str, Axes]\n        Mapping between the title / label and the Axes.\n    fontsize : int, optional\n        How big the label should be.\n    \"\"\"\n    kw = dict(ha=\"center\", va=\"center\", fontsize=fontsize, color=\"darkgrey\")\n    for k, ax in ax_dict.items():\n        ax.text(0.5, 0.5, k, transform=ax.transAxes, **kw)\n\n\n# %%\n# If we want a 2x2 grid we can use `.Figure.subplots` which returns a 2D array\n# of `.axes.Axes` which we can index into to do our plotting.\nnp.random.seed(19680801)\nhist_data = np.random.randn(1_500)\n\n\nfig = plt.figure(layout=\"constrained\")\nax_array = fig.subplots(2, 2, squeeze=False)\n\nax_array[0, 0].bar([\"a\", \"b\", \"c\"], [5, 7, 9])\nax_array[0, 1].plot([1, 2, 3])\nax_array[1, 0].hist(hist_data, bins=\"auto\")\nax_array[1, 1].imshow([[1, 2], [2, 1]])\n\nidentify_axes(\n    {(j, k): a for j, r in enumerate(ax_array) for k, a in enumerate(r)},\n)\n\n# %%\n# Using `.Figure.subplot_mosaic` we can produce the same mosaic but give the\n# axes semantic names\n\nfig = plt.figure(layout=\"constrained\")\nax_dict = fig.subplot_mosaic(\n    [\n        [\"bar\", \"plot\"],\n        [\"hist\", \"image\"],\n    ],\n)\nax_dict[\"bar\"].bar([\"a\", \"b\", \"c\"], [5, 7, 9])\nax_dict[\"plot\"].plot([1, 2, 3])\nax_dict[\"hist\"].hist(hist_data)\nax_dict[\"image\"].imshow([[1, 2], [2, 1]])\nidentify_axes(ax_dict)\n\n# %%",
                "filename": "galleries/users_explain/axes/mosaic.py",
                "start_index": 0,
                "end_index": 2996,
                "start_line": 1,
                "end_line": 383,
                "max_line": 392,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "# A key difference between `.Figure.subplots` and\n# `.Figure.subplot_mosaic` is the return value. While the former\n# returns an array for index access, the latter returns a dictionary\n# mapping the labels to the `.axes.Axes` instances created\n\nprint(ax_dict)\n\n\n# %%\n# String short-hand\n# =================\n#\n# By restricting our axes labels to single characters we can\n# \"draw\" the Axes we want as \"ASCII art\".  The following\n\n\nmosaic = \"\"\"\n    AB\n    CD\n    \"\"\"\n\n# %%\n# will give us 4 Axes laid out in a 2x2 grid and generates the same\n# figure mosaic as above (but now labeled with ``{\"A\", \"B\", \"C\",\n# \"D\"}`` rather than ``{\"bar\", \"plot\", \"hist\", \"image\"}``).\n\nfig = plt.figure(layout=\"constrained\")\nax_dict = fig.subplot_mosaic(mosaic)\nidentify_axes(ax_dict)\n\n# %%\n# Alternatively, you can use the more compact string notation\nmosaic = \"AB;CD\"\n\n# %%\n# will give you the same composition, where the ``\";\"`` is used\n# as the row separator instead of newline.\n\nfig = plt.figure(layout=\"constrained\")\nax_dict = fig.subplot_mosaic(mosaic)\nidentify_axes(ax_dict)\n\n# %%\n# Axes spanning multiple rows/columns\n# ===================================\n#\n# Something we can do with `.Figure.subplot_mosaic`, that we cannot\n# do with `.Figure.subplots`, is to specify that an Axes should span\n# several rows or columns.\n\n\n# %%\n# If we want to re-arrange our four Axes to have ``\"C\"`` be a horizontal\n# span on the bottom and ``\"D\"`` be a vertical span on the right we would do\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"\"\"\n    ABD\n    CCD\n    \"\"\"\n)\nidentify_axes(axd)\n\n# %%\n# If we do not want to fill in all the spaces in the Figure with Axes,\n# we can specify some spaces in the grid to be blank\n\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"\"\"\n    A.C\n    BBB\n    .D.\n    \"\"\"\n)\nidentify_axes(axd)\n\n\n# %%\n# If we prefer to use another character (rather than a period ``\".\"``)\n# to mark the empty space, we can use *empty_sentinel* to specify the\n# character to use.\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"\"\"\n    aX\n    Xb\n    \"\"\",\n    empty_sentinel=\"X\",\n)\nidentify_axes(axd)\n\n\n# %%\n#\n# Internally there is no meaning attached to the letters we use, any\n# Unicode code point is valid!\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"\"\"\u03b1\u0431\n       \u211d\u2622\"\"\"\n)\nidentify_axes(axd)\n\n# %%\n# It is not recommended to use white space as either a label or an\n# empty sentinel with the string shorthand because it may be stripped\n# while processing the input.\n#\n# Controlling mosaic creation\n# ===========================\n#\n# This feature is built on top of `.gridspec` and you can pass the\n# keyword arguments through to the underlying `.gridspec.GridSpec`\n# (the same as `.Figure.subplots`).\n#\n# In this case we want to use the input to specify the arrangement,\n# but set the relative widths of the rows / columns.  For convenience,\n# `.gridspec.GridSpec`'s *height_ratios* and *width_ratios* are exposed in the\n# `.F",
                "filename": "galleries/users_explain/axes/mosaic.py",
                "start_index": 2997,
                "end_index": 5960,
                "start_line": 94,
                "end_line": 213,
                "max_line": 392,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "mosaic = _make_array(mosaic)\n        rows, cols = mosaic.shape\n        gs = self.add_gridspec(rows, cols, **gridspec_kw)\n        ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n        ax0 = next(iter(ret.values()))\n        for ax in ret.values():\n            if sharex:\n                ax.sharex(ax0)\n                ax._label_outer_xaxis(skip_non_rectangular_axes=True)\n            if sharey:\n                ax.sharey(ax0)\n                ax._label_outer_yaxis(skip_non_rectangular_axes=True)\n        if extra := set(per_subplot_kw) - set(ret):\n            raise ValueError(\n                f\"The keys {extra} are in *per_subplot_kw* \"\n                \"but not in the mosaic.\"\n            )\n        return ret",
                "filename": "lib/matplotlib/figure.py",
                "start_index": 80570,
                "end_index": 81299,
                "start_line": 2113,
                "end_line": 2130,
                "max_line": 3625,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "igure.subplot_mosaic` calling sequence.\n\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"\"\"\n    .a.\n    bAc\n    .d.\n    \"\"\",\n    # set the height ratios between the rows\n    height_ratios=[1, 3.5, 1],\n    # set the width ratios between the columns\n    width_ratios=[1, 3.5, 1],\n)\nidentify_axes(axd)\n\n# %%\n# Other `.gridspec.GridSpec` keywords can be passed via *gridspec_kw*.  For\n# example, use the {*left*, *right*, *bottom*, *top*} keyword arguments to\n# position the overall mosaic to put multiple versions of the same\n# mosaic in a figure.\n\nmosaic = \"\"\"AA\n            BC\"\"\"\nfig = plt.figure()\naxd = fig.subplot_mosaic(\n    mosaic,\n    gridspec_kw={\n        \"bottom\": 0.25,\n        \"top\": 0.95,\n        \"left\": 0.1,\n        \"right\": 0.5,\n        \"wspace\": 0.5,\n        \"hspace\": 0.5,\n    },\n)\nidentify_axes(axd)\n\naxd = fig.subplot_mosaic(\n    mosaic,\n    gridspec_kw={\n        \"bottom\": 0.05,\n        \"top\": 0.75,\n        \"left\": 0.6,\n        \"right\": 0.95,\n        \"wspace\": 0.5,\n        \"hspace\": 0.5,\n    },\n)\nidentify_axes(axd)\n\n# %%\n# Alternatively, you can use the sub-Figure functionality:\n\nmosaic = \"\"\"AA\n            BC\"\"\"\nfig = plt.figure(layout=\"constrained\")\nleft, right = fig.subfigures(nrows=1, ncols=2)\naxd = left.subplot_mosaic(mosaic)\nidentify_axes(axd)\n\naxd = right.subplot_mosaic(mosaic)\nidentify_axes(axd)\n\n\n# %%\n# Controlling subplot creation\n# ============================\n#\n# We can also pass through arguments used to create the subplots\n# (again, the same as `.Figure.subplots`) which will apply to all\n# of the Axes created.\n\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"AB\", subplot_kw={\"projection\": \"polar\"}\n)\nidentify_axes(axd)\n\n# %%\n# Per-Axes subplot keyword arguments\n# ----------------------------------\n#\n# If you need to control the parameters passed to each subplot individually use\n# *per_subplot_kw* to pass a mapping between the Axes identifiers (or\n# tuples of Axes identifiers) to dictionaries of keywords to be passed.\n#\n# .. versionadded:: 3.7\n#\n\n\nfig, axd = plt.subplot_mosaic(\n    \"AB;CD\",\n    per_subplot_kw={\n        \"A\": {\"projection\": \"polar\"},\n        (\"C\", \"D\"): {\"xscale\": \"log\"}\n    },\n)\nidentify_axes(axd)\n\n# %%\n# If the layout is specified with the string short-hand, then we know the\n# Axes labels will be one character and can unambiguously interpret longer\n# strings in *per_subplot_kw* to specify a set of Axes to apply the\n# keywords to:\n\n\nfig, axd = plt.subplot_mosaic(\n    \"AB;CD\",\n    per_subplot_kw={\n        \"AD\": {\"projection\": \"polar\"},\n        \"BC\": {\"facecolor\": \".9\"}\n    },\n)\nidentify_axes(axd)\n\n# %%\n# If *subplot_kw* and *per_subplot_kw* are used together, then they are\n# merged with *per_subplot_kw* taking priority:\n\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"AB;CD\",\n    subplot_kw={\"facecolor\": \"xkcd:tangerine\"},\n    per_subplot_kw={\n        \"B\": {\"facecolor\": \"xkcd:water blue\"},\n        \"D\": {\"projection\": \"polar\", \"facecolor\": \"w\"},\n    }\n)\nidentify_axes(axd)\n\n\n# %",
                "filename": "galleries/users_explain/axes/mosaic.py",
                "start_index": 5960,
                "end_index": 8959,
                "start_line": 213,
                "end_line": 383,
                "max_line": 392,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "# `~.pyplot.subplot_mosaic` as the *gridspec_kw* argument.\n\nfig = plt.figure(layout=None, facecolor='lightblue')\ngs = fig.add_gridspec(nrows=3, ncols=3, left=0.05, right=0.75,\n                      hspace=0.1, wspace=0.05)\nax0 = fig.add_subplot(gs[:-1, :])\nannotate_axes(ax0, 'ax0')\nax1 = fig.add_subplot(gs[-1, :-1])\nannotate_axes(ax1, 'ax1')\nax2 = fig.add_subplot(gs[-1, -1])\nannotate_axes(ax2, 'ax2')\nfig.suptitle('Manual gridspec with right=0.75')\n\n# %%\n# Nested layouts with SubplotSpec\n# -------------------------------\n#\n# You can create nested layout similar to `~.Figure.subfigures` using\n# `~.gridspec.SubplotSpec.subgridspec`.  Here the Axes spines *are*\n# aligned.\n#\n# Note this is also available from the more verbose\n# `.gridspec.GridSpecFromSubplotSpec`.\n\nfig = plt.figure(layout=\"constrained\")\ngs0 = fig.add_gridspec(1, 2)\n\ngs00 = gs0[0].subgridspec(2, 2)\ngs01 = gs0[1].subgridspec(3, 1)\n\nfor a in range(2):\n    for b in range(2):\n        ax = fig.add_subplot(gs00[a, b])\n        annotate_axes(ax, f'axLeft[{a}, {b}]', fontsize=10)\n        if a == 1 and b == 1:\n            ax.set_xlabel('xlabel')\nfor a in range(3):\n    ax = fig.add_subplot(gs01[a])\n    annotate_axes(ax, f'axRight[{a}, {b}]')\n    if a == 2:\n        ax.set_ylabel('ylabel')\n\nfig.suptitle('nested gridspecs')\n\n# %%\n# Here's a more sophisticated example of nested *GridSpec*: We create an outer\n# 4x4 grid with each cell containing an inner 3x3 grid of Axes. We outline\n# the outer 4x4 grid by hiding appropriate spines in each of the inner 3x3\n# grids.\n\n\ndef squiggle_xy(a, b, c, d, i=np.arange(0.0, 2*np.pi, 0.05)):\n    return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d)\n\nfig = plt.figure(figsize=(8, 8), layout='constrained')\nouter_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0)\n\nfor a in range(4):\n    for b in range(4):\n        # gridspec inside gridspec\n        inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0)\n        axs = inner_grid.subplots()  # Create all subplots for the inner grid.\n        for (c, d), ax in np.ndenumerate(axs):\n            ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1))\n            ax.set(xticks=[], yticks=[])\n\n# show only the outside spines\nfor ax in fig.get_axes():\n    ss = ax.get_subplotspec()\n    ax.spines.top.set_visible(ss.is_first_row())\n    ax.spines.bottom.set_visible(ss.is_last_row())\n    ax.spines.left.set_visible(ss.is_first_col())\n    ax.spines.right.set_visible(ss.is_last_col())\n\nplt.show()\n\n# %%\n#\n# More reading\n# ============\n#\n# - More details about :ref:`subplot mosaic <mosaic>`.\n# - More details about :ref:`constrained layout\n#   <constrainedlayout_guide>`, used to align\n#   spacing in most of these examples.\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.pyplot.subplot_mosaic`\n#    - `matplotlib.figure.Figure.add_gridspec`\n#    - `matplotlib.figure.Figure.add_subplot`",
                "filename": "galleries/users_explain/axes/arranging_axes.py",
                "start_index": 12141,
                "end_index": 15130,
                "start_line": 339,
                "end_line": 433,
                "max_line": 436,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n.. redirect-from:: /tutorials/intermediate/gridspec\n.. redirect-from:: /tutorials/intermediate/arranging_axes\n\n.. _arranging_axes:\n\n===================================\nArranging multiple Axes in a Figure\n===================================\n\nOften more than one Axes is wanted on a figure at a time, usually\norganized into a regular grid.  Matplotlib has a variety of tools for\nworking with grids of Axes that have evolved over the history of the library.\nHere we will discuss the tools we think users should use most often, the tools\nthat underpin how Axes are organized, and mention some of the older tools.\n\n.. note::\n\n    Matplotlib uses *Axes* to refer to the drawing area that contains\n    data, x- and y-axis, ticks, labels, title, etc. See :ref:`figure_parts`\n    for more details.  Another term that is often used is \"subplot\", which\n    refers to an Axes that is in a grid with other Axes objects.\n\nOverview\n========\n\nCreate grid-shaped combinations of Axes\n---------------------------------------\n\n`~matplotlib.pyplot.subplots`\n    The primary function used to create figures and a grid of Axes.  It\n    creates and places all Axes on the figure at once, and returns an\n    object array with handles for the Axes in the grid.  See\n    `.Figure.subplots`.\n\nor\n\n`~matplotlib.pyplot.subplot_mosaic`\n    A simple way to create figures and a grid of Axes, with the added\n    flexibility that Axes can also span rows or columns. The Axes are returned\n    in a labelled dictionary instead of an array.  See also\n    `.Figure.subplot_mosaic` and\n    :ref:`mosaic`.\n\nSometimes it is natural to have more than one distinct group of Axes grids,\nin which case Matplotlib has the concept of `.SubFigure`:\n\n`~matplotlib.figure.SubFigure`\n    A virtual figure within a figure.\n\nUnderlying tools\n----------------\n\nUnderlying these are the concept of a `~.gridspec.GridSpec` and\na `~.SubplotSpec`:\n\n`~matplotlib.gridspec.GridSpec`\n    Specifies the geometry of the grid that a subplot will be\n    placed. The number of rows and number of columns of the grid\n    need to be set. Optionally, the subplot layout parameters\n    (e.g., left, right, etc.) can be tuned.\n\n`~matplotlib.gridspec.SubplotSpec`\n    Specifies the location of the subplot in the given `.GridSpec`.\n\n.. _fixed_size_axes:\n\nAdding single Axes at a time\n----------------------------\n\nThe above functions create all Axes in a single function call.  It is also\npossible to add Axes one at a time, and this was originally how Matplotlib\nused to work.  Doing so is generally less elegant and flexible, though\nsometimes useful for interactive work or to place an Axes in a custom\nlocation:\n\n`~matplotlib.figure.Figure.add_axes`\n    Adds a single axes at a location specified by\n    ``[left, bottom, width, height]`` in fractions of figure width or height.\n\n`~matplotlib.pyplot.subplot` or `.Figure.add_subplot`\n    Adds a single subplot on a figure, with 1-based indexing (inherited from\n    Matlab).  Columns and rows can be spanned by specifying a range of grid\n    cells.\n\n`~matplotlib.pyplot.subplot2grid`\n    Similar to `.pyplot.subplot`, but uses 0-based indexing and two-d python\n    slicing to choose cells.\n\n\"\"\"",
                "filename": "galleries/users_explain/axes/arranging_axes.py",
                "start_index": 0,
                "end_index": 3178,
                "start_line": 1,
                "end_line": 90,
                "max_line": 436,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "#    - `matplotlib.gridspec.GridSpec`\n#    - `matplotlib.gridspec.SubplotSpec.subgridspec`\n#    - `matplotlib.gridspec.GridSpecFromSubplotSpec`",
                "filename": "galleries/users_explain/axes/arranging_axes.py",
                "start_index": 15131,
                "end_index": 15274,
                "start_line": 434,
                "end_line": 436,
                "max_line": 436,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,\n                       width_ratios=None, height_ratios=None,\n                       empty_sentinel='.',\n                       subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):",
                "filename": "lib/matplotlib/figure.py",
                "start_index": 68104,
                "end_index": 68352,
                "start_line": 1823,
                "end_line": 1826,
                "max_line": 3625,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "fig = figure(**fig_kw)\n    ax_dict = fig.subplot_mosaic(\n        mosaic, sharex=sharex, sharey=sharey,\n        height_ratios=height_ratios, width_ratios=width_ratios,\n        subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,\n        empty_sentinel=empty_sentinel,\n        per_subplot_kw=per_subplot_kw,\n    )\n    return fig, ax_dict",
                "filename": "lib/matplotlib/pyplot.py",
                "start_index": 60800,
                "end_index": 61130,
                "start_line": 1595,
                "end_line": 1724,
                "max_line": 4320,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "axs1 = subfigs[1].subplots(3, 1)\nsubfigs[1].suptitle('subfigs[1]')\nsubfigs[1].supylabel('ylabel for subfigs[1]')\n\n# %%\n# It is also possible to nest Axes using `~.pyplot.subplot_mosaic` using\n# nested lists.  This method does not use subfigures, like above, so lacks\n# the ability to add per-subfigure ``suptitle`` and ``supxlabel``, etc.\n# Rather it is a convenience wrapper around the `~.SubplotSpec.subgridspec`\n# method described below.\n\ninner = [['innerA'],\n         ['innerB']]\nouter = [['upper left',  inner],\n          ['lower left', 'lower right']]\n\nfig, axd = plt.subplot_mosaic(outer, layout=\"constrained\")\nfor k in axd:\n    annotate_axes(axd[k], f'axd[\"{k}\"]')\n\n# %%\n# Low-level and advanced grid methods\n# ===================================\n#\n# Internally, the arrangement of a grid of Axes is controlled by creating\n# instances of `~.GridSpec` and `~.SubplotSpec`. *GridSpec* defines a\n# (possibly non-uniform) grid of cells. Indexing into the *GridSpec* returns\n# a SubplotSpec that covers one or more grid cells, and can be used to\n# specify the location of an Axes.\n#\n# The following examples show how to use low-level methods to arrange Axes\n# using *GridSpec* objects.\n#\n# Basic 2x2 grid\n# --------------\n#\n# We can accomplish a 2x2 grid in the same manner as\n# ``plt.subplots(2, 2)``:\n\nfig = plt.figure(figsize=(5.5, 3.5), layout=\"constrained\")\nspec = fig.add_gridspec(ncols=2, nrows=2)\n\nax0 = fig.add_subplot(spec[0, 0])\nannotate_axes(ax0, 'ax0')\n\nax1 = fig.add_subplot(spec[0, 1])\nannotate_axes(ax1, 'ax1')\n\nax2 = fig.add_subplot(spec[1, 0])\nannotate_axes(ax2, 'ax2')\n\nax3 = fig.add_subplot(spec[1, 1])\nannotate_axes(ax3, 'ax3')\n\nfig.suptitle('Manually added subplots using add_gridspec')\n\n# %%\n# Axes spanning rows or grids in a grid\n# -------------------------------------\n#\n# We can index the *spec* array using `NumPy slice syntax\n# <https://numpy.org/doc/stable/reference/arrays.indexing.html>`_\n# and the new Axes will span the slice.  This would be the same\n# as ``fig, axd = plt.subplot_mosaic([['ax0', 'ax0'], ['ax1', 'ax2']], ...)``:\n\nfig = plt.figure(figsize=(5.5, 3.5), layout=\"constrained\")\nspec = fig.add_gridspec(2, 2)\n\nax0 = fig.add_subplot(spec[0, :])\nannotate_axes(ax0, 'ax0')\n\nax10 = fig.add_subplot(spec[1, 0])\nannotate_axes(ax10, 'ax10')\n\nax11 = fig.add_subplot(spec[1, 1])\nannotate_axes(ax11, 'ax11')\n\nfig.suptitle('Manually added subplots, spanning a column')\n\n# %%\n# Manual adjustments to a *GridSpec* layout\n# -----------------------------------------\n#\n# When a  *GridSpec* is explicitly used, you can adjust the layout\n# parameters of subplots that are created from the  *GridSpec*.  Note this\n# option is not compatible with *constrained layout* or\n# `.Figure.tight_layout` which both ignore *left* and *right* and adjust\n# subplot sizes to fill the figure.  Usually such manual placement\n# requires iterations to make the Axes tick labels not overlap the Axes.\n#\n# These spacing parameters can also be passed to `~.pyplot.subplots` and",
                "filename": "galleries/users_explain/axes/arranging_axes.py",
                "start_index": 9153,
                "end_index": 12140,
                "start_line": 248,
                "end_line": 338,
                "max_line": 436,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "galleries/users_explain/axes/mosaic.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\n.. redirect-from:: /tutorials/provisional/mosaic\n.. redirect-from:: /gallery/subplots_axes_and_figures/mosaic\n\n.. _mosaic:\n\n========================================================\nComplex and semantic figure composition (subplot_mosaic)\n========================================================\n\nLaying out Axes in a Figure in a non-uniform grid can be both tedious\nand verbose.  For dense, even grids we have `.Figure.subplots` but for\nmore complex layouts, such as Axes that span multiple columns / rows\nof the layout or leave some areas of the Figure blank, you can use\n`.gridspec.GridSpec` (see :ref:`arranging_axes`) or\nmanually place your axes.  `.Figure.subplot_mosaic` aims to provide an\ninterface to visually lay out your axes (as either ASCII art or nested\nlists) to streamline this process.\n\nThis interface naturally supports naming your axes.\n`.Figure.subplot_mosaic` returns a dictionary keyed on the\nlabels used to lay out the Figure.  By returning data structures with\nnames, it is easier to write plotting code that is independent of the\nFigure layout.\n\n\nThis is inspired by a `proposed MEP\n<https://github.com/matplotlib/matplotlib/pull/4384>`__ and the\n`patchwork <https://github.com/thomasp85/patchwork>`__ library for R.\nWhile we do not implement the operator overloading style, we do\nprovide a Pythonic API for specifying (nested) Axes layouts.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Helper function used for visualization in the following examples\ndef identify_axes(ax_dict, fontsize=48):\n    \"\"\"\n    Helper to identify the Axes in the examples below.\n\n    Draws the label in a large font in the center of the Axes.\n\n    Parameters\n    ----------\n    ax_dict : dict[str, Axes]\n        Mapping between the title / label and the Axes.\n    fontsize : int, optional\n        How big the label should be.\n    \"\"\"\n    kw = dict(ha=\"center\", va=\"center\", fontsize=fontsize, color=\"darkgrey\")\n    for k, ax in ax_dict.items():\n        ax.text(0.5, 0.5, k, transform=ax.transAxes, **kw)\n\n\n# %%\n# If we want a 2x2 grid we can use `.Figure.subplots` which returns a 2D array\n# of `.axes.Axes` which we can index into to do our plotting.\nnp.random.seed(19680801)\nhist_data = np.random.randn(1_500)\n\n\nfig = plt.figure(layout=\"constrained\")\nax_array = fig.subplots(2, 2, squeeze=False)\n\nax_array[0, 0].bar([\"a\", \"b\", \"c\"], [5, 7, 9])\nax_array[0, 1].plot([1, 2, 3])\nax_array[1, 0].hist(hist_data, bins=\"auto\")\nax_array[1, 1].imshow([[1, 2], [2, 1]])\n\nidentify_axes(\n    {(j, k): a for j, r in enumerate(ax_array) for k, a in enumerate(r)},\n)\n\n# %%\n# Using `.Figure.subplot_mosaic` we can produce the same mosaic but give the\n# axes semantic names\n\nfig = plt.figure(layout=\"constrained\")\nax_dict = fig.subplot_mosaic(\n    [\n        [\"bar\", \"plot\"],\n        [\"hist\", \"image\"],\n    ],\n)\nax_dict[\"bar\"].bar([\"a\", \"b\", \"c\"], [5, 7, 9])\nax_dict[\"plot\"].plot([1, 2, 3])\nax_dict[\"hist\"].hist(hist_data)\nax_dict[\"image\"].imshow([[1, 2], [2, 1]])\nidentify_axes(ax_dict)\n\n# %%",
                        "filename": "galleries/users_explain/axes/mosaic.py",
                        "start_index": 0,
                        "end_index": 2996,
                        "start_line": 1,
                        "end_line": 383,
                        "max_line": 392,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet provides a comprehensive overview of the subplot_mosaic functionality, which is directly related to the issue of combining different projections within a mosaic layout."
                },
                {
                    "chunk": {
                        "code": "igure.subplot_mosaic` calling sequence.\n\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"\"\"\n    .a.\n    bAc\n    .d.\n    \"\"\",\n    # set the height ratios between the rows\n    height_ratios=[1, 3.5, 1],\n    # set the width ratios between the columns\n    width_ratios=[1, 3.5, 1],\n)\nidentify_axes(axd)\n\n# %%\n# Other `.gridspec.GridSpec` keywords can be passed via *gridspec_kw*.  For\n# example, use the {*left*, *right*, *bottom*, *top*} keyword arguments to\n# position the overall mosaic to put multiple versions of the same\n# mosaic in a figure.\n\nmosaic = \"\"\"AA\n            BC\"\"\"\nfig = plt.figure()\naxd = fig.subplot_mosaic(\n    mosaic,\n    gridspec_kw={\n        \"bottom\": 0.25,\n        \"top\": 0.95,\n        \"left\": 0.1,\n        \"right\": 0.5,\n        \"wspace\": 0.5,\n        \"hspace\": 0.5,\n    },\n)\nidentify_axes(axd)\n\naxd = fig.subplot_mosaic(\n    mosaic,\n    gridspec_kw={\n        \"bottom\": 0.05,\n        \"top\": 0.75,\n        \"left\": 0.6,\n        \"right\": 0.95,\n        \"wspace\": 0.5,\n        \"hspace\": 0.5,\n    },\n)\nidentify_axes(axd)\n\n# %%\n# Alternatively, you can use the sub-Figure functionality:\n\nmosaic = \"\"\"AA\n            BC\"\"\"\nfig = plt.figure(layout=\"constrained\")\nleft, right = fig.subfigures(nrows=1, ncols=2)\naxd = left.subplot_mosaic(mosaic)\nidentify_axes(axd)\n\naxd = right.subplot_mosaic(mosaic)\nidentify_axes(axd)\n\n\n# %%\n# Controlling subplot creation\n# ============================\n#\n# We can also pass through arguments used to create the subplots\n# (again, the same as `.Figure.subplots`) which will apply to all\n# of the Axes created.\n\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"AB\", subplot_kw={\"projection\": \"polar\"}\n)\nidentify_axes(axd)\n\n# %%\n# Per-Axes subplot keyword arguments\n# ----------------------------------\n#\n# If you need to control the parameters passed to each subplot individually use\n# *per_subplot_kw* to pass a mapping between the Axes identifiers (or\n# tuples of Axes identifiers) to dictionaries of keywords to be passed.\n#\n# .. versionadded:: 3.7\n#\n\n\nfig, axd = plt.subplot_mosaic(\n    \"AB;CD\",\n    per_subplot_kw={\n        \"A\": {\"projection\": \"polar\"},\n        (\"C\", \"D\"): {\"xscale\": \"log\"}\n    },\n)\nidentify_axes(axd)\n\n# %%\n# If the layout is specified with the string short-hand, then we know the\n# Axes labels will be one character and can unambiguously interpret longer\n# strings in *per_subplot_kw* to specify a set of Axes to apply the\n# keywords to:\n\n\nfig, axd = plt.subplot_mosaic(\n    \"AB;CD\",\n    per_subplot_kw={\n        \"AD\": {\"projection\": \"polar\"},\n        \"BC\": {\"facecolor\": \".9\"}\n    },\n)\nidentify_axes(axd)\n\n# %%\n# If *subplot_kw* and *per_subplot_kw* are used together, then they are\n# merged with *per_subplot_kw* taking priority:\n\n\naxd = plt.figure(layout=\"constrained\").subplot_mosaic(\n    \"AB;CD\",\n    subplot_kw={\"facecolor\": \"xkcd:tangerine\"},\n    per_subplot_kw={\n        \"B\": {\"facecolor\": \"xkcd:water blue\"},\n        \"D\": {\"projection\": \"polar\", \"facecolor\": \"w\"},\n    }\n)\nidentify_axes(axd)\n\n\n# %",
                        "filename": "galleries/users_explain/axes/mosaic.py",
                        "start_index": 5960,
                        "end_index": 8959,
                        "start_line": 213,
                        "end_line": 383,
                        "max_line": 392,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet demonstrates the use of subplot_mosaic with the 'projection' parameter, which is relevant to the issue as it shows how different projections can be applied to subplots within a mosaic."
                }
            ],
            "lib/matplotlib/figure.py": [
                {
                    "chunk": {
                        "code": "mosaic = _make_array(mosaic)\n        rows, cols = mosaic.shape\n        gs = self.add_gridspec(rows, cols, **gridspec_kw)\n        ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n        ax0 = next(iter(ret.values()))\n        for ax in ret.values():\n            if sharex:\n                ax.sharex(ax0)\n                ax._label_outer_xaxis(skip_non_rectangular_axes=True)\n            if sharey:\n                ax.sharey(ax0)\n                ax._label_outer_yaxis(skip_non_rectangular_axes=True)\n        if extra := set(per_subplot_kw) - set(ret):\n            raise ValueError(\n                f\"The keys {extra} are in *per_subplot_kw* \"\n                \"but not in the mosaic.\"\n            )\n        return ret",
                        "filename": "lib/matplotlib/figure.py",
                        "start_index": 80570,
                        "end_index": 81299,
                        "start_line": 2113,
                        "end_line": 2130,
                        "max_line": 3625,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from the figure.py file contains the implementation of subplot_mosaic, which is relevant to the issue as any enhancements or changes to support different projections would likely involve modifications to this function."
                },
                {
                    "chunk": {
                        "code": "def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,\n                       width_ratios=None, height_ratios=None,\n                       empty_sentinel='.',\n                       subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):",
                        "filename": "lib/matplotlib/figure.py",
                        "start_index": 68104,
                        "end_index": 68352,
                        "start_line": 1823,
                        "end_line": 1826,
                        "max_line": 3625,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the signature of the subplot_mosaic method, which is relevant to the issue as it may need to be modified to support the proposed gridspec_mosaic functionality."
                }
            ]
        },
        "solution_task": "To implement the feature request for `gridspec_mosaic`, you can follow these steps:\n\n- Modify the `Figure` class to include a new method `gridspec_mosaic`.\n- This method should accept the same arguments as `subplot_mosaic` but return a dictionary of `SubplotSpec` instances instead of `Axes` instances.\n- Users can then create `Axes` with different projections by calling `add_subplot` on the `Figure` with the `SubplotSpec` and the desired projection.\n\nHere's a high-level overview of the implementation:\n\n```python\nfrom matplotlib.figure import Figure\nfrom matplotlib.gridspec import GridSpec\n\nclass Figure(Figure):\n    def gridspec_mosaic(self, mosaic, *, gridspec_kw=None, **kwargs):\n        # Create a GridSpec instance\n        mosaic = _make_array(mosaic)\n        rows, cols = mosaic.shape\n        gs = GridSpec(rows, cols, figure=self, **gridspec_kw)\n        \n        # Create a dictionary of SubplotSpecs from the mosaic layout\n        specs = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n        \n        # Return the dictionary of SubplotSpecs\n        return specs\n\n# Usage example\nfig = plt.figure()\nspecs = fig.gridspec_mosaic([\n    [\"foo\", \"bar\"],\n    [\"baz\", \"qux\"],\n])\naxes_dict = {\n    \"foo\": fig.add_subplot(specs[\"foo\"], projection='rectilinear'),\n    \"bar\": fig.add_subplot(specs[\"bar\"], projection='polar'),\n    \"baz\": fig.add_subplot(specs[\"baz\"], projection='3d'),\n    \"qux\": fig.add_subplot(specs[\"qux\"])  # Default projection\n}\n```\n\nIn this example, `_make_array`, `_do_layout`, and `_identify_keys_and_nested` are internal helper functions used by the existing `subplot_mosaic` method to parse the mosaic layout and create the grid. You would need to reuse or adapt these functions for `gridspec_mosaic`.\n\nThis is a high-level overview, and the actual implementation may require more details, such as handling edge cases and integrating with the existing Matplotlib codebase. The `gridspec_kw` argument allows users to pass additional keyword arguments to the `GridSpec` constructor, providing further customization of the grid layout.\n\nFor further research, you may want to look into the following:\n- The `matplotlib.gridspec.GridSpec` class for creating grid layouts.\n- The `matplotlib.figure.Figure.add_subplot` method for adding axes to a figure.\n- The internal implementation of `subplot_mosaic` to understand how to parse and layout the mosaic pattern.",
        "bouncer_response": {
            "score": 7,
            "criteria": "RESPONSES that are highly relevant, offering clear and comprehensive suggestions or solutions for the described feature request, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a clear and comprehensive suggestion for implementing the `gridspec_mosaic` feature. It outlines a step-by-step approach to modify the `Figure` class, create a new method, and use it to return a dictionary of `SubplotSpec` instances. The RESPONSE also includes a high-level overview of the implementation with a code example, which is directly relevant to the feature request. Additionally, the RESPONSE provides further research directions and relevant code snippets to check, which are useful for understanding the current implementation and for guiding the development of the new feature. However, the RESPONSE does not address the side point mentioned in the PROMPT about the repetition of `fig` in each call to `add_subplot` and the previously proposed idea of `SubplotSpec.add_subplot()`. This omission prevents the RESPONSE from scoring higher, as it does not address all aspects of the feature request.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711697503.017833,
        "result": "To implement the feature request for `gridspec_mosaic`, you can follow these steps:\n\n- Modify the `Figure` class to include a new method `gridspec_mosaic`.\n- This method should accept the same arguments as `subplot_mosaic` but return a dictionary of `SubplotSpec` instances instead of `Axes` instances.\n- Users can then create `Axes` with different projections by calling `add_subplot` on the `Figure` with the `SubplotSpec` and the desired projection.\n\nHere's a high-level overview of the implementation:\n\n```python\nfrom matplotlib.figure import Figure\nfrom matplotlib.gridspec import GridSpec\n\nclass Figure(Figure):\n    def gridspec_mosaic(self, mosaic, *, gridspec_kw=None, **kwargs):\n        # Create a GridSpec instance\n        mosaic = _make_array(mosaic)\n        rows, cols = mosaic.shape\n        gs = GridSpec(rows, cols, figure=self, **gridspec_kw)\n        \n        # Create a dictionary of SubplotSpecs from the mosaic layout\n        specs = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n        \n        # Return the dictionary of SubplotSpecs\n        return specs\n\n# Usage example\nfig = plt.figure()\nspecs = fig.gridspec_mosaic([\n    [\"foo\", \"bar\"],\n    [\"baz\", \"qux\"],\n])\naxes_dict = {\n    \"foo\": fig.add_subplot(specs[\"foo\"], projection='rectilinear'),\n    \"bar\": fig.add_subplot(specs[\"bar\"], projection='polar'),\n    \"baz\": fig.add_subplot(specs[\"baz\"], projection='3d'),\n    \"qux\": fig.add_subplot(specs[\"qux\"])  # Default projection\n}\n```\n\nIn this example, `_make_array`, `_do_layout`, and `_identify_keys_and_nested` are internal helper functions used by the existing `subplot_mosaic` method to parse the mosaic layout and create the grid. You would need to reuse or adapt these functions for `gridspec_mosaic`.\n\nThis is a high-level overview, and the actual implementation may require more details, such as handling edge cases and integrating with the existing Matplotlib codebase. The `gridspec_kw` argument allows users to pass additional keyword arguments to the `GridSpec` constructor, providing further customization of the grid layout.\n\nFor further research, you may want to look into the following:\n- The `matplotlib.gridspec.GridSpec` class for creating grid layouts.\n- The `matplotlib.figure.Figure.add_subplot` method for adding axes to a figure.\n- The internal implementation of `subplot_mosaic` to understand how to parse and layout the mosaic pattern.\n\n### Code snippets to check\n\n-  \u2192 [galleries](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//galleries) \u2192 [users_explain](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//galleries/users_explain) \u2192 [axes](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//galleries/users_explain/axes)- [Lines 1 - 383](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//galleries/users_explain/axes/mosaic.py#L1-L383)\n\n This snippet provides a comprehensive overview of the subplot_mosaic functionality, which is directly related to the issue of combining different projections within a mosaic layout. \n\n\n   - [Lines 213 - 383](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//galleries/users_explain/axes/mosaic.py#L213-L383)\n\n This snippet demonstrates the use of subplot_mosaic with the 'projection' parameter, which is relevant to the issue as it shows how different projections can be applied to subplots within a mosaic.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 2113 - 2130](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/figure.py#L2113-L2130)\n\n This snippet from the figure.py file contains the implementation of subplot_mosaic, which is relevant to the issue as any enhancements or changes to support different projections would likely involve modifications to this function. \n\n\n   - [Lines 1823 - 1826](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/figure.py#L1823-L1826)\n\n This snippet shows the signature of the subplot_mosaic method, which is relevant to the issue as it may need to be modified to support the proposed gridspec_mosaic functionality."
    }
}