{
    "id": "pylint-dev__pylint-6196",
    "repo_name": "testbed/pylint-dev__pylint__2.14",
    "task_id": 1791322875737894949,
    "title": "Use, misuse and confusion of ``@check_messages`` decorator",
    "body": "### Current problem\n\nThe work on #5953 showed that specifically enabling just a single message is sometimes not working as expected.\r\nThis is due to either missing message declaration in a checkers ``msgs`` attribute or the incorrect usage of the ``@check_messages`` decorator.\r\nIdeally I would like to implement a new, optional checker aimed at Pylint core development and custom checker development.\r\nThis checker would focus on correct message declaration and handling. \r\nI already started working on it, but noticed that there is especially quite some problems with the ``@check_messages`` decorator. I totally understand that, because while being extensively used across all checker classes, there is not a single word on its purpose and effect in the documentation. Its docstring is also not really helpful, you have to dig deeper into the codebase to understand what it does.\n\n### Desired solution\n\nBefore continuing my work on the new checker, I want to address and clarify some questions about the intended use of ``@check_messages``. \r\nAfter that this issue can be closed with a PR that extends the documentation, and if necessary some code changes.\r\n\r\nA brief explanation on what ``@check_messages`` does:\r\nIt helps the ``ASTWalker`` decide whether a callback for the current node type should be called or not. \r\nThis is done by adding the list of messages passed in as a ``checks_messages`` attribute on method object.\r\nWhen a checker is added to the ``ASTWalker`` instance, it loops over all of its methods. Every method starting with ``visit_`` or ``leave_`` is now checked for the ``checks_messages`` attribute:\r\n* if the attribute does not exist, this method will be added to the list of callbacks\r\n* if it exists and at least one message of the ``checks_messages`` list is enabled, this method will be added to the list of callbacks\r\n* otherwise, it will not be added to the list of callbacks and will therefore **not** be executed\r\n\r\nEssentially this means:\r\n1. The main (and only) intent of the ``@check_messages`` decorator is to improve performance\r\n2. Placing the ``@check_messages`` decorator on any method which is not a \"top level callback\" (methods starting with ``visit_`` or ``leave_`` does not have any effect\r\n3. Forgetting to apply the ``@check_messages`` decorator has no negative functional consequences, it only affects performance (which, of course, is always an issue)\r\n4. Applying the decorator but forgetting to add messages that are emitted from this callback can lead to false negatives: if none of the messages actually included in the decorator are enabled, it will not be called\r\n5. Applying the decorator to a callback that not only emits messages but also does other things can have nasty side effects (false positives, false negatives, crashes)\r\n\r\n**What I want to gain a consensus on:**\r\n1. Do we want to keep the name ``check_messages``? I don't think it really conveys the effect it has on the decorated method.\r\n2. What shall we regard as best practice for this decorator? Should every callback be decorated and the list of messages must always be correct and consistent, or should we rather advise to use it only in cases where we expect a significant speedup when this callback is omitted?\r\n3. Do we want to keep the restriction that this decorator only has an effect on the \"top level callbacks\"? Seeing that a lot of those callbacks can emit quite a lot of messages and the logic for the checks is often split up into several subfunctions, it would be more flexible and also more robust (as it is easier to keep track of the messages that need to be included in the decorator) if one could apply it on the subfunctions rather than on the top level callback.\r\n\r\nLooking over the code base there are quite a lot of places where the decorator is not used correctly:\r\n* used with simply passing in all messages (which has the same effect as just omitting it): ``@check_messages(*MSGS)``\r\n* used on methods that are not a callback (which has no effect)\r\n* Used, but not including all messages possibly emitted by the callback\n\n### Additional context\n\n_No response_\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pylint-dev__pylint__2.14.git",
    "requested_commit": "",
    "mayil_response": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83d\ude41.                   But we've outlined some ideas that might help you get started:\n\n1. Do we want to keep the name ``check_messages``?\n   - No consensus provided; cannot answer.\n\n2. What shall we regard as best practice for this decorator?\n   - Every callback that emits messages should be decorated with `@check_messages`.\n   - The list of messages must always be correct and consistent.\n   - Use it to improve performance by skipping callbacks when their associated messages are not enabled.\n\n3. Do we want to keep the restriction that this decorator only has an effect on the \"top level callbacks\"?\n   - No consensus provided; cannot answer.\n\nRelevant code snippet from `pylint/checkers/utils.py`:\n```python\ndef only_required_for_messages(\n    *messages: str,\n) -> Callable[\n    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]\n]:\n    \"\"\"Decorator to store messages that are handled by a checker method as an\n    attribute of the function object.\n\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n\n    def store_messages(\n        func: AstCallbackMethod[_CheckerT, _NodeT]\n    ) -> AstCallbackMethod[_CheckerT, _NodeT]:\n        func.checks_msgs = messages  # type: ignore[attr-defined]\n        return func\n\n    return store_messages\n```",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000394,
        "snippet_processor": 0.05498,
        "issue_star_creation": 0.03671,
        "issue_star_solver": 0.04805,
        "bouncer": 0.02606
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711700046.464596,
        "relevant_snippets": [
            {
                "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Check for signs of poor design.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom collections import defaultdict\nfrom collections.abc import Iterator\nfrom typing import TYPE_CHECKING\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.utils import is_enum, only_required_for_messages\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\nMSGS: dict[\n    str, MessageDefinitionTuple\n] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n    \"R0901\": (\n        \"Too many ancestors (%s/%s)\",\n        \"too-many-ancestors\",\n        \"Used when class has too many parent classes, try to reduce \"\n        \"this to get a simpler (and so easier to use) class.\",\n    ),\n    \"R0902\": (\n        \"Too many instance attributes (%s/%s)\",\n        \"too-many-instance-attributes\",\n        \"Used when class has too many instance attributes, try to reduce \"\n        \"this to get a simpler (and so easier to use) class.\",\n    ),\n    \"R0903\": (\n        \"Too few public methods (%s/%s)\",\n        \"too-few-public-methods\",\n        \"Used when class has too few public methods, so be sure it's \"\n        \"really worth it.\",\n    ),\n    \"R0904\": (\n        \"Too many public methods (%s/%s)\",\n        \"too-many-public-methods\",\n        \"Used when class has too many public methods, try to reduce \"\n        \"this to get a simpler (and so easier to use) class.\",\n    ),\n    \"R0911\": (\n        \"Too many return statements (%s/%s)\",\n        \"too-many-return-statements\",\n        \"Used when a function or method has too many return statement, \"\n        \"making it hard to follow.\",\n    ),\n    \"R0912\": (\n        \"Too many branches (%s/%s)\",\n        \"too-many-branches\",\n        \"Used when a function or method has too many branches, \"\n        \"making it hard to follow.\",\n    ),\n    \"R0913\": (\n        \"Too many arguments (%s/%s)\",\n        \"too-many-arguments\",\n        \"Used when a function or method takes too many arguments.\",\n    ),\n    \"R0914\": (\n        \"Too many local variables (%s/%s)\",\n        \"too-many-locals\",\n        \"Used when a function or method has too many local variables.\",\n    ),\n    \"R0915\": (\n        \"Too many statements (%s/%s)\",\n        \"too-many-statements\",\n        \"Used when a function or method has too many statements. You \"\n        \"should then split it in smaller functions / methods.\",\n    ),\n    \"R0916\": (\n        \"Too many boolean expressions in if statement (%s/%s)\",\n        \"too-many-boolean-expressions\",\n        \"Used when an if statement contains too many boolean expressions.\",\n    ),\n}\nSPECIAL_OBJ = re.compile(\"^_{2}[a-z]+_{2}$\")\nDATACLASSES_DECORATORS = frozenset({\"dataclass\", \"attrs\"})\nDATACLASS_IMPORT = \"dataclasses\"",
                "filename": "pylint/checkers/design_analysis.py",
                "start_index": 0,
                "end_index": 2987,
                "start_line": 1,
                "end_line": 87,
                "max_line": 658,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom collections.abc import Iterable, Sequence\nfrom inspect import cleandoc\nfrom tokenize import TokenInfo\nfrom typing import TYPE_CHECKING, Any\n\nfrom astroid import nodes\n\nfrom pylint.config.arguments_provider import _ArgumentsProvider\nfrom pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope\nfrom pylint.exceptions import InvalidMessageError\nfrom pylint.interfaces import Confidence\nfrom pylint.message.message_definition import MessageDefinition\nfrom pylint.typing import (\n    ExtraMessageOptions,\n    MessageDefinitionTuple,\n    OptionDict,\n    Options,\n    ReportsCallable,\n)\nfrom pylint.utils import get_rst_section, get_rst_title\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter",
                "filename": "pylint/checkers/base_checker.py",
                "start_index": 0,
                "end_index": 1005,
                "start_line": 1,
                "end_line": 31,
                "max_line": 249,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "def is_func_decorator(node: nodes.NodeNG) -> bool:\n    \"\"\"Return true if the name is used in function decorator.\"\"\"\n    for parent in node.node_ancestors():\n        if isinstance(parent, nodes.Decorators):\n            return True\n        if parent.is_statement or isinstance(\n            parent,\n            (\n                nodes.Lambda,\n                nodes.ComprehensionScope,\n                nodes.ListComp,\n            ),\n        ):\n            break\n    return False\n\n\ndef is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether `frame` is an astroid.Class node with `node` in the\n    subtree of its bases attribute.\n    \"\"\"\n    if not isinstance(frame, nodes.ClassDef):\n        return False\n    return any(node in base.nodes_of_class(nodes.Name) for base in frame.bases)\n\n\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\n\n\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n\ndef overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:\n    \"\"\"Return True if <name> is a method overridden from an ancestor\n    which is not the base object class.\n    \"\"\"\n    for ancestor in class_node.ancestors():\n        if ancestor.name == \"object\":\n            continue\n        if name in ancestor and isinstance(ancestor[name], nodes.FunctionDef):\n            return True\n    return False\n\n\ndef only_required_for_messages(\n    *messages: str,\n) -> Callable[\n    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]\n]:\n    \"\"\"Decorator to store messages that are handled by a checker method as an\n    attribute of the function object.\n\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n\n    def store_messages(\n        func: AstCallbackMethod[_CheckerT, _NodeT]\n    ) -> AstCallbackMethod[_CheckerT, _NodeT]:\n        func.checks_msgs = messages  # type: ignore[attr-defined]\n        return func\n\n    return store_messages\n\n\nclass IncompleteFormatString(Exception):\n    \"\"\"A format string ended in the middle of a format specifier.\"\"\"\n\n\nclass UnsupportedFormatCharacter(Exception):\n    \"\"\"A format character in a format string is not one of the supported\n    format characters.\n    \"\"\"\n\n    def __init__(self, index: int) -> None:\n        super().__init__(index)\n        self.index = index",
                "filename": "pylint/checkers/utils.py",
                "start_index": 12948,
                "end_index": 15891,
                "start_line": 421,
                "end_line": 506,
                "max_line": 2268,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "name: \ud83e\udd14 Support question\ndescription: Questions about pylint that are not covered in the documentation\nlabels: [\"Needs triage :inbox_tray:\", \"Question\", \"Documentation :green_book:\"]\nbody:\n  - type: markdown\n    attributes:\n      value: >\n        **Thank you for wanting to report a problem with pylint documentation!**\n\n\n        Please fill out your suggestions below. If the problem seems straightforward,\n        feel free to go ahead and submit a pull request instead!\n\n\n        \u26a0 Verify first that your issue is not [already reported on GitHub][issue\n        search].\n\n        \ud83d\udcac If you are seeking community support, please consider [starting a discussion\n        on Discord][Discussions].\n\n\n        [issue search]:\n        https://github.com/pylint-dev/pylint/issues?q=is%3Aissue+is%3Aopen+\n\n        [Discussions]: https://discord.com/invite/Egy6P8AMB5\n\n  - type: textarea\n    id: question\n    attributes:\n      label: Question\n    validations:\n      required: true\n  - type: textarea\n    id: documentation\n    attributes:\n      label: Documentation for future user\n      description:\n        Where did you expect this information to be? What do we need to add or what do\n        we need to reorganize?\n    validations:\n      required: true\n  - type: textarea\n    attributes:\n      label: Additional context\n      description: >\n        Add any other context, links, etc. about the question here.\n      placeholder: >-\n        I asked on https://stackoverflow.com/... and the community advised me to do X, Y\n        and Z.",
                "filename": ".github/ISSUE_TEMPLATE/QUESTION.yml",
                "start_index": 0,
                "end_index": 1528,
                "start_line": 1,
                "end_line": 49,
                "max_line": 49,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "\"\"\"Checker of potential misdesigns.\n\n    Checks for sign of poor/misdesign:\n    * number of methods, attributes, local variables...\n    * size, complexity of functions, methods\n    \"\"\"\n\n    # configuration section name\n    name = \"design\"\n    # messages\n    msgs = MSGS\n    # configuration options",
                "filename": "pylint/checkers/design_analysis.py",
                "start_index": 9129,
                "end_index": 9426,
                "start_line": 274,
                "end_line": 285,
                "max_line": 658,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "def _check_dispatch_decorators(self, node: nodes.FunctionDef) -> None:\n        decorators_map: dict[str, tuple[nodes.NodeNG, interfaces.Confidence]] = {}\n\n        for decorator in node.decorators.nodes:\n            if isinstance(decorator, nodes.Name) and decorator.name:\n                decorators_map[decorator.name] = (decorator, interfaces.HIGH)\n            elif utils.is_registered_in_singledispatch_function(node):\n                decorators_map[\"singledispatch\"] = (decorator, interfaces.INFERENCE)\n            elif utils.is_registered_in_singledispatchmethod_function(node):\n                decorators_map[\"singledispatchmethod\"] = (\n                    decorator,\n                    interfaces.INFERENCE,\n                )\n\n        if \"singledispatch\" in decorators_map and \"classmethod\" in decorators_map:\n            self.add_message(\n                \"singledispatch-method\",\n                node=decorators_map[\"singledispatch\"][0],\n                confidence=decorators_map[\"singledispatch\"][1],\n            )\n        elif (\n            \"singledispatchmethod\" in decorators_map\n            and \"staticmethod\" in decorators_map\n        ):\n            self.add_message(\n                \"singledispatchmethod-function\",\n                node=decorators_map[\"singledispatchmethod\"][0],\n                confidence=decorators_map[\"singledispatchmethod\"][1],\n            )\n\n    def _check_redundant_assert(self, node: nodes.Call, infer: InferenceResult) -> None:\n        if (\n            isinstance(infer, astroid.BoundMethod)\n            and node.args\n            and isinstance(node.args[0], nodes.Const)\n            and infer.name in {\"assertTrue\", \"assertFalse\"}\n        ):\n            self.add_message(\n                \"redundant-unittest-assert\",\n                args=(infer.name, node.args[0].value),\n                node=node,\n            )\n\n    def _check_datetime(self, node: nodes.NodeNG) -> None:\n        \"\"\"Check that a datetime was inferred, if so, emit boolean-datetime warning.\"\"\"\n        try:\n            inferred = next(node.infer())\n        except astroid.InferenceError:\n            return\n        if isinstance(inferred, astroid.Instance) and inferred.qname() in {\n            \"_pydatetime.time\",\n            \"datetime.time\",\n        }:\n            self.add_message(\"boolean-datetime\", node=node)",
                "filename": "pylint/checkers/stdlib.py",
                "start_index": 25471,
                "end_index": 27794,
                "start_line": 667,
                "end_line": 720,
                "max_line": 873,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom typing import NoReturn\n\nfrom pylint.exceptions import (\n    DeletedMessageError,\n    InvalidMessageError,\n    MessageBecameExtensionError,\n    UnknownMessageError,\n)\nfrom pylint.message._deleted_message_ids import (\n    is_deleted_msgid,\n    is_deleted_symbol,\n    is_moved_msgid,\n    is_moved_symbol,\n)",
                "filename": "pylint/message/message_id_store.py",
                "start_index": 0,
                "end_index": 576,
                "start_line": 1,
                "end_line": 160,
                "max_line": 163,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "\"\"\"Checker that detects invalid or problematic usage in dataclasses.\n\n    Checks for\n    * invalid-field-call\n    \"\"\"\n\n    name = \"dataclass\"\n    msgs = {\n        \"E3701\": (\n            \"Invalid usage of field(), %s\",\n            \"invalid-field-call\",\n            \"The dataclasses.field() specifier should only be used as the value of \"\n            \"an assignment within a dataclass, or within the make_dataclass() function.\",\n        ),\n    }\n\n    @utils.only_required_for_messages(\"invalid-field-call\")\n    def visit_call(self, node: nodes.Call) -> None:\n        self._check_invalid_field_call(node)\n\n    def _check_invalid_field_call(self, node: nodes.Call) -> None:\n        \"\"\"Checks for correct usage of the dataclasses.field() specifier in\n        dataclasses or within the make_dataclass() function.\n\n        Emits message\n        when field() is detected to be used outside a class decorated with\n        @dataclass decorator and outside make_dataclass() function, or when it\n        is used improperly within a dataclass.\n        \"\"\"\n        if not isinstance(node.func, (nodes.Name, nodes.Attribute)):\n            return\n        if not _check_name_or_attrname_eq_to(node.func, \"field\"):\n            return\n        inferred_func = utils.safe_infer(node.func)\n        if not (\n            isinstance(inferred_func, nodes.FunctionDef)\n            and _is_dataclasses_module(inferred_func.root())\n        ):\n            return\n        scope_node = node.parent\n        while scope_node and not isinstance(scope_node, (nodes.ClassDef, nodes.Call)):\n            scope_node = scope_node.parent\n\n        if isinstance(scope_node, nodes.Call):\n            self._check_invalid_field_call_within_call(node, scope_node)\n            return\n\n        if not scope_node or not scope_node.is_dataclass:\n            self.add_message(\n                \"invalid-field-call\",\n                node=node,\n                args=(\n                    \"it should be used within a dataclass or the make_dataclass() function.\",\n                ),\n                confidence=INFERENCE,\n            )\n            return\n\n        if not (isinstance(node.parent, nodes.AnnAssign) and node == node.parent.value):\n            self.add_message(\n                \"invalid-field-call\",\n                node=node,\n                args=(\"it should be the value of an assignment within a dataclass.\",),\n                confidence=INFERENCE,\n            )",
                "filename": "pylint/checkers/dataclass_checker.py",
                "start_index": 1132,
                "end_index": 3552,
                "start_line": 38,
                "end_line": 123,
                "max_line": 129,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "\"\"\"Check characters that could be used to hide bad code to humans.\n\n    This includes:\n\n    - Bidirectional Unicode (see https://trojansource.codes/)\n\n    - Bad ASCII characters (see PEP672)\n\n        If a programmer requires to use such a character they should use the escaped\n        version, that is also much easier to read and does not depend on the editor used.\n\n    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n\n    At the time of writing Python supported only UTF-8. See\n    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789\n    for background.\n    \"\"\"\n\n    name = \"unicode_checker\"\n\n    msgs = {\n        \"E2501\": (\n            # This error will be only displayed to users once Python Supports\n            # UTF-16/UTF-32 (if at all)\n            \"UTF-16 and UTF-32 aren't backward compatible. Use UTF-8 instead\",\n            \"invalid-unicode-codec\",\n            (\n                \"For compatibility use UTF-8 instead of UTF-16/UTF-32. \"\n                \"See also https://bugs.python.org/issue1503789 for a history \"\n                \"of this issue. And \"\n                \"https://softwareengineering.stackexchange.com/questions/102205/ \"\n                \"for some possible problems when using UTF-16 for instance.\"\n            ),\n        ),\n        \"E2502\": (\n            (\n                \"Contains control characters that can permit obfuscated code \"\n                \"executed differently than displayed\"\n            ),\n            \"bidirectional-unicode\",\n            (\n                \"bidirectional unicode are typically not displayed characters required \"\n                \"to display right-to-left (RTL) script \"\n                \"(i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. \"\n                \"So can you trust this code? \"\n                \"Are you sure it displayed correctly in all editors? \"\n                \"If you did not write it or your language is not RTL,\"\n                \" remove the special characters, as they could be used to trick you into \"\n                \"executing code, \"\n                \"that does something else than what it looks like.\\n\"\n                \"More Information:\\n\"\n                \"https://en.wikipedia.org/wiki/Bidirectional_text\\n\"\n                \"https://trojansource.codes/\"\n            ),\n        ),\n        \"C2503\": (\n            \"PEP8 recommends UTF-8 as encoding for Python files\",\n            \"bad-file-encoding\",\n            (\n                \"PEP8 recommends UTF-8 default encoding for Python files. See \"\n                \"https://peps.python.org/pep-0008/#source-file-encoding\"\n            ),\n        ),\n        **{\n            bad_char.code: (\n                bad_char.description(),\n                bad_char.human_code(),\n                bad_char.help_text,\n            )\n            for bad_char in BAD_CHARS\n        },\n    }",
                "filename": "pylint/checkers/unicode.py",
                "start_index": 8778,
                "end_index": 11668,
                "start_line": 302,
                "end_line": 374,
                "max_line": 538,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            },
            {
                "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Check for new / old style related problems.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.checkers.utils import (\n    has_known_bases,\n    node_frame_class,\n    only_required_for_messages,\n)\nfrom pylint.typing import MessageDefinitionTuple\n\nif TYPE_CHECKING:\n    from pylint.lint import PyLinter\n\nMSGS: dict[str, MessageDefinitionTuple] = {\n    \"E1003\": (\n        \"Bad first argument %r given to super()\",\n        \"bad-super-call\",\n        \"Used when another argument than the current class is given as \"\n        \"first argument of the super builtin.\",\n    )\n}",
                "filename": "pylint/checkers/newstyle.py",
                "start_index": 0,
                "end_index": 917,
                "start_line": 1,
                "end_line": 32,
                "max_line": 129,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.14",
                "sha": ""
            }
        ],
        "classification": "question",
        "question_answerer_task": "1. Do we want to keep the name ``check_messages``?\n   - No consensus provided; cannot answer.\n\n2. What shall we regard as best practice for this decorator?\n   - Every callback that emits messages should be decorated with `@check_messages`.\n   - The list of messages must always be correct and consistent.\n   - Use it to improve performance by skipping callbacks when their associated messages are not enabled.\n\n3. Do we want to keep the restriction that this decorator only has an effect on the \"top level callbacks\"?\n   - No consensus provided; cannot answer.\n\nRelevant code snippet from `pylint/checkers/utils.py`:\n```python\ndef only_required_for_messages(\n    *messages: str,\n) -> Callable[\n    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]\n]:\n    \"\"\"Decorator to store messages that are handled by a checker method as an\n    attribute of the function object.\n\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n\n    def store_messages(\n        func: AstCallbackMethod[_CheckerT, _NodeT]\n    ) -> AstCallbackMethod[_CheckerT, _NodeT]:\n        func.checks_msgs = messages  # type: ignore[attr-defined]\n        return func\n\n    return store_messages\n```",
        "bouncer_response": {
            "score": 3,
            "criteria": "The RESPONSE should provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher. It should address the specific inquiry and context presented in the PROMPT.",
            "supporting_evidence": "The RESPONSE fails to provide a consensus or actionable guidance on the first and third questions, stating 'No consensus provided; cannot answer.' This is not helpful as the PROMPT is seeking opinions or suggestions for a consensus. For the second question, the RESPONSE does provide a clear stance on best practices for the decorator, which is relevant and actionable. However, it does not address the nuances of the question, such as advising on when to use the decorator for significant speedup. The inclusion of the code snippet is somewhat relevant but does not add significant value as it does not directly address the questions posed in the PROMPT.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711700105.1758678,
        "result": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83d\ude41.                   But we've outlined some ideas that might help you get started:\n\n1. Do we want to keep the name ``check_messages``?\n   - No consensus provided; cannot answer.\n\n2. What shall we regard as best practice for this decorator?\n   - Every callback that emits messages should be decorated with `@check_messages`.\n   - The list of messages must always be correct and consistent.\n   - Use it to improve performance by skipping callbacks when their associated messages are not enabled.\n\n3. Do we want to keep the restriction that this decorator only has an effect on the \"top level callbacks\"?\n   - No consensus provided; cannot answer.\n\nRelevant code snippet from `pylint/checkers/utils.py`:\n```python\ndef only_required_for_messages(\n    *messages: str,\n) -> Callable[\n    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]\n]:\n    \"\"\"Decorator to store messages that are handled by a checker method as an\n    attribute of the function object.\n\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n\n    def store_messages(\n        func: AstCallbackMethod[_CheckerT, _NodeT]\n    ) -> AstCallbackMethod[_CheckerT, _NodeT]:\n        func.checks_msgs = messages  # type: ignore[attr-defined]\n        return func\n\n    return store_messages\n```"
    }
}