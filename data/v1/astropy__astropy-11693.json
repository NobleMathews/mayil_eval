{
    "id": "astropy__astropy-11693",
    "repo_name": "testbed/astropy__astropy__4.2",
    "task_id": 7938572804751975773,
    "title": "'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions",
    "body": "<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions\n<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/master/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/master/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nWhen trying to plot an image with a WCS as projection that contains non linear Distortions it fails with a `NoConvergence` error.\r\n\r\n### Expected behavior\r\nWhen I add `quiet=True` as parameter to the call \r\n```pixel = self.all_world2pix(*world_arrays, 0)``` \r\nat line 326 of `astropy/wcs/wcsapi/fitswcs.py` I get the good enough looking plot below:\r\n\r\n![bugreport](https://user-images.githubusercontent.com/64231/112940287-37c2c800-912d-11eb-8ce8-56fd284bb8e7.png)\r\n\r\nIt would be nice if there was a way of getting that plot without having to hack the library code like that.\r\n### Actual behavior\r\n<!-- What actually happened. -->\r\n<!-- Was the output confusing or poorly described? -->\r\nThe call to plotting the grid fails with the following error (last few lines, can provide more if necessary):\r\n\r\n```\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcsapi/fitswcs.py in world_to_pixel_values(self, *world_arrays)\r\n    324 \r\n    325     def world_to_pixel_values(self, *world_arrays):\r\n--> 326         pixel = self.all_world2pix(*world_arrays, 0)\r\n    327         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\r\n    328 \r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/utils/decorators.py in wrapper(*args, **kwargs)\r\n    534                     warnings.warn(message, warning_type, stacklevel=2)\r\n    535 \r\n--> 536             return function(*args, **kwargs)\r\n    537 \r\n    538         return wrapper\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in all_world2pix(self, tolerance, maxiter, adaptive, detect_divergence, quiet, *args, **kwargs)\r\n   1886             raise ValueError(\"No basic WCS settings were created.\")\r\n   1887 \r\n-> 1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n   1890             self._all_world2pix(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _array_converter(self, func, sky, ra_dec_order, *args)\r\n   1335                     \"a 1-D array for each axis, followed by an origin.\")\r\n   1336 \r\n-> 1337             return _return_list_of_arrays(axes, origin)\r\n   1338 \r\n   1339         raise TypeError(\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _return_list_of_arrays(axes, origin)\r\n   1289             if ra_dec_order and sky == 'input':\r\n   1290                 xy = self._denormalize_sky(xy)\r\n-> 1291             output = func(xy, origin)\r\n   1292             if ra_dec_order and sky == 'output':\r\n   1293                 output = self._normalize_sky(output)\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in <lambda>(*args, **kwargs)\r\n   1888         return self._array_converter(\r\n   1889             lambda *args, **kwargs:\r\n-> 1890             self._all_world2pix(\r\n   1891                 *args, tolerance=tolerance, maxiter=maxiter,\r\n   1892                 adaptive=adaptive, detect_divergence=detect_divergence,\r\n\r\n~/work/develop/env/lib/python3.9/site-packages/astropy/wcs/wcs.py in _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet)\r\n   1869                     slow_conv=ind, divergent=None)\r\n   1870             else:\r\n-> 1871                 raise NoConvergence(\r\n   1872                     \"'WCS.all_world2pix' failed to \"\r\n   1873                     \"converge to the requested accuracy.\\n\"\r\n\r\nNoConvergence: 'WCS.all_world2pix' failed to converge to the requested accuracy.\r\nAfter 20 iterations, the solution is diverging at least for one input point.\r\n```\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\nHere is the code to reproduce the problem:\r\n```\r\nfrom astropy.wcs import WCS, Sip\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nwcs = WCS(naxis=2)\r\na = [[ 0.00000000e+00,  0.00000000e+00,  6.77532513e-07,\r\n        -1.76632141e-10],\r\n       [ 0.00000000e+00,  9.49130161e-06, -1.50614321e-07,\r\n         0.00000000e+00],\r\n       [ 7.37260409e-06,  2.07020239e-09,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [-1.20116753e-07,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\nb = [[ 0.00000000e+00,  0.00000000e+00,  1.34606617e-05,\r\n        -1.41919055e-07],\r\n       [ 0.00000000e+00,  5.85158316e-06, -1.10382462e-09,\r\n         0.00000000e+00],\r\n       [ 1.06306407e-05, -1.36469008e-07,  0.00000000e+00,\r\n         0.00000000e+00],\r\n       [ 3.27391123e-09,  0.00000000e+00,  0.00000000e+00,\r\n         0.00000000e+00]]\r\ncrpix = [1221.87375165,  994.90917378]\r\nap = bp = np.zeros((4, 4))\r\n\r\nwcs.sip = Sip(a, b, ap, bp, crpix)\r\n\r\nplt.subplot(projection=wcs)\r\nplt.imshow(np.zeros((1944, 2592)))\r\nplt.grid(color='white', ls='solid')\r\n```\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\n```\r\n>>> import platform; print(platform.platform())\r\nLinux-5.11.10-arch1-1-x86_64-with-glibc2.33\r\n>>> import sys; print(\"Python\", sys.version)\r\nPython 3.9.2 (default, Feb 20 2021, 18:40:11) \r\n[GCC 10.2.0]\r\n>>> import numpy; print(\"Numpy\", numpy.__version__)\r\nNumpy 1.20.2\r\n>>> import astropy; print(\"astropy\", astropy.__version__)\r\nastropy 4.3.dev690+g7811614f8\r\n>>> import scipy; print(\"Scipy\", scipy.__version__)\r\nScipy 1.6.1\r\n>>> import matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\nMatplotlib 3.3.4\r\n```\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__4.2.git",
    "requested_commit": "",
    "mayil_response": "- Locate the `all_world2pix` method in the `WCS` class within the `astropy/wcs/wcs.py` file.\n- Modify the method call to include the `quiet=True` parameter to suppress the `NoConvergence` exception.\n- Ensure that the `quiet` parameter is set to `True` in the appropriate method call within the `fitswcs.py` file at line 326, as indicated in the issue description. If the `quiet` parameter is not present, add it to the method call with the value `True`.\n- Since the `quiet` parameter is already part of the `all_world2pix` method signature, no changes to the method definition are required.\n- Save the changes and ensure that the software no longer raises the `NoConvergence` exception when `all_world2pix` is called with `quiet=True`.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__4.2/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__4.2/tree//astropy/wcs)- [Lines 2079 - 2107](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L2079-L2107)\n\n This snippet contains the exception raising logic for the 'NoConvergence' error, which is directly related to the issue reported. \n\n\n   - [Lines 2109 - 3796](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L2109-L3796)\n\n This snippet shows the 'all_world2pix' method where the 'quiet' parameter is used, which is relevant to the issue as the user's workaround involved modifying this parameter. \n\n\n   - [Lines 377 - 2436](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L377-L2436)\n\n This snippet provides context on the 'all_world2pix' method, including the 'NoConvergence' exception that can be raised, which is relevant to understanding the issue. \n\n\n   - [Lines 581 - 2678](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L581-L2678)\n\n This snippet includes the documentation for the 'all_world2pix' method, explaining the parameters and their effects, which is relevant to the issue. \n\n\n   - [Lines 1704 - 1764](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L1704-L1764)\n\n This snippet outlines the numerical method used by 'all_world2pix', which is relevant to understanding why convergence issues may occur.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.002101,
        "snippet_processor": 0.12437000000000001,
        "issue_star_creation": 0.06015000000000001,
        "issue_star_solver": 0.08718000000000001,
        "bouncer": 0.059800000000000006
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711737440.50068,
        "relevant_snippets": [
            {
                "code": "0}}\"\n        ...         .format(e.divergent))\n        ...   print(\"Indices of poorly converging points: {{0}}\"\n        ...         .format(e.slow_conv))\n        ...   print(\"Best solution:\\\\n{{0}}\".format(e.best_solution))\n        ...   print(\"Achieved accuracy:\\\\n{{0}}\".format(e.accuracy))\n        Indices of diverging points: [1]\n        Indices of poorly converging points: None\n        Best solution:\n        [[  1.00000238e+00   9.99999965e-01]\n         [ -1.99441636e+06   1.44309097e+06]\n         [  3.00000236e+00   9.99999966e-01]]\n        Achieved accuracy:\n        [[  6.13968380e-05   8.59638593e-07]\n         [  8.59526812e+11   6.61713548e+11]\n         [  6.09398446e-05   8.38759724e-07]]\n        >>> raise e\n        Traceback (most recent call last):\n        ...\n        NoConvergence: 'WCS.all_world2pix' failed to converge to the\n        requested accuracy.  After 5 iterations, the solution is\n        diverging at least for one input point.\n\n        >>> # This time turn detect_divergence off:\n        >>> try:  # doctest: +FLOAT_CMP\n        ...   xy = w.all_world2pix(divradec, 1, maxiter=20,\n        ...                        tolerance=1.0e-4, adaptive=False,\n        ...                        detect_divergence=False,\n        ...                        quiet=False)\n        ... except wcs.wcs.NoConvergence as e:\n        ...   print(\"Indices of diverging points: {{0}}\"\n        ...         .format(e.divergent))\n        ...   print(\"Indices of poorly converging points: {{0}}\"\n        ...         .format(e.slow_conv))\n        ...   print(\"Best solution:\\\\n{{0}}\".format(e.best_solution))\n        ...   print(\"Achieved accuracy:\\\\n{{0}}\".format(e.accuracy))\n        Indices of diverging points: [1]\n        Indices of poorly converging points: None\n        Best solution:\n        [[ 1.00000009  1.        ]\n         [        nan         nan]\n         [ 3.00000009  1.        ]]\n        Achieved accuracy:\n        [[  2.29417358e-06   3.21222995e-08]\n         [             nan              nan]\n         [  2.27407877e-06   3.13005639e-08]]\n        >>> raise e\n        Traceback (most recent call last):\n        ...\n        NoConvergence: 'WCS.all_world2pix' failed to converge to the\n        requested accuracy.  After 6 iterations, the solution is\n        diverging at least for one input point.\n\n        \"\"\"",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 91388,
                "end_index": 93725,
                "start_line": 2406,
                "end_line": 3565,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "# Additional relax bit flags\nWCSHDO_SIP = 0x80000\n\n# Regular expression defining SIP keyword It matches keyword that starts with A\n# or B, optionally followed by P, followed by an underscore then a number in\n# range of 0-19, followed by an underscore and another number in range of 0-19.\n# Keyword optionally ends with a capital letter.\nSIP_KW = re.compile(\"\"\"^[AB]P?_1?[0-9]_1?[0-9][A-Z]?$\"\"\")\n\n\ndef _parse_keysel(keysel):\n    keysel_flags = 0\n    if keysel is not None:\n        for element in keysel:\n            if element.lower() == \"image\":\n                keysel_flags |= _wcs.WCSHDR_IMGHEAD\n            elif element.lower() == \"binary\":\n                keysel_flags |= _wcs.WCSHDR_BIMGARR\n            elif element.lower() == \"pixel\":\n                keysel_flags |= _wcs.WCSHDR_PIXLIST\n            else:\n                raise ValueError(\n                    \"keysel must be a list of 'image', 'binary' and/or 'pixel'\"\n                )\n    else:\n        keysel_flags = -1\n\n    return keysel_flags\n\n\nclass NoConvergence(Exception):\n    \"\"\"\n    An error class used to report non-convergence and/or divergence\n    of numerical methods. It is used to report errors in the\n    iterative solution used by\n    the :py:meth:`~astropy.wcs.WCS.all_world2pix`.\n\n    Attributes\n    ----------\n    best_solution : `numpy.ndarray`\n        Best solution achieved by the numerical method.\n\n    accuracy : `numpy.ndarray`\n        Accuracy of the ``best_solution``.\n\n    niter : `int`\n        Number of iterations performed by the numerical method\n        to compute ``best_solution``.\n\n    divergent : None, `numpy.ndarray`\n        Indices of the points in ``best_solution`` array\n        for which the solution appears to be divergent. If the\n        solution does not diverge, ``divergent`` will be set to `None`.\n\n    slow_conv : None, `numpy.ndarray`\n        Indices of the solutions in ``best_solution`` array\n        for which the solution failed to converge within the\n        specified maximum number of iterations. If there are no\n        non-converging solutions (i.e., if the required accuracy\n        has been achieved for all input data points)\n        then ``slow_conv`` will be set to `None`.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        best_solution=None,\n        accuracy=None,\n        niter=None,\n        divergent=None,\n        slow_conv=None,\n        **kwargs,\n    ):\n        super().__init__(*args)\n\n        self.best_solution = best_solution\n        self.accuracy = accuracy\n        self.niter = niter\n        self.divergent = divergent\n        self.slow_conv = slow_conv\n\n        if kwargs:\n            warnings.warn(\n                f\"Function received unexpected arguments ({list(kwargs)}) these \"\n                \"are ignored but will raise an Exception in the \"\n                \"future.\",\n                AstropyDeprecationWarning,\n            )",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 5290,
                "end_index": 8173,
                "start_line": 176,
                "end_line": 3796,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "# #  RAISE EXCEPTION IF DIVERGING OR TOO SLOWLY CONVERGING  ##\n        # #  DATA POINTS HAVE BEEN DETECTED:                        ##\n        # ############################################################\n        if (ind is not None or inddiv is not None) and not quiet:\n            if inddiv is None:\n                raise NoConvergence(\n                    \"'WCS.all_world2pix' failed to \"\n                    f\"converge to the requested accuracy after {k:d} \"\n                    \"iterations.\",\n                    best_solution=pix,\n                    accuracy=np.abs(dpix),\n                    niter=k,\n                    slow_conv=ind,\n                    divergent=None,\n                )\n            else:\n                raise NoConvergence(\n                    \"'WCS.all_world2pix' failed to \"\n                    \"converge to the requested accuracy.\\n\"\n                    f\"After {k:d} iterations, the solution is diverging \"\n                    \"at least for one input point.\",\n                    best_solution=pix,\n                    accuracy=np.abs(dpix),\n                    niter=k,\n                    slow_conv=ind,\n                    divergent=inddiv,\n                )\n\n        return pix",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 76972,
                "end_index": 78186,
                "start_line": 2079,
                "end_line": 2107,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "Notes\n        -----\n        The order of the axes for the input world array is determined by\n        the ``CTYPEia`` keywords in the FITS header, therefore it may\n        not always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp`, and\n        `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        Using the method of fixed-point iterations approximations we\n        iterate starting with the initial approximation, which is\n        computed using the non-distortion-aware\n        :py:meth:`wcs_world2pix` (or equivalent).\n\n        The :py:meth:`all_world2pix` function uses a vectorized\n        implementation of the method of consecutive approximations and\n        therefore it is highly efficient (>30x) when *all* data points\n        that need to be converted from sky coordinates to image\n        coordinates are passed at *once*. Therefore, it is advisable,\n        whenever possible, to pass as input a long array of all points\n        that need to be converted to :py:meth:`all_world2pix` instead\n        of calling :py:meth:`all_world2pix` for each data point. Also\n        see the note to the ``adaptive`` parameter.\n\n        Raises\n        ------\n        NoConvergence\n            The method did not converge to a\n            solution to the required accuracy within a specified\n            number of maximum iterations set by the ``maxiter``\n            parameter. To turn off this exception, set ``quiet`` to\n            `True`. Indices of the points for which the requested\n            accuracy was not achieved (if any) will be listed in the\n            ``slow_conv`` attribute of the\n            raised :py:class:`NoConvergence` exception object.\n\n            See :py:class:`NoConvergence` documentation for\n            more details.\n\n        MemoryError\n            Memory allocation failed.\n\n        SingularMatrixError\n            Linear transformation matrix is singular.\n\n        InconsistentAxisTypesError\n            Inconsistent or unrecognized coordinate axis types.\n\n        ValueError\n            Invalid parameter value.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n\n        ValueError\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n\n        Examples\n        --------\n        >>> import astropy.io.fits as fits\n        >>> import astropy.wcs as wcs\n        >>> import numpy as np\n        >>> import os\n\n        >>> filename = os.path.join(wcs.__path__[0], 'tests/data/j94f05bgq_flt.fits')\n        >>> hdulist = fits.open(filename)\n        >>> w = wcs.WCS(hdulist[('sci',1)].header, hdulist)\n        >>> hdulist.close()\n\n        >>> ra, dec = w.all_pix2world([1,2,3], [1,1,1], 1)\n        >>> print(ra)  # doctest: +FLOAT_CMP\n        [ 5.52645627  5.52649663  5.52653698]\n        >>> print(dec)  # doctest: +FLOAT_CMP\n        [-72.05171757 -72.05171276 -72.05170795]\n        >>> radec = w.all_pix2world([[1,1], [2,1], [3,1]], 1)\n        >>> print(radec)  # doctest: +FLOAT_CMP\n        [[  5.52645627 -72.05171757]\n         [  5.52649663 -72.05171276]\n         [  5.52653698 -72.05170795]]\n        >>> x, y = w.all_world2pix(ra, dec, 1)\n        >>> print(x)  # doctest: +FLOAT_CMP\n        [ 1.00000238  2.00000237  3.00000236]\n        >>> print(y)  # doctest: +FLOAT_CMP\n        [ 0.99999996  0.99999997  0.99999997]\n        >>> xy = w.all_world2pix(radec, 1)\n        >>> print(xy)  # doctest: +FLOAT_CMP\n        [[ 1.00000238  0.99999996]\n         [ 2.00000237  0.99999997]\n         [ 3.00000236  0.99999997]]\n        >>> xy = w.all_world2pix(radec, 1, maxiter=3,\n        ...                      tolerance=1.0e-10, quiet=False)\n        Traceback (most recent call last):\n        ...\n        NoConvergence: 'WCS.all_world2pix' failed to converge to the\n        requested accuracy. After 3 iterations, the solution is\n        diverging at least for one input point.\n\n        >>> # Now try to use some diverging data:\n        >>> divradec = w.all_pix2world([[1.0, 1.0],\n        ...                             [10000.0, 50000.0],\n        ...                             [3.0, 1.0]], 1)\n        >>> print(divradec)  # doctest: +FLOAT_CMP\n        [[  5.52645627 -72.05171757]\n         [  7.15976932 -70.8140779 ]\n         [  5.52653698 -72.05170795]]\n\n        >>> # First, turn detect_divergence on:\n        >>> try:  # doctest: +FLOAT_CMP\n        ...   xy = w.all_world2pix(divradec, 1, maxiter=20,\n        ...                        tolerance=1.0e-4, adaptive=False,\n        ...                        detect_divergence=True,\n        ...                        quiet=False)\n        ... except wcs.wcs.NoConvergence as e:\n        ...   print(\"Indices of diverging points: {{",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 86424,
                "end_index": 91388,
                "start_line": 377,
                "end_line": 2436,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "# of `all_pix2world` we get about 25% increase in performance\n        # (by not performing the linear `W` transformation at each\n        # step) and we also avoid the \"RA wrapping\" issue described\n        # above (by working in focal plane coordinates and avoiding\n        # pix->world transformations).\n        #\n        # As an added benefit, the process converges to the correct\n        # solution in just one iteration when distortions are not\n        # present (compare to\n        # https://github.com/astropy/astropy/issues/1977 and\n        # https://github.com/astropy/astropy/pull/2294): in this case\n        # `pix2foc` is the identical transformation\n        # `x_i=pix2foc(x_i)` and from equation (7) we get:\n        #\n        # x' = x_0 = wcs_world2pix(w)\n        # x_1 = x' - pix2foc(x_0) + x_0 = x' - pix2foc(x') + x' = x'\n        #     = wcs_world2pix(w) = x_0\n        # =>\n        # |x_1-x_0| = 0 < tolerance (with tolerance > 0)\n        #\n        # However, for performance reasons, it is still better to\n        # avoid iterations altogether and return the exact linear\n        # solution (`wcs_world2pix`) right-away when non-linear\n        # distortions are not present by checking that attributes\n        # `sip`, `cpdis1`, `cpdis2`, `det2im1`, and `det2im2` are\n        # *all* `None`.\n        #\n        #\n        #         ### Outline of the Algorithm ###\n        #\n        #\n        # While the proposed code is relatively long (considering\n        # the simplicity of the algorithm), this is due to: 1)\n        # checking if iterative solution is necessary at all; 2)\n        # checking for divergence; 3) re-implementation of the\n        # completely vectorized algorithm as an \"adaptive\" vectorized\n        # algorithm (for cases when some points diverge for which we\n        # want to stop iterations). In my tests, the adaptive version\n        # of the algorithm is about 50% slower than non-adaptive\n        # version for all HST images.\n        #\n        # The essential part of the vectorized non-adaptive algorithm\n        # (without divergence and other checks) can be described\n        # as follows:\n        #\n        #     pix0 = self.wcs_world2pix(world, origin)\n        #     pix  = pix0.copy() # 0-order solution\n        #\n        #     for k in range(maxiter):\n        #         # find correction to the previous solution:\n        #         dpix = self.pix2foc(pix, origin) - pix0\n        #\n        #         # compute norm (L2) of the correction:\n        #         dn = np.linalg.norm(dpix, axis=1)\n        #\n        #         # apply correction:\n        #         pix -= dpix\n        #\n        #         # check convergence:\n        #         if np.max(dn) < tolerance:\n        #             break\n        #\n        #    return pix\n        #\n        # Here, the input parameter `world` can be a `MxN` array\n        # where `M` is the number of coordinate axes in WCS and `N`\n        # is the number of points to be converted simultaneously to",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 66820,
                "end_index": 69804,
                "start_line": 1830,
                "end_line": 1896,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "f\"\"\"\n        all_world2pix(*arg, tolerance=1.0e-4, maxiter=20,\n        adaptive=False, detect_divergence=True, quiet=False)\n\n        Transforms world coordinates to pixel coordinates, using\n        numerical iteration to invert the full forward transformation\n        `~astropy.wcs.WCS.all_pix2world` with complete\n        distortion model.\n\n\n        Parameters\n        ----------\n        {docstrings.TWO_OR_MORE_ARGS('naxis', 8)}\n\n            For a transformation that is not two-dimensional, the\n            two-argument form must be used.\n\n        {docstrings.RA_DEC_ORDER(8)}\n\n        tolerance : float, optional (default = 1.0e-4)\n            Tolerance of solution. Iteration terminates when the\n            iterative solver estimates that the \"true solution\" is\n            within this many pixels current estimate, more\n            specifically, when the correction to the solution found\n            during the previous iteration is smaller\n            (in the sense of the L2 norm) than ``tolerance``.\n\n        maxiter : int, optional (default = 20)\n            Maximum number of iterations allowed to reach a solution.\n\n        quiet : bool, optional (default = False)\n            Do not throw :py:class:`NoConvergence` exceptions when\n            the method does not converge to a solution with the\n            required accuracy within a specified number of maximum\n            iterations set by ``maxiter`` parameter. Instead,\n            simply return the found solution.\n\n        Other Parameters\n        ----------------\n        adaptive : bool, optional (default = False)\n            Specifies whether to adaptively select only points that\n            did not converge to a solution within the required\n            accuracy for the next iteration. Default is recommended\n            for HST as well as most other instruments.\n\n            .. note::\n               The :py:meth:`all_world2pix` uses a vectorized\n               implementation of the method of consecutive\n               approximations (see ``Notes`` section below) in which it\n               iterates over *all* input points *regardless* until\n               the required accuracy has been reached for *all* input\n               points. In some cases it may be possible that\n               *almost all* points have reached the required accuracy\n               but there are only a few of input data points for\n               which additional iterations may be needed (this\n               depends mostly on the characteristics of the geometric\n               distortions for a given instrument). In this situation\n               it may be advantageous to set ``adaptive`` = `True` in\n               which case :py:meth:`all_world2pix` will continue\n               iterating *only* over the points that have not yet\n               converged to the required accuracy. However, for the\n               HST's ACS/WFC detector, which has the strongest\n               distortions of all HST instruments, testing has\n               shown that enabling this option would lead to a about\n               50-100% penalty in computational time (depending on\n               specifics of the image, geometric distortions, and\n               number of input points to be converted). Therefore,\n               for HST and possibly instruments, it is recommended\n               to set ``adaptive`` = `False`. The only danger in\n               getting this setting wrong will be a performance\n               penalty.\n\n            .. note::\n               When ``detect_divergence`` is `True`,\n               :py:meth:`all_world2pix` will automatically switch\n               to the adaptive algorithm once divergence has been\n               detected.\n\n        detect_divergence : bool, optional (default = True)\n            Specifies whether to perform a more detailed analysis\n            of the convergence to a solution. Normally\n            :py:meth:`all_world2pix` may not achieve the required\n            accuracy if either the ``tolerance`` or ``maxiter`` arguments\n            are too low. However, it may happen that for some\n            geometric distortions the conditions of convergence for\n            the the method of consecutive approximations used by\n            :py:meth:`all_world2pix` may not be satisfied, in which\n            case consecutive approximations to the solution will\n            diverge regardless of the ``tolerance`` or ``maxiter``\n            settings.\n\n            When ``detect_divergence`` is `False`, these divergent\n            points will be detected as not having achieved the\n            required accuracy (without further details). In addition,\n            if ``adaptive`` is `False` then the algorithm will not\n            know that the solution (for specific points) is diverging\n            and will continue iterating and trying to \"improve\"\n            diverging solutions. This may result in ``NaN`` or\n            ``Inf`` values in the return results (in addition to a\n            performance penalties). Even when ``detect_divergence``\n            is `False`, :py:meth:`all_world2pix`, at the end of the\n            iterative process, will identify invalid results\n            (``NaN`` or ``Inf``) as \"diverging\" solutions and will\n            raise :py:class:`NoConvergence` unless the ``quiet``\n            parameter is set to `True`.\n\n            When ``detect_divergence`` is `True`,\n            :py:meth:`all_world2pix` will detect points for which\n            current correction to the coordinates is larger than\n            the correction applied during the previous iteration\n            **if** the requested accuracy **has not yet been\n            achieved**. In this case, if ``adaptive`` is `True`,\n            these points will be excluded from further iterations and\n            if ``adaptive`` is `False`, :py:meth:`all_world2pix` will\n            automatically switch to the adaptive algorithm. Thus, the\n            reported divergent solution will be the latest converging\n            solution computed immediately *before* divergence\n            has been detected.\n\n            .. note::\n               When accuracy has been achieved, small increases in\n               current corrections may be possible due to rounding\n               errors (when ``adaptive`` is `False`) and such\n               increases will be ignored.\n\n            .. note::\n               Based on our testing using HST ACS/WFC images, setting\n               ``detect_divergence`` to `True` will incur about 5-20%\n               performance penalty with the larger penalty\n               corresponding to ``adaptive`` set to `True`.\n               Because the benefits of enabling this\n               feature outweigh the small performance penalty,\n               especially when ``adaptive`` = `False`, it is\n               recommended to set ``detect_divergence`` to `True`,\n               unless extensive testing of the distortion models for\n               images from specific instruments show a good stability\n               of the numerical method for a wide range of\n               coordinates (even outside the image itself).\n\n            .. note::\n               Indices of the diverging inverse solutions will be\n               reported in the ``divergent`` attribute of the\n               raised :py:class:`NoConvergence` exception object.\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('pixel coordinates', 8)}",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 78970,
                "end_index": 86414,
                "start_line": 581,
                "end_line": 2678,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "def _all_world2pix(\n        self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet\n    ):\n        # ############################################################\n        # #          DESCRIPTION OF THE NUMERICAL METHOD            ##\n        # ############################################################\n        # In this section I will outline the method of solving\n        # the inverse problem of converting world coordinates to\n        # pixel coordinates (*inverse* of the direct transformation\n        # `all_pix2world`) and I will summarize some of the aspects\n        # of the method proposed here and some of the issues of the\n        # original `all_world2pix` (in relation to this method)\n        # discussed in https://github.com/astropy/astropy/issues/1977\n        # A more detailed discussion can be found here:\n        # https://github.com/astropy/astropy/pull/2373\n        #\n        #\n        #                  ### Background ###\n        #\n        #\n        # I will refer here to the [SIP Paper]\n        # (http://fits.gsfc.nasa.gov/registry/sip/SIP_distortion_v1_0.pdf).\n        # According to this paper, the effect of distortions as\n        # described in *their* equation (1) is:\n        #\n        # (1)   x = CD*(u+f(u)),\n        #\n        # where `x` is a *vector* of \"intermediate spherical\n        # coordinates\" (equivalent to (x,y) in the paper) and `u`\n        # is a *vector* of \"pixel coordinates\", and `f` is a vector\n        # function describing geometrical distortions\n        # (see equations 2 and 3 in SIP Paper.\n        # However, I prefer to use `w` for \"intermediate world\n        # coordinates\", `x` for pixel coordinates, and assume that\n        # transformation `W` performs the **linear**\n        # (CD matrix + projection onto celestial sphere) part of the\n        # conversion from pixel coordinates to world coordinates.\n        # Then we can re-write (1) as:\n        #\n        # (2)   w = W*(x+f(x)) = T(x)\n        #\n        # In `astropy.wcs.WCS` transformation `W` is represented by\n        # the `wcs_pix2world` member, while the combined (\"total\")\n        # transformation (linear part + distortions) is performed by\n        # `all_pix2world`. Below I summarize the notations and their\n        # equivalents in `astropy.wcs.WCS`:\n        #\n        # | Equation term | astropy.WCS/meaning          |\n        # | ------------- | ---------------------------- |\n        # | `x`           | pixel coordinates            |\n        # | `w`           | world coordinates            |\n        # | `W`           | `wcs_pix2world()`            |\n        # | `W^{-1}`      | `wcs_world2pix()`            |\n        # | `T`           | `all_pix2world()`            |\n        # | `x+f(x)`      | `pix2foc()`                  |\n        #\n        #\n        #      ### Direct Solving of Equation (2)  ###\n        #\n        #\n        # In order to find the pixel coordinates that correspond to",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 60873,
                "end_index": 63820,
                "start_line": 1704,
                "end_line": 1764,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "@deprecated_renamed_argument(\"accuracy\", \"tolerance\", \"4.3\")\n    def all_world2pix(\n        self,\n        *args,\n        tolerance=1e-4,\n        maxiter=20,\n        adaptive=False,\n        detect_divergence=True,\n        quiet=False,\n        **kwargs,\n    ):\n        if self.wcs is None:\n            raise ValueError(\"No basic WCS settings were created.\")\n\n        return self._array_converter(\n            lambda *args, **kwargs: self._all_world2pix(\n                *args,\n                tolerance=tolerance,\n                maxiter=maxiter,\n                adaptive=adaptive,\n                detect_divergence=detect_divergence,\n                quiet=quiet,\n            ),\n            \"input\",\n            *args,\n            **kwargs,\n        )",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 78192,
                "end_index": 78940,
                "start_line": 2109,
                "end_line": 3796,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Under the hood, there are 3 separate classes that perform different\n# parts of the transformation:\n#\n#    - `~astropy.wcs.Wcsprm`: Is a direct wrapper of the core WCS\n#      functionality in `wcslib`_.  (This includes TPV and TPD\n#      polynomial distortion, but not SIP distortion).\n#\n#    - `~astropy.wcs.Sip`: Handles polynomial distortion as defined in the\n#      `SIP`_ convention.\n#\n#    - `~astropy.wcs.DistortionLookupTable`: Handles `distortion paper`_\n#      lookup tables.\n#\n# Additionally, the class `WCS` aggregates all of these transformations\n# together in a pipeline:\n#\n#    - Detector to image plane correction (by a pair of\n#      `~astropy.wcs.DistortionLookupTable` objects).\n#\n#    - `SIP`_ distortion correction (by an underlying `~astropy.wcs.Sip`\n#      object)\n#\n#    - `distortion paper`_ table-lookup correction (by a pair of\n#      `~astropy.wcs.DistortionLookupTable` objects).\n#\n#    - `wcslib`_ WCS transformation (by a `~astropy.wcs.Wcsprm` object)\n\n# STDLIB\nimport builtins\nimport copy\nimport io\nimport itertools\nimport os\nimport re\nimport textwrap\nimport uuid\nimport warnings\n\n# THIRD-PARTY\nimport numpy as np\nfrom packaging.version import Version\n\n# LOCAL\nfrom astropy import log\nfrom astropy import units as u\nfrom astropy.io import fits\nfrom astropy.utils.decorators import deprecated_renamed_argument\nfrom astropy.utils.exceptions import (\n    AstropyDeprecationWarning,\n    AstropyUserWarning,\n    AstropyWarning,\n)\n\nfrom . import _wcs, docstrings\n\n# Mix-in class that provides the APE 14 API\nfrom .wcsapi.fitswcs import FITSWCSAPIMixin, SlicedFITSWCS\n\n__all__ = [\n    \"FITSFixedWarning\",\n    \"WCS\",\n    \"find_all_wcs\",\n    \"DistortionLookupTable\",\n    \"Sip\",\n    \"Tabprm\",\n    \"Wcsprm\",\n    \"Auxprm\",\n    \"Celprm\",\n    \"Prjprm\",\n    \"Wtbarr\",\n    \"WCSBase\",\n    \"validate\",\n    \"WcsError\",\n    \"SingularMatrixError\",\n    \"InconsistentAxisTypesError\",\n    \"InvalidTransformError\",\n    \"InvalidCoordinateError\",\n    \"InvalidPrjParametersError\",\n    \"NoSolutionError\",\n    \"InvalidSubimageSpecificationError\",\n    \"NoConvergence\",\n    \"NonseparableSubimageCoordinateSystemError\",\n    \"NoWcsKeywordsFoundError\",\n    \"InvalidTabularParametersError\",\n]\n\n\n__doctest_skip__ = [\"WCS.all_world2pix\"]",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 0,
                "end_index": 2297,
                "start_line": 1,
                "end_line": 90,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            },
            {
                "code": "def is_proj_plane_distorted(wcs, maxerr=1.0e-5):\n    r\"\"\"\n    For a WCS returns `False` if square image (detector) pixels stay square\n    when projected onto the \"plane of intermediate world coordinates\"\n    as defined in\n    `Greisen & Calabretta 2002, A&A, 395, 1061 <https://ui.adsabs.harvard.edu/abs/2002A%26A...395.1061G>`_.\n    It will return `True` if transformation from image (detector) coordinates\n    to the focal plane coordinates is non-orthogonal or if WCS contains\n    non-linear (e.g., SIP) distortions.\n\n    .. note::\n        Since this function is concerned **only** about the transformation\n        \"image plane\"->\"focal plane\" and **not** about the transformation\n        \"celestial sphere\"->\"focal plane\"->\"image plane\",\n        this function ignores distortions arising due to non-linear nature\n        of most projections.\n\n    Let's denote by *C* either the original or the reconstructed\n    (from ``PC`` and ``CDELT``) CD matrix. `is_proj_plane_distorted`\n    verifies that the transformation from image (detector) coordinates\n    to the focal plane coordinates is orthogonal using the following\n    check:\n\n    .. math::\n        \\left \\| \\frac{C \\cdot C^{\\mathrm{T}}}\n        {| det(C)|} - I \\right \\|_{\\mathrm{max}} < \\epsilon .\n\n    Parameters\n    ----------\n    wcs : `~astropy.wcs.WCS`\n        World coordinate system object\n\n    maxerr : float, optional\n        Accuracy to which the CD matrix, **normalized** such\n        that :math:`|det(CD)|=1`, should be close to being an\n        orthogonal matrix as described in the above equation\n        (see :math:`\\epsilon`).\n\n    Returns\n    -------\n    distorted : bool\n        Returns `True` if focal (projection) plane is distorted and `False`\n        otherwise.\n\n    \"\"\"\n    cwcs = wcs.celestial\n    return not _is_cd_orthogonal(cwcs.pixel_scale_matrix, maxerr) or _has_distortion(cwcs)  # fmt: skip\n\n\ndef _is_cd_orthogonal(cd, maxerr):\n    shape = cd.shape\n    if not (len(shape) == 2 and shape[0] == shape[1]):\n        raise ValueError(\"CD (or PC) matrix must be a 2D square matrix.\")\n\n    pixarea = np.abs(np.linalg.det(cd))\n    if pixarea == 0.0:\n        raise ValueError(\"CD (or PC) matrix is singular.\")\n\n    # NOTE: Technically, below we should use np.dot(cd, np.conjugate(cd.T))\n    # However, I am not aware of complex CD/PC matrices...\n    I = np.dot(cd, cd.T) / pixarea\n    cd_unitary_err = np.amax(np.abs(I - np.eye(shape[0])))\n\n    return cd_unitary_err < maxerr",
                "filename": "astropy/wcs/utils.py",
                "start_index": 14128,
                "end_index": 16583,
                "start_line": 420,
                "end_line": 483,
                "max_line": 1266,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__4.2",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "astropy/wcs/wcs.py": [
                {
                    "chunk": {
                        "code": "# #  RAISE EXCEPTION IF DIVERGING OR TOO SLOWLY CONVERGING  ##\n        # #  DATA POINTS HAVE BEEN DETECTED:                        ##\n        # ############################################################\n        if (ind is not None or inddiv is not None) and not quiet:\n            if inddiv is None:\n                raise NoConvergence(\n                    \"'WCS.all_world2pix' failed to \"\n                    f\"converge to the requested accuracy after {k:d} \"\n                    \"iterations.\",\n                    best_solution=pix,\n                    accuracy=np.abs(dpix),\n                    niter=k,\n                    slow_conv=ind,\n                    divergent=None,\n                )\n            else:\n                raise NoConvergence(\n                    \"'WCS.all_world2pix' failed to \"\n                    \"converge to the requested accuracy.\\n\"\n                    f\"After {k:d} iterations, the solution is diverging \"\n                    \"at least for one input point.\",\n                    best_solution=pix,\n                    accuracy=np.abs(dpix),\n                    niter=k,\n                    slow_conv=ind,\n                    divergent=inddiv,\n                )\n\n        return pix",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 76972,
                        "end_index": 78186,
                        "start_line": 2079,
                        "end_line": 2107,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the exception raising logic for the 'NoConvergence' error, which is directly related to the issue reported."
                },
                {
                    "chunk": {
                        "code": "@deprecated_renamed_argument(\"accuracy\", \"tolerance\", \"4.3\")\n    def all_world2pix(\n        self,\n        *args,\n        tolerance=1e-4,\n        maxiter=20,\n        adaptive=False,\n        detect_divergence=True,\n        quiet=False,\n        **kwargs,\n    ):\n        if self.wcs is None:\n            raise ValueError(\"No basic WCS settings were created.\")\n\n        return self._array_converter(\n            lambda *args, **kwargs: self._all_world2pix(\n                *args,\n                tolerance=tolerance,\n                maxiter=maxiter,\n                adaptive=adaptive,\n                detect_divergence=detect_divergence,\n                quiet=quiet,\n            ),\n            \"input\",\n            *args,\n            **kwargs,\n        )",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 78192,
                        "end_index": 78940,
                        "start_line": 2109,
                        "end_line": 3796,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the 'all_world2pix' method where the 'quiet' parameter is used, which is relevant to the issue as the user's workaround involved modifying this parameter."
                },
                {
                    "chunk": {
                        "code": "Notes\n        -----\n        The order of the axes for the input world array is determined by\n        the ``CTYPEia`` keywords in the FITS header, therefore it may\n        not always be of the form (*ra*, *dec*).  The\n        `~astropy.wcs.Wcsprm.lat`, `~astropy.wcs.Wcsprm.lng`,\n        `~astropy.wcs.Wcsprm.lattyp`, and\n        `~astropy.wcs.Wcsprm.lngtyp`\n        members can be used to determine the order of the axes.\n\n        Using the method of fixed-point iterations approximations we\n        iterate starting with the initial approximation, which is\n        computed using the non-distortion-aware\n        :py:meth:`wcs_world2pix` (or equivalent).\n\n        The :py:meth:`all_world2pix` function uses a vectorized\n        implementation of the method of consecutive approximations and\n        therefore it is highly efficient (>30x) when *all* data points\n        that need to be converted from sky coordinates to image\n        coordinates are passed at *once*. Therefore, it is advisable,\n        whenever possible, to pass as input a long array of all points\n        that need to be converted to :py:meth:`all_world2pix` instead\n        of calling :py:meth:`all_world2pix` for each data point. Also\n        see the note to the ``adaptive`` parameter.\n\n        Raises\n        ------\n        NoConvergence\n            The method did not converge to a\n            solution to the required accuracy within a specified\n            number of maximum iterations set by the ``maxiter``\n            parameter. To turn off this exception, set ``quiet`` to\n            `True`. Indices of the points for which the requested\n            accuracy was not achieved (if any) will be listed in the\n            ``slow_conv`` attribute of the\n            raised :py:class:`NoConvergence` exception object.\n\n            See :py:class:`NoConvergence` documentation for\n            more details.\n\n        MemoryError\n            Memory allocation failed.\n\n        SingularMatrixError\n            Linear transformation matrix is singular.\n\n        InconsistentAxisTypesError\n            Inconsistent or unrecognized coordinate axis types.\n\n        ValueError\n            Invalid parameter value.\n\n        ValueError\n            Invalid coordinate transformation parameters.\n\n        ValueError\n            x- and y-coordinate arrays are not the same size.\n\n        InvalidTransformError\n            Invalid coordinate transformation parameters.\n\n        InvalidTransformError\n            Ill-conditioned coordinate transformation parameters.\n\n        Examples\n        --------\n        >>> import astropy.io.fits as fits\n        >>> import astropy.wcs as wcs\n        >>> import numpy as np\n        >>> import os\n\n        >>> filename = os.path.join(wcs.__path__[0], 'tests/data/j94f05bgq_flt.fits')\n        >>> hdulist = fits.open(filename)\n        >>> w = wcs.WCS(hdulist[('sci',1)].header, hdulist)\n        >>> hdulist.close()\n\n        >>> ra, dec = w.all_pix2world([1,2,3], [1,1,1], 1)\n        >>> print(ra)  # doctest: +FLOAT_CMP\n        [ 5.52645627  5.52649663  5.52653698]\n        >>> print(dec)  # doctest: +FLOAT_CMP\n        [-72.05171757 -72.05171276 -72.05170795]\n        >>> radec = w.all_pix2world([[1,1], [2,1], [3,1]], 1)\n        >>> print(radec)  # doctest: +FLOAT_CMP\n        [[  5.52645627 -72.05171757]\n         [  5.52649663 -72.05171276]\n         [  5.52653698 -72.05170795]]\n        >>> x, y = w.all_world2pix(ra, dec, 1)\n        >>> print(x)  # doctest: +FLOAT_CMP\n        [ 1.00000238  2.00000237  3.00000236]\n        >>> print(y)  # doctest: +FLOAT_CMP\n        [ 0.99999996  0.99999997  0.99999997]\n        >>> xy = w.all_world2pix(radec, 1)\n        >>> print(xy)  # doctest: +FLOAT_CMP\n        [[ 1.00000238  0.99999996]\n         [ 2.00000237  0.99999997]\n         [ 3.00000236  0.99999997]]\n        >>> xy = w.all_world2pix(radec, 1, maxiter=3,\n        ...                      tolerance=1.0e-10, quiet=False)\n        Traceback (most recent call last):\n        ...\n        NoConvergence: 'WCS.all_world2pix' failed to converge to the\n        requested accuracy. After 3 iterations, the solution is\n        diverging at least for one input point.\n\n        >>> # Now try to use some diverging data:\n        >>> divradec = w.all_pix2world([[1.0, 1.0],\n        ...                             [10000.0, 50000.0],\n        ...                             [3.0, 1.0]], 1)\n        >>> print(divradec)  # doctest: +FLOAT_CMP\n        [[  5.52645627 -72.05171757]\n         [  7.15976932 -70.8140779 ]\n         [  5.52653698 -72.05170795]]\n\n        >>> # First, turn detect_divergence on:\n        >>> try:  # doctest: +FLOAT_CMP\n        ...   xy = w.all_world2pix(divradec, 1, maxiter=20,\n        ...                        tolerance=1.0e-4, adaptive=False,\n        ...                        detect_divergence=True,\n        ...                        quiet=False)\n        ... except wcs.wcs.NoConvergence as e:\n        ...   print(\"Indices of diverging points: {{",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 86424,
                        "end_index": 91388,
                        "start_line": 377,
                        "end_line": 2436,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet provides context on the 'all_world2pix' method, including the 'NoConvergence' exception that can be raised, which is relevant to understanding the issue."
                },
                {
                    "chunk": {
                        "code": "f\"\"\"\n        all_world2pix(*arg, tolerance=1.0e-4, maxiter=20,\n        adaptive=False, detect_divergence=True, quiet=False)\n\n        Transforms world coordinates to pixel coordinates, using\n        numerical iteration to invert the full forward transformation\n        `~astropy.wcs.WCS.all_pix2world` with complete\n        distortion model.\n\n\n        Parameters\n        ----------\n        {docstrings.TWO_OR_MORE_ARGS('naxis', 8)}\n\n            For a transformation that is not two-dimensional, the\n            two-argument form must be used.\n\n        {docstrings.RA_DEC_ORDER(8)}\n\n        tolerance : float, optional (default = 1.0e-4)\n            Tolerance of solution. Iteration terminates when the\n            iterative solver estimates that the \"true solution\" is\n            within this many pixels current estimate, more\n            specifically, when the correction to the solution found\n            during the previous iteration is smaller\n            (in the sense of the L2 norm) than ``tolerance``.\n\n        maxiter : int, optional (default = 20)\n            Maximum number of iterations allowed to reach a solution.\n\n        quiet : bool, optional (default = False)\n            Do not throw :py:class:`NoConvergence` exceptions when\n            the method does not converge to a solution with the\n            required accuracy within a specified number of maximum\n            iterations set by ``maxiter`` parameter. Instead,\n            simply return the found solution.\n\n        Other Parameters\n        ----------------\n        adaptive : bool, optional (default = False)\n            Specifies whether to adaptively select only points that\n            did not converge to a solution within the required\n            accuracy for the next iteration. Default is recommended\n            for HST as well as most other instruments.\n\n            .. note::\n               The :py:meth:`all_world2pix` uses a vectorized\n               implementation of the method of consecutive\n               approximations (see ``Notes`` section below) in which it\n               iterates over *all* input points *regardless* until\n               the required accuracy has been reached for *all* input\n               points. In some cases it may be possible that\n               *almost all* points have reached the required accuracy\n               but there are only a few of input data points for\n               which additional iterations may be needed (this\n               depends mostly on the characteristics of the geometric\n               distortions for a given instrument). In this situation\n               it may be advantageous to set ``adaptive`` = `True` in\n               which case :py:meth:`all_world2pix` will continue\n               iterating *only* over the points that have not yet\n               converged to the required accuracy. However, for the\n               HST's ACS/WFC detector, which has the strongest\n               distortions of all HST instruments, testing has\n               shown that enabling this option would lead to a about\n               50-100% penalty in computational time (depending on\n               specifics of the image, geometric distortions, and\n               number of input points to be converted). Therefore,\n               for HST and possibly instruments, it is recommended\n               to set ``adaptive`` = `False`. The only danger in\n               getting this setting wrong will be a performance\n               penalty.\n\n            .. note::\n               When ``detect_divergence`` is `True`,\n               :py:meth:`all_world2pix` will automatically switch\n               to the adaptive algorithm once divergence has been\n               detected.\n\n        detect_divergence : bool, optional (default = True)\n            Specifies whether to perform a more detailed analysis\n            of the convergence to a solution. Normally\n            :py:meth:`all_world2pix` may not achieve the required\n            accuracy if either the ``tolerance`` or ``maxiter`` arguments\n            are too low. However, it may happen that for some\n            geometric distortions the conditions of convergence for\n            the the method of consecutive approximations used by\n            :py:meth:`all_world2pix` may not be satisfied, in which\n            case consecutive approximations to the solution will\n            diverge regardless of the ``tolerance`` or ``maxiter``\n            settings.\n\n            When ``detect_divergence`` is `False`, these divergent\n            points will be detected as not having achieved the\n            required accuracy (without further details). In addition,\n            if ``adaptive`` is `False` then the algorithm will not\n            know that the solution (for specific points) is diverging\n            and will continue iterating and trying to \"improve\"\n            diverging solutions. This may result in ``NaN`` or\n            ``Inf`` values in the return results (in addition to a\n            performance penalties). Even when ``detect_divergence``\n            is `False`, :py:meth:`all_world2pix`, at the end of the\n            iterative process, will identify invalid results\n            (``NaN`` or ``Inf``) as \"diverging\" solutions and will\n            raise :py:class:`NoConvergence` unless the ``quiet``\n            parameter is set to `True`.\n\n            When ``detect_divergence`` is `True`,\n            :py:meth:`all_world2pix` will detect points for which\n            current correction to the coordinates is larger than\n            the correction applied during the previous iteration\n            **if** the requested accuracy **has not yet been\n            achieved**. In this case, if ``adaptive`` is `True`,\n            these points will be excluded from further iterations and\n            if ``adaptive`` is `False`, :py:meth:`all_world2pix` will\n            automatically switch to the adaptive algorithm. Thus, the\n            reported divergent solution will be the latest converging\n            solution computed immediately *before* divergence\n            has been detected.\n\n            .. note::\n               When accuracy has been achieved, small increases in\n               current corrections may be possible due to rounding\n               errors (when ``adaptive`` is `False`) and such\n               increases will be ignored.\n\n            .. note::\n               Based on our testing using HST ACS/WFC images, setting\n               ``detect_divergence`` to `True` will incur about 5-20%\n               performance penalty with the larger penalty\n               corresponding to ``adaptive`` set to `True`.\n               Because the benefits of enabling this\n               feature outweigh the small performance penalty,\n               especially when ``adaptive`` = `False`, it is\n               recommended to set ``detect_divergence`` to `True`,\n               unless extensive testing of the distortion models for\n               images from specific instruments show a good stability\n               of the numerical method for a wide range of\n               coordinates (even outside the image itself).\n\n            .. note::\n               Indices of the diverging inverse solutions will be\n               reported in the ``divergent`` attribute of the\n               raised :py:class:`NoConvergence` exception object.\n\n        Returns\n        -------\n\n        {docstrings.RETURNS('pixel coordinates', 8)}",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 78970,
                        "end_index": 86414,
                        "start_line": 581,
                        "end_line": 2678,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the documentation for the 'all_world2pix' method, explaining the parameters and their effects, which is relevant to the issue."
                },
                {
                    "chunk": {
                        "code": "def _all_world2pix(\n        self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet\n    ):\n        # ############################################################\n        # #          DESCRIPTION OF THE NUMERICAL METHOD            ##\n        # ############################################################\n        # In this section I will outline the method of solving\n        # the inverse problem of converting world coordinates to\n        # pixel coordinates (*inverse* of the direct transformation\n        # `all_pix2world`) and I will summarize some of the aspects\n        # of the method proposed here and some of the issues of the\n        # original `all_world2pix` (in relation to this method)\n        # discussed in https://github.com/astropy/astropy/issues/1977\n        # A more detailed discussion can be found here:\n        # https://github.com/astropy/astropy/pull/2373\n        #\n        #\n        #                  ### Background ###\n        #\n        #\n        # I will refer here to the [SIP Paper]\n        # (http://fits.gsfc.nasa.gov/registry/sip/SIP_distortion_v1_0.pdf).\n        # According to this paper, the effect of distortions as\n        # described in *their* equation (1) is:\n        #\n        # (1)   x = CD*(u+f(u)),\n        #\n        # where `x` is a *vector* of \"intermediate spherical\n        # coordinates\" (equivalent to (x,y) in the paper) and `u`\n        # is a *vector* of \"pixel coordinates\", and `f` is a vector\n        # function describing geometrical distortions\n        # (see equations 2 and 3 in SIP Paper.\n        # However, I prefer to use `w` for \"intermediate world\n        # coordinates\", `x` for pixel coordinates, and assume that\n        # transformation `W` performs the **linear**\n        # (CD matrix + projection onto celestial sphere) part of the\n        # conversion from pixel coordinates to world coordinates.\n        # Then we can re-write (1) as:\n        #\n        # (2)   w = W*(x+f(x)) = T(x)\n        #\n        # In `astropy.wcs.WCS` transformation `W` is represented by\n        # the `wcs_pix2world` member, while the combined (\"total\")\n        # transformation (linear part + distortions) is performed by\n        # `all_pix2world`. Below I summarize the notations and their\n        # equivalents in `astropy.wcs.WCS`:\n        #\n        # | Equation term | astropy.WCS/meaning          |\n        # | ------------- | ---------------------------- |\n        # | `x`           | pixel coordinates            |\n        # | `w`           | world coordinates            |\n        # | `W`           | `wcs_pix2world()`            |\n        # | `W^{-1}`      | `wcs_world2pix()`            |\n        # | `T`           | `all_pix2world()`            |\n        # | `x+f(x)`      | `pix2foc()`                  |\n        #\n        #\n        #      ### Direct Solving of Equation (2)  ###\n        #\n        #\n        # In order to find the pixel coordinates that correspond to",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 60873,
                        "end_index": 63820,
                        "start_line": 1704,
                        "end_line": 1764,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet outlines the numerical method used by 'all_world2pix', which is relevant to understanding why convergence issues may occur."
                }
            ]
        },
        "solution_task": "- Locate the `all_world2pix` method in the `WCS` class within the `astropy/wcs/wcs.py` file.\n- Modify the method call to include the `quiet=True` parameter to suppress the `NoConvergence` exception.\n- Ensure that the `quiet` parameter is set to `True` in the appropriate method call within the `fitswcs.py` file at line 326, as indicated in the issue description. If the `quiet` parameter is not present, add it to the method call with the value `True`.\n- Since the `quiet` parameter is already part of the `all_world2pix` method signature, no changes to the method definition are required.\n- Save the changes and ensure that the software no longer raises the `NoConvergence` exception when `all_world2pix` is called with `quiet=True`.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the issue described in the PROMPT by suggesting to modify the method call to include the 'quiet=True' parameter, which is the exact workaround the user applied to get a good enough plot. It also correctly identifies the location of the method call in the 'fitswcs.py' file and the method signature in the 'wcs.py' file, which is relevant to the issue. The RESPONSE also includes code snippets from the repository that are relevant to the issue, which can help the user to understand the context of the problem and the solution. However, the RESPONSE does not address the user's desire for a solution that does not involve hacking the library code, which would likely involve a more permanent fix or feature addition to the library. Therefore, the RESPONSE is not complete in addressing all aspects of the issue, which is why it does not score a 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711737517.70366,
        "result": "- Locate the `all_world2pix` method in the `WCS` class within the `astropy/wcs/wcs.py` file.\n- Modify the method call to include the `quiet=True` parameter to suppress the `NoConvergence` exception.\n- Ensure that the `quiet` parameter is set to `True` in the appropriate method call within the `fitswcs.py` file at line 326, as indicated in the issue description. If the `quiet` parameter is not present, add it to the method call with the value `True`.\n- Since the `quiet` parameter is already part of the `all_world2pix` method signature, no changes to the method definition are required.\n- Save the changes and ensure that the software no longer raises the `NoConvergence` exception when `all_world2pix` is called with `quiet=True`.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__4.2/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__4.2/tree//astropy/wcs)- [Lines 2079 - 2107](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L2079-L2107)\n\n This snippet contains the exception raising logic for the 'NoConvergence' error, which is directly related to the issue reported. \n\n\n   - [Lines 2109 - 3796](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L2109-L3796)\n\n This snippet shows the 'all_world2pix' method where the 'quiet' parameter is used, which is relevant to the issue as the user's workaround involved modifying this parameter. \n\n\n   - [Lines 377 - 2436](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L377-L2436)\n\n This snippet provides context on the 'all_world2pix' method, including the 'NoConvergence' exception that can be raised, which is relevant to understanding the issue. \n\n\n   - [Lines 581 - 2678](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L581-L2678)\n\n This snippet includes the documentation for the 'all_world2pix' method, explaining the parameters and their effects, which is relevant to the issue. \n\n\n   - [Lines 1704 - 1764](https://github.com/testbed/astropy__astropy__4.2/blob//astropy/wcs/wcs.py#L1704-L1764)\n\n This snippet outlines the numerical method used by 'all_world2pix', which is relevant to understanding why convergence issues may occur."
    }
}