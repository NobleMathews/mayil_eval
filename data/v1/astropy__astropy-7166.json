{
    "id": "astropy__astropy-7166",
    "repo_name": "testbed/astropy__astropy__1.3",
    "task_id": 5712905581354287145,
    "title": "InheritDocstrings metaclass doesn't work for properties",
    "body": "Inside the InheritDocstrings metaclass it uses `inspect.isfunction` which returns `False` for properties.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__1.3.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `InheritDocstrings` metaclass to handle properties correctly by checking for properties using `inspect.isdatadescriptor` instead of `inspect.isfunction`.\n- In the `__new__` method of the `InheritDocstrings` metaclass, iterate over the items in the `namespace` dictionary.\n- For each item, check if it is a property using `inspect.isdatadescriptor(item)`.\n- If it is a property, inherit the docstring from the base classes as needed.\n\n```python\nimport inspect\n\nclass InheritDocstrings(type):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        for attr_name, attr_value in namespace.items():\n            if inspect.isdatadescriptor(attr_value):\n                for base in bases:\n                    if hasattr(base, attr_name):\n                        base_attr = getattr(base, attr_name)\n                        if not attr_value.__doc__:\n                            attr_value.__doc__ = base_attr.__doc__\n                        break\n        return super().__new__(mcs, name, bases, namespace, **kwargs)\n```\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [utils](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/utils)- [Lines 1 - 29](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L1-L29)\n\n This snippet imports 'inspect' which is mentioned in the issue description. The issue might be related to the use of 'inspect.isfunction' which could be found in this file. \n\n\n   - [Lines 2 - 1120](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L2-L1120)\n\n This snippet describes the 'classproperty' decorator and mentions the use of a metaclass for implementing modifiable class-level properties, which is relevant to the issue regarding the InheritDocstrings metaclass. \n\n\n   - [Lines 709 - 781](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L709-L781)\n\n This snippet contains the implementation of a property-like descriptor which might be relevant for understanding how properties are currently handled and how they might be affected by the metaclass in question. \n\n\n   - [Lines 784 - 857](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L784-L857)\n\n This snippet defines 'lazyproperty', which is a property-like descriptor. It could be relevant to understand how properties are implemented and how the metaclass might interact with them.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002895,
        "snippet_processor": 0.10317000000000001,
        "issue_star_creation": 0.01988,
        "issue_star_solver": 0.07297000000000001,
        "bouncer": 0.023039999999999998
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711737693.684787,
        "relevant_snippets": [
            {
                "code": "# Instead of a custom property use the MetaData descriptor also used for\n    # Tables. It will check if the meta is dict-like or raise an exception.\n    meta = MetaData(doc=_meta_doc, copy=False)",
                "filename": "astropy/nddata/nddata.py",
                "start_index": 4235,
                "end_index": 4430,
                "start_line": 126,
                "end_line": 128,
                "max_line": 409,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "class classproperty(property):",
                "filename": "astropy/utils/decorators.py",
                "start_index": 21512,
                "end_index": 21542,
                "start_line": 612,
                "end_line": 612,
                "max_line": 1149,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "# TODO: This can still be made to work for setters by implementing an\n# accompanying metaclass that supports it; we just don't need that right this\n# second",
                "filename": "astropy/utils/decorators.py",
                "start_index": 21355,
                "end_index": 21511,
                "start_line": 609,
                "end_line": 611,
                "max_line": 1149,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "def __new__(cls, fget=None, doc=None, lazy=False):\n        if fget is None:\n            # Being used as a decorator--return a wrapper that implements\n            # decorator syntax\n            def wrapper(func):\n                return cls(func, lazy=lazy)\n\n            return wrapper\n\n        return super().__new__(cls)\n\n    def __init__(self, fget, doc=None, lazy=False):\n        self._lazy = lazy\n        if lazy:\n            self._lock = threading.RLock()  # Protects _cache\n            self._cache = {}\n        fget = self._wrap_fget(fget)\n\n        super().__init__(fget=fget, doc=doc)\n\n        # There is a buglet in Python where self.__doc__ doesn't\n        # get set properly on instances of property subclasses if\n        # the doc argument was used rather than taking the docstring\n        # from fget\n        # Related Python issue: https://bugs.python.org/issue24766\n        if doc is not None:\n            self.__doc__ = doc\n\n    def __get__(self, obj, objtype):\n        if self._lazy:\n            val = self._cache.get(objtype, _NotFound)\n            if val is _NotFound:\n                with self._lock:\n                    # Check if another thread initialised before we locked.\n                    val = self._cache.get(objtype, _NotFound)\n                    if val is _NotFound:\n                        val = self.fget.__wrapped__(objtype)\n                        self._cache[objtype] = val\n        else:\n            # The base property.__get__ will just return self here;\n            # instead we pass objtype through to the original wrapped\n            # function (which takes the class as its sole argument)\n            val = self.fget.__wrapped__(objtype)\n        return val\n\n    def getter(self, fget):\n        return super().getter(self._wrap_fget(fget))\n\n    def setter(self, fset):\n        raise NotImplementedError(\n            \"classproperty can only be read-only; use a metaclass to \"\n            \"implement modifiable class-level properties\"\n        )\n\n    def deleter(self, fdel):\n        raise NotImplementedError(\n            \"classproperty can only be read-only; use a metaclass to \"\n            \"implement modifiable class-level properties\"\n        )\n\n    @staticmethod\n    def _wrap_fget(orig_fget):\n        if isinstance(orig_fget, classmethod):\n            orig_fget = orig_fget.__func__\n\n        # Using stock functools.wraps instead of the fancier version\n        # found later in this module, which is overkill for this purpose\n\n        @functools.wraps(orig_fget)\n        def fget(obj):\n            return orig_fget(obj.__class__)\n\n        return fget",
                "filename": "astropy/utils/decorators.py",
                "start_index": 24654,
                "end_index": 27248,
                "start_line": 709,
                "end_line": 781,
                "max_line": 1149,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\"\"\"Sundry function and class decorators.\"\"\"\n\n\nimport functools\nimport inspect\nimport textwrap\nimport threading\nimport types\nimport warnings\nfrom inspect import signature\n\nfrom .exceptions import (\n    AstropyDeprecationWarning,\n    AstropyPendingDeprecationWarning,\n    AstropyUserWarning,\n)\n\n__all__ = [\n    \"classproperty\",\n    \"deprecated\",\n    \"deprecated_attribute\",\n    \"deprecated_renamed_argument\",\n    \"format_doc\",\n    \"lazyproperty\",\n    \"sharedmethod\",\n]\n\n_NotFound = object()",
                "filename": "astropy/utils/decorators.py",
                "start_index": 0,
                "end_index": 552,
                "start_line": 1,
                "end_line": 29,
                "max_line": 1149,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "for prop in islice(SUPPORTED_PROPERTIES, 1, None):\n                    # We only need to do something if the property exists on\n                    # the NDData object\n                    try:\n                        value = getattr(data, prop)\n                    except AttributeError:\n                        continue\n                    # Skip if the property exists but is None or empty.\n                    if prop == \"meta\" and not value:\n                        continue\n                    elif value is None:\n                        continue\n                    # Warn if the property is set but not used by the function.\n                    propmatch = attr_arg_map.get(prop, prop)\n                    if propmatch not in func_kwargs:\n                        ignored.append(prop)\n                        continue\n\n                    # Check if the property was explicitly given and issue a\n                    # Warning if it is.\n                    if propmatch in bound_args.arguments:\n                        # If it's in the func_args it's trivial but if it was\n                        # in the func_kwargs we need to compare it to the\n                        # default.\n                        # Comparison to the default is done by comparing their\n                        # identity, this works because defaults in function\n                        # signatures are only created once and always reference\n                        # the same item.\n                        # FIXME: Python interns some values, for example the\n                        # integers from -5 to 255 (any maybe some other types\n                        # as well). In that case the default is\n                        # indistinguishable from an explicitly passed kwarg\n                        # and it won't notice that and use the attribute of the\n                        # NDData.\n                        if propmatch in func_args or (\n                            propmatch in func_kwargs\n                            and (\n                                bound_args.arguments[propmatch]\n                                is not sig[propmatch].default\n                            )\n                        ):\n                            warnings.warn(\n                                \"Property {} has been passed explicitly and \"\n                                \"as an NDData property{}, using explicitly \"\n                                \"specified value\"\n                                \"\".format(\n                                    propmatch, \"\" if prop == propmatch else \" \" + prop\n                                ),\n                                AstropyUserWarning,\n                            )\n                            continue\n                    # Otherwise use the property as input for the function.\n                    kwargs[propmatch] = value\n                # Finally, replace data by the data attribute\n                data = data.data",
                "filename": "astropy/nddata/decorators.py",
                "start_index": 7106,
                "end_index": 10051,
                "start_line": 197,
                "end_line": 251,
                "max_line": 294,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Similar to `property`, but allows class-level properties.  That is,\n    a property whose getter is like a `classmethod`.\n\n    The wrapped method may explicitly use the `classmethod` decorator (which\n    must become before this decorator), or the `classmethod` may be omitted\n    (it is implicit through use of this decorator).\n\n    .. note::\n\n        classproperty only works for *read-only* properties.  It does not\n        currently allow writeable/deletable properties, due to subtleties of how\n        Python descriptors work.  In order to implement such properties on a class\n        a metaclass for that class must be implemented.\n\n    Parameters\n    ----------\n    fget : callable\n        The function that computes the value of this property (in particular,\n        the function when this is used as a decorator) a la `property`.\n\n    doc : str, optional\n        The docstring for the property--by default inherited from the getter\n        function.\n\n    lazy : bool, optional\n        If True, caches the value returned by the first call to the getter\n        function, so that it is only called once (used for lazy evaluation\n        of an attribute).  This is analogous to `lazyproperty`.  The ``lazy``\n        argument can also be used when `classproperty` is used as a decorator\n        (see the third example below).  When used in the decorator syntax this\n        *must* be passed in as a keyword argument.\n\n    Examples\n    --------\n    ::\n\n        >>> class Foo:\n        ...     _bar_internal = 1\n        ...     @classproperty\n        ...     def bar(cls):\n        ...         return cls._bar_internal + 1\n        ...\n        >>> Foo.bar\n        2\n        >>> foo_instance = Foo()\n        >>> foo_instance.bar\n        2\n        >>> foo_instance._bar_internal = 2\n        >>> foo_instance.bar  # Ignores instance attributes\n        2\n\n    As previously noted, a `classproperty` is limited to implementing\n    read-only attributes::\n\n        >>> class Foo:\n        ...     _bar_internal = 1\n        ...     @classproperty\n        ...     def bar(cls):\n        ...         return cls._bar_internal\n        ...     @bar.setter\n        ...     def bar(cls, value):\n        ...         cls._bar_internal = value\n        ...\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: classproperty can only be read-only; use a\n        metaclass to implement modifiable class-level properties\n\n    When the ``lazy`` option is used, the getter is only called once::\n\n        >>> class Foo:\n        ...     @classproperty(lazy=True)\n        ...     def bar(cls):\n        ...         print(\"Performing complicated calculation\")\n        ...         return 1\n        ...\n        >>> Foo.bar\n        Performing complicated calculation\n        1\n        >>> Foo.bar\n        1\n\n    If a subclass inherits a lazy `classproperty` the property is still\n    re-evaluated for the subclass::\n\n        >>> class FooSub(Foo):\n        ...     pass\n        ...\n        >>> FooSub.bar\n        Performing complicated calculation\n        1\n        >>> FooSub.bar\n        1\n    \"\"\"",
                "filename": "astropy/utils/decorators.py",
                "start_index": 21547,
                "end_index": 24648,
                "start_line": 2,
                "end_line": 1120,
                "max_line": 1149,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "# -----------------------------------------------------------------------------\n\n\nclass UnifiedReadWriteMethod(property):\n    \"\"\"Descriptor class for creating read() and write() methods in unified I/O.\n\n    The canonical example is in the ``Table`` class, where the ``connect.py``\n    module creates subclasses of the ``UnifiedReadWrite`` class.  These have\n    custom ``__call__`` methods that do the setup work related to calling the\n    registry read() or write() functions.  With this, the ``Table`` class\n    defines read and write methods as follows::\n\n      read = UnifiedReadWriteMethod(TableRead)\n      write = UnifiedReadWriteMethod(TableWrite)\n\n    Parameters\n    ----------\n    func : `~astropy.io.registry.UnifiedReadWrite` subclass\n        Class that defines read or write functionality\n\n    \"\"\"\n\n    # We subclass property to ensure that __set__ is defined and that,\n    # therefore, we are a data descriptor, which cannot be overridden.\n    # This also means we automatically inherit the __doc__ of fget (which will\n    # be a UnifiedReadWrite subclass), and that this docstring gets recognized\n    # and properly typeset by sphinx (which was previously an issue; see\n    # gh-11554).\n    # We override __get__ to pass both instance and class to UnifiedReadWrite.\n    def __get__(self, instance, owner_cls):\n        return self.fget(instance, owner_cls)",
                "filename": "astropy/io/registry/interface.py",
                "start_index": 4163,
                "end_index": 5532,
                "start_line": 12,
                "end_line": 156,
                "max_line": 156,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "# Adapted from the recipe at\n# http://code.activestate.com/recipes/363602-lazy-property-evaluation\nclass lazyproperty(property):\n    \"\"\"\n    Works similarly to property(), but computes the value only once.\n\n    This essentially memorizes the value of the property by storing the result\n    of its computation in the ``__dict__`` of the object instance.  This is\n    useful for computing the value of some property that should otherwise be\n    invariant.  For example::\n\n        >>> class LazyTest:\n        ...     @lazyproperty\n        ...     def complicated_property(self):\n        ...         print('Computing the value for complicated_property...')\n        ...         return 42\n        ...\n        >>> lt = LazyTest()\n        >>> lt.complicated_property\n        Computing the value for complicated_property...\n        42\n        >>> lt.complicated_property\n        42\n\n    As the example shows, the second time ``complicated_property`` is accessed,\n    the ``print`` statement is not executed.  Only the return value from the\n    first access off ``complicated_property`` is returned.\n\n    By default, a setter and deleter are used which simply overwrite and\n    delete, respectively, the value stored in ``__dict__``. Any user-specified\n    setter or deleter is executed before executing these default actions.\n    The one exception is that the default setter is not run if the user setter\n    already sets the new value in ``__dict__`` and returns that value and the\n    returned value is not ``None``.\n\n    \"\"\"\n\n    def __init__(self, fget, fset=None, fdel=None, doc=None):\n        super().__init__(fget, fset, fdel, doc)\n        self._key = self.fget.__name__\n        self._lock = threading.RLock()\n\n    def __get__(self, obj, owner=None):\n        try:\n            obj_dict = obj.__dict__\n            val = obj_dict.get(self._key, _NotFound)\n            if val is _NotFound:\n                with self._lock:\n                    # Check if another thread beat us to it.\n                    val = obj_dict.get(self._key, _NotFound)\n                    if val is _NotFound:\n                        val = self.fget(obj)\n                        obj_dict[self._key] = val\n            return val\n        except AttributeError:\n            if obj is None:\n                return self\n            raise\n\n    def __set__(self, obj, val):\n        obj_dict = obj.__dict__\n        if self.fset:\n            ret = self.fset(obj, val)\n            if ret is not None and obj_dict.get(self._key) is ret:\n                # By returning the value set the setter signals that it\n                # took over setting the value in obj.__dict__; this\n                # mechanism allows it to override the input value\n                return\n        obj_dict[self._key] = val\n\n    def __delete__(self, obj):\n        if self.fdel:\n            self.fdel(obj)\n        obj.__dict__.pop(self._key, None)  # Delete if present",
                "filename": "astropy/utils/decorators.py",
                "start_index": 27251,
                "end_index": 30153,
                "start_line": 784,
                "end_line": 857,
                "max_line": 1149,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            },
            {
                "code": "if unpack:\n                # We loop over a list of pre-defined properties",
                "filename": "astropy/nddata/decorators.py",
                "start_index": 7015,
                "end_index": 7089,
                "start_line": 195,
                "end_line": 196,
                "max_line": 294,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__1.3",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "astropy/utils/decorators.py": [
                {
                    "chunk": {
                        "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\"\"\"Sundry function and class decorators.\"\"\"\n\n\nimport functools\nimport inspect\nimport textwrap\nimport threading\nimport types\nimport warnings\nfrom inspect import signature\n\nfrom .exceptions import (\n    AstropyDeprecationWarning,\n    AstropyPendingDeprecationWarning,\n    AstropyUserWarning,\n)\n\n__all__ = [\n    \"classproperty\",\n    \"deprecated\",\n    \"deprecated_attribute\",\n    \"deprecated_renamed_argument\",\n    \"format_doc\",\n    \"lazyproperty\",\n    \"sharedmethod\",\n]\n\n_NotFound = object()",
                        "filename": "astropy/utils/decorators.py",
                        "start_index": 0,
                        "end_index": 552,
                        "start_line": 1,
                        "end_line": 29,
                        "max_line": 1149,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet imports 'inspect' which is mentioned in the issue description. The issue might be related to the use of 'inspect.isfunction' which could be found in this file."
                },
                {
                    "chunk": {
                        "code": "\"\"\"\n    Similar to `property`, but allows class-level properties.  That is,\n    a property whose getter is like a `classmethod`.\n\n    The wrapped method may explicitly use the `classmethod` decorator (which\n    must become before this decorator), or the `classmethod` may be omitted\n    (it is implicit through use of this decorator).\n\n    .. note::\n\n        classproperty only works for *read-only* properties.  It does not\n        currently allow writeable/deletable properties, due to subtleties of how\n        Python descriptors work.  In order to implement such properties on a class\n        a metaclass for that class must be implemented.\n\n    Parameters\n    ----------\n    fget : callable\n        The function that computes the value of this property (in particular,\n        the function when this is used as a decorator) a la `property`.\n\n    doc : str, optional\n        The docstring for the property--by default inherited from the getter\n        function.\n\n    lazy : bool, optional\n        If True, caches the value returned by the first call to the getter\n        function, so that it is only called once (used for lazy evaluation\n        of an attribute).  This is analogous to `lazyproperty`.  The ``lazy``\n        argument can also be used when `classproperty` is used as a decorator\n        (see the third example below).  When used in the decorator syntax this\n        *must* be passed in as a keyword argument.\n\n    Examples\n    --------\n    ::\n\n        >>> class Foo:\n        ...     _bar_internal = 1\n        ...     @classproperty\n        ...     def bar(cls):\n        ...         return cls._bar_internal + 1\n        ...\n        >>> Foo.bar\n        2\n        >>> foo_instance = Foo()\n        >>> foo_instance.bar\n        2\n        >>> foo_instance._bar_internal = 2\n        >>> foo_instance.bar  # Ignores instance attributes\n        2\n\n    As previously noted, a `classproperty` is limited to implementing\n    read-only attributes::\n\n        >>> class Foo:\n        ...     _bar_internal = 1\n        ...     @classproperty\n        ...     def bar(cls):\n        ...         return cls._bar_internal\n        ...     @bar.setter\n        ...     def bar(cls, value):\n        ...         cls._bar_internal = value\n        ...\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: classproperty can only be read-only; use a\n        metaclass to implement modifiable class-level properties\n\n    When the ``lazy`` option is used, the getter is only called once::\n\n        >>> class Foo:\n        ...     @classproperty(lazy=True)\n        ...     def bar(cls):\n        ...         print(\"Performing complicated calculation\")\n        ...         return 1\n        ...\n        >>> Foo.bar\n        Performing complicated calculation\n        1\n        >>> Foo.bar\n        1\n\n    If a subclass inherits a lazy `classproperty` the property is still\n    re-evaluated for the subclass::\n\n        >>> class FooSub(Foo):\n        ...     pass\n        ...\n        >>> FooSub.bar\n        Performing complicated calculation\n        1\n        >>> FooSub.bar\n        1\n    \"\"\"",
                        "filename": "astropy/utils/decorators.py",
                        "start_index": 21547,
                        "end_index": 24648,
                        "start_line": 2,
                        "end_line": 1120,
                        "max_line": 1149,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet describes the 'classproperty' decorator and mentions the use of a metaclass for implementing modifiable class-level properties, which is relevant to the issue regarding the InheritDocstrings metaclass."
                },
                {
                    "chunk": {
                        "code": "def __new__(cls, fget=None, doc=None, lazy=False):\n        if fget is None:\n            # Being used as a decorator--return a wrapper that implements\n            # decorator syntax\n            def wrapper(func):\n                return cls(func, lazy=lazy)\n\n            return wrapper\n\n        return super().__new__(cls)\n\n    def __init__(self, fget, doc=None, lazy=False):\n        self._lazy = lazy\n        if lazy:\n            self._lock = threading.RLock()  # Protects _cache\n            self._cache = {}\n        fget = self._wrap_fget(fget)\n\n        super().__init__(fget=fget, doc=doc)\n\n        # There is a buglet in Python where self.__doc__ doesn't\n        # get set properly on instances of property subclasses if\n        # the doc argument was used rather than taking the docstring\n        # from fget\n        # Related Python issue: https://bugs.python.org/issue24766\n        if doc is not None:\n            self.__doc__ = doc\n\n    def __get__(self, obj, objtype):\n        if self._lazy:\n            val = self._cache.get(objtype, _NotFound)\n            if val is _NotFound:\n                with self._lock:\n                    # Check if another thread initialised before we locked.\n                    val = self._cache.get(objtype, _NotFound)\n                    if val is _NotFound:\n                        val = self.fget.__wrapped__(objtype)\n                        self._cache[objtype] = val\n        else:\n            # The base property.__get__ will just return self here;\n            # instead we pass objtype through to the original wrapped\n            # function (which takes the class as its sole argument)\n            val = self.fget.__wrapped__(objtype)\n        return val\n\n    def getter(self, fget):\n        return super().getter(self._wrap_fget(fget))\n\n    def setter(self, fset):\n        raise NotImplementedError(\n            \"classproperty can only be read-only; use a metaclass to \"\n            \"implement modifiable class-level properties\"\n        )\n\n    def deleter(self, fdel):\n        raise NotImplementedError(\n            \"classproperty can only be read-only; use a metaclass to \"\n            \"implement modifiable class-level properties\"\n        )\n\n    @staticmethod\n    def _wrap_fget(orig_fget):\n        if isinstance(orig_fget, classmethod):\n            orig_fget = orig_fget.__func__\n\n        # Using stock functools.wraps instead of the fancier version\n        # found later in this module, which is overkill for this purpose\n\n        @functools.wraps(orig_fget)\n        def fget(obj):\n            return orig_fget(obj.__class__)\n\n        return fget",
                        "filename": "astropy/utils/decorators.py",
                        "start_index": 24654,
                        "end_index": 27248,
                        "start_line": 709,
                        "end_line": 781,
                        "max_line": 1149,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of a property-like descriptor which might be relevant for understanding how properties are currently handled and how they might be affected by the metaclass in question."
                },
                {
                    "chunk": {
                        "code": "# Adapted from the recipe at\n# http://code.activestate.com/recipes/363602-lazy-property-evaluation\nclass lazyproperty(property):\n    \"\"\"\n    Works similarly to property(), but computes the value only once.\n\n    This essentially memorizes the value of the property by storing the result\n    of its computation in the ``__dict__`` of the object instance.  This is\n    useful for computing the value of some property that should otherwise be\n    invariant.  For example::\n\n        >>> class LazyTest:\n        ...     @lazyproperty\n        ...     def complicated_property(self):\n        ...         print('Computing the value for complicated_property...')\n        ...         return 42\n        ...\n        >>> lt = LazyTest()\n        >>> lt.complicated_property\n        Computing the value for complicated_property...\n        42\n        >>> lt.complicated_property\n        42\n\n    As the example shows, the second time ``complicated_property`` is accessed,\n    the ``print`` statement is not executed.  Only the return value from the\n    first access off ``complicated_property`` is returned.\n\n    By default, a setter and deleter are used which simply overwrite and\n    delete, respectively, the value stored in ``__dict__``. Any user-specified\n    setter or deleter is executed before executing these default actions.\n    The one exception is that the default setter is not run if the user setter\n    already sets the new value in ``__dict__`` and returns that value and the\n    returned value is not ``None``.\n\n    \"\"\"\n\n    def __init__(self, fget, fset=None, fdel=None, doc=None):\n        super().__init__(fget, fset, fdel, doc)\n        self._key = self.fget.__name__\n        self._lock = threading.RLock()\n\n    def __get__(self, obj, owner=None):\n        try:\n            obj_dict = obj.__dict__\n            val = obj_dict.get(self._key, _NotFound)\n            if val is _NotFound:\n                with self._lock:\n                    # Check if another thread beat us to it.\n                    val = obj_dict.get(self._key, _NotFound)\n                    if val is _NotFound:\n                        val = self.fget(obj)\n                        obj_dict[self._key] = val\n            return val\n        except AttributeError:\n            if obj is None:\n                return self\n            raise\n\n    def __set__(self, obj, val):\n        obj_dict = obj.__dict__\n        if self.fset:\n            ret = self.fset(obj, val)\n            if ret is not None and obj_dict.get(self._key) is ret:\n                # By returning the value set the setter signals that it\n                # took over setting the value in obj.__dict__; this\n                # mechanism allows it to override the input value\n                return\n        obj_dict[self._key] = val\n\n    def __delete__(self, obj):\n        if self.fdel:\n            self.fdel(obj)\n        obj.__dict__.pop(self._key, None)  # Delete if present",
                        "filename": "astropy/utils/decorators.py",
                        "start_index": 27251,
                        "end_index": 30153,
                        "start_line": 784,
                        "end_line": 857,
                        "max_line": 1149,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines 'lazyproperty', which is a property-like descriptor. It could be relevant to understand how properties are implemented and how the metaclass might interact with them."
                }
            ]
        },
        "solution_task": "- Modify the `InheritDocstrings` metaclass to handle properties correctly by checking for properties using `inspect.isdatadescriptor` instead of `inspect.isfunction`.\n- In the `__new__` method of the `InheritDocstrings` metaclass, iterate over the items in the `namespace` dictionary.\n- For each item, check if it is a property using `inspect.isdatadescriptor(item)`.\n- If it is a property, inherit the docstring from the base classes as needed.\n\n```python\nimport inspect\n\nclass InheritDocstrings(type):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        for attr_name, attr_value in namespace.items():\n            if inspect.isdatadescriptor(attr_value):\n                for base in bases:\n                    if hasattr(base, attr_name):\n                        base_attr = getattr(base, attr_name)\n                        if not attr_value.__doc__:\n                            attr_value.__doc__ = base_attr.__doc__\n                        break\n        return super().__new__(mcs, name, bases, namespace, **kwargs)\n```",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT. It correctly identifies that `inspect.isfunction` does not work for properties and suggests using `inspect.isdatadescriptor` to check for properties instead. The provided code snippet is a direct implementation of the suggested solution, which is likely to resolve the issue with the `InheritDocstrings` metaclass not working for properties. The RESPONSE also includes a thoughtful approach to inheriting docstrings from base classes for properties, which is the core functionality desired from the metaclass. Additionally, the RESPONSE provides relevant code snippets from the astropy project that could be affected by the issue and may need to be reviewed in light of the proposed solution. The RESPONSE is comprehensive and addresses the issue with a high level of specificity.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711737783.750161,
        "result": "- Modify the `InheritDocstrings` metaclass to handle properties correctly by checking for properties using `inspect.isdatadescriptor` instead of `inspect.isfunction`.\n- In the `__new__` method of the `InheritDocstrings` metaclass, iterate over the items in the `namespace` dictionary.\n- For each item, check if it is a property using `inspect.isdatadescriptor(item)`.\n- If it is a property, inherit the docstring from the base classes as needed.\n\n```python\nimport inspect\n\nclass InheritDocstrings(type):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        for attr_name, attr_value in namespace.items():\n            if inspect.isdatadescriptor(attr_value):\n                for base in bases:\n                    if hasattr(base, attr_name):\n                        base_attr = getattr(base, attr_name)\n                        if not attr_value.__doc__:\n                            attr_value.__doc__ = base_attr.__doc__\n                        break\n        return super().__new__(mcs, name, bases, namespace, **kwargs)\n```\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__1.3/tree//astropy) \u2192 [utils](https://github.com/testbed/astropy__astropy__1.3/tree//astropy/utils)- [Lines 1 - 29](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L1-L29)\n\n This snippet imports 'inspect' which is mentioned in the issue description. The issue might be related to the use of 'inspect.isfunction' which could be found in this file. \n\n\n   - [Lines 2 - 1120](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L2-L1120)\n\n This snippet describes the 'classproperty' decorator and mentions the use of a metaclass for implementing modifiable class-level properties, which is relevant to the issue regarding the InheritDocstrings metaclass. \n\n\n   - [Lines 709 - 781](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L709-L781)\n\n This snippet contains the implementation of a property-like descriptor which might be relevant for understanding how properties are currently handled and how they might be affected by the metaclass in question. \n\n\n   - [Lines 784 - 857](https://github.com/testbed/astropy__astropy__1.3/blob//astropy/utils/decorators.py#L784-L857)\n\n This snippet defines 'lazyproperty', which is a property-like descriptor. It could be relevant to understand how properties are implemented and how the metaclass might interact with them."
    }
}