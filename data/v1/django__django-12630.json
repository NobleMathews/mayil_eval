{
    "id": "django__django-12630",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 7379815500896162693,
    "title": "Add --check flag to migrate.",
    "body": "Description\n\t \n\t\t(last modified by thenewguy)\n\t \nIt would be helpful if there was a flag for migrate that acted similar to makemigrations --check that could be used to stop CI from deploying an application automatically when unapplied migrations exist.\nThis is different from makemigrations --check because the new command flag would tell us if we need to *run* any migrations where as makemigrations --check tells us if we need to *create* any migrations.\nOne currently needs to parse output. It seems like this would be universally useful.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the `--check` flag for the `migrate` command in Django, you can follow these steps:\n\n- Modify the `migrate` command to accept the new `--check` flag.\n- Implement logic to check for unapplied migrations when the `--check` flag is used.\n- Exit with a non-zero status code if unapplied migrations are found.\n\nHere's a high-level overview of the changes needed in the `django/core/management/commands/migrate.py` file:\n\n```python\nfrom django.core.management.base import BaseCommand\nfrom django.db.migrations.executor import MigrationExecutor\nfrom django.db import connections, DEFAULT_DB_ALIAS\n\nclass Command(BaseCommand):\n    # ... existing code ...\n\n    def add_arguments(self, parser):\n        # ... existing code ...\n        parser.add_argument(\n            \"--check\",\n            action=\"store_true\",\n            dest=\"check_unapplied\",\n            help=(\n                \"Exits with a non-zero status if unapplied migrations exist and does \"\n                \"not actually apply migrations.\"\n            ),\n        )\n        # ... existing code ...\n\n    def handle(self, *args, **options):\n        # ... existing code ...\n\n        # Add logic to handle the --check flag\n        if options['check_unapplied']:\n            self.check_unapplied_migrations(options['database'])\n\n        # ... existing code ...\n\n    def check_unapplied_migrations(self, database):\n        connection = connections[database]\n        executor = MigrationExecutor(connection)\n        targets = executor.loader.graph.leaf_nodes()\n\n        # Check if there are any unapplied migrations\n        unapplied_migrations = executor.migration_plan(targets)\n        if unapplied_migrations:\n            self.stdout.write(self.style.ERROR(\"Unapplied migrations detected.\"))\n            sys.exit(1)\n        else:\n            self.stdout.write(self.style.SUCCESS(\"No unapplied migrations found.\"))\n```\n\nIn this implementation:\n\n- A new argument `--check` is added to the `migrate` command's argument parser.\n- A new method `check_unapplied_migrations` is defined to check for unapplied migrations.\n- The `MigrationExecutor` is used to determine if there are any migrations that have not been applied yet.\n- If unapplied migrations are found, the command prints an error message and exits with a non-zero status code.\n- If no unapplied migrations are found, a success message is printed.\n\nThis feature would be useful for Continuous Integration (CI) systems to prevent automatic deployment if there are pending migrations that need to be applied.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [management](https://github.com/testbed/django__django__3.1/tree//django/core/management) \u2192 [commands](https://github.com/testbed/django__django__3.1/tree//django/core/management/commands)- [Lines 18 - 482](https://github.com/testbed/django__django__3.1/blob//django/core/management/commands/migrate.py#L18-L482)\n\n This snippet from 'migrate.py' shows the command line argument parsing for the 'migrate' command, including the addition of a new '--check' flag that is relevant to the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005205,
        "snippet_processor": 0.056010000000000004,
        "issue_star_creation": 0.02105,
        "issue_star_solver": 0.06346,
        "bouncer": 0.02602
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711731137.460902,
        "relevant_snippets": [
            {
                "code": "for migration in app_migrations:\n                # Describe the migration",
                "filename": "django/core/management/commands/makemigrations.py",
                "start_index": 13742,
                "end_index": 13815,
                "start_line": 299,
                "end_line": 341,
                "max_line": 513,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from django.apps import apps\nfrom django.core import checks\nfrom django.core.checks.registry import registry\nfrom django.core.management.base import BaseCommand, CommandError\n\n\nclass Command(BaseCommand):\n    help = \"Checks the entire Django project for potential problems.\"\n\n    requires_system_checks = []\n\n    def add_arguments(self, parser):\n        parser.add_argument(\"args\", metavar=\"app_label\", nargs=\"*\")\n        parser.add_argument(\n            \"--tag\",\n            \"-t\",\n            action=\"append\",\n            dest=\"tags\",\n            help=\"Run only checks labeled with given tag.\",\n        )\n        parser.add_argument(\n            \"--list-tags\",\n            action=\"store_true\",\n            help=\"List available tags.\",\n        )\n        parser.add_argument(\n            \"--deploy\",\n            action=\"store_true\",\n            help=\"Check deployment settings.\",\n        )\n        parser.add_argument(\n            \"--fail-level\",\n            default=\"ERROR\",\n            choices=[\"CRITICAL\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"],\n            help=(\n                \"Message level that will cause the command to exit with a \"\n                \"non-zero status. Default is ERROR.\"\n            ),\n        )\n        parser.add_argument(\n            \"--database\",\n            action=\"append\",\n            dest=\"databases\",\n            help=\"Run database related checks against these aliases.\",\n        )\n\n    def handle(self, *app_labels, **options):\n        include_deployment_checks = options[\"deploy\"]\n        if options[\"list_tags\"]:\n            self.stdout.write(\n                \"\\n\".join(sorted(registry.tags_available(include_deployment_checks)))\n            )\n            return\n\n        if app_labels:\n            app_configs = [apps.get_app_config(app_label) for app_label in app_labels]\n        else:\n            app_configs = None\n\n        tags = options[\"tags\"]\n        if tags:\n            try:\n                invalid_tag = next(\n                    tag\n                    for tag in tags\n                    if not checks.tag_exists(tag, include_deployment_checks)\n                )\n            except StopIteration:\n                # no invalid tags\n                pass\n            else:\n                raise CommandError(\n                    'There is no system check with the \"%s\" tag.' % invalid_tag\n                )\n\n        self.check(\n            app_configs=app_configs,\n            tags=tags,\n            display_num_errors=True,\n            include_deployment_checks=include_deployment_checks,\n            fail_level=getattr(checks, options[\"fail_level\"]),\n            databases=options[\"databases\"],\n        )",
                "filename": "django/core/management/commands/check.py",
                "start_index": 0,
                "end_index": 2651,
                "start_line": 1,
                "end_line": 83,
                "max_line": 83,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "DateTimeCheckMixin:\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_mutually_exclusive_options(),\n            *self._check_fix_default_value(),\n        ]\n\n    def _check_mutually_exclusive_options(self):\n        # auto_now, auto_now_add, and default are mutually exclusive\n        # options. The use of more than one of these options together\n        # will trigger an Error\n        mutually_exclusive_options = [\n            self.auto_now_add,\n            self.auto_now,\n            self.has_default(),\n        ]\n        enabled_options = [\n            option not in (None, False) for option in mutually_exclusive_options\n        ].count(True)\n        if enabled_options > 1:\n            return [\n                checks.Error(\n                    \"The options auto_now, auto_now_add, and default \"\n                    \"are mutually exclusive. Only one of these options \"\n                    \"may be present.\",\n                    obj=self,\n                    id=\"fields.E160\",\n                )\n            ]\n        else:\n            return []\n\n    def _check_fix_default_value(self):\n        return []\n\n    # Concrete subclasses use this in their implementations of\n    # _check_fix_default_value().\n    def _check_if_value_fixed(self, value, now=None):\n        \"\"\"\n        Check if the given value appears to have been provided as a \"fixed\"\n        time value, and include a warning in the returned list if it does. The\n        value argument must be a date object or aware/naive datetime object. If\n        now is provided, it must be a naive datetime object.\n        \"\"\"\n        if now is None:\n            now = _get_naive_now()\n        offset = datetime.timedelta(seconds=10)\n        lower = now - offset\n        upper = now + offset\n        if isinstance(value, datetime.datetime):\n            value = _to_naive(value)\n        else:\n            assert isinstance(value, datetime.date)\n            lower = lower.date()\n            upper = upper.date()\n        if lower <= value <= upper:\n            return [\n                checks.Warning(\n                    \"Fixed default value provided.\",\n                    hint=(\n                        \"It seems you set a fixed date / time / datetime \"\n                        \"value as default for this field. This may not be \"\n                        \"what you want. If you want to have the current date \"\n                        \"as default, use `django.utils.timezone.now`\"\n                    ),\n                    obj=self,\n                    id=\"fields.W161\",\n                )\n            ]\n        return []\n\n\nclass",
                "filename": "django/db/models/fields/__init__.py",
                "start_index": 48261,
                "end_index": 50902,
                "start_line": 1334,
                "end_line": 2864,
                "max_line": 2869,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "def check_dependencies(**kwargs):",
                "filename": "django/contrib/admin/checks.py",
                "start_index": 1643,
                "end_index": 1676,
                "start_line": 56,
                "end_line": 56,
                "max_line": 1367,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "if not changes:\n            # No changes? Tell them.\n            if self.verbosity >= 1:\n                if app_labels:\n                    if len(app_labels) == 1:\n                        self.log(\"No changes detected in app '%s'\" % app_labels.pop())\n                    else:\n                        self.log(\n                            \"No changes detected in apps '%s'\"\n                            % (\"', '\".join(app_labels))\n                        )\n                else:\n                    self.log(\"No changes detected\")\n        else:\n            if check_changes:\n                sys.exit(1)\n            if self.update:\n                self.write_to_last_migration_files(changes)\n            else:\n                self.write_migration_files(changes)",
                "filename": "django/core/management/commands/makemigrations.py",
                "start_index": 9050,
                "end_index": 9810,
                "start_line": 240,
                "end_line": 259,
                "max_line": 513,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "verbosity = options[\"verbosity\"]\n        app_label = options[\"app_label\"]\n        migration_name = options[\"migration_name\"]\n        check = options[\"check\"]\n\n        # Validate app_label.\n        try:\n            apps.get_app_config(app_label)\n        except LookupError as err:\n            raise CommandError(str(err))\n\n        # Load the current graph state.\n        loader = MigrationLoader(None)\n        if app_label not in loader.migrated_apps:\n            raise CommandError(f\"App '{app_label}' does not have migrations.\")\n        # Find a migration.\n        try:\n            migration = loader.get_migration_by_prefix(app_label, migration_name)\n        except AmbiguityError:\n            raise CommandError(\n                f\"More than one migration matches '{migration_name}' in app \"\n                f\"'{app_label}'. Please be more specific.\"\n            )\n        except KeyError:\n            raise CommandError(\n                f\"Cannot find a migration matching '{migration_name}' from app \"\n                f\"'{app_label}'.\"\n            )\n\n        # Optimize the migration.\n        optimizer = MigrationOptimizer()\n        new_operations = optimizer.optimize(migration.operations, migration.app_label)\n        if len(migration.operations) == len(new_operations):\n            if verbosity > 0:\n                self.stdout.write(\"No optimizations possible.\")\n            return\n        else:\n            if verbosity > 0:\n                self.stdout.write(\n                    \"Optimizing from %d operations to %d operations.\"\n                    % (len(migration.operations), len(new_operations))\n                )\n            if check:\n                sys.exit(1)\n\n        # Set the new migration optimizations.\n        migration.operations = new_operations\n\n        # Write out the optimized migration file.\n        writer = MigrationWriter(migration)\n        migration_file_string = writer.as_string()",
                "filename": "django/core/management/commands/optimizemigration.py",
                "start_index": 1118,
                "end_index": 3035,
                "start_line": 33,
                "end_line": 105,
                "max_line": 129,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "help = (\n        \"Updates database schema. Manages both apps with migrations and those without.\"\n    )\n    requires_system_checks = []\n\n    def add_arguments(self, parser):\n        parser.add_argument(\n            \"--skip-checks\",\n            action=\"store_true\",\n            help=\"Skip system checks.\",\n        )\n        parser.add_argument(\n            \"app_label\",\n            nargs=\"?\",\n            help=\"App label of an application to synchronize the state.\",\n        )\n        parser.add_argument(\n            \"migration_name\",\n            nargs=\"?\",\n            help=\"Database state will be brought to the state after that \"\n            'migration. Use the name \"zero\" to unapply all migrations.',\n        )\n        parser.add_argument(\n            \"--noinput\",\n            \"--no-input\",\n            action=\"store_false\",\n            dest=\"interactive\",\n            help=\"Tells Django to NOT prompt the user for input of any kind.\",\n        )\n        parser.add_argument(\n            \"--database\",\n            default=DEFAULT_DB_ALIAS,\n            help=(\n                'Nominates a database to synchronize. Defaults to the \"default\" '\n                \"database.\"\n            ),\n        )\n        parser.add_argument(\n            \"--fake\",\n            action=\"store_true\",\n            help=\"Mark migrations as run without actually running them.\",\n        )\n        parser.add_argument(\n            \"--fake-initial\",\n            action=\"store_true\",\n            help=(\n                \"Detect if tables already exist and fake-apply initial migrations if \"\n                \"so. Make sure that the current database schema matches your initial \"\n                \"migration before using this flag. Django will only check for an \"\n                \"existing table name.\"\n            ),\n        )\n        parser.add_argument(\n            \"--plan\",\n            action=\"store_true\",\n            help=\"Shows a list of the migration actions that will be performed.\",\n        )\n        parser.add_argument(\n            \"--run-syncdb\",\n            action=\"store_true\",\n            help=\"Creates tables for apps without migrations.\",\n        )\n        parser.add_argument(\n            \"--check\",\n            action=\"store_true\",\n            dest=\"check_unapplied\",\n            help=(\n                \"Exits with a non-zero status if unapplied migrations exist and does \"\n                \"not actually apply migrations.\"\n            ),\n        )\n        parser.add_argument(\n            \"--prune\",\n            action=\"store_true\",\n            dest=\"prune\",\n            help=\"Delete nonexistent migrations from the django_migrations table.\",\n        )",
                "filename": "django/core/management/commands/migrate.py",
                "start_index": 703,
                "end_index": 3345,
                "start_line": 18,
                "end_line": 482,
                "max_line": 511,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\n        Test whether a migration has been implicitly applied - that the\n        tables or columns it would create exist. This is intended only for use\n        on initial migrations (as it only looks for CreateModel and AddField).\n        \"\"\"\n\n        def should_skip_detecting_model(migration, model):\n            \"\"\"\n            No need to detect tables for proxy models, unmanaged models, or\n            models that can't be migrated on the current database.\n            \"\"\"\n            return (\n                model._meta.proxy\n                or not model._meta.managed\n                or not router.allow_migrate(\n                    self.connection.alias,\n                    migration.app_label,\n                    model_name=model._meta.model_name,\n                )\n            )\n\n        if migration.initial is None:\n            # Bail if the migration isn't the first one in its app\n            if any(app == migration.app_label for app, name in migration.dependencies):\n                return False, project_state\n        elif migration.initial is False:\n            # Bail if it's NOT an initial migration\n            return False, project_state\n\n        if project_state is None:\n            after_state = self.loader.project_state(\n                (migration.app_label, migration.name), at_end=True\n            )\n        else:\n            after_state = migration.mutate_state(project_state)\n        apps = after_state.apps\n        found_create_model_migration = False\n        found_add_field_migration = False\n        fold_identifier_case = self.connection.features.ignores_table_name_case\n        with self.connection.cursor() as cursor:\n            existing_table_names = set(\n                self.connection.introspection.table_names(cursor)\n            )\n            if fold_identifier_case:\n                existing_table_names = {\n                    name.casefold() for name in existing_table_names\n                }\n        # Make sure all create model and add field operations are done",
                "filename": "django/db/migrations/executor.py",
                "start_index": 13981,
                "end_index": 15997,
                "start_line": 11,
                "end_line": 355,
                "max_line": 410,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "def check(\n        self,\n        app_configs=None,\n        tags=None,\n        display_num_errors=False,\n        include_deployment_checks=False,\n        fail_level=checks.ERROR,\n        databases=None,\n    ):",
                "filename": "django/core/management/base.py",
                "start_index": 16533,
                "end_index": 16741,
                "start_line": 470,
                "end_line": 478,
                "max_line": 688,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "def detect_soft_applied(self, project_state, migration):",
                "filename": "django/db/migrations/executor.py",
                "start_index": 13916,
                "end_index": 13972,
                "start_line": 307,
                "end_line": 307,
                "max_line": 410,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/core/management/commands/migrate.py": [
                {
                    "chunk": {
                        "code": "help = (\n        \"Updates database schema. Manages both apps with migrations and those without.\"\n    )\n    requires_system_checks = []\n\n    def add_arguments(self, parser):\n        parser.add_argument(\n            \"--skip-checks\",\n            action=\"store_true\",\n            help=\"Skip system checks.\",\n        )\n        parser.add_argument(\n            \"app_label\",\n            nargs=\"?\",\n            help=\"App label of an application to synchronize the state.\",\n        )\n        parser.add_argument(\n            \"migration_name\",\n            nargs=\"?\",\n            help=\"Database state will be brought to the state after that \"\n            'migration. Use the name \"zero\" to unapply all migrations.',\n        )\n        parser.add_argument(\n            \"--noinput\",\n            \"--no-input\",\n            action=\"store_false\",\n            dest=\"interactive\",\n            help=\"Tells Django to NOT prompt the user for input of any kind.\",\n        )\n        parser.add_argument(\n            \"--database\",\n            default=DEFAULT_DB_ALIAS,\n            help=(\n                'Nominates a database to synchronize. Defaults to the \"default\" '\n                \"database.\"\n            ),\n        )\n        parser.add_argument(\n            \"--fake\",\n            action=\"store_true\",\n            help=\"Mark migrations as run without actually running them.\",\n        )\n        parser.add_argument(\n            \"--fake-initial\",\n            action=\"store_true\",\n            help=(\n                \"Detect if tables already exist and fake-apply initial migrations if \"\n                \"so. Make sure that the current database schema matches your initial \"\n                \"migration before using this flag. Django will only check for an \"\n                \"existing table name.\"\n            ),\n        )\n        parser.add_argument(\n            \"--plan\",\n            action=\"store_true\",\n            help=\"Shows a list of the migration actions that will be performed.\",\n        )\n        parser.add_argument(\n            \"--run-syncdb\",\n            action=\"store_true\",\n            help=\"Creates tables for apps without migrations.\",\n        )\n        parser.add_argument(\n            \"--check\",\n            action=\"store_true\",\n            dest=\"check_unapplied\",\n            help=(\n                \"Exits with a non-zero status if unapplied migrations exist and does \"\n                \"not actually apply migrations.\"\n            ),\n        )\n        parser.add_argument(\n            \"--prune\",\n            action=\"store_true\",\n            dest=\"prune\",\n            help=\"Delete nonexistent migrations from the django_migrations table.\",\n        )",
                        "filename": "django/core/management/commands/migrate.py",
                        "start_index": 703,
                        "end_index": 3345,
                        "start_line": 18,
                        "end_line": 482,
                        "max_line": 511,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from 'migrate.py' shows the command line argument parsing for the 'migrate' command, including the addition of a new '--check' flag that is relevant to the issue."
                }
            ]
        },
        "solution_task": "To implement the `--check` flag for the `migrate` command in Django, you can follow these steps:\n\n- Modify the `migrate` command to accept the new `--check` flag.\n- Implement logic to check for unapplied migrations when the `--check` flag is used.\n- Exit with a non-zero status code if unapplied migrations are found.\n\nHere's a high-level overview of the changes needed in the `django/core/management/commands/migrate.py` file:\n\n```python\nfrom django.core.management.base import BaseCommand\nfrom django.db.migrations.executor import MigrationExecutor\nfrom django.db import connections, DEFAULT_DB_ALIAS\n\nclass Command(BaseCommand):\n    # ... existing code ...\n\n    def add_arguments(self, parser):\n        # ... existing code ...\n        parser.add_argument(\n            \"--check\",\n            action=\"store_true\",\n            dest=\"check_unapplied\",\n            help=(\n                \"Exits with a non-zero status if unapplied migrations exist and does \"\n                \"not actually apply migrations.\"\n            ),\n        )\n        # ... existing code ...\n\n    def handle(self, *args, **options):\n        # ... existing code ...\n\n        # Add logic to handle the --check flag\n        if options['check_unapplied']:\n            self.check_unapplied_migrations(options['database'])\n\n        # ... existing code ...\n\n    def check_unapplied_migrations(self, database):\n        connection = connections[database]\n        executor = MigrationExecutor(connection)\n        targets = executor.loader.graph.leaf_nodes()\n\n        # Check if there are any unapplied migrations\n        unapplied_migrations = executor.migration_plan(targets)\n        if unapplied_migrations:\n            self.stdout.write(self.style.ERROR(\"Unapplied migrations detected.\"))\n            sys.exit(1)\n        else:\n            self.stdout.write(self.style.SUCCESS(\"No unapplied migrations found.\"))\n```\n\nIn this implementation:\n\n- A new argument `--check` is added to the `migrate` command's argument parser.\n- A new method `check_unapplied_migrations` is defined to check for unapplied migrations.\n- The `MigrationExecutor` is used to determine if there are any migrations that have not been applied yet.\n- If unapplied migrations are found, the command prints an error message and exits with a non-zero status code.\n- If no unapplied migrations are found, a success message is printed.\n\nThis feature would be useful for Continuous Integration (CI) systems to prevent automatic deployment if there are pending migrations that need to be applied.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant suggestions that can directly lead to the successful implementation or improvement of the requested feature.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable step-by-step guide to implement the requested '--check' flag for the 'migrate' command in Django. It includes modifications to the command's argument parser, the addition of a new method to check for unapplied migrations, and the use of the MigrationExecutor to determine the migration status. The RESPONSE also includes a code snippet that demonstrates the necessary changes, which is directly relevant to the feature request. The RESPONSE addresses the need for a CI system to detect unapplied migrations before deployment, which is the core of the feature request. The only reason it does not score a 10 is that it does not explicitly mention updating documentation or tests, which are often part of implementing a new feature.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711731353.350749,
        "result": "To implement the `--check` flag for the `migrate` command in Django, you can follow these steps:\n\n- Modify the `migrate` command to accept the new `--check` flag.\n- Implement logic to check for unapplied migrations when the `--check` flag is used.\n- Exit with a non-zero status code if unapplied migrations are found.\n\nHere's a high-level overview of the changes needed in the `django/core/management/commands/migrate.py` file:\n\n```python\nfrom django.core.management.base import BaseCommand\nfrom django.db.migrations.executor import MigrationExecutor\nfrom django.db import connections, DEFAULT_DB_ALIAS\n\nclass Command(BaseCommand):\n    # ... existing code ...\n\n    def add_arguments(self, parser):\n        # ... existing code ...\n        parser.add_argument(\n            \"--check\",\n            action=\"store_true\",\n            dest=\"check_unapplied\",\n            help=(\n                \"Exits with a non-zero status if unapplied migrations exist and does \"\n                \"not actually apply migrations.\"\n            ),\n        )\n        # ... existing code ...\n\n    def handle(self, *args, **options):\n        # ... existing code ...\n\n        # Add logic to handle the --check flag\n        if options['check_unapplied']:\n            self.check_unapplied_migrations(options['database'])\n\n        # ... existing code ...\n\n    def check_unapplied_migrations(self, database):\n        connection = connections[database]\n        executor = MigrationExecutor(connection)\n        targets = executor.loader.graph.leaf_nodes()\n\n        # Check if there are any unapplied migrations\n        unapplied_migrations = executor.migration_plan(targets)\n        if unapplied_migrations:\n            self.stdout.write(self.style.ERROR(\"Unapplied migrations detected.\"))\n            sys.exit(1)\n        else:\n            self.stdout.write(self.style.SUCCESS(\"No unapplied migrations found.\"))\n```\n\nIn this implementation:\n\n- A new argument `--check` is added to the `migrate` command's argument parser.\n- A new method `check_unapplied_migrations` is defined to check for unapplied migrations.\n- The `MigrationExecutor` is used to determine if there are any migrations that have not been applied yet.\n- If unapplied migrations are found, the command prints an error message and exits with a non-zero status code.\n- If no unapplied migrations are found, a success message is printed.\n\nThis feature would be useful for Continuous Integration (CI) systems to prevent automatic deployment if there are pending migrations that need to be applied.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [management](https://github.com/testbed/django__django__3.1/tree//django/core/management) \u2192 [commands](https://github.com/testbed/django__django__3.1/tree//django/core/management/commands)- [Lines 18 - 482](https://github.com/testbed/django__django__3.1/blob//django/core/management/commands/migrate.py#L18-L482)\n\n This snippet from 'migrate.py' shows the command line argument parsing for the 'migrate' command, including the addition of a new '--check' flag that is relevant to the issue."
    }
}