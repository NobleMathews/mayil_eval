{
    "id": "matplotlib__matplotlib-24224",
    "repo_name": "testbed/matplotlib__matplotlib__3.6",
    "task_id": 1391248298120913447,
    "title": "[Doc]: document `julian2num` and `num2julian`?",
    "body": "### Documentation Link\r\n\r\nhttps://matplotlib.org/stable/api/dates_api.html\r\n\r\n### Problem\r\n\r\nThese two methods have a decent doc-string, but are not in the documentation.\r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/7de767e927b4b4f5212e268c6432107116752d85/lib/matplotlib/dates.py#L461-L503\r\n\r\nThey were added 2006-08-10\r\n\r\n### Suggested improvement\r\n\r\nMaybe add them to the documentation?\r\n\r\nIt would make sense to add them towards the end of the page and include those and all functions after the last Locator in a new subsection \"Miscellaneous date functions\" or something.\r\n\r\nEdit: looking at the source, https://github.com/matplotlib/matplotlib/blob/main/doc/api/dates_api.rst it is not really clear why they are not there...\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.6.git",
    "requested_commit": "",
    "mayil_response": "To add documentation for the `julian2num` and `num2julian` functions in the Matplotlib project, follow these steps:\n\n- Fork the Matplotlib repository on GitHub if you haven't already.\n- Clone your fork locally.\n- Create a new branch for your changes.\n\nHere's a high-level overview of the steps to add the documentation:\n\n1. Update the `dates_api.rst` file:\n   - Navigate to the `doc/api` directory in the Matplotlib repository.\n   - Open the `dates_api.rst` file.\n   - Add a new subsection \"Miscellaneous date functions\" towards the end of the file, after the last Locator section.\n   - Include the `julian2num` and `num2julian` functions in this subsection using the appropriate reStructuredText format.\n\n2. Add the docstrings to the documentation:\n   - Use the existing docstrings from the `dates.py` file as a starting point.\n   - Ensure that the docstrings are formatted correctly for Sphinx, the documentation generator used by Matplotlib.\n   - If necessary, update the docstrings in `dates.py` to ensure they are clear and complete.\n\n3. Build the documentation:\n   - Follow the instructions in the Matplotlib documentation to set up your environment for building the documentation.\n   - Build the documentation locally to ensure that your changes appear correctly.\n\n4. Commit your changes:\n   - Use descriptive commit messages to explain your changes.\n   - Commit the updated `dates_api.rst` file and any changes to `dates.py`.\n\n5. Push your changes to your fork on GitHub and create a pull request:\n   - Push your new branch to your GitHub fork.\n   - Create a pull request against the main Matplotlib repository.\n   - Fill in the pull request template, linking to the issue that requested the documentation.\n\n6. Wait for a review:\n   - Matplotlib maintainers will review your pull request.\n   - Make any requested changes and update the pull request as needed.\n\nHere's an example of what the new subsection in `dates_api.rst` might look like:\n\n```rst\nMiscellaneous date functions\n----------------------------\n\n.. autofunction:: matplotlib.dates.julian2num\n.. autofunction:: matplotlib.dates.num2julian\n```\n\nAnd ensure that the docstrings in `dates.py` are properly formatted, for example:\n\n```python\ndef julian2num(j):\n    \"\"\"\n    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).\n\n    Parameters\n    ----------\n    j : float or sequence of floats\n        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian\n        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar).\n\n    Returns\n    -------\n    float or sequence of floats\n        Matplotlib dates (days relative to `.get_epoch`).\n    \"\"\"\n    # Function implementation...\n```\n\nRemember to follow the Matplotlib contribution guidelines and code of conduct when making contributions to the project.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 469 - 566](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/dates.py#L469-L566)\n\n This snippet contains the implementation of the `num2julian` function, which is one of the methods mentioned in the issue that is not currently documented in the official Matplotlib documentation. \n\n\n   - [Lines 417 - 490](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/dates.py#L417-L490)\n\n This snippet contains the implementation of the `julian2num` function, which is the other method mentioned in the issue that is not currently documented in the official Matplotlib documentation.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000252,
        "snippet_processor": 0.06308000000000001,
        "issue_star_creation": 0.02484,
        "issue_star_solver": 0.07439,
        "bouncer": 0.02942
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711697571.422364,
        "relevant_snippets": [
            {
                "code": "@_api.deprecated(\"3.7\")\ndef num2julian(n):\n    \"\"\"\n    Convert a Matplotlib date (or sequence) to a Julian date (or sequence).\n\n    Parameters\n    ----------\n    n : float or sequence of floats\n        Matplotlib dates (days relative to `.get_epoch`).\n\n    Returns\n    -------\n    float or sequence of floats\n        Julian dates (days relative to 4713 BC Jan 1, 12:00:00).\n    \"\"\"\n    ep = np.datetime64(get_epoch(), 'h').astype(float) / 24.\n    ep0 = np.datetime64('0000-12-31T00:00:00', 'h').astype(float) / 24.\n    # Julian offset defined above is relative to 0000-12-31, but we need\n    # relative to our current epoch:\n    dt = __getattr__(\"JULIAN_OFFSET\") - ep0 + ep\n    return np.add(n, dt)  # Handles both scalar & nonscalar j.\n\n\ndef num2date(x, tz=None):\n    \"\"\"\n    Convert Matplotlib dates to `~datetime.datetime` objects.\n\n    Parameters\n    ----------\n    x : float or sequence of floats\n        Number of days (fraction part represents hours, minutes, seconds)\n        since the epoch.  See `.get_epoch` for the\n        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.\n    tz : str or `~datetime.tzinfo`, default: :rc:`timezone`\n        Timezone of *x*. If a string, *tz* is passed to `dateutil.tz`.\n\n    Returns\n    -------\n    `~datetime.datetime` or sequence of `~datetime.datetime`\n        Dates are returned in timezone *tz*.\n\n        If *x* is a sequence, a sequence of `~datetime.datetime` objects will\n        be returned.\n\n    Notes\n    -----\n    The Gregorian calendar is assumed; this is not universal practice.\n    For details, see the module docstring.\n    \"\"\"\n    tz = _get_tzinfo(tz)\n    return _from_ordinalf_np_vectorized(x, tz).tolist()\n\n\n_ordinalf_to_timedelta_np_vectorized = np.vectorize(\n    lambda x: datetime.timedelta(days=x), otypes=\"O\")\n\n\ndef num2timedelta(x):\n    \"\"\"\n    Convert number of days to a `~datetime.timedelta` object.\n\n    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will\n    be returned.\n\n    Parameters\n    ----------\n    x : float, sequence of floats\n        Number of days. The fraction part represents hours, minutes, seconds.\n\n    Returns\n    -------\n    `datetime.timedelta` or list[`datetime.timedelta`]\n    \"\"\"\n    return _ordinalf_to_timedelta_np_vectorized(x).tolist()",
                "filename": "lib/matplotlib/dates.py",
                "start_index": 16405,
                "end_index": 18677,
                "start_line": 469,
                "end_line": 566,
                "max_line": 1894,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def date2num(d):\n    \"\"\"\n    Convert datetime objects to Matplotlib dates.\n\n    Parameters\n    ----------\n    d : `datetime.datetime` or `numpy.datetime64` or sequences of these\n\n    Returns\n    -------\n    float or sequence of floats\n        Number of days since the epoch.  See `.get_epoch` for the\n        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.  If\n        the epoch is \"1970-01-01T00:00:00\" (default) then noon Jan 1 1970\n        (\"1970-01-01T12:00:00\") returns 0.5.\n\n    Notes\n    -----\n    The Gregorian calendar is assumed; this is not universal practice.\n    For details see the module docstring.\n    \"\"\"\n    # Unpack in case of e.g. Pandas or xarray object\n    d = cbook._unpack_to_numpy(d)\n\n    # make an iterable, but save state to unpack later:\n    iterable = np.iterable(d)\n    if not iterable:\n        d = [d]\n\n    masked = np.ma.is_masked(d)\n    mask = np.ma.getmask(d)\n    d = np.asarray(d)\n\n    # convert to datetime64 arrays, if not already:\n    if not np.issubdtype(d.dtype, np.datetime64):\n        # datetime arrays\n        if not d.size:\n            # deals with an empty array...\n            return d\n        tzi = getattr(d[0], 'tzinfo', None)\n        if tzi is not None:\n            # make datetime naive:\n            d = [dt.astimezone(UTC).replace(tzinfo=None) for dt in d]\n            d = np.asarray(d)\n        d = d.astype('datetime64[us]')\n\n    d = np.ma.masked_array(d, mask=mask) if masked else d\n    d = _dt64_to_ordinalf(d)\n\n    return d if iterable else d[0]\n\n\n@_api.deprecated(\"3.7\")\ndef julian2num(j):\n    \"\"\"\n    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).\n\n    Parameters\n    ----------\n    j : float or sequence of floats\n        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian\n        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar).\n\n    Returns\n    -------\n    float or sequence of floats\n        Matplotlib dates (days relative to `.get_epoch`).\n    \"\"\"\n    ep = np.datetime64(get_epoch(), 'h').astype(float) / 24.\n    ep0 = np.datetime64('0000-12-31T00:00:00', 'h').astype(float) / 24.\n    # Julian offset defined above is relative to 0000-12-31, but we need\n    # relative to our current epoch:\n    dt = __getattr__(\"JULIAN_OFFSET\") - ep0 + ep\n    return np.subtract(j, dt)  # Handles both scalar & nonscalar j.",
                "filename": "lib/matplotlib/dates.py",
                "start_index": 14058,
                "end_index": 16402,
                "start_line": 417,
                "end_line": 490,
                "max_line": 1894,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\nMatplotlib provides sophisticated date plotting capabilities, standing on the\nshoulders of python :mod:`datetime` and the add-on module dateutil_.\n\nBy default, Matplotlib uses the units machinery described in\n`~matplotlib.units` to convert `datetime.datetime`, and `numpy.datetime64`\nobjects when plotted on an x- or y-axis. The user does not\nneed to do anything for dates to be formatted, but dates often have strict\nformatting needs, so this module provides many tick locators and formatters.\nA basic example using `numpy.datetime64` is::\n\n    import numpy as np\n\n    times = np.arange(np.datetime64('2001-01-02'),\n                      np.datetime64('2002-02-03'), np.timedelta64(75, 'm'))\n    y = np.random.randn(len(times))\n\n    fig, ax = plt.subplots()\n    ax.plot(times, y)\n\n.. seealso::\n\n    - :doc:`/gallery/text_labels_and_annotations/date`\n    - :doc:`/gallery/ticks/date_concise_formatter`\n    - :doc:`/gallery/ticks/date_demo_convert`\n\n.. _date-format:\n\nMatplotlib date format\n----------------------\n\nMatplotlib represents dates using floating point numbers specifying the number\nof days since a default epoch of 1970-01-01 UTC; for example,\n1970-01-01, 06:00 is the floating point number 0.25. The formatters and\nlocators require the use of `datetime.datetime` objects, so only dates between\nyear 0001 and 9999 can be represented.  Microsecond precision\nis achievable for (approximately) 70 years on either side of the epoch, and\n20 microseconds for the rest of the allowable range of dates (year 0001 to\n9999). The epoch can be changed at import time via `.dates.set_epoch` or\n:rc:`dates.epoch` to other dates if necessary; see\n:doc:`/gallery/ticks/date_precision_and_epochs` for a discussion.\n\n.. note::\n\n   Before Matplotlib 3.3, the epoch was 0000-12-31 which lost modern\n   microsecond precision and also made the default axis limit of 0 an invalid\n   datetime.  In 3.3 the epoch was changed as above.  To convert old\n   ordinal floats to the new epoch, users can do::\n\n     new_ordinal = old_ordinal + mdates.date2num(np.datetime64('0000-12-31'))\n\n\nThere are a number of helper functions to convert between :mod:`datetime`\nobjects and Matplotlib dates:\n\n.. currentmodule:: matplotlib.dates\n\n.. autosummary::\n   :nosignatures:\n\n   datestr2num\n   date2num\n   num2date\n   num2timedelta\n   drange\n   set_epoch\n   get_epoch\n\n.. note::\n\n   Like Python's `datetime.datetime`, Matplotlib uses the Gregorian calendar\n   for all conversions between dates and floating point numbers. This practice\n   is not universal, and calendar differences can cause confusing\n   differences between what Python and Matplotlib give as the number of days\n   since 0001-01-01 and what other software and databases yield.  For\n   example, the US Naval Observatory uses a calendar that switches\n   from Julian to Gregorian in October, 1582.  Hence, using their\n   calculator, the number of days between 0001-01-01 and 2006-04-01 is\n   732403, whereas using the Gregorian calendar via the datetime\n   module we find::\n\n     In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()\n     Out[1]: 732401\n\nAll the Matplotlib date converters, locators and formatters are timezone aware.\nIf no explicit timezone is provided, :rc:`timezone` is assumed, provided as a\nstring.  If you want to use a different timezone, pass the *tz* keyword\nargument of `num2date` to any date tick locators or formatters you create. This\ncan be either a `datetime.tzinfo` instance or a string with the timezone name\nthat can be parsed by `~dateutil.tz.gettz`.\n\nA wide range of specific and general purpose date tick locators and\nformatters are provided in this module.  See\n:mod:`matplotlib.ticker` for general information on tick locators\nand formatters.  These are described below.\n\nThe dateutil_ module provides additional code to handle date ticking, making it\neasy to place ticks on any kinds of dates.  See examples below.\n\n.. _dateutil: https://dateutil.readthedocs.io\n\n.. _date-locators:\n\nDate tick locators\n------------------\n\nMost of the date tick locators can locate single or multiple ticks. For example::\n\n    # import constants for the days of the week\n    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU\n\n    # tick on Mondays every week\n    loc = WeekdayLocator(byweekday=MO, tz=tz)\n\n    # tick on Mondays and Saturdays\n    loc = WeekdayLocator(byweekday=(MO, SA))\n\nIn addition, most of the constructors take an interval argument::\n\n    # tick on Mondays every second week\n    loc = WeekdayLocator(byweekday=MO, interval=2)\n\nThe rrule locator allows completely general date ticking::\n\n    # tick every 5th easter\n    rule = rrulewrapper(YEARLY, byeaster=1, interval=5)\n    loc = RRuleLocator(rule)\n\nThe available date tick locators are:\n\n* `MicrosecondLocator`: Locate microseconds.\n\n* `SecondLocator`: Locate seconds.\n\n* `MinuteLocator`: Locate minutes.\n\n* `HourLocator`: Locate hours.\n\n* `DayLocator`: Locate specified days of the month.\n\n* `WeekdayLocator`: Locate days of the week, e.g., MO, TU.\n\n* `MonthLocator`: Locate months, e.g., 7 for July.\n\n* `YearLocator`: Locate years that are multiples of base.\n\n* `RRuleLocator`: Locate using a `rrulewrapper`.\n  `rrulewrapper` is a simple wrapper around dateutil_'s `dateutil.rrule`\n  which allow almost arbitrary date tick specifications.\n  See :doc:`rrule example </gallery/ticks/date_demo_rrule>`.\n\n* `AutoDateLocator`: On autoscale, this class picks the best `DateLocator`\n  (e.g., `RRuleLocator`) to set the view limits and the tick locations.  If\n  called with ``interval_multiples=True`` it will make ticks line up with\n  sensible multiples of the tick intervals.  For example, if the interval is\n  4 hours, it will pick hours 0, 4, 8, etc. as ticks.  This behaviour is not\n  guaranteed by default.\n\n.. _date-formatters:\n\nDate formatters\n---------------\n\nThe available date formatters are:\n\n* `AutoDateFormatter`: attempts to figure out the best format to use.  This is\n  most useful when used with the `AutoDateLocator`.\n\n* `ConciseDateFormatter`: also attempts to figure out the best format to use,\n  and to make the format as compact as possible while still having complete\n  date information.  This is most useful when used with the `AutoDateLocator`.\n\n* `DateFormatter`: use `~datetime.datetime.strftime` format strings.\n\"\"\"",
                "filename": "lib/matplotlib/dates.py",
                "start_index": 0,
                "end_index": 6288,
                "start_line": 1,
                "end_line": 1871,
                "max_line": 1894,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "import datetime\nimport functools\nimport logging\nimport re\n\nfrom dateutil.rrule import (rrule, MO, TU, WE, TH, FR, SA, SU, YEARLY,\n                            MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,\n                            SECONDLY)\nfrom dateutil.relativedelta import relativedelta\nimport dateutil.parser\nimport dateutil.tz\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import _api, cbook, ticker, units\n\n__all__ = ('datestr2num', 'date2num', 'num2date', 'num2timedelta', 'drange',\n           'set_epoch', 'get_epoch', 'DateFormatter', 'ConciseDateFormatter',\n           'AutoDateFormatter', 'DateLocator', 'RRuleLocator',\n           'AutoDateLocator', 'YearLocator', 'MonthLocator', 'WeekdayLocator',\n           'DayLocator', 'HourLocator', 'MinuteLocator',\n           'SecondLocator', 'MicrosecondLocator',\n           'rrule', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU',\n           'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',\n           'HOURLY', 'MINUTELY', 'SECONDLY', 'MICROSECONDLY', 'relativedelta',\n           'DateConverter', 'ConciseDateConverter', 'rrulewrapper')\n\n\n_log = logging.getLogger(__name__)\nUTC = datetime.timezone.utc\n\n\n@_api.caching_module_getattr\nclass __getattr__:\n    JULIAN_OFFSET = _api.deprecated(\"3.7\")(property(lambda self: 1721424.5))\n    # Julian date at 0000-12-31\n    # note that the Julian day epoch is achievable w/\n    # np.datetime64('-4713-11-24T12:00:00'); datetime64 is proleptic\n    # Gregorian and BC has a one-year offset.  So\n    # np.datetime64('0000-12-31') - np.datetime64('-4713-11-24T12:00') =\n    # 1721424.5\n    # Ref: https://en.wikipedia.org/wiki/Julian_day\n\n\ndef _get_tzinfo(tz=None):\n    \"\"\"\n    Generate `~datetime.tzinfo` from a string or return `~datetime.tzinfo`.\n    If None, retrieve the preferred timezone from the rcParams dictionary.\n    \"\"\"\n    tz = mpl._val_or_rc(tz, 'timezone')\n    if tz == 'UTC':\n        return UTC\n    if isinstance(tz, str):\n        tzinfo = dateutil.tz.gettz(tz)\n        if tzinfo is None:\n            raise ValueError(f\"{tz} is not a valid timezone as parsed by\"\n                             \" dateutil.tz.gettz.\")\n        return tzinfo\n    if isinstance(tz, datetime.tzinfo):\n        return tz\n    raise TypeError(f\"tz must be string or tzinfo subclass, not {tz!r}.\")\n\n\n# Time-related constants.\nEPOCH_OFFSET = float(datetime.datetime(1970, 1, 1).toordinal())\n# EPOCH_OFFSET is not used by matplotlib\nMICROSECONDLY = SECONDLY + 1\nHOURS_PER_DAY = 24.\nMIN_PER_HOUR = 60.\nSEC_PER_MIN = 60.\nMONTHS_PER_YEAR = 12.\n\nDAYS_PER_WEEK = 7.\nDAYS_PER_MONTH = 30.\nDAYS_PER_YEAR = 365.0\n\nMINUTES_PER_DAY = MIN_PER_HOUR * HOURS_PER_DAY\n\nSEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR\nSEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY\nSEC_PER_WEEK = SEC_PER_DAY * DAYS_PER_WEEK\n\nMUSECONDS_PER_DAY = 1e6 * SEC_PER_DAY\n\nMONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY = (\n    MO, TU, WE, TH, FR, SA, SU)\nWEEKDAYS = (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY)",
                "filename": "lib/matplotlib/dates.py",
                "start_index": 6290,
                "end_index": 9260,
                "start_line": 176,
                "end_line": 262,
                "max_line": 1894,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "print('After Roundtrip:  ', date2)\n\n# %%\n# datetime64\n# ----------\n#\n# `numpy.datetime64` objects have microsecond precision for a much larger\n# timespace than `.datetime` objects.  However, currently Matplotlib time is\n# only converted back to datetime objects, which have microsecond resolution,\n# and years that only span 0000 to 9999.\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = np.datetime64('2000-01-01T00:10:00.000012')\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# Plotting\n# --------\n#\n# This all of course has an effect on plotting.  With the old default epoch\n# the times were rounded during the internal ``date2num`` conversion, leading\n# to jumps in the data:\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)\n\nx = np.arange('2000-01-01T00:00:00.0', '2000-01-01T00:00:00.000100',\n              dtype='datetime64[us]')\n# simulate the plot being made using the old epoch\nxold = np.array([mdates.num2date(mdates.date2num(d)) for d in x])\ny = np.arange(0, len(x))\n\n# resetting the Epoch so plots are comparable\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(xold, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\n# %%\n# For dates plotted using the more recent epoch, the plot is smooth:\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(x, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.dates.num2date`\n#    - `matplotlib.dates.date2num`\n#    - `matplotlib.dates.set_epoch`",
                "filename": "galleries/examples/ticks/date_precision_and_epochs.py",
                "start_index": 2990,
                "end_index": 5053,
                "start_line": 55,
                "end_line": 158,
                "max_line": 158,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n=================\nDate Demo Convert\n=================\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import DateFormatter, DayLocator, HourLocator, drange\n\ndate1 = datetime.datetime(2000, 3, 2)\ndate2 = datetime.datetime(2000, 3, 6)\ndelta = datetime.timedelta(hours=6)\ndates = drange(date1, date2, delta)\n\ny = np.arange(len(dates))\n\nfig, ax = plt.subplots()\nax.plot(dates, y**2, 'o')\n\n# this is superfluous, since the autoscaler should get it right, but\n# use date2num and num2date to convert between dates and floats if\n# you want; both date2num and num2date convert an instance or sequence\nax.set_xlim(dates[0], dates[-1])\n\n# The hour locator takes the hour or sequence of hours you want to\n# tick, not the base multiple\n\nax.xaxis.set_major_locator(DayLocator())\nax.xaxis.set_minor_locator(HourLocator(range(0, 25, 6)))\nax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d'))\n\nax.fmt_xdata = DateFormatter('%Y-%m-%d %H:%M:%S')\nfig.autofmt_xdate()\n\nplt.show()",
                "filename": "galleries/examples/ticks/date_demo_convert.py",
                "start_index": 0,
                "end_index": 1012,
                "start_line": 1,
                "end_line": 39,
                "max_line": 39,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n================\nDate tick labels\n================\n\nMatplotlib date plotting is done by converting date instances into\ndays since an epoch (by default 1970-01-01T00:00:00). The\n:mod:`matplotlib.dates` module provides the converter functions `.date2num`\nand `.num2date` that convert `datetime.datetime` and `numpy.datetime64`\nobjects to and from Matplotlib's internal representation.  These data\ntypes are registered with the unit conversion mechanism described in\n:mod:`matplotlib.units`, so the conversion happens automatically for the user.\nThe registration process also sets the default tick ``locator`` and\n``formatter`` for the axis to be `~.matplotlib.dates.AutoDateLocator` and\n`~.matplotlib.dates.AutoDateFormatter`.\n\nAn alternative formatter is the `~.dates.ConciseDateFormatter`,\nused in the second ``Axes`` below (see\n:doc:`/gallery/ticks/date_concise_formatter`), which often removes the need to\nrotate the tick labels. The last ``Axes`` formats the dates manually, using\n`~.dates.DateFormatter` to format the dates using the format strings documented\nat `datetime.date.strftime`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.dates as mdates\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column.\ndata = cbook.get_sample_data('goog.npz')['price_data']\n\nfig, axs = plt.subplots(3, 1, figsize=(6.4, 7), layout='constrained')\n# common to all three:\nfor ax in axs:\n    ax.plot('date', 'adj_close', data=data)\n    # Major ticks every half year, minor ticks every month,\n    ax.xaxis.set_major_locator(mdates.MonthLocator(bymonth=(1, 7)))\n    ax.xaxis.set_minor_locator(mdates.MonthLocator())\n    ax.grid(True)\n    ax.set_ylabel(r'Price [\\$]')\n\n# different formats:\nax = axs[0]\nax.set_title('DefaultFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\n\nax = axs[1]\nax.set_title('ConciseFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\nax.xaxis.set_major_formatter(\n    mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\nax = axs[2]\nax.set_title('Manual DateFormatter', loc='left', y=0.85, x=0.02,\n             fontsize='medium')\n# Text in the x-axis will be displayed in 'YYYY-mm' format.\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%b'))\n# Rotates and right-aligns the x labels so they don't crowd each other.\nfor label in ax.get_xticklabels(which='major'):\n    label.set(rotation=30, horizontalalignment='right')\n\nplt.show()",
                "filename": "galleries/examples/text_labels_and_annotations/date.py",
                "start_index": 0,
                "end_index": 2611,
                "start_line": 1,
                "end_line": 64,
                "max_line": 64,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.dates.AutoDateLocator`\n#    - `matplotlib.dates.YearLocator`\n#    - `matplotlib.dates.MonthLocator`\n#    - `matplotlib.dates.DayLocator`\n#    - `matplotlib.dates.WeekdayLocator`\n#    - `matplotlib.dates.HourLocator`\n#    - `matplotlib.dates.MinuteLocator`\n#    - `matplotlib.dates.SecondLocator`\n#    - `matplotlib.dates.MicrosecondLocator`\n#    - `matplotlib.dates.RRuleLocator`\n#    - `matplotlib.dates.rrulewrapper`\n#    - `matplotlib.dates.DateFormatter`\n#    - `matplotlib.dates.AutoDateFormatter`\n#    - `matplotlib.dates.ConciseDateFormatter`",
                "filename": "galleries/examples/ticks/date_formatters_locators.py",
                "start_index": 3004,
                "end_index": 3713,
                "start_line": 37,
                "end_line": 100,
                "max_line": 100,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n=========================\nDate Precision and Epochs\n=========================\n\nMatplotlib can handle `.datetime` objects and `numpy.datetime64` objects using\na unit converter that recognizes these dates and converts them to floating\npoint numbers.\n\nBefore Matplotlib 3.3, the default for this conversion returns a float that was\ndays since \"0000-12-31T00:00:00\".  As of Matplotlib 3.3, the default is\ndays from \"1970-01-01T00:00:00\".  This allows more resolution for modern\ndates.  \"2020-01-01\" with the old epoch converted to 730120, and a 64-bit\nfloating point number has a resolution of 2^{-52}, or approximately\n14 microseconds, so microsecond precision was lost.  With the new default\nepoch \"2020-01-01\" is 10957.0, so the achievable resolution is 0.21\nmicroseconds.\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\n\ndef _reset_epoch_for_tutorial():\n    \"\"\"\n    Users (and downstream libraries) should not use the private method of\n    resetting the epoch.\n    \"\"\"\n    mdates._reset_epoch_test_example()\n\n\n# %%\n# Datetime\n# --------\n#\n# Python `.datetime` objects have microsecond resolution, so with the\n# old default matplotlib dates could not round-trip full-resolution datetime\n# objects.\n\nold_epoch = '0000-12-31T00:00:00'\nnew_epoch = '1970-01-01T00:00:00'\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)  # old epoch (pre MPL 3.3)\n\ndate1 = datetime.datetime(2000, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# Note this is only a round-off error, and there is no problem for\n# dates closer to the old epoch:\n\ndate1 = datetime.datetime(10, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# If a user wants to use modern dates at microsecond precision, they\n# can change the epoch using `.set_epoch`.  However, the epoch has to be\n# set before any date operations to prevent confusion between different\n# epochs. Trying to change the epoch later will raise a `RuntimeError`.\n\ntry:\n    mdates.set_epoch(new_epoch)  # this is the new MPL 3.3 default.\nexcept RuntimeError as e:\n    print('RuntimeError:', str(e))\n\n# %%\n# For this tutorial, we reset the sentinel using a private method, but users\n# should just set the epoch once, if at all.\n\n_reset_epoch_for_tutorial()  # Just being done for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = datetime.datetime(2020, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)",
                "filename": "galleries/examples/ticks/date_precision_and_epochs.py",
                "start_index": 0,
                "end_index": 2989,
                "start_line": 1,
                "end_line": 108,
                "max_line": 158,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "ax.set_xlabel('X [m]')\nax.legend()\n\n\ndef forward(x):\n    return np.interp(x, xold, xnew)\n\n\ndef inverse(x):\n    return np.interp(x, xnew, xold)\n\n\nsecax = ax.secondary_xaxis('top', functions=(forward, inverse))\nsecax.xaxis.set_minor_locator(AutoMinorLocator())\nsecax.set_xlabel('$X_{other}$')\n\nplt.show()\n\n# %%\n# A final example translates np.datetime64 to yearday on the x axis and\n# from Celsius to Fahrenheit on the y axis.  Note the addition of a\n# third y axis, and that it can be placed using a float for the\n# location argument\n\ndates = [datetime.datetime(2018, 1, 1) + datetime.timedelta(hours=k * 6)\n         for k in range(240)]\ntemperature = np.random.randn(len(dates)) * 4 + 6.7\nfig, ax = plt.subplots(layout='constrained')\n\nax.plot(dates, temperature)\nax.set_ylabel(r'$T\\ [^oC]$')\nplt.xticks(rotation=70)\n\n\ndef date2yday(x):\n    \"\"\"Convert matplotlib datenum to days since 2018-01-01.\"\"\"\n    y = x - mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\ndef yday2date(x):\n    \"\"\"Return a matplotlib datenum for *x* days after 2018-01-01.\"\"\"\n    y = x + mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\nsecax_x = ax.secondary_xaxis('top', functions=(date2yday, yday2date))\nsecax_x.set_xlabel('yday [2018]')\n\n\ndef celsius_to_fahrenheit(x):\n    return x * 1.8 + 32\n\n\ndef fahrenheit_to_celsius(x):\n    return (x - 32) / 1.8\n\n\nsecax_y = ax.secondary_yaxis(\n    'right', functions=(celsius_to_fahrenheit, fahrenheit_to_celsius))\nsecax_y.set_ylabel(r'$T\\ [^oF]$')\n\n\ndef celsius_to_anomaly(x):\n    return (x - np.mean(temperature))\n\n\ndef anomaly_to_celsius(x):\n    return (x + np.mean(temperature))\n\n\n# use of a float for the position:\nsecax_y2 = ax.secondary_yaxis(\n    1.2, functions=(celsius_to_anomaly, anomaly_to_celsius))\nsecax_y2.set_ylabel(r'$T - \\overline{T}\\ [^oC]$')\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.secondary_xaxis`\n#    - `matplotlib.axes.Axes.secondary_yaxis`",
                "filename": "galleries/examples/subplots_axes_and_figures/secondary_axis.py",
                "start_index": 2980,
                "end_index": 5028,
                "start_line": 107,
                "end_line": 194,
                "max_line": 194,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "lib/matplotlib/dates.py": [
                {
                    "chunk": {
                        "code": "@_api.deprecated(\"3.7\")\ndef num2julian(n):\n    \"\"\"\n    Convert a Matplotlib date (or sequence) to a Julian date (or sequence).\n\n    Parameters\n    ----------\n    n : float or sequence of floats\n        Matplotlib dates (days relative to `.get_epoch`).\n\n    Returns\n    -------\n    float or sequence of floats\n        Julian dates (days relative to 4713 BC Jan 1, 12:00:00).\n    \"\"\"\n    ep = np.datetime64(get_epoch(), 'h').astype(float) / 24.\n    ep0 = np.datetime64('0000-12-31T00:00:00', 'h').astype(float) / 24.\n    # Julian offset defined above is relative to 0000-12-31, but we need\n    # relative to our current epoch:\n    dt = __getattr__(\"JULIAN_OFFSET\") - ep0 + ep\n    return np.add(n, dt)  # Handles both scalar & nonscalar j.\n\n\ndef num2date(x, tz=None):\n    \"\"\"\n    Convert Matplotlib dates to `~datetime.datetime` objects.\n\n    Parameters\n    ----------\n    x : float or sequence of floats\n        Number of days (fraction part represents hours, minutes, seconds)\n        since the epoch.  See `.get_epoch` for the\n        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.\n    tz : str or `~datetime.tzinfo`, default: :rc:`timezone`\n        Timezone of *x*. If a string, *tz* is passed to `dateutil.tz`.\n\n    Returns\n    -------\n    `~datetime.datetime` or sequence of `~datetime.datetime`\n        Dates are returned in timezone *tz*.\n\n        If *x* is a sequence, a sequence of `~datetime.datetime` objects will\n        be returned.\n\n    Notes\n    -----\n    The Gregorian calendar is assumed; this is not universal practice.\n    For details, see the module docstring.\n    \"\"\"\n    tz = _get_tzinfo(tz)\n    return _from_ordinalf_np_vectorized(x, tz).tolist()\n\n\n_ordinalf_to_timedelta_np_vectorized = np.vectorize(\n    lambda x: datetime.timedelta(days=x), otypes=\"O\")\n\n\ndef num2timedelta(x):\n    \"\"\"\n    Convert number of days to a `~datetime.timedelta` object.\n\n    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will\n    be returned.\n\n    Parameters\n    ----------\n    x : float, sequence of floats\n        Number of days. The fraction part represents hours, minutes, seconds.\n\n    Returns\n    -------\n    `datetime.timedelta` or list[`datetime.timedelta`]\n    \"\"\"\n    return _ordinalf_to_timedelta_np_vectorized(x).tolist()",
                        "filename": "lib/matplotlib/dates.py",
                        "start_index": 16405,
                        "end_index": 18677,
                        "start_line": 469,
                        "end_line": 566,
                        "max_line": 1894,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of the `num2julian` function, which is one of the methods mentioned in the issue that is not currently documented in the official Matplotlib documentation."
                },
                {
                    "chunk": {
                        "code": "def date2num(d):\n    \"\"\"\n    Convert datetime objects to Matplotlib dates.\n\n    Parameters\n    ----------\n    d : `datetime.datetime` or `numpy.datetime64` or sequences of these\n\n    Returns\n    -------\n    float or sequence of floats\n        Number of days since the epoch.  See `.get_epoch` for the\n        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.  If\n        the epoch is \"1970-01-01T00:00:00\" (default) then noon Jan 1 1970\n        (\"1970-01-01T12:00:00\") returns 0.5.\n\n    Notes\n    -----\n    The Gregorian calendar is assumed; this is not universal practice.\n    For details see the module docstring.\n    \"\"\"\n    # Unpack in case of e.g. Pandas or xarray object\n    d = cbook._unpack_to_numpy(d)\n\n    # make an iterable, but save state to unpack later:\n    iterable = np.iterable(d)\n    if not iterable:\n        d = [d]\n\n    masked = np.ma.is_masked(d)\n    mask = np.ma.getmask(d)\n    d = np.asarray(d)\n\n    # convert to datetime64 arrays, if not already:\n    if not np.issubdtype(d.dtype, np.datetime64):\n        # datetime arrays\n        if not d.size:\n            # deals with an empty array...\n            return d\n        tzi = getattr(d[0], 'tzinfo', None)\n        if tzi is not None:\n            # make datetime naive:\n            d = [dt.astimezone(UTC).replace(tzinfo=None) for dt in d]\n            d = np.asarray(d)\n        d = d.astype('datetime64[us]')\n\n    d = np.ma.masked_array(d, mask=mask) if masked else d\n    d = _dt64_to_ordinalf(d)\n\n    return d if iterable else d[0]\n\n\n@_api.deprecated(\"3.7\")\ndef julian2num(j):\n    \"\"\"\n    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).\n\n    Parameters\n    ----------\n    j : float or sequence of floats\n        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian\n        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar).\n\n    Returns\n    -------\n    float or sequence of floats\n        Matplotlib dates (days relative to `.get_epoch`).\n    \"\"\"\n    ep = np.datetime64(get_epoch(), 'h').astype(float) / 24.\n    ep0 = np.datetime64('0000-12-31T00:00:00', 'h').astype(float) / 24.\n    # Julian offset defined above is relative to 0000-12-31, but we need\n    # relative to our current epoch:\n    dt = __getattr__(\"JULIAN_OFFSET\") - ep0 + ep\n    return np.subtract(j, dt)  # Handles both scalar & nonscalar j.",
                        "filename": "lib/matplotlib/dates.py",
                        "start_index": 14058,
                        "end_index": 16402,
                        "start_line": 417,
                        "end_line": 490,
                        "max_line": 1894,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of the `julian2num` function, which is the other method mentioned in the issue that is not currently documented in the official Matplotlib documentation."
                }
            ]
        },
        "solution_task": "To add documentation for the `julian2num` and `num2julian` functions in the Matplotlib project, follow these steps:\n\n- Fork the Matplotlib repository on GitHub if you haven't already.\n- Clone your fork locally.\n- Create a new branch for your changes.\n\nHere's a high-level overview of the steps to add the documentation:\n\n1. Update the `dates_api.rst` file:\n   - Navigate to the `doc/api` directory in the Matplotlib repository.\n   - Open the `dates_api.rst` file.\n   - Add a new subsection \"Miscellaneous date functions\" towards the end of the file, after the last Locator section.\n   - Include the `julian2num` and `num2julian` functions in this subsection using the appropriate reStructuredText format.\n\n2. Add the docstrings to the documentation:\n   - Use the existing docstrings from the `dates.py` file as a starting point.\n   - Ensure that the docstrings are formatted correctly for Sphinx, the documentation generator used by Matplotlib.\n   - If necessary, update the docstrings in `dates.py` to ensure they are clear and complete.\n\n3. Build the documentation:\n   - Follow the instructions in the Matplotlib documentation to set up your environment for building the documentation.\n   - Build the documentation locally to ensure that your changes appear correctly.\n\n4. Commit your changes:\n   - Use descriptive commit messages to explain your changes.\n   - Commit the updated `dates_api.rst` file and any changes to `dates.py`.\n\n5. Push your changes to your fork on GitHub and create a pull request:\n   - Push your new branch to your GitHub fork.\n   - Create a pull request against the main Matplotlib repository.\n   - Fill in the pull request template, linking to the issue that requested the documentation.\n\n6. Wait for a review:\n   - Matplotlib maintainers will review your pull request.\n   - Make any requested changes and update the pull request as needed.\n\nHere's an example of what the new subsection in `dates_api.rst` might look like:\n\n```rst\nMiscellaneous date functions\n----------------------------\n\n.. autofunction:: matplotlib.dates.julian2num\n.. autofunction:: matplotlib.dates.num2julian\n```\n\nAnd ensure that the docstrings in `dates.py` are properly formatted, for example:\n\n```python\ndef julian2num(j):\n    \"\"\"\n    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).\n\n    Parameters\n    ----------\n    j : float or sequence of floats\n        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian\n        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar).\n\n    Returns\n    -------\n    float or sequence of floats\n        Matplotlib dates (days relative to `.get_epoch`).\n    \"\"\"\n    # Function implementation...\n```\n\nRemember to follow the Matplotlib contribution guidelines and code of conduct when making contributions to the project.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed, step-by-step guide on how to add documentation for the `julian2num` and `num2julian` functions to the Matplotlib project. It includes instructions on updating the `dates_api.rst` file, adding docstrings, building the documentation, committing changes, and creating a pull request. The RESPONSE also provides an example of how the new subsection might look in the documentation and how to format the docstrings. Additionally, it includes links to the code snippets containing the implementations of the functions to be documented. The RESPONSE is actionable, relevant, and nearly comprehensive, only missing a minor detail such as a reminder to check for any existing pull requests or issues related to the same documentation update to avoid duplicate work.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711697650.877834,
        "result": "To add documentation for the `julian2num` and `num2julian` functions in the Matplotlib project, follow these steps:\n\n- Fork the Matplotlib repository on GitHub if you haven't already.\n- Clone your fork locally.\n- Create a new branch for your changes.\n\nHere's a high-level overview of the steps to add the documentation:\n\n1. Update the `dates_api.rst` file:\n   - Navigate to the `doc/api` directory in the Matplotlib repository.\n   - Open the `dates_api.rst` file.\n   - Add a new subsection \"Miscellaneous date functions\" towards the end of the file, after the last Locator section.\n   - Include the `julian2num` and `num2julian` functions in this subsection using the appropriate reStructuredText format.\n\n2. Add the docstrings to the documentation:\n   - Use the existing docstrings from the `dates.py` file as a starting point.\n   - Ensure that the docstrings are formatted correctly for Sphinx, the documentation generator used by Matplotlib.\n   - If necessary, update the docstrings in `dates.py` to ensure they are clear and complete.\n\n3. Build the documentation:\n   - Follow the instructions in the Matplotlib documentation to set up your environment for building the documentation.\n   - Build the documentation locally to ensure that your changes appear correctly.\n\n4. Commit your changes:\n   - Use descriptive commit messages to explain your changes.\n   - Commit the updated `dates_api.rst` file and any changes to `dates.py`.\n\n5. Push your changes to your fork on GitHub and create a pull request:\n   - Push your new branch to your GitHub fork.\n   - Create a pull request against the main Matplotlib repository.\n   - Fill in the pull request template, linking to the issue that requested the documentation.\n\n6. Wait for a review:\n   - Matplotlib maintainers will review your pull request.\n   - Make any requested changes and update the pull request as needed.\n\nHere's an example of what the new subsection in `dates_api.rst` might look like:\n\n```rst\nMiscellaneous date functions\n----------------------------\n\n.. autofunction:: matplotlib.dates.julian2num\n.. autofunction:: matplotlib.dates.num2julian\n```\n\nAnd ensure that the docstrings in `dates.py` are properly formatted, for example:\n\n```python\ndef julian2num(j):\n    \"\"\"\n    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).\n\n    Parameters\n    ----------\n    j : float or sequence of floats\n        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian\n        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar).\n\n    Returns\n    -------\n    float or sequence of floats\n        Matplotlib dates (days relative to `.get_epoch`).\n    \"\"\"\n    # Function implementation...\n```\n\nRemember to follow the Matplotlib contribution guidelines and code of conduct when making contributions to the project.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 469 - 566](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/dates.py#L469-L566)\n\n This snippet contains the implementation of the `num2julian` function, which is one of the methods mentioned in the issue that is not currently documented in the official Matplotlib documentation. \n\n\n   - [Lines 417 - 490](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/dates.py#L417-L490)\n\n This snippet contains the implementation of the `julian2num` function, which is the other method mentioned in the issue that is not currently documented in the official Matplotlib documentation."
    }
}