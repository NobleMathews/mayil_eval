{
    "id": "pytest-dev__pytest-8516",
    "repo_name": "testbed/pytest-dev__pytest__6.3",
    "task_id": 4853169293302308677,
    "title": "Minor temporary directory security issue in pytest versions before 6.2.3",
    "body": "A minor temporary directory security issue was found in pytest versions before 6.2.3. This issue is fixed in pytest 6.2.3.\r\n\r\npytest used to create directories under ``/tmp`` with world-readable\r\npermissions. This means that any user in the system was able to read\r\ninformation written by tests in temporary directories (such as those created by\r\nthe ``tmp_path``/``tmpdir`` fixture). Now the directories are created with\r\nprivate permissions.\r\n\r\npytest used to silenty use a pre-existing ``/tmp/pytest-of-<username>`` directory,\r\neven if owned by another user. This means another user could pre-create such a\r\ndirectory and gain control of another user's temporary directory. Now such a\r\ncondition results in an error.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pytest-dev__pytest__6.3.git",
    "requested_commit": "",
    "mayil_response": "- Update the pytest dependency to version 6.2.3 or later to resolve the temporary directory security issue.\n- Ensure that the `tmp_path` and `tmpdir` fixtures create directories with private permissions (e.g., `700`).\n- Implement error handling to check for pre-existing `/tmp/pytest-of-<username>` directories and raise an error if the directory is owned by another user.\n- Use the `os` module to check directory ownership and set permissions.\n\n```python\nimport os\nimport errno\nimport pytest\n\ndef create_temp_directory(username: str) -> str:\n    base_temp_dir = \"/tmp/pytest-of-{}\".format(username)\n    try:\n        os.makedirs(base_temp_dir, mode=0o700, exist_ok=True)\n    except OSError as e:\n        if e.errno == errno.EEXIST and not check_directory_ownership(base_temp_dir, username):\n            raise PermissionError(\"Directory {} already exists and is owned by another user.\".format(base_temp_dir))\n    return base_temp_dir\n\ndef check_directory_ownership(path: str, username: str) -> bool:\n    try:\n        stat_info = os.stat(path)\n        return stat_info.st_uid == os.getuid()\n    except FileNotFoundError:\n        return False\n\n# Ensure pytest version is 6.2.3 or later\nassert packaging.version.parse(pytest.__version__) >= packaging.version.parse(\"6.2.3\"), \"pytest version must be 6.2.3 or later\"\n```\n\n- The above code snippet should be integrated into the relevant part of the pytest codebase where temporary directories are handled.\n- Replace the placeholder implementation comments with the actual code provided above.\n- The version assertion should be placed at the beginning of the module where the temporary directory creation is handled.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000784,
        "snippet_processor": 0.050530000000000005,
        "issue_star_creation": 0.03726,
        "issue_star_solver": 0.03486,
        "bouncer": 0.04079
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711734564.8067079,
        "relevant_snippets": [
            {
                "code": "rtd:\n  project: pytest",
                "filename": ".github/config.yml",
                "start_index": 0,
                "end_index": 22,
                "start_line": 1,
                "end_line": 2,
                "max_line": 2,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "blank_issues_enabled: false\ncontact_links:\n  - name: \u2753 Support Question\n    url: https://github.com/pytest-dev/pytest/discussions\n    about: Use GitHub's new Discussions feature for questions",
                "filename": ".github/ISSUE_TEMPLATE/config.yml",
                "start_index": 0,
                "end_index": 191,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "import json\nfrom pathlib import Path\n\nimport requests\n\nissues_url = \"https://api.github.com/repos/pytest-dev/pytest/issues\"\n\n\ndef get_issues():\n    issues = []\n    url = issues_url\n    while 1:\n        get_data = {\"state\": \"all\"}\n        r = requests.get(url, params=get_data)\n        data = r.json()\n        if r.status_code == 403:\n            # API request limit exceeded\n            print(data[\"message\"])\n            exit(1)\n        issues.extend(data)\n\n        # Look for next page\n        links = requests.utils.parse_header_links(r.headers[\"Link\"])\n        another_page = False\n        for link in links:\n            if link[\"rel\"] == \"next\":\n                url = link[\"url\"]\n                another_page = True\n        if not another_page:\n            return issues\n\n\ndef main(args):\n    cachefile = Path(args.cache)\n    if not cachefile.exists() or args.refresh:\n        issues = get_issues()\n        cachefile.write_text(json.dumps(issues), \"utf-8\")\n    else:\n        issues = json.loads(cachefile.read_text(\"utf-8\"))\n\n    open_issues = [x for x in issues if x[\"state\"] == \"open\"]\n\n    open_issues.sort(key=lambda x: x[\"number\"])\n    report(open_issues)\n\n\ndef _get_kind(issue):\n    labels = [label[\"name\"] for label in issue[\"labels\"]]\n    for key in (\"bug\", \"enhancement\", \"proposal\"):\n        if key in labels:\n            return key\n    return \"issue\"\n\n\ndef report(issues):\n    for issue in issues:\n        title = issue[\"title\"]\n        # body = issue[\"body\"]\n        kind = _get_kind(issue)\n        status = issue[\"state\"]\n        number = issue[\"number\"]\n        link = \"https://github.com/pytest-dev/pytest/issues/%s/\" % number\n        print(\"----\")\n        print(status, kind, link)\n        print(title)\n        # print()\n        # lines = body.split(\"\\n\")\n        # print(\"\\n\".join(lines[:3]))\n        # if len(lines) > 3 or len(body) > 240:\n        #    print(\"...\")\n    print(\"\\n\\nFound %s open issues\" % len(issues))\n\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(\"process bitbucket issues\")\n    parser.add_argument(\n        \"--refresh\", action=\"store_true\", help=\"invalidate cache, refresh issues\"\n    )\n    parser.add_argument(\n        \"--cache\", action=\"store\", default=\"issues.json\", help=\"cache file\"\n    )\n    args = parser.parse_args()\n    main(args)",
                "filename": "extra/get_issues.py",
                "start_index": 0,
                "end_index": 2321,
                "start_line": 1,
                "end_line": 85,
                "max_line": 85,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "# shim for pylib going away\n# if pylib is installed this file will get skipped\n# (`py/__init__.py` has higher precedence)\nimport sys\n\nimport _pytest._py.error as error\nimport _pytest._py.path as path\n\nsys.modules[\"py.error\"] = error\nsys.modules[\"py.path\"] = path",
                "filename": "src/py.py",
                "start_index": 0,
                "end_index": 262,
                "start_line": 1,
                "end_line": 10,
                "max_line": 10,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "import sys\n\nif __name__ == \"__main__\":\n    import cProfile\n    import pytest  # NOQA\n    import pstats\n\n    script = sys.argv[1:] if len(sys.argv) > 1 else [\"empty.py\"]\n    cProfile.run(\"pytest.cmdline.main(%r)\" % script, \"prof\")\n    p = pstats.Stats(\"prof\")\n    p.strip_dirs()\n    p.sort_stats(\"cumulative\")\n    print(p.print_stats(500))",
                "filename": "bench/bench.py",
                "start_index": 0,
                "end_index": 338,
                "start_line": 1,
                "end_line": 13,
                "max_line": 13,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "import datetime\nimport pathlib\nimport re\nfrom textwrap import dedent\nfrom textwrap import indent\n\nimport packaging.version\nimport platformdirs\nimport tabulate\nimport wcwidth\nfrom requests_cache import CachedResponse\nfrom requests_cache import CachedSession\nfrom requests_cache import OriginalResponse\nfrom requests_cache import SQLiteCache\nfrom tqdm import tqdm\n\n\nFILE_HEAD = r\"\"\"\n.. Note this file is autogenerated by scripts/update-plugin-list.py - usually weekly via github action\n\n.. _plugin-list:\n\nPlugin List\n===========\n\nPyPI projects that match \"pytest-\\*\" are considered plugins and are listed\nautomatically together with a manually-maintained list in `the source\ncode <https://github.com/pytest-dev/pytest/blob/main/scripts/update-plugin-list.py>`_.\nPackages classified as inactive are excluded.\n\n.. The following conditional uses a different format for this list when\n   creating a PDF, because otherwise the table gets far too wide for the\n   page.\n\n\"\"\"\nDEVELOPMENT_STATUS_CLASSIFIERS = (\n    \"Development Status :: 1 - Planning\",\n    \"Development Status :: 2 - Pre-Alpha\",\n    \"Development Status :: 3 - Alpha\",\n    \"Development Status :: 4 - Beta\",\n    \"Development Status :: 5 - Production/Stable\",\n    \"Development Status :: 6 - Mature\",\n    \"Development Status :: 7 - Inactive\",\n)\nADDITIONAL_PROJECTS = {  # set of additional projects to consider as plugins\n    \"logassert\",\n    \"nuts\",\n}\n\n\ndef escape_rst(text: str) -> str:\n    \"\"\"Rudimentary attempt to escape special RST characters to appear as\n    plain text.\"\"\"\n    text = (\n        text.replace(\"*\", \"\\\\*\")\n        .replace(\"<\", \"\\\\<\")\n        .replace(\">\", \"\\\\>\")\n        .replace(\"`\", \"\\\\`\")\n    )\n    text = re.sub(r\"_\\b\", \"\", text)\n    return text\n\n\ndef project_response_with_refresh(\n    session: CachedSession, name: str, last_serial: int\n) -> OriginalResponse | CachedResponse:\n    \"\"\"Get a http cached pypi project\n\n    force refresh in case of last serial mismatch\n    \"\"\"\n\n    response = session.get(f\"https://pypi.org/pypi/{name}/json\")\n    if int(response.headers.get(\"X-PyPI-Last-Serial\", -1)) != last_serial:\n        response = session.get(f\"https://pypi.org/pypi/{name}/json\", refresh=True)\n    return response\n\n\ndef get_session() -> CachedSession:\n    \"\"\"Configures the requests-cache session\"\"\"\n    cache_path = platformdirs.user_cache_path(\"pytest-plugin-list\")\n    cache_path.mkdir(exist_ok=True, parents=True)\n    cache_file = cache_path.joinpath(\"http_cache.sqlite3\")\n    return CachedSession(backend=SQLiteCache(cache_file))\n\n\ndef pytest_plugin_projects_from_pypi(session: CachedSession) -> dict[str, int]:\n    response = session.get(\n        \"https://pypi.org/simple\",\n        headers={\"Accept\": \"application/vnd.pypi.simple.v1+json\"},\n        refresh=True,\n    )\n    return {\n        name: p[\"_last-serial\"]\n        for p in response.json()[\"projects\"]\n        if (name := p[\"name\"]).startswith(\"pytest-\") or name in ADDITIONAL_PROJECTS\n    }",
                "filename": "scripts/update-plugin-list.py",
                "start_index": 0,
                "end_index": 2939,
                "start_line": 1,
                "end_line": 155,
                "max_line": 195,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "import pytest\n\n\n@pytest.fixture(scope=\"module\", params=range(966))\ndef foo(request):\n    return request.param\n\n\ndef test_it(foo):\n    pass\n\n\ndef test_it2(foo):\n    pass",
                "filename": "bench/manyparam.py",
                "start_index": 0,
                "end_index": 168,
                "start_line": 1,
                "end_line": 14,
                "max_line": 14,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "# info:\n# * https://help.github.com/en/articles/displaying-a-sponsor-button-in-your-repository\n# * https://tidelift.com/subscription/how-to-connect-tidelift-with-github\ntidelift: pypi/pytest\nopen_collective: pytest",
                "filename": ".github/FUNDING.yml",
                "start_index": 0,
                "end_index": 214,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "\"\"\"\nThis script is part of the pytest release process which is triggered manually in the Actions\ntab of the repository.\n\nThe user will need to enter the base branch to start the release from (for example\n``6.1.x`` or ``main``) and if it should be a major release.\n\nThe appropriate version will be obtained based on the given branch automatically.\n\nAfter that, it will create a release using the `release` tox environment, and push a new PR.\n\n**Token**: currently the token from the GitHub Actions is used, pushed with\n`pytest bot <pytestbot@gmail.com>` commit author.\n\"\"\"\nimport argparse\nimport re\nfrom pathlib import Path\nfrom subprocess import check_call\nfrom subprocess import check_output\nfrom subprocess import run\n\nfrom colorama import Fore\nfrom colorama import init\nfrom github3.repos import Repository\n\n\nclass InvalidFeatureRelease(Exception):\n    pass\n\n\nSLUG = \"pytest-dev/pytest\"\n\nPR_BODY = \"\"\"\\\nCreated automatically from manual trigger.\n\nOnce all builds pass and it has been **approved** by one or more maintainers, the build\ncan be released by pushing a tag `{version}` to this repository.\n\"\"\"\n\n\ndef login(token: str) -> Repository:\n    import github3\n\n    github = github3.login(token=token)\n    owner, repo = SLUG.split(\"/\")\n    return github.repository(owner, repo)",
                "filename": "scripts/prepare-release-pr.py",
                "start_index": 0,
                "end_index": 1281,
                "start_line": 1,
                "end_line": 46,
                "max_line": 174,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "version: 2\nupdates:\n- package-ecosystem: pip\n  directory: \"/testing/plugins_integration\"\n  schedule:\n    interval: weekly\n    time: \"03:00\"\n  open-pull-requests-limit: 10\n  allow:\n  - dependency-type: direct\n  - dependency-type: indirect\n- package-ecosystem: github-actions\n  directory: /\n  schedule:\n    interval: weekly\n    time: \"03:00\"\n  open-pull-requests-limit: 10",
                "filename": ".github/dependabot.yml",
                "start_index": 0,
                "end_index": 370,
                "start_line": 1,
                "end_line": 17,
                "max_line": 17,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {},
        "solution_task": "- Update the pytest dependency to version 6.2.3 or later to resolve the temporary directory security issue.\n- Ensure that the `tmp_path` and `tmpdir` fixtures create directories with private permissions (e.g., `700`).\n- Implement error handling to check for pre-existing `/tmp/pytest-of-<username>` directories and raise an error if the directory is owned by another user.\n- Use the `os` module to check directory ownership and set permissions.\n\n```python\nimport os\nimport errno\nimport pytest\n\ndef create_temp_directory(username: str) -> str:\n    base_temp_dir = \"/tmp/pytest-of-{}\".format(username)\n    try:\n        os.makedirs(base_temp_dir, mode=0o700, exist_ok=True)\n    except OSError as e:\n        if e.errno == errno.EEXIST and not check_directory_ownership(base_temp_dir, username):\n            raise PermissionError(\"Directory {} already exists and is owned by another user.\".format(base_temp_dir))\n    return base_temp_dir\n\ndef check_directory_ownership(path: str, username: str) -> bool:\n    try:\n        stat_info = os.stat(path)\n        return stat_info.st_uid == os.getuid()\n    except FileNotFoundError:\n        return False\n\n# Ensure pytest version is 6.2.3 or later\nassert packaging.version.parse(pytest.__version__) >= packaging.version.parse(\"6.2.3\"), \"pytest version must be 6.2.3 or later\"\n```\n\n- The above code snippet should be integrated into the relevant part of the pytest codebase where temporary directories are handled.\n- Replace the placeholder implementation comments with the actual code provided above.\n- The version assertion should be placed at the beginning of the module where the temporary directory creation is handled.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSE must provide precise, actionable guidance and directly address all aspects of the described bug to facilitate its resolution.",
            "supporting_evidence": "The RESPONSE provides a comprehensive solution to the security issue described in the PROMPT. It suggests updating pytest to version 6.2.3 or later, which is the correct action to resolve the issue as stated in the PROMPT. It also provides actionable advice on ensuring that the `tmp_path` and `tmpdir` fixtures create directories with private permissions and includes a code snippet to check for pre-existing directories and set the correct permissions. The RESPONSE also correctly suggests using the `os` module for checking directory ownership and setting permissions. The code snippet provided is relevant and appears to be correctly implemented to address the security concerns. The RESPONSE also advises integrating the code into the pytest codebase and placing the version assertion at the beginning of the module, which is a logical step for ensuring the version requirement is met. The RESPONSE is only missing minor details that could make it a perfect solution, such as specific instructions on where to integrate the code snippet in the pytest codebase or how to handle potential exceptions that may arise from the version assertion.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711734663.859251,
        "result": "- Update the pytest dependency to version 6.2.3 or later to resolve the temporary directory security issue.\n- Ensure that the `tmp_path` and `tmpdir` fixtures create directories with private permissions (e.g., `700`).\n- Implement error handling to check for pre-existing `/tmp/pytest-of-<username>` directories and raise an error if the directory is owned by another user.\n- Use the `os` module to check directory ownership and set permissions.\n\n```python\nimport os\nimport errno\nimport pytest\n\ndef create_temp_directory(username: str) -> str:\n    base_temp_dir = \"/tmp/pytest-of-{}\".format(username)\n    try:\n        os.makedirs(base_temp_dir, mode=0o700, exist_ok=True)\n    except OSError as e:\n        if e.errno == errno.EEXIST and not check_directory_ownership(base_temp_dir, username):\n            raise PermissionError(\"Directory {} already exists and is owned by another user.\".format(base_temp_dir))\n    return base_temp_dir\n\ndef check_directory_ownership(path: str, username: str) -> bool:\n    try:\n        stat_info = os.stat(path)\n        return stat_info.st_uid == os.getuid()\n    except FileNotFoundError:\n        return False\n\n# Ensure pytest version is 6.2.3 or later\nassert packaging.version.parse(pytest.__version__) >= packaging.version.parse(\"6.2.3\"), \"pytest version must be 6.2.3 or later\"\n```\n\n- The above code snippet should be integrated into the relevant part of the pytest codebase where temporary directories are handled.\n- Replace the placeholder implementation comments with the actual code provided above.\n- The version assertion should be placed at the beginning of the module where the temporary directory creation is handled."
    }
}