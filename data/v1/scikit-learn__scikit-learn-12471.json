{
    "id": "scikit-learn__scikit-learn-12471",
    "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
    "task_id": 4012569524182216725,
    "title": "OneHotEncoder ignore unknown error when categories are strings ",
    "body": "#### Description\r\n\r\nThis bug is very specific, but it happens when you set OneHotEncoder to ignore unknown entries.\r\nand your labels are strings. The memory of the arrays is not handled safely and it can lead to a ValueError\r\n\r\nBasically, when you call the transform method it will sets all the unknown strings on your array to OneHotEncoder.categories_[i][0] which is the first category alphabetically sorted given for fit\r\nIf this OneHotEncoder.categories_[i][0] is a long string, and the array that you want to transform has small strings, then it is impossible to fit the whole  OneHotEncoder.categories_[i][0] into the entries of the array we want to transform. So  OneHotEncoder.categories_[i][0]  is truncated and this raise the ValueError.\r\n\r\n\r\n\r\n#### Steps/Code to Reproduce\r\n```\r\n\r\nimport numpy as np\r\nfrom sklearn.preprocessing import OneHotEncoder\r\n\r\n\r\n# It needs to be numpy arrays, the error does not appear \r\n# is you have lists of lists because it gets treated like an array of objects.\r\ntrain  = np.array([ '22','333','4444','11111111' ]).reshape((-1,1))\r\ntest   = np.array([ '55555',  '22' ]).reshape((-1,1))\r\n\r\nohe = OneHotEncoder(dtype=bool,handle_unknown='ignore')\r\n\r\nohe.fit( train )\r\nenc_test = ohe.transform( test )\r\n\r\n```\r\n\r\n\r\n#### Expected Results\r\nHere we should get an sparse matrix 2x4 false everywhere except at (1,1) the '22' that is known\r\n\r\n#### Actual Results\r\n\r\n> ValueError: y contains previously unseen labels: ['111111']\r\n\r\n\r\n#### Versions\r\nSystem:\r\n    python: 2.7.12 (default, Dec  4 2017, 14:50:18)  [GCC 5.4.0 20160609]\r\n   machine: Linux-4.4.0-138-generic-x86_64-with-Ubuntu-16.04-xenial\r\nexecutable: /usr/bin/python\r\n\r\nBLAS:\r\n    macros: HAVE_CBLAS=None\r\ncblas_libs: openblas, openblas\r\n  lib_dirs: /usr/lib\r\n\r\nPython deps:\r\n    Cython: 0.25.2\r\n     scipy: 0.18.1\r\nsetuptools: 36.7.0\r\n       pip: 9.0.1\r\n     numpy: 1.15.2\r\n    pandas: 0.19.1\r\n   sklearn: 0.21.dev0\r\n\r\n\r\n\r\n#### Comments\r\n\r\nI already implemented a fix for this issue, where I check the size of the elements in the array before, and I cast them into objects if necessary.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__0.21.git",
    "requested_commit": "",
    "mayil_response": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83d\ude41.                   But we've outlined some ideas that might help you get started:\n\n- Ensure that `OneHotEncoder` is initialized with `handle_unknown='ignore'` to avoid errors when encountering unseen labels during transformation.\n- Check that the `fit` method correctly sorts and stores the categories in `categories_` attribute.\n- Verify that the `transform` method does not raise a `ValueError` when encountering unseen labels and that it outputs a matrix with all zeros for the unseen category, as per the `handle_unknown='ignore'` behavior.\n- If the issue persists, investigate if there is a bug in the `transform` method where it incorrectly maps unknown strings to the first category from `fit` instead of assigning all zeros.\n- Ensure that the `dtype` parameter is set to `bool` if a boolean output is desired.\n- If the issue is related to memory handling or truncation of string categories, consider casting the input data to `object` dtype before fitting and transforming to prevent truncation and memory issues.\n- If the issue is reproducible with numpy arrays and not with lists of lists, ensure that the input data is properly reshaped using `reshape((-1, 1))` before passing it to `fit` or `transform`.\n- If a custom fix involving casting to objects has been implemented, review the fix to ensure it aligns with the expected behavior of `OneHotEncoder` when `handle_unknown='ignore'` is set.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn) \u2192 [preprocessing](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn/preprocessing)- [Lines 531 - 1603](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/preprocessing/_encoders.py#L531-L1603)\n\n This snippet contains the description of the 'handle_unknown' parameter for OneHotEncoder, which is directly related to the issue of handling unknown categories when they are strings. \n\n\n   - [Lines 23 - 530](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/preprocessing/_encoders.py#L23-L530)\n\n This snippet provides an overview of the OneHotEncoder class and its purpose, which is relevant to understanding the context of the issue. \n\n\n   - [Lines 1 - 19](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/preprocessing/_encoders.py#L1-L19)\n\n This snippet includes the import statements and the declaration of the OneHotEncoder class, which might be necessary for a developer to understand the dependencies and the context of the class implementation.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005909999999999999,
        "snippet_processor": 0.06463,
        "issue_star_creation": 0.03545,
        "issue_star_solver": 0.08279,
        "bouncer": 0.03024
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711741362.2817001,
        "relevant_snippets": [
            {
                "code": "if self.handle_unknown == \"use_encoded_value\":\n            for cardinality in cardinalities:\n                if 0 <= self.unknown_value < cardinality:\n                    raise ValueError(\n                        \"The used value for unknown_value \"\n                        f\"{self.unknown_value} is one of the \"\n                        \"values already used for encoding the \"\n                        \"seen categories.\"\n                    )\n\n        if self._missing_indices:\n            if np.dtype(self.dtype).kind != \"f\" and is_scalar_nan(\n                self.encoded_missing_value\n            ):\n                raise ValueError(\n                    \"There are missing values in features \"\n                    f\"{list(self._missing_indices)}. For OrdinalEncoder to \"\n                    f\"encode missing values with dtype: {self.dtype}, set \"\n                    \"encoded_missing_value to a non-nan value, or \"\n                    \"set dtype to a float\"\n                )\n\n            if not is_scalar_nan(self.encoded_missing_value):\n                # Features are invalid when they contain a missing category\n                # and encoded_missing_value was already used to encode a\n                # known category\n                invalid_features = [\n                    cat_idx\n                    for cat_idx, cardinality in enumerate(cardinalities)\n                    if cat_idx in self._missing_indices\n                    and 0 <= self.encoded_missing_value < cardinality\n                ]\n\n                if invalid_features:\n                    # Use feature names if they are available\n                    if hasattr(self, \"feature_names_in_\"):\n                        invalid_features = self.feature_names_in_[invalid_features]\n                    raise ValueError(\n                        f\"encoded_missing_value ({self.encoded_missing_value}) \"\n                        \"is already used to encode a known category in features: \"\n                        f\"{invalid_features}\"\n                    )\n\n        return self",
                "filename": "sklearn/preprocessing/_encoders.py",
                "start_index": 60923,
                "end_index": 62960,
                "start_line": 1463,
                "end_line": 1557,
                "max_line": 1674,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "default='error'\n        Specifies the way unknown categories are handled during :meth:`transform`.\n\n        - 'error' : Raise an error if an unknown category is present during transform.\n        - 'ignore' : When an unknown category is encountered during\n          transform, the resulting one-hot encoded columns for this feature\n          will be all zeros. In the inverse transform, an unknown category\n          will be denoted as None.\n        - 'infrequent_if_exist' : When an unknown category is encountered\n          during transform, the resulting one-hot encoded columns for this\n          feature will map to the infrequent category if it exists. The\n          infrequent category will be mapped to the last position in the\n          encoding. During inverse transform, an unknown category will be\n          mapped to the category denoted `'infrequent'` if it exists. If the\n          `'infrequent'` category does not exist, then :meth:`transform` and\n          :meth:`inverse_transform` will handle an unknown category as with\n          `handle_unknown='ignore'`. Infrequent categories exist based on\n          `min_frequency` and `max_categories`. Read more in the\n          :ref:`User Guide <encoder_infrequent_categories>`.\n\n        .. versionchanged:: 1.1\n            `'infrequent_if_exist'` was added to automatically handle unknown\n            categories and infrequent categories.\n\n    min_frequency : int or float, default=None\n        Specifies the minimum frequency below which a category will be\n        considered infrequent.\n\n        - If `int`, categories with a smaller cardinality will be considered\n          infrequent.\n\n        - If `float`, categories with a smaller cardinality than\n          `min_frequency * n_samples`  will be considered infrequent.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    max_categories : int, default=None\n        Specifies an upper limit to the number of output features for each input\n        feature when considering infrequent categories. If there are infrequent\n        categories, `max_categories` includes the category representing the\n        infrequent categories along with the frequent categories. If `None`,\n        there is no limit to the number of output features.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    feature_name_combiner : \"concat\" or callable, default=\"concat\"\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        `\"concat\"` concatenates encoded feature name and category with\n        `feature + \"_\" + str(category)`.E.g. feature X with values 1, 6, 7 create\n        feature names `X_1, X_6, X_7`.\n\n        .. versionadded:: 1.3\n\n    Attributes\n    ----------\n    categories_ : list of arrays\n        The categories of each feature determined during fitting\n        (in order of the features in X and corresponding with the output\n        of ``transform``). This includes the category specified in ``drop``\n        (if any).\n\n    drop_idx_ : array of shape (n_features,)\n        - ``drop_idx_[i]`` is the index in ``categories_[i]`` of the category\n          to be dropped for each feature.\n        - ``drop_idx_[i] = None`` if no category is to be dropped from the\n          feature with index ``i``, e.g. when `drop='if_binary'` and the\n          feature isn't binary.\n        - ``drop_idx_ = None`` if all the transformed features will be\n          retained.\n\n        If infrequent categories are enabled by setting `min_frequency` or\n        `max_categories` to a non-default value and `drop_idx[i]` corresponds\n        to a infrequent category, then the entire infrequent category is\n        dropped.\n\n        .. versionchanged:: 0.23\n           Added the possibility to contain `None` values.\n\n    infrequent_categories_ : list of ndarray\n        Defined only if infrequent categories are enabled by setting\n        `min_frequency` or `max_categories` to a non-default value.\n        `infrequent_categories_[i]` are the infrequent categories for feature\n        `i`. If the feature `i` has no infrequent categories\n        `infrequent_categories_[i]` is None.\n\n        .. versionadded:: 1.1\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 1.0\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    feature_name_combiner : callable or None\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        .. versionadded:: 1.3\n\n    See Also\n    --------\n    OrdinalEncoder : Performs an ordinal (integer)\n      encoding of the categorical features.\n    TargetEncoder : Encodes categorical features using the target.\n    sklearn.feature_extraction.DictVectorizer : Performs a one-hot encoding of\n      dictionary items (also handles string-valued features).\n    sklearn.feature_extraction.FeatureHasher : Performs an approximate one-hot\n      encoding of dictionary items or strings.\n    LabelBinarizer : Binarizes labels in a one-vs-all\n      fashion.\n    MultiLabelBinarizer : Transforms between iterable of\n      iterables and a multilabel format, e.g. a (samples x classes) binary\n      matrix indicating the presence of a class label.\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to a binary one-hot encoding.\n\n    >>> from sklearn.preprocessing import OneHotEncoder\n\n    One can discard categories not seen during `fit`:\n\n    >>> enc = OneHotEncoder(handle_unknown='ignore')\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OneHotEncoder(handle_unknown='ignore')\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 1], ['Male', 4]]).toarray()\n    array([[1., 0., 1., 0., 0.],\n           [0., 1., 0., 0., 0.]])\n    >>> enc.inverse_transform([[0, 1, 1, 0, 0], [0, 0, 0, 1, 0]])\n    array([['Male', 1],\n           [None, 2]], dtype=object)\n    >>> enc.get_feature_names_out(['gender', 'group'])\n    array(['gender_Female', 'gender_Male', 'group_1', 'group_2', 'group_3'], ...)\n\n    One can always drop the first column for each feature:\n\n    >>> drop_enc = OneHotEncoder(drop='first').fit(X)\n    >>> drop_enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> drop_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 0., 0.],\n           [1., 1., 0.]])\n\n    Or drop a column for feature only having 2 categories:\n\n    >>> drop_binary_enc = OneHotEncoder(drop='if_binary').fit(X)\n    >>> drop_binary_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 1., 0., 0.],\n           [1., 0., 1., 0.]])\n\n    One can change the way feature names are created.\n\n    >>> def custom_combiner(feature, category):\n    ...     return str(feature) + \"_\" + type(category).__name__ + \"_\" + str(category)\n    >>> custom_fnames_enc = OneHotEncoder(feature_name_combiner=custom_combiner).fit(X)\n    >>> custom_fnames_enc.get_feature_names_out()\n    array(['x0_str_Female', 'x0_str_Male', 'x1_int_1', 'x1_int_2', 'x1_int_3'],\n          dtype=object)\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n\n    >>> import numpy as np\n    >>> X = np.array([[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3], dtype=object).T\n    >>> ohe = OneHotEncoder(max_categories=3, sparse_output=False).fit(X)\n    >>> ohe.infrequent_categories_\n    [array(['a', 'd'], dtype=object)]\n    >>> ohe.transform([[\"a\"], [\"b\"]])\n    array([[0., 0., 1.],\n           [1., 0., 0.]])\n    \"\"\"",
                "filename": "sklearn/preprocessing/_encoders.py",
                "start_index": 21466,
                "end_index": 29587,
                "start_line": 531,
                "end_line": 1603,
                "max_line": 1674,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Encode categorical features as a one-hot numeric array.\n\n    The input to this transformer should be an array-like of integers or\n    strings, denoting the values taken on by categorical (discrete) features.\n    The features are encoded using a one-hot (aka 'one-of-K' or 'dummy')\n    encoding scheme. This creates a binary column for each category and\n    returns a sparse matrix or dense array (depending on the ``sparse_output``\n    parameter)\n\n    By default, the encoder derives the categories based on the unique values\n    in each feature. Alternatively, you can also specify the `categories`\n    manually.\n\n    This encoding is needed for feeding categorical data to many scikit-learn\n    estimators, notably linear models and SVMs with the standard kernels.\n\n    Note: a one-hot encoding of y labels should use a LabelBinarizer\n    instead.\n\n    Read more in the :ref:`User Guide <preprocessing_categorical_features>`.\n\n    Parameters\n    ----------\n    categories : 'auto' or a list of array-like, default='auto'\n        Categories (unique values) per feature:\n\n        - 'auto' : Determine categories automatically from the training data.\n        - list : ``categories[i]`` holds the categories expected in the ith\n          column. The passed categories should not mix strings and numeric\n          values within a single feature, and should be sorted in case of\n          numeric values.\n\n        The used categories can be found in the ``categories_`` attribute.\n\n        .. versionadded:: 0.20\n\n    drop : {'first', 'if_binary'} or an array-like of shape (n_features,), \\\n            default=None\n        Specifies a methodology to use to drop one of the categories per\n        feature. This is useful in situations where perfectly collinear\n        features cause problems, such as when feeding the resulting data\n        into an unregularized linear regression model.\n\n        However, dropping one category breaks the symmetry of the original\n        representation and can therefore induce a bias in downstream models,\n        for instance for penalized linear classification or regression models.\n\n        - None : retain all features (the default).\n        - 'first' : drop the first category in each feature. If only one\n          category is present, the feature will be dropped entirely.\n        - 'if_binary' : drop the first category in each feature with two\n          categories. Features with 1 or more than 2 categories are\n          left intact.\n        - array : ``drop[i]`` is the category in feature ``X[:, i]`` that\n          should be dropped.\n\n        When `max_categories` or `min_frequency` is configured to group\n        infrequent categories, the dropping behavior is handled after the\n        grouping.\n\n        .. versionadded:: 0.21\n           The parameter `drop` was added in 0.21.\n\n        .. versionchanged:: 0.23\n           The option `drop='if_binary'` was added in 0.23.\n\n        .. versionchanged:: 1.1\n            Support for dropping infrequent categories.\n\n    sparse : bool, default=True\n        Will return sparse matrix if set True else will return an array.\n\n        .. deprecated:: 1.2\n           `sparse` is deprecated in 1.2 and will be removed in 1.4. Use\n           `sparse_output` instead.\n\n    sparse_output : bool, default=True\n        Will return sparse matrix if set True else will return an array.\n\n        .. versionadded:: 1.2\n           `sparse` was renamed to `sparse_output`\n\n    dtype : number type, default=float\n        Desired dtype of output.\n\n    handle_unknown : {'error', 'ignore', 'infrequent_if_exist'}, \\",
                "filename": "sklearn/preprocessing/_encoders.py",
                "start_index": 17847,
                "end_index": 21444,
                "start_line": 23,
                "end_line": 530,
                "max_line": 1674,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "# More details in the :ref:`User Guide <target_encoder>`.\nimport numpy as np\nfrom sklearn.preprocessing import TargetEncoder\n\nX = np.array([[\"cat\"] * 30 + [\"dog\"] * 20 + [\"snake\"] * 38], dtype=object).T\ny = [90.3] * 30 + [20.4] * 20 + [21.2] * 38\n\nenc = TargetEncoder(random_state=0)\nX_trans = enc.fit_transform(X, y)\n\nenc.encodings_\n\n# %%\n# Missing values support in decision trees\n# ----------------------------------------\n# The classes :class:`tree.DecisionTreeClassifier` and\n# :class:`tree.DecisionTreeRegressor` now support missing values. For each potential\n# threshold on the non-missing data, the splitter will evaluate the split with all the\n# missing values going to the left node or the right node.\n# More details in the :ref:`User Guide <tree_missing_value_support>`.\nimport numpy as np\nfrom sklearn.tree import DecisionTreeClassifier\n\nX = np.array([0, 1, 6, np.nan]).reshape(-1, 1)\ny = [0, 0, 1, 1]\n\ntree = DecisionTreeClassifier(random_state=0).fit(X, y)\ntree.predict(X)\n\n# %%\n# New display `model_selection.ValidationCurveDisplay`\n# ----------------------------------------------------\n# :class:`model_selection.ValidationCurveDisplay` is now available to plot results\n# from :func:`model_selection.validation_curve`.\nfrom sklearn.datasets import make_classification\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import ValidationCurveDisplay\n\nX, y = make_classification(1000, 10, random_state=0)\n\n_ = ValidationCurveDisplay.from_estimator(\n    LogisticRegression(),\n    X,\n    y,\n    param_name=\"C\",\n    param_range=np.geomspace(1e-5, 1e3, num=9),\n    score_type=\"both\",\n    score_name=\"Accuracy\",\n)\n\n# %%\n# Gamma loss for gradient boosting\n# --------------------------------\n# The class :class:`ensemble.HistGradientBoostingRegressor` supports the\n# Gamma deviance loss function via `loss=\"gamma\"`. This loss function is useful for\n# modeling strictly positive targets with a right-skewed distribution.\nimport numpy as np\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.datasets import make_low_rank_matrix\nfrom sklearn.ensemble import HistGradientBoostingRegressor\n\nn_samples, n_features = 500, 10\nrng = np.random.RandomState(0)\nX = make_low_rank_matrix(n_samples, n_features, random_state=rng)\ncoef = rng.uniform(low=-10, high=20, size=n_features)\ny = rng.gamma(shape=2, scale=np.exp(X @ coef) / 2)\ngbdt = HistGradientBoostingRegressor(loss=\"gamma\")\ncross_val_score(gbdt, X, y).mean()\n\n# %%\n# Grouping infrequent categories in :class:`preprocessing.OrdinalEncoder`\n# -----------------------------------------------------------------------\n# Similarly to :class:`preprocessing.OneHotEncoder`, the class\n# :class:`preprocessing.OrdinalEncoder` now supports aggregating infrequent categories\n# into a single output for each feature. The parameters to enable the gathering of\n# infrequent categories are `min_frequency` and `max_categories`.\n# See the :ref:`User Guide <encoder_infrequent_categories>` for more details.",
                "filename": "examples/release_highlights/plot_release_highlights_1_3_0.py",
                "start_index": 2966,
                "end_index": 5954,
                "start_line": 72,
                "end_line": 148,
                "max_line": 156,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "# Authors: Andreas Mueller <amueller@ais.uni-bonn.de>\n#          Joris Van den Bossche <jorisvandenbossche@gmail.com>\n# License: BSD 3 clause\n\nimport numbers\nimport warnings\nfrom numbers import Integral\n\nimport numpy as np\nfrom scipy import sparse\n\nfrom ..base import BaseEstimator, OneToOneFeatureMixin, TransformerMixin, _fit_context\nfrom ..utils import _safe_indexing, check_array, is_scalar_nan\nfrom ..utils._encode import _check_unknown, _encode, _get_counts, _unique\nfrom ..utils._mask import _get_mask\nfrom ..utils._param_validation import Hidden, Interval, RealNotInt, StrOptions\nfrom ..utils.validation import _check_feature_names_in, check_is_fitted\n\n__all__ = [\"OneHotEncoder\", \"OrdinalEncoder\"]",
                "filename": "sklearn/preprocessing/_encoders.py",
                "start_index": 0,
                "end_index": 706,
                "start_line": 1,
                "end_line": 19,
                "max_line": 1674,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Encode categorical features as an integer array.\n\n    The input to this transformer should be an array-like of integers or\n    strings, denoting the values taken on by categorical (discrete) features.\n    The features are converted to ordinal integers. This results in\n    a single column of integers (0 to n_categories - 1) per feature.\n\n    Read more in the :ref:`User Guide <preprocessing_categorical_features>`.\n\n    .. versionadded:: 0.20\n\n    Parameters\n    ----------\n    categories : 'auto' or a list of array-like, default='auto'\n        Categories (unique values) per feature:\n\n        - 'auto' : Determine categories automatically from the training data.\n        - list : ``categories[i]`` holds the categories expected in the ith\n          column. The passed categories should not mix strings and numeric\n          values, and should be sorted in case of numeric values.\n\n        The used categories can be found in the ``categories_`` attribute.\n\n    dtype : number type, default=np.float64\n        Desired dtype of output.\n\n    handle_unknown : {'error', 'use_encoded_value'}, default='error'\n        When set to 'error' an error will be raised in case an unknown\n        categorical feature is present during transform. When set to\n        'use_encoded_value', the encoded value of unknown categories will be\n        set to the value given for the parameter `unknown_value`. In\n        :meth:`inverse_transform`, an unknown category will be denoted as None.\n\n        .. versionadded:: 0.24\n\n    unknown_value : int or np.nan, default=None\n        When the parameter handle_unknown is set to 'use_encoded_value', this\n        parameter is required and will set the encoded value of unknown\n        categories. It has to be distinct from the values used to encode any of\n        the categories in `fit`. If set to np.nan, the `dtype` parameter must\n        be a float dtype.\n\n        .. versionadded:: 0.24\n\n    encoded_missing_value : int or np.nan, default=np.nan\n        Encoded value of missing categories. If set to `np.nan`, then the `dtype`\n        parameter must be a float dtype.\n\n        .. versionadded:: 1.1\n\n    min_frequency : int or float, default=None\n        Specifies the minimum frequency below which a category will be\n        considered infrequent.\n\n        - If `int`, categories with a smaller cardinality will be considered\n          infrequent.\n\n        - If `float`, categories with a smaller cardinality than\n          `min_frequency * n_samples`  will be considered infrequent.\n\n        .. versionadded:: 1.3\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    max_categories : int, default=None\n        Specifies an upper limit to the number of output categories for each input\n        feature when considering infrequent categories. If there are infrequent\n        categories, `max_categories` includes the category representing the\n        infrequent categories along with the frequent categories. If `None`,\n        there is no limit to the number of output features.\n\n        `max_categories` do **not** take into account missing or unknown\n        categories. Setting `unknown_value` or `encoded_missing_value` to an\n        integer will increase the number of unique integer codes by one each.\n        This can result in up to `max_categories + 2` integer codes.\n\n        .. versionadded:: 1.3\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    Attributes\n    ----------\n    categories_ : list of arrays\n        The categories of each feature determined during ``fit`` (in order of\n        the features in X and corresponding with the output of ``transform``).\n        This does not include categories that weren't seen during ``fit``.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 1.0\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    infrequent_categories_ : list of ndarray\n        Defined only if infrequent categories are enabled by setting\n        `min_frequency` or `max_categories` to a non-default value.\n        `infrequent_categories_[i]` are the infrequent categories for feature\n        `i`. If the feature `i` has no infrequent categories\n        `infrequent_categories_[i]` is None.\n\n        .. versionadded:: 1.3\n\n    See Also\n    --------\n    OneHotEncoder : Performs a one-hot encoding of categorical features. This encoding\n        is suitable for low to medium cardinality categorical variables, both in\n        supervised and unsupervised settings.\n    TargetEncoder : Encodes categorical features using supervised signal\n        in a classification or regression pipeline. This encoding is typically\n        suitable for high cardinality categorical variables.\n    LabelEncoder : Encodes target labels with values between 0 and\n        ``n_classes-1``.\n\n    Notes\n    -----\n    With a high proportion of `nan` values, inferring categories becomes slow with\n    Python versions before 3.10. The handling of `nan` values was improved\n    from Python 3.10 onwards, (c.f.\n    `bpo-43475 <https://github.com/python/cpython/issues/87641>`_).\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to an ordinal encoding.\n\n    >>> from sklearn.preprocessing import OrdinalEncoder\n    >>> enc = OrdinalEncoder()\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OrdinalEncoder()\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 3], ['Male', 1]])\n    array([[0., 2.],\n           [1., 0.]])\n\n    >>> enc.inverse_transform([[1, 0], [0, 1]])\n    array([['Male', 1],\n           ['Female', 2]], dtype=object)\n\n    By default, :class:`OrdinalEncoder` is lenient towards missing values by\n    propagating them.\n\n    >>> import numpy as np\n    >>> X = [['Male', 1], ['Female', 3], ['Female', np.nan]]\n    >>> enc.fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., nan]])\n\n    You can use the parameter `encoded_missing_value` to encode missing values.\n\n    >>> enc.set_params(encoded_missing_value=-1).fit_transform(X)\n    array([[ 1.,  0.],\n           [ 0.,  1.],\n           [ 0., -1.]])\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n    In the following example, \"a\" and \"d\" are considered infrequent and grouped\n    together into a single category, \"b\" and \"c\" are their own categories, unknown\n    values are encoded as 3 and missing values are encoded as 4.\n\n    >>> X_train = np.array(\n    ...     [[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3 + [np.nan]],\n    ...     dtype=object).T\n    >>> enc = OrdinalEncoder(\n    ...     handle_unknown=\"use_encoded_value\", unknown_value=3,\n    ...     max_categories=3, encoded_missing_value=4)\n    >>> _ = enc.fit(X_train)\n    >>> X_test = np.array([[\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [np.nan]], dtype=object)\n    >>> enc.transform(X_test)\n    array([[2.],\n           [0.],\n           [1.],\n           [2.],\n           [3.],\n           [4.]])\n    \"\"\"",
                "filename": "sklearn/preprocessing/_encoders.py",
                "start_index": 49615,
                "end_index": 56949,
                "start_line": 23,
                "end_line": 1603,
                "max_line": 1674,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "from sklearn.preprocessing import OrdinalEncoder\nimport numpy as np\n\nX = np.array(\n    [[\"dog\"] * 5 + [\"cat\"] * 20 + [\"rabbit\"] * 10 + [\"snake\"] * 3], dtype=object\n).T\nenc = OrdinalEncoder(min_frequency=6).fit(X)\nenc.infrequent_categories_",
                "filename": "examples/release_highlights/plot_release_highlights_1_3_0.py",
                "start_index": 5955,
                "end_index": 6194,
                "start_line": 149,
                "end_line": 156,
                "max_line": 156,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "\"\"\"\n=======================================\nTarget Encoder's Internal Cross fitting\n=======================================\n\n.. currentmodule:: sklearn.preprocessing\n\nThe :class:`TargetEncoder` replaces each category of a categorical feature with\nthe mean of the target variable for that category. This method is useful\nin cases where there is a strong relationship between the categorical feature\nand the target. To prevent overfitting, :meth:`TargetEncoder.fit_transform` uses\nan internal cross fitting scheme to encode the training data to be used by a\ndownstream model. In this example, we demonstrate the importance of the cross fitting\nprocedure to prevent overfitting.\n\"\"\"\n\n# %%\n# Create Synthetic Dataset\n# ========================\n# For this example, we build a dataset with three categorical features: an informative\n# feature with medium cardinality, an uninformative feature with medium cardinality,\n# and an uninformative feature with high cardinality. First, we generate the informative\n# feature:\nimport numpy as np\n\nfrom sklearn.preprocessing import KBinsDiscretizer\n\nn_samples = 50_000\n\nrng = np.random.RandomState(42)\ny = rng.randn(n_samples)\nnoise = 0.5 * rng.randn(n_samples)\nn_categories = 100\n\nkbins = KBinsDiscretizer(\n    n_bins=n_categories, encode=\"ordinal\", strategy=\"uniform\", random_state=rng\n)\nX_informative = kbins.fit_transform((y + noise).reshape(-1, 1))\n\n# Remove the linear relationship between y and the bin index by permuting the values of\n# X_informative\npermuted_categories = rng.permutation(n_categories)\nX_informative = permuted_categories[X_informative.astype(np.int32)]\n\n# %%\n# The uninformative feature with medium cardinality is generated by permuting the\n# informative feature and removing the relationship with the target:\nX_shuffled = rng.permutation(X_informative)\n\n# %%\n# The uninformative feature with high cardinality is generated so that is independent of\n# the target variable. We will show that target encoding without cross fitting will\n# cause catastrophic overfitting for the downstream regressor. These high cardinality\n# features are basically unique identifiers for samples which should generally be\n# removed from machine learning dataset. In this example, we generate them to show how\n# :class:`TargetEncoder`'s default cross fitting behavior mitigates the overfitting\n# issue automatically.\nX_near_unique_categories = rng.choice(\n    int(0.9 * n_samples), size=n_samples, replace=True\n).reshape(-1, 1)\n\n# %%\n# Finally, we assemble the dataset and perform a train test split:\nimport pandas as pd\n\nfrom sklearn.model_selection import train_test_split\n\nX = pd.DataFrame(\n    np.concatenate(\n        [X_informative, X_shuffled, X_near_unique_categories],\n        axis=1,\n    ),\n    columns=[\"informative\", \"shuffled\", \"near_unique\"],\n)\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)\n\n# %%\n# Training a Ridge Regressor\n# ==========================",
                "filename": "examples/preprocessing/plot_target_encoder_cross_val.py",
                "start_index": 0,
                "end_index": 2933,
                "start_line": 1,
                "end_line": 79,
                "max_line": 162,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "class OneHotEncoder(_BaseEncoder):",
                "filename": "sklearn/preprocessing/_encoders.py",
                "start_index": 17808,
                "end_index": 17842,
                "start_line": 443,
                "end_line": 443,
                "max_line": 1674,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "@ignore_warnings(category=FutureWarning)\ndef check_classifiers_one_label(name, classifier_orig):\n    error_string_fit = \"Classifier can't train when only one class is present.\"\n    error_string_predict = \"Classifier can't predict when only one class is present.\"\n    rnd = np.random.RandomState(0)\n    X_train = rnd.uniform(size=(10, 3))\n    X_test = rnd.uniform(size=(10, 3))\n    y = np.ones(10)\n    # catch deprecation warnings\n    with ignore_warnings(category=FutureWarning):\n        classifier = clone(classifier_orig)\n        with raises(\n            ValueError, match=\"class\", may_pass=True, err_msg=error_string_fit\n        ) as cm:\n            classifier.fit(X_train, y)\n\n        if cm.raised_and_matched:\n            # ValueError was raised with proper error message\n            return\n\n        assert_array_equal(classifier.predict(X_test), y, err_msg=error_string_predict)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_classifiers_one_label_sample_weights(name, classifier_orig):\n    \"\"\"Check that classifiers accepting sample_weight fit or throws a ValueError with\n    an explicit message if the problem is reduced to one class.\n    \"\"\"\n    error_fit = (\n        f\"{name} failed when fitted on one label after sample_weight trimming. Error \"\n        \"message is not explicit, it should have 'class'.\"\n    )\n    error_predict = f\"{name} prediction results should only output the remaining class.\"\n    rnd = np.random.RandomState(0)\n    # X should be square for test on SVC with precomputed kernel\n    X_train = rnd.uniform(size=(10, 10))\n    X_test = rnd.uniform(size=(10, 10))\n    y = np.arange(10) % 2\n    sample_weight = y.copy()  # select a single class\n    classifier = clone(classifier_orig)\n\n    if has_fit_parameter(classifier, \"sample_weight\"):\n        match = [r\"\\bclass(es)?\\b\", error_predict]\n        err_type, err_msg = (AssertionError, ValueError), error_fit\n    else:\n        match = r\"\\bsample_weight\\b\"\n        err_type, err_msg = (TypeError, ValueError), None\n\n    with raises(err_type, match=match, may_pass=True, err_msg=err_msg) as cm:\n        classifier.fit(X_train, y, sample_weight=sample_weight)\n        if cm.raised_and_matched:\n            # raise the proper error type with the proper error message\n            return\n        # for estimators that do not fail, they should be able to predict the only\n        # class remaining during fit\n        assert_array_equal(\n            classifier.predict(X_test), np.ones(10), err_msg=error_predict\n        )",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 79371,
                "end_index": 81868,
                "start_line": 181,
                "end_line": 4639,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sklearn/preprocessing/_encoders.py": [
                {
                    "chunk": {
                        "code": "default='error'\n        Specifies the way unknown categories are handled during :meth:`transform`.\n\n        - 'error' : Raise an error if an unknown category is present during transform.\n        - 'ignore' : When an unknown category is encountered during\n          transform, the resulting one-hot encoded columns for this feature\n          will be all zeros. In the inverse transform, an unknown category\n          will be denoted as None.\n        - 'infrequent_if_exist' : When an unknown category is encountered\n          during transform, the resulting one-hot encoded columns for this\n          feature will map to the infrequent category if it exists. The\n          infrequent category will be mapped to the last position in the\n          encoding. During inverse transform, an unknown category will be\n          mapped to the category denoted `'infrequent'` if it exists. If the\n          `'infrequent'` category does not exist, then :meth:`transform` and\n          :meth:`inverse_transform` will handle an unknown category as with\n          `handle_unknown='ignore'`. Infrequent categories exist based on\n          `min_frequency` and `max_categories`. Read more in the\n          :ref:`User Guide <encoder_infrequent_categories>`.\n\n        .. versionchanged:: 1.1\n            `'infrequent_if_exist'` was added to automatically handle unknown\n            categories and infrequent categories.\n\n    min_frequency : int or float, default=None\n        Specifies the minimum frequency below which a category will be\n        considered infrequent.\n\n        - If `int`, categories with a smaller cardinality will be considered\n          infrequent.\n\n        - If `float`, categories with a smaller cardinality than\n          `min_frequency * n_samples`  will be considered infrequent.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    max_categories : int, default=None\n        Specifies an upper limit to the number of output features for each input\n        feature when considering infrequent categories. If there are infrequent\n        categories, `max_categories` includes the category representing the\n        infrequent categories along with the frequent categories. If `None`,\n        there is no limit to the number of output features.\n\n        .. versionadded:: 1.1\n            Read more in the :ref:`User Guide <encoder_infrequent_categories>`.\n\n    feature_name_combiner : \"concat\" or callable, default=\"concat\"\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        `\"concat\"` concatenates encoded feature name and category with\n        `feature + \"_\" + str(category)`.E.g. feature X with values 1, 6, 7 create\n        feature names `X_1, X_6, X_7`.\n\n        .. versionadded:: 1.3\n\n    Attributes\n    ----------\n    categories_ : list of arrays\n        The categories of each feature determined during fitting\n        (in order of the features in X and corresponding with the output\n        of ``transform``). This includes the category specified in ``drop``\n        (if any).\n\n    drop_idx_ : array of shape (n_features,)\n        - ``drop_idx_[i]`` is the index in ``categories_[i]`` of the category\n          to be dropped for each feature.\n        - ``drop_idx_[i] = None`` if no category is to be dropped from the\n          feature with index ``i``, e.g. when `drop='if_binary'` and the\n          feature isn't binary.\n        - ``drop_idx_ = None`` if all the transformed features will be\n          retained.\n\n        If infrequent categories are enabled by setting `min_frequency` or\n        `max_categories` to a non-default value and `drop_idx[i]` corresponds\n        to a infrequent category, then the entire infrequent category is\n        dropped.\n\n        .. versionchanged:: 0.23\n           Added the possibility to contain `None` values.\n\n    infrequent_categories_ : list of ndarray\n        Defined only if infrequent categories are enabled by setting\n        `min_frequency` or `max_categories` to a non-default value.\n        `infrequent_categories_[i]` are the infrequent categories for feature\n        `i`. If the feature `i` has no infrequent categories\n        `infrequent_categories_[i]` is None.\n\n        .. versionadded:: 1.1\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 1.0\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    feature_name_combiner : callable or None\n        Callable with signature `def callable(input_feature, category)` that returns a\n        string. This is used to create feature names to be returned by\n        :meth:`get_feature_names_out`.\n\n        .. versionadded:: 1.3\n\n    See Also\n    --------\n    OrdinalEncoder : Performs an ordinal (integer)\n      encoding of the categorical features.\n    TargetEncoder : Encodes categorical features using the target.\n    sklearn.feature_extraction.DictVectorizer : Performs a one-hot encoding of\n      dictionary items (also handles string-valued features).\n    sklearn.feature_extraction.FeatureHasher : Performs an approximate one-hot\n      encoding of dictionary items or strings.\n    LabelBinarizer : Binarizes labels in a one-vs-all\n      fashion.\n    MultiLabelBinarizer : Transforms between iterable of\n      iterables and a multilabel format, e.g. a (samples x classes) binary\n      matrix indicating the presence of a class label.\n\n    Examples\n    --------\n    Given a dataset with two features, we let the encoder find the unique\n    values per feature and transform the data to a binary one-hot encoding.\n\n    >>> from sklearn.preprocessing import OneHotEncoder\n\n    One can discard categories not seen during `fit`:\n\n    >>> enc = OneHotEncoder(handle_unknown='ignore')\n    >>> X = [['Male', 1], ['Female', 3], ['Female', 2]]\n    >>> enc.fit(X)\n    OneHotEncoder(handle_unknown='ignore')\n    >>> enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> enc.transform([['Female', 1], ['Male', 4]]).toarray()\n    array([[1., 0., 1., 0., 0.],\n           [0., 1., 0., 0., 0.]])\n    >>> enc.inverse_transform([[0, 1, 1, 0, 0], [0, 0, 0, 1, 0]])\n    array([['Male', 1],\n           [None, 2]], dtype=object)\n    >>> enc.get_feature_names_out(['gender', 'group'])\n    array(['gender_Female', 'gender_Male', 'group_1', 'group_2', 'group_3'], ...)\n\n    One can always drop the first column for each feature:\n\n    >>> drop_enc = OneHotEncoder(drop='first').fit(X)\n    >>> drop_enc.categories_\n    [array(['Female', 'Male'], dtype=object), array([1, 2, 3], dtype=object)]\n    >>> drop_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 0., 0.],\n           [1., 1., 0.]])\n\n    Or drop a column for feature only having 2 categories:\n\n    >>> drop_binary_enc = OneHotEncoder(drop='if_binary').fit(X)\n    >>> drop_binary_enc.transform([['Female', 1], ['Male', 2]]).toarray()\n    array([[0., 1., 0., 0.],\n           [1., 0., 1., 0.]])\n\n    One can change the way feature names are created.\n\n    >>> def custom_combiner(feature, category):\n    ...     return str(feature) + \"_\" + type(category).__name__ + \"_\" + str(category)\n    >>> custom_fnames_enc = OneHotEncoder(feature_name_combiner=custom_combiner).fit(X)\n    >>> custom_fnames_enc.get_feature_names_out()\n    array(['x0_str_Female', 'x0_str_Male', 'x1_int_1', 'x1_int_2', 'x1_int_3'],\n          dtype=object)\n\n    Infrequent categories are enabled by setting `max_categories` or `min_frequency`.\n\n    >>> import numpy as np\n    >>> X = np.array([[\"a\"] * 5 + [\"b\"] * 20 + [\"c\"] * 10 + [\"d\"] * 3], dtype=object).T\n    >>> ohe = OneHotEncoder(max_categories=3, sparse_output=False).fit(X)\n    >>> ohe.infrequent_categories_\n    [array(['a', 'd'], dtype=object)]\n    >>> ohe.transform([[\"a\"], [\"b\"]])\n    array([[0., 0., 1.],\n           [1., 0., 0.]])\n    \"\"\"",
                        "filename": "sklearn/preprocessing/_encoders.py",
                        "start_index": 21466,
                        "end_index": 29587,
                        "start_line": 531,
                        "end_line": 1603,
                        "max_line": 1674,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the description of the 'handle_unknown' parameter for OneHotEncoder, which is directly related to the issue of handling unknown categories when they are strings."
                },
                {
                    "chunk": {
                        "code": "\"\"\"\n    Encode categorical features as a one-hot numeric array.\n\n    The input to this transformer should be an array-like of integers or\n    strings, denoting the values taken on by categorical (discrete) features.\n    The features are encoded using a one-hot (aka 'one-of-K' or 'dummy')\n    encoding scheme. This creates a binary column for each category and\n    returns a sparse matrix or dense array (depending on the ``sparse_output``\n    parameter)\n\n    By default, the encoder derives the categories based on the unique values\n    in each feature. Alternatively, you can also specify the `categories`\n    manually.\n\n    This encoding is needed for feeding categorical data to many scikit-learn\n    estimators, notably linear models and SVMs with the standard kernels.\n\n    Note: a one-hot encoding of y labels should use a LabelBinarizer\n    instead.\n\n    Read more in the :ref:`User Guide <preprocessing_categorical_features>`.\n\n    Parameters\n    ----------\n    categories : 'auto' or a list of array-like, default='auto'\n        Categories (unique values) per feature:\n\n        - 'auto' : Determine categories automatically from the training data.\n        - list : ``categories[i]`` holds the categories expected in the ith\n          column. The passed categories should not mix strings and numeric\n          values within a single feature, and should be sorted in case of\n          numeric values.\n\n        The used categories can be found in the ``categories_`` attribute.\n\n        .. versionadded:: 0.20\n\n    drop : {'first', 'if_binary'} or an array-like of shape (n_features,), \\\n            default=None\n        Specifies a methodology to use to drop one of the categories per\n        feature. This is useful in situations where perfectly collinear\n        features cause problems, such as when feeding the resulting data\n        into an unregularized linear regression model.\n\n        However, dropping one category breaks the symmetry of the original\n        representation and can therefore induce a bias in downstream models,\n        for instance for penalized linear classification or regression models.\n\n        - None : retain all features (the default).\n        - 'first' : drop the first category in each feature. If only one\n          category is present, the feature will be dropped entirely.\n        - 'if_binary' : drop the first category in each feature with two\n          categories. Features with 1 or more than 2 categories are\n          left intact.\n        - array : ``drop[i]`` is the category in feature ``X[:, i]`` that\n          should be dropped.\n\n        When `max_categories` or `min_frequency` is configured to group\n        infrequent categories, the dropping behavior is handled after the\n        grouping.\n\n        .. versionadded:: 0.21\n           The parameter `drop` was added in 0.21.\n\n        .. versionchanged:: 0.23\n           The option `drop='if_binary'` was added in 0.23.\n\n        .. versionchanged:: 1.1\n            Support for dropping infrequent categories.\n\n    sparse : bool, default=True\n        Will return sparse matrix if set True else will return an array.\n\n        .. deprecated:: 1.2\n           `sparse` is deprecated in 1.2 and will be removed in 1.4. Use\n           `sparse_output` instead.\n\n    sparse_output : bool, default=True\n        Will return sparse matrix if set True else will return an array.\n\n        .. versionadded:: 1.2\n           `sparse` was renamed to `sparse_output`\n\n    dtype : number type, default=float\n        Desired dtype of output.\n\n    handle_unknown : {'error', 'ignore', 'infrequent_if_exist'}, \\",
                        "filename": "sklearn/preprocessing/_encoders.py",
                        "start_index": 17847,
                        "end_index": 21444,
                        "start_line": 23,
                        "end_line": 530,
                        "max_line": 1674,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet provides an overview of the OneHotEncoder class and its purpose, which is relevant to understanding the context of the issue."
                },
                {
                    "chunk": {
                        "code": "# Authors: Andreas Mueller <amueller@ais.uni-bonn.de>\n#          Joris Van den Bossche <jorisvandenbossche@gmail.com>\n# License: BSD 3 clause\n\nimport numbers\nimport warnings\nfrom numbers import Integral\n\nimport numpy as np\nfrom scipy import sparse\n\nfrom ..base import BaseEstimator, OneToOneFeatureMixin, TransformerMixin, _fit_context\nfrom ..utils import _safe_indexing, check_array, is_scalar_nan\nfrom ..utils._encode import _check_unknown, _encode, _get_counts, _unique\nfrom ..utils._mask import _get_mask\nfrom ..utils._param_validation import Hidden, Interval, RealNotInt, StrOptions\nfrom ..utils.validation import _check_feature_names_in, check_is_fitted\n\n__all__ = [\"OneHotEncoder\", \"OrdinalEncoder\"]",
                        "filename": "sklearn/preprocessing/_encoders.py",
                        "start_index": 0,
                        "end_index": 706,
                        "start_line": 1,
                        "end_line": 19,
                        "max_line": 1674,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the import statements and the declaration of the OneHotEncoder class, which might be necessary for a developer to understand the dependencies and the context of the class implementation."
                }
            ]
        },
        "solution_task": "- Ensure that `OneHotEncoder` is initialized with `handle_unknown='ignore'` to avoid errors when encountering unseen labels during transformation.\n- Check that the `fit` method correctly sorts and stores the categories in `categories_` attribute.\n- Verify that the `transform` method does not raise a `ValueError` when encountering unseen labels and that it outputs a matrix with all zeros for the unseen category, as per the `handle_unknown='ignore'` behavior.\n- If the issue persists, investigate if there is a bug in the `transform` method where it incorrectly maps unknown strings to the first category from `fit` instead of assigning all zeros.\n- Ensure that the `dtype` parameter is set to `bool` if a boolean output is desired.\n- If the issue is related to memory handling or truncation of string categories, consider casting the input data to `object` dtype before fitting and transforming to prevent truncation and memory issues.\n- If the issue is reproducible with numpy arrays and not with lists of lists, ensure that the input data is properly reshaped using `reshape((-1, 1))` before passing it to `fit` or `transform`.\n- If a custom fix involving casting to objects has been implemented, review the fix to ensure it aligns with the expected behavior of `OneHotEncoder` when `handle_unknown='ignore'` is set.",
        "bouncer_response": {
            "score": 3,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher. RESPONSES that are tangentially relevant but lack actionable content should receive scores between 1 and 3.",
            "supporting_evidence": "The RESPONSE provides some generic advice that is tangentially related to the issue described in the PROMPT, such as ensuring that `OneHotEncoder` is initialized with `handle_unknown='ignore'` and checking the `fit` method. However, it fails to provide actionable insights specific to the memory handling and truncation issue that is the core of the bug. The suggestion to cast the input data to `object` dtype is somewhat relevant, but it is not clear how this would resolve the specific memory handling issue. The RESPONSE also includes a reference to code snippets, which could be helpful for a developer, but it does not directly address the bug described. Overall, the RESPONSE lacks actionable content that would lead to resolving the memory handling and truncation issue.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711741462.109356,
        "result": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83d\ude41.                   But we've outlined some ideas that might help you get started:\n\n- Ensure that `OneHotEncoder` is initialized with `handle_unknown='ignore'` to avoid errors when encountering unseen labels during transformation.\n- Check that the `fit` method correctly sorts and stores the categories in `categories_` attribute.\n- Verify that the `transform` method does not raise a `ValueError` when encountering unseen labels and that it outputs a matrix with all zeros for the unseen category, as per the `handle_unknown='ignore'` behavior.\n- If the issue persists, investigate if there is a bug in the `transform` method where it incorrectly maps unknown strings to the first category from `fit` instead of assigning all zeros.\n- Ensure that the `dtype` parameter is set to `bool` if a boolean output is desired.\n- If the issue is related to memory handling or truncation of string categories, consider casting the input data to `object` dtype before fitting and transforming to prevent truncation and memory issues.\n- If the issue is reproducible with numpy arrays and not with lists of lists, ensure that the input data is properly reshaped using `reshape((-1, 1))` before passing it to `fit` or `transform`.\n- If a custom fix involving casting to objects has been implemented, review the fix to ensure it aligns with the expected behavior of `OneHotEncoder` when `handle_unknown='ignore'` is set.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn) \u2192 [preprocessing](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn/preprocessing)- [Lines 531 - 1603](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/preprocessing/_encoders.py#L531-L1603)\n\n This snippet contains the description of the 'handle_unknown' parameter for OneHotEncoder, which is directly related to the issue of handling unknown categories when they are strings. \n\n\n   - [Lines 23 - 530](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/preprocessing/_encoders.py#L23-L530)\n\n This snippet provides an overview of the OneHotEncoder class and its purpose, which is relevant to understanding the context of the issue. \n\n\n   - [Lines 1 - 19](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/preprocessing/_encoders.py#L1-L19)\n\n This snippet includes the import statements and the declaration of the OneHotEncoder class, which might be necessary for a developer to understand the dependencies and the context of the class implementation."
    }
}