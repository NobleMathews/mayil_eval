{
    "id": "sphinx-doc__sphinx-8627",
    "repo_name": "testbed/sphinx-doc__sphinx__3.5",
    "task_id": 684020386898643155,
    "title": "autodoc isn't able to resolve struct.Struct type annotations",
    "body": "**Describe the bug**\r\nIf `struct.Struct` is declared in any type annotations, I get `class reference target not found: Struct`\r\n\r\n**To Reproduce**\r\nSimple `index.rst`\r\n```\r\nHello World\r\n===========\r\n\r\ncode docs\r\n=========\r\n\r\n.. automodule:: helloworld.helloworld\r\n```\r\n\r\nSimple `helloworld.py`\r\n```\r\nimport struct\r\nimport pathlib\r\n\r\ndef consume_struct(_: struct.Struct) -> None:\r\n    pass\r\n\r\ndef make_struct() -> struct.Struct:\r\n    mystruct = struct.Struct('HH')\r\n    return mystruct\r\n\r\ndef make_path() -> pathlib.Path:\r\n    return pathlib.Path()\r\n```\r\n\r\nCommand line:\r\n```\r\npython3 -m sphinx -b html docs/ doc-out -nvWT\r\n```\r\n\r\n**Expected behavior**\r\nIf you comment out the 2 functions that have `Struct` type annotations, you'll see that `pathlib.Path` resolves fine and shows up in the resulting documentation. I'd expect that `Struct` would also resolve correctly.\r\n\r\n**Your project**\r\nn/a\r\n\r\n**Screenshots**\r\nn/a\r\n\r\n**Environment info**\r\n- OS: Ubuntu 18.04, 20.04\r\n- Python version: 3.8.2\r\n- Sphinx version: 3.2.1\r\n- Sphinx extensions:  'sphinx.ext.autodoc',\r\n              'sphinx.ext.autosectionlabel',\r\n              'sphinx.ext.intersphinx',\r\n              'sphinx.ext.doctest',\r\n              'sphinx.ext.todo'\r\n- Extra tools: \r\n\r\n**Additional context**\r\n\r\n\r\n- [e.g. URL or Ticket]\r\n\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__3.5.git",
    "requested_commit": "",
    "mayil_response": "- The issue is that Sphinx is not resolving the `struct.Struct` type annotation correctly, resulting in the error message `class reference target not found: Struct`.\n- The relevant code snippet is:\n  ```python\n  import struct\n\n  def consume_struct(_: struct.Struct) -> None:\n      pass\n\n  def make_struct() -> struct.Struct:\n      mystruct = struct.Struct('HH')\n      return mystruct\n  ```\n- The `struct.Struct` class is a built-in class that is incorrectly reported by its `__module__` attribute before Python 3.9, as indicated in the `sphinx/util/typing.py` file.\n- To resolve the issue, you can add an entry to the `autodoc_type_aliases` configuration in `conf.py` to map `struct.Struct` to the correct reference that Sphinx can resolve.\n\nSolution:\n- In your `conf.py` file, add the following configuration:\n  ```python\n  autodoc_type_aliases = {\n      'struct.Struct': 'struct.Struct',\n  }\n  ```\n- This will tell Sphinx to treat `struct.Struct` as a reference to the `Struct` class in the `struct` module, which should resolve the documentation generation issue.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx/util)- [Lines 1 - 94](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/util/typing.py#L1-L94)\n\n This snippet contains the definition of INVALID_BUILTIN_CLASSES which includes Struct from the struct module. The issue is related to struct.Struct not being resolved correctly, so this snippet is likely relevant to the issue.\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx) \u2192 [domains](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx/domains)- [Lines 1 - 102](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/domains/python.py#L1-L102)\n\n This snippet is from the Python domain of Sphinx and contains code related to parsing and resolving references in Python code. Since the issue is about Sphinx not resolving struct.Struct correctly, this code may be involved in the bug.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000321,
        "snippet_processor": 0.062240000000000004,
        "issue_star_creation": 0.02068,
        "issue_star_solver": 0.07839,
        "bouncer": 0.031020000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711703125.809864,
        "relevant_snippets": [
            {
                "code": "\"\"\"The Python domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nimport builtins\nimport inspect\nimport re\nimport typing\nfrom inspect import Parameter\nfrom typing import Any, Iterable, Iterator, List, NamedTuple, Tuple, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node\nfrom docutils.parsers.rst import directives\nfrom docutils.parsers.rst.states import Inliner\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, Index, IndexEntry, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.roles import XRefRole\nfrom sphinx.util import logging\nfrom sphinx.util.docfields import Field, GroupedField, TypedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.inspect import signature_from_str\nfrom sphinx.util.nodes import (\n    find_pending_xref_condition,\n    make_id,\n    make_refnode,\n    nested_parse_with_titles,\n)\nfrom sphinx.util.typing import OptionSpec, TextlikeNode\n\nlogger = logging.getLogger(__name__)\n\n\n# REs for Python signatures\npy_sig_re = re.compile(\n    r'''^ ([\\w.]*\\.)?            # class name(s)\n          (\\w+)  \\s*             # thing name\n          (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n           (?:\\s* -> \\s* (.*))?  #           return annotation\n          )? $                   # and nothing more\n          ''', re.VERBOSE)\n\n\npairindextypes = {\n    'module':    _('module'),\n    'keyword':   _('keyword'),\n    'operator':  _('operator'),\n    'object':    _('object'),\n    'exception': _('exception'),\n    'statement': _('statement'),\n    'builtin':   _('built-in function'),\n}\n\n\nclass ObjectEntry(NamedTuple):\n    docname: str\n    node_id: str\n    objtype: str\n    aliased: bool\n\n\nclass ModuleEntry(NamedTuple):\n    docname: str\n    node_id: str\n    synopsis: str\n    platform: str\n    deprecated: bool\n\n\ndef parse_reftarget(reftarget: str, suppress_prefix: bool = False,\n                    ) -> tuple[str, str, str, bool]:\n    \"\"\"Parse a type string and return (reftype, reftarget, title, refspecific flag)\"\"\"\n    refspecific = False\n    if reftarget.startswith('.'):\n        reftarget = reftarget[1:]\n        title = reftarget\n        refspecific = True\n    elif reftarget.startswith('~'):\n        reftarget = reftarget[1:]\n        title = reftarget.split('.')[-1]\n    elif suppress_prefix:\n        title = reftarget.split('.')[-1]\n    elif reftarget.startswith('typing.'):\n        title = reftarget[7:]\n    else:\n        title = reftarget\n\n    if reftarget == 'None' or reftarget.startswith('typing.'):\n        # typing module provides non-class types.  Obj reference is good to refer them.\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    return reftype, reftarget, title, refspecific",
                "filename": "sphinx/domains/python.py",
                "start_index": 0,
                "end_index": 2948,
                "start_line": 1,
                "end_line": 102,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "\"\"\"The composite types for Sphinx.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport typing\nfrom struct import Struct\nfrom types import TracebackType\nfrom typing import Any, Callable, Dict, ForwardRef, List, Tuple, TypeVar, Union\n\nfrom docutils import nodes\nfrom docutils.parsers.rst.states import Inliner\n\ntry:\n    from types import UnionType  # type: ignore  # python 3.10 or above\nexcept ImportError:\n    UnionType = None\n\n# builtin classes that have incorrect __module__\nINVALID_BUILTIN_CLASSES = {\n    Struct: 'struct.Struct',  # Before Python 3.9\n    TracebackType: 'types.TracebackType',\n}\n\n\ndef is_invalid_builtin_class(obj: Any) -> bool:\n    \"\"\"Check *obj* is an invalid built-in class.\"\"\"\n    try:\n        return obj in INVALID_BUILTIN_CLASSES\n    except TypeError:  # unhashable type\n        return False\n\n\n# Text like nodes which are initialized with text and rawsource\nTextlikeNode = Union[nodes.Text, nodes.TextElement]\n\n# type of None\nNoneType = type(None)\n\n# path matcher\nPathMatcher = Callable[[str], bool]\n\n# common role functions\nRoleFunction = Callable[[str, str, str, int, Inliner, Dict[str, Any], List[str]],\n                        Tuple[List[nodes.Node], List[nodes.system_message]]]\n\n# A option spec for directive\nOptionSpec = Dict[str, Callable[[str], Any]]\n\n# title getter functions for enumerable nodes (see sphinx.domains.std)\nTitleGetter = Callable[[nodes.Node], str]\n\n# inventory data on memory\nInventoryItem = Tuple[\n    str,  # project name\n    str,  # project version\n    str,  # URL\n    str,  # display name\n]\nInventory = Dict[str, Dict[str, InventoryItem]]\n\n\ndef get_type_hints(\n    obj: Any, globalns: dict[str, Any] | None = None, localns: dict | None = None,\n) -> dict[str, Any]:\n    \"\"\"Return a dictionary containing type hints for a function, method, module or class\n    object.\n\n    This is a simple wrapper of `typing.get_type_hints()` that does not raise an error on\n    runtime.\n    \"\"\"\n    from sphinx.util.inspect import safe_getattr  # lazy loading\n\n    try:\n        return typing.get_type_hints(obj, globalns, localns)\n    except NameError:\n        # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n        return safe_getattr(obj, '__annotations__', {})\n    except AttributeError:\n        # Failed to evaluate ForwardRef (maybe not runtime checkable)\n        return safe_getattr(obj, '__annotations__', {})\n    except TypeError:\n        # Invalid object is given. But try to get __annotations__ as a fallback for\n        # the code using type union operator (PEP 604) in python 3.9 or below.\n        return safe_getattr(obj, '__annotations__', {})\n    except KeyError:\n        # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n        return {}\n\n\ndef is_system_TypeVar(typ: Any) -> bool:\n    \"\"\"Check *typ* is system defined TypeVar.\"\"\"\n    modname = getattr(typ, '__module__', '')\n    return modname == 'typing' and isinstance(typ, TypeVar)",
                "filename": "sphinx/util/typing.py",
                "start_index": 0,
                "end_index": 2933,
                "start_line": 1,
                "end_line": 94,
                "max_line": 361,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "class TypeAliasForwardRef:\n    \"\"\"Pseudo typing class for autodoc_type_aliases.\n\n    This avoids the error on evaluating the type inside `get_type_hints()`.\n    \"\"\"\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n    def __call__(self) -> None:\n        # Dummy method to imitate special typing classes\n        pass\n\n    def __eq__(self, other: Any) -> bool:\n        return self.name == other\n\n    def __hash__(self) -> int:\n        return hash(self.name)\n\n    def __repr__(self) -> str:\n        return self.name\n\n\nclass TypeAliasModule:\n    \"\"\"Pseudo module class for autodoc_type_aliases.\"\"\"\n\n    def __init__(self, modname: str, mapping: dict[str, str]) -> None:\n        self.__modname = modname\n        self.__mapping = mapping\n\n        self.__module: ModuleType | None = None\n\n    def __getattr__(self, name: str) -> Any:\n        fullname = '.'.join(filter(None, [self.__modname, name]))\n        if fullname in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[fullname])\n        else:\n            prefix = fullname + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(fullname, nested)\n            else:\n                # no sub modules or classes found.\n                try:\n                    # return the real submodule if exists\n                    return import_module(fullname)\n                except ImportError:\n                    # return the real class\n                    if self.__module is None:\n                        self.__module = import_module(self.__modname)\n\n                    return getattr(self.__module, name)\n\n\nclass TypeAliasNamespace(Dict[str, Any]):\n    \"\"\"Pseudo namespace class for autodoc_type_aliases.\n\n    This enables to look up nested modules and classes like `mod1.mod2.Class`.\n    \"\"\"\n\n    def __init__(self, mapping: dict[str, str]) -> None:\n        self.__mapping = mapping\n\n    def __getitem__(self, key: str) -> Any:\n        if key in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[key])\n        else:\n            prefix = key + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(key, nested)\n            else:\n                raise KeyError\n\n\ndef _should_unwrap(subject: Callable) -> bool:\n    \"\"\"Check the function should be unwrapped on getting signature.\"\"\"\n    __globals__ = getglobals(subject)\n    if (__globals__.get('__name__') == 'contextlib' and\n            __globals__.get('__file__') == contextlib.__file__):\n        # contextmanger should be unwrapped\n        return True\n\n    return False",
                "filename": "sphinx/util/inspect.py",
                "start_index": 13767,
                "end_index": 16641,
                "start_line": 436,
                "end_line": 522,
                "max_line": 817,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "name: Bug report\ndescription: Something is not working correctly.\nlabels: \"bug\"\n\nbody:\n  - type: textarea\n    attributes:\n      label: Describe the bug\n      description: >-\n        A clear and concise description of what the bug is, including the \n        expected behaviour and what has gone wrong.\n        \n        Please include screenshots, if applicable.\n    validations:\n      required: true\n\n  - type: textarea\n    attributes:\n      label: How to Reproduce\n      description: >-\n        Please provide steps to reproduce this bug, with the smallest possible\n        set of source files. For normal bugs this should ideally be one \n        ``index.rst`` file, and for ``sphinx.ext.autodoc`` bugs, this should\n        ideally be a single ``index.rst`` file, and a single example Python \n        module.\n      placeholder: |\n        Minimal method (you can also paste the contents of ``index.rst`` and\n        ``conf.py`` into this report):\n        ```bash\n        $ echo \"Content demonstrating the bug...\" > index.rst\n        $ echo \"\" > conf.py\n        $ sphinx-build -M html . _build\n        $ # open _build/html/index and see bla bla\n        ```\n        \n        ``git clone`` method (this is advised against, to help the Sphinx team):\n        ```bash\n        $ git clone https://github.com/.../some_project\n        $ cd some_project\n        $ pip install -r requirements.txt\n        $ cd docs\n        $ make html SPHINXOPTS=\"-D language=de\"\n        $ # open _build/html/index and see bla bla\n        ```\n    validations:\n      required: true\n\n  - type: markdown\n    attributes:\n      value: |\n        ## Environment info\n\n  - type: textarea\n    attributes:\n      label: Environment Information\n      render: text\n      description: >-\n        Install the latest Sphinx \n        ``pip install -U \"sphinx>=5.3\"``\n        then run ``sphinx-build --bug-report`` or ``python -m sphinx --bug-report``.\n        and paste the output here.\n    validations:\n      required: true\n  - type: textarea\n    attributes:\n      label: Sphinx extensions\n      render: python\n      description: >-\n        Attempt to reproduce your error with the smallest set of extensions possible.\n        This makes it easier to determine where the problem you are encountering is.\n        \n        e.g. ``[\"sphinx.ext.autodoc\", \"recommonmark\"]``\n    validations:\n      required: false\n  - type: textarea\n    attributes:\n      label: Additional context\n      description: >-\n        Add any other context about the problem here, for example:\n        \n        * Any other tools used (Browser, TeX, etc) with versions\n        * Reference to another issue or pull request\n        * URL to some external resource",
                "filename": ".github/ISSUE_TEMPLATE/bug-report.yml",
                "start_index": 0,
                "end_index": 2685,
                "start_line": 1,
                "end_line": 83,
                "max_line": 83,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "\"\"\"Add external links to module code in Python object descriptions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom docutils import nodes\nfrom docutils.nodes import Node\n\nimport sphinx\nfrom sphinx import addnodes\nfrom sphinx.application import Sphinx\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import _\n\n\nclass LinkcodeError(SphinxError):\n    category = \"linkcode error\"\n\n\ndef doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n\n    resolve_target = getattr(env.config, 'linkcode_resolve', None)\n    if not callable(env.config.linkcode_resolve):\n        raise LinkcodeError(\n            \"Function `linkcode_resolve` is not given in conf.py\")\n\n    domain_keys = {\n        'py': ['module', 'fullname'],\n        'c': ['names'],\n        'cpp': ['names'],\n        'js': ['object', 'fullname'],\n    }\n\n    for objnode in list(doctree.findall(addnodes.desc)):\n        domain = objnode.get('domain')\n        uris: set[str] = set()\n        for signode in objnode:\n            if not isinstance(signode, addnodes.desc_signature):\n                continue\n\n            # Convert signode to a specified format\n            info = {}\n            for key in domain_keys.get(domain, []):\n                value = signode.get(key)\n                if not value:\n                    value = ''\n                info[key] = value\n            if not info:\n                continue\n\n            # Call user code to resolve the link\n            uri = resolve_target(domain, info)\n            if not uri:\n                # no source\n                continue\n\n            if uri in uris or not uri:\n                # only one link per name, please\n                continue\n            uris.add(uri)\n\n            inline = nodes.inline('', _('[source]'), classes=['viewcode-link'])\n            onlynode = addnodes.only(expr='html')\n            onlynode += nodes.reference('', '', inline, internal=False, refuri=uri)\n            signode += onlynode\n\n\ndef setup(app: Sphinx) -> dict[str, Any]:\n    app.connect('doctree-read', doctree_read)\n    app.add_config_value('linkcode_resolve', None, '')\n    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}",
                "filename": "sphinx/ext/linkcode.py",
                "start_index": 0,
                "end_index": 2202,
                "start_line": 1,
                "end_line": 73,
                "max_line": 73,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "def doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n\n    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n        entry = env._viewcode_modules.get(modname, None)  # type: ignore\n        if entry is False:\n            return False\n\n        code_tags = app.emit_firstresult('viewcode-find-source', modname)\n        if code_tags is None:\n            try:\n                analyzer = ModuleAnalyzer.for_module(modname)\n                analyzer.find_tags()\n            except Exception:\n                env._viewcode_modules[modname] = False  # type: ignore\n                return False\n\n            code = analyzer.code\n            tags = analyzer.tags\n        else:\n            code, tags = code_tags\n\n        if entry is None or entry[0] != code:\n            entry = code, tags, {}, refname\n            env._viewcode_modules[modname] = entry  # type: ignore\n        _, tags, used, _ = entry\n        if fullname in tags:\n            used[fullname] = docname\n            return True\n\n        return False\n\n    for objnode in list(doctree.findall(addnodes.desc)):\n        if objnode.get('domain') != 'py':\n            continue\n        names: set[str] = set()\n        for signode in objnode:\n            if not isinstance(signode, addnodes.desc_signature):\n                continue\n            modname = signode.get('module')\n            fullname = signode.get('fullname')\n            refname = modname\n            if env.config.viewcode_follow_imported_members:\n                new_modname = app.emit_firstresult(\n                    'viewcode-follow-imported', modname, fullname,\n                )\n                if not new_modname:\n                    new_modname = _get_full_modname(app, modname, fullname)\n                modname = new_modname\n            if not modname:\n                continue\n            fullname = signode.get('fullname')\n            if not has_tag(modname, fullname, env.docname, refname):\n                continue\n            if fullname in names:\n                # only one link per name, please\n                continue\n            names.add(fullname)\n            pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n            signode += viewcode_anchor(reftarget=pagename, refid=fullname, refdoc=env.docname)",
                "filename": "sphinx/ext/viewcode.py",
                "start_index": 2249,
                "end_index": 4656,
                "start_line": 69,
                "end_line": 130,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "\"\"\"Build documentation from a provided source.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport bdb\nimport locale\nimport multiprocessing\nimport os\nimport pdb  # NoQA: T100\nimport sys\nimport traceback\nfrom os import path\nfrom typing import Any, TextIO\n\nfrom docutils.utils import SystemMessage\n\nimport sphinx.locale\nfrom sphinx import __display_version__\nfrom sphinx.application import Sphinx\nfrom sphinx.errors import SphinxError\nfrom sphinx.locale import __\nfrom sphinx.util import Tee\nfrom sphinx.util.console import color_terminal, nocolor, red, terminal_safe  # type: ignore\nfrom sphinx.util.docutils import docutils_namespace, patch_docutils\nfrom sphinx.util.exceptions import format_exception_cut_frames, save_traceback\nfrom sphinx.util.osutil import abspath, ensuredir",
                "filename": "sphinx/cmd/build.py",
                "start_index": 0,
                "end_index": 789,
                "start_line": 1,
                "end_line": 27,
                "max_line": 325,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "# -- autosummary_toc node ------------------------------------------------------\n\nclass autosummary_toc(nodes.comment):\n    pass\n\n\ndef autosummary_toc_visit_html(self: nodes.NodeVisitor, node: autosummary_toc) -> None:\n    \"\"\"Hide autosummary toctree list in HTML output.\"\"\"\n    raise nodes.SkipNode\n\n\ndef autosummary_noop(self: nodes.NodeVisitor, node: Node) -> None:\n    pass\n\n\n# -- autosummary_table node ----------------------------------------------------\n\nclass autosummary_table(nodes.comment):\n    pass\n\n\ndef autosummary_table_visit_html(self: HTML5Translator, node: autosummary_table) -> None:\n    \"\"\"Make the first column of the table non-breaking.\"\"\"\n    try:\n        table = cast(nodes.table, node[0])\n        tgroup = cast(nodes.tgroup, table[0])\n        tbody = cast(nodes.tbody, tgroup[-1])\n        rows = cast(List[nodes.row], tbody)\n        for row in rows:\n            col1_entry = cast(nodes.entry, row[0])\n            par = cast(nodes.paragraph, col1_entry[0])\n            for j, subnode in enumerate(list(par)):\n                if isinstance(subnode, nodes.Text):\n                    new_text = subnode.astext().replace(\" \", \"\\u00a0\")\n                    par[j] = nodes.Text(new_text)\n    except IndexError:\n        pass\n\n\n# -- autodoc integration -------------------------------------------------------\n\nclass FakeApplication:\n    def __init__(self) -> None:\n        self.doctreedir = None\n        self.events = None\n        self.extensions: dict[str, Extension] = {}\n        self.srcdir = None\n        self.config = Config()\n        self.project = Project(None, None)\n        self.registry = SphinxComponentRegistry()\n\n\nclass FakeDirective(DocumenterBridge):\n    def __init__(self) -> None:\n        settings = Struct(tab_width=8)\n        document = Struct(settings=settings)\n        app = FakeApplication()\n        app.config.add('autodoc_class_signature', 'mixed', True, None)\n        env = BuildEnvironment(app)  # type: ignore\n        state = Struct(document=document)\n        super().__init__(env, None, Options(), 0, state)",
                "filename": "sphinx/ext/autosummary/__init__.py",
                "start_index": 2965,
                "end_index": 5016,
                "start_line": 103,
                "end_line": 163,
                "max_line": 841,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "class ASTMacroParameter(ASTBase):\n    def __init__(self, arg: ASTNestedName | None, ellipsis: bool = False,\n                 variadic: bool = False) -> None:\n        self.arg = arg\n        self.ellipsis = ellipsis\n        self.variadic = variadic\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        if self.ellipsis:\n            return '...'\n        elif self.variadic:\n            return transform(self.arg) + '...'\n        else:\n            return transform(self.arg)\n\n    def describe_signature(self, signode: Any, mode: str,\n                           env: BuildEnvironment, symbol: Symbol) -> None:\n        verify_description_mode(mode)\n        if self.ellipsis:\n            signode += addnodes.desc_sig_punctuation('...', '...')\n        elif self.variadic:\n            name = str(self)\n            signode += addnodes.desc_sig_name(name, name)\n        else:\n            self.arg.describe_signature(signode, mode, env, symbol=symbol)\n\n\nclass ASTMacro(ASTBase):\n    def __init__(self, ident: ASTNestedName, args: list[ASTMacroParameter] | None) -> None:\n        self.ident = ident\n        self.args = args\n\n    @property\n    def name(self) -> ASTNestedName:\n        return self.ident\n\n    def get_id(self, version: int, objectType: str, symbol: Symbol) -> str:\n        return symbol.get_full_nested_name().get_id(version)\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        res = []\n        res.append(transform(self.ident))\n        if self.args is not None:\n            res.append('(')\n            first = True\n            for arg in self.args:\n                if not first:\n                    res.append(', ')\n                first = False\n                res.append(transform(arg))\n            res.append(')')\n        return ''.join(res)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: BuildEnvironment, symbol: Symbol) -> None:\n        verify_description_mode(mode)\n        self.ident.describe_signature(signode, mode, env, symbol)\n        if self.args is None:\n            return\n        paramlist = addnodes.desc_parameterlist()\n        for arg in self.args:\n            param = addnodes.desc_parameter('', '', noemph=True)\n            arg.describe_signature(param, 'param', env, symbol=symbol)\n            paramlist += param\n        signode += paramlist\n\n\nclass ASTStruct(ASTBase):\n    def __init__(self, name: ASTNestedName) -> None:\n        self.name = name\n\n    def get_id(self, version: int, objectType: str, symbol: Symbol) -> str:\n        return symbol.get_full_nested_name().get_id(version)\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return transform(self.name)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: BuildEnvironment, symbol: Symbol) -> None:\n        verify_description_mode(mode)\n        self.name.describe_signature(signode, mode, env, symbol=symbol)",
                "filename": "sphinx/domains/c.py",
                "start_index": 46198,
                "end_index": 49153,
                "start_line": 1275,
                "end_line": 1387,
                "max_line": 3876,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            },
            {
                "code": "\"\"\"Utility functions for Sphinx.\"\"\"\n\nfrom __future__ import annotations\n\nimport hashlib\nimport os\nimport posixpath\nimport re\nimport sys\nfrom importlib import import_module\nfrom os import path\nfrom typing import IO, Any\nfrom urllib.parse import parse_qsl, quote_plus, urlencode, urlsplit, urlunsplit\n\nfrom sphinx.errors import ExtensionError, FiletypeNotFoundError\nfrom sphinx.locale import __\nfrom sphinx.util import display as _display\nfrom sphinx.util import exceptions as _exceptions\nfrom sphinx.util import http_date as _http_date\nfrom sphinx.util import logging\nfrom sphinx.util import osutil as _osutil\nfrom sphinx.util.console import strip_colors  # NoQA: F401\nfrom sphinx.util.matching import patfilter  # noqa: F401\nfrom sphinx.util.nodes import (  # noqa: F401\n    caption_ref_re,\n    explicit_title_re,\n    nested_parse_with_titles,\n    split_explicit_title,\n)\n\n# import other utilities; partly for backwards compatibility, so don't\n# prune unused ones indiscriminately\nfrom sphinx.util.osutil import (  # noqa: F401\n    SEP,\n    copyfile,\n    copytimes,\n    ensuredir,\n    make_filename,\n    mtimes_of_files,\n    os_path,\n    relative_uri,\n)\n\nlogger = logging.getLogger(__name__)\n\n# Generally useful regular expressions.\nws_re: re.Pattern = re.compile(r'\\s+')\nurl_re: re.Pattern = re.compile(r'(?P<schema>.+)://.*')\n\n\n# High-level utility functions.\n\ndef docname_join(basedocname: str, docname: str) -> str:\n    return posixpath.normpath(\n        posixpath.join('/' + basedocname, '..', docname))[1:]\n\n\ndef get_filetype(source_suffix: dict[str, str], filename: str) -> str:\n    for suffix, filetype in source_suffix.items():\n        if filename.endswith(suffix):\n            # If default filetype (None), considered as restructuredtext.\n            return filetype or 'restructuredtext'\n    raise FiletypeNotFoundError",
                "filename": "sphinx/util/__init__.py",
                "start_index": 0,
                "end_index": 1830,
                "start_line": 1,
                "end_line": 63,
                "max_line": 371,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sphinx/util/typing.py": [
                {
                    "chunk": {
                        "code": "\"\"\"The composite types for Sphinx.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport typing\nfrom struct import Struct\nfrom types import TracebackType\nfrom typing import Any, Callable, Dict, ForwardRef, List, Tuple, TypeVar, Union\n\nfrom docutils import nodes\nfrom docutils.parsers.rst.states import Inliner\n\ntry:\n    from types import UnionType  # type: ignore  # python 3.10 or above\nexcept ImportError:\n    UnionType = None\n\n# builtin classes that have incorrect __module__\nINVALID_BUILTIN_CLASSES = {\n    Struct: 'struct.Struct',  # Before Python 3.9\n    TracebackType: 'types.TracebackType',\n}\n\n\ndef is_invalid_builtin_class(obj: Any) -> bool:\n    \"\"\"Check *obj* is an invalid built-in class.\"\"\"\n    try:\n        return obj in INVALID_BUILTIN_CLASSES\n    except TypeError:  # unhashable type\n        return False\n\n\n# Text like nodes which are initialized with text and rawsource\nTextlikeNode = Union[nodes.Text, nodes.TextElement]\n\n# type of None\nNoneType = type(None)\n\n# path matcher\nPathMatcher = Callable[[str], bool]\n\n# common role functions\nRoleFunction = Callable[[str, str, str, int, Inliner, Dict[str, Any], List[str]],\n                        Tuple[List[nodes.Node], List[nodes.system_message]]]\n\n# A option spec for directive\nOptionSpec = Dict[str, Callable[[str], Any]]\n\n# title getter functions for enumerable nodes (see sphinx.domains.std)\nTitleGetter = Callable[[nodes.Node], str]\n\n# inventory data on memory\nInventoryItem = Tuple[\n    str,  # project name\n    str,  # project version\n    str,  # URL\n    str,  # display name\n]\nInventory = Dict[str, Dict[str, InventoryItem]]\n\n\ndef get_type_hints(\n    obj: Any, globalns: dict[str, Any] | None = None, localns: dict | None = None,\n) -> dict[str, Any]:\n    \"\"\"Return a dictionary containing type hints for a function, method, module or class\n    object.\n\n    This is a simple wrapper of `typing.get_type_hints()` that does not raise an error on\n    runtime.\n    \"\"\"\n    from sphinx.util.inspect import safe_getattr  # lazy loading\n\n    try:\n        return typing.get_type_hints(obj, globalns, localns)\n    except NameError:\n        # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n        return safe_getattr(obj, '__annotations__', {})\n    except AttributeError:\n        # Failed to evaluate ForwardRef (maybe not runtime checkable)\n        return safe_getattr(obj, '__annotations__', {})\n    except TypeError:\n        # Invalid object is given. But try to get __annotations__ as a fallback for\n        # the code using type union operator (PEP 604) in python 3.9 or below.\n        return safe_getattr(obj, '__annotations__', {})\n    except KeyError:\n        # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n        return {}\n\n\ndef is_system_TypeVar(typ: Any) -> bool:\n    \"\"\"Check *typ* is system defined TypeVar.\"\"\"\n    modname = getattr(typ, '__module__', '')\n    return modname == 'typing' and isinstance(typ, TypeVar)",
                        "filename": "sphinx/util/typing.py",
                        "start_index": 0,
                        "end_index": 2933,
                        "start_line": 1,
                        "end_line": 94,
                        "max_line": 361,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the definition of INVALID_BUILTIN_CLASSES which includes Struct from the struct module. The issue is related to struct.Struct not being resolved correctly, so this snippet is likely relevant to the issue."
                }
            ],
            "sphinx/domains/python.py": [
                {
                    "chunk": {
                        "code": "\"\"\"The Python domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nimport builtins\nimport inspect\nimport re\nimport typing\nfrom inspect import Parameter\nfrom typing import Any, Iterable, Iterator, List, NamedTuple, Tuple, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node\nfrom docutils.parsers.rst import directives\nfrom docutils.parsers.rst.states import Inliner\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, Index, IndexEntry, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.roles import XRefRole\nfrom sphinx.util import logging\nfrom sphinx.util.docfields import Field, GroupedField, TypedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.inspect import signature_from_str\nfrom sphinx.util.nodes import (\n    find_pending_xref_condition,\n    make_id,\n    make_refnode,\n    nested_parse_with_titles,\n)\nfrom sphinx.util.typing import OptionSpec, TextlikeNode\n\nlogger = logging.getLogger(__name__)\n\n\n# REs for Python signatures\npy_sig_re = re.compile(\n    r'''^ ([\\w.]*\\.)?            # class name(s)\n          (\\w+)  \\s*             # thing name\n          (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n           (?:\\s* -> \\s* (.*))?  #           return annotation\n          )? $                   # and nothing more\n          ''', re.VERBOSE)\n\n\npairindextypes = {\n    'module':    _('module'),\n    'keyword':   _('keyword'),\n    'operator':  _('operator'),\n    'object':    _('object'),\n    'exception': _('exception'),\n    'statement': _('statement'),\n    'builtin':   _('built-in function'),\n}\n\n\nclass ObjectEntry(NamedTuple):\n    docname: str\n    node_id: str\n    objtype: str\n    aliased: bool\n\n\nclass ModuleEntry(NamedTuple):\n    docname: str\n    node_id: str\n    synopsis: str\n    platform: str\n    deprecated: bool\n\n\ndef parse_reftarget(reftarget: str, suppress_prefix: bool = False,\n                    ) -> tuple[str, str, str, bool]:\n    \"\"\"Parse a type string and return (reftype, reftarget, title, refspecific flag)\"\"\"\n    refspecific = False\n    if reftarget.startswith('.'):\n        reftarget = reftarget[1:]\n        title = reftarget\n        refspecific = True\n    elif reftarget.startswith('~'):\n        reftarget = reftarget[1:]\n        title = reftarget.split('.')[-1]\n    elif suppress_prefix:\n        title = reftarget.split('.')[-1]\n    elif reftarget.startswith('typing.'):\n        title = reftarget[7:]\n    else:\n        title = reftarget\n\n    if reftarget == 'None' or reftarget.startswith('typing.'):\n        # typing module provides non-class types.  Obj reference is good to refer them.\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    return reftype, reftarget, title, refspecific",
                        "filename": "sphinx/domains/python.py",
                        "start_index": 0,
                        "end_index": 2948,
                        "start_line": 1,
                        "end_line": 102,
                        "max_line": 1517,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is from the Python domain of Sphinx and contains code related to parsing and resolving references in Python code. Since the issue is about Sphinx not resolving struct.Struct correctly, this code may be involved in the bug."
                }
            ]
        },
        "solution_task": "- The issue is that Sphinx is not resolving the `struct.Struct` type annotation correctly, resulting in the error message `class reference target not found: Struct`.\n- The relevant code snippet is:\n  ```python\n  import struct\n\n  def consume_struct(_: struct.Struct) -> None:\n      pass\n\n  def make_struct() -> struct.Struct:\n      mystruct = struct.Struct('HH')\n      return mystruct\n  ```\n- The `struct.Struct` class is a built-in class that is incorrectly reported by its `__module__` attribute before Python 3.9, as indicated in the `sphinx/util/typing.py` file.\n- To resolve the issue, you can add an entry to the `autodoc_type_aliases` configuration in `conf.py` to map `struct.Struct` to the correct reference that Sphinx can resolve.\n\nSolution:\n- In your `conf.py` file, add the following configuration:\n  ```python\n  autodoc_type_aliases = {\n      'struct.Struct': 'struct.Struct',\n  }\n  ```\n- This will tell Sphinx to treat `struct.Struct` as a reference to the `Struct` class in the `struct` module, which should resolve the documentation generation issue.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE accurately identifies the issue with Sphinx not resolving the `struct.Struct` type annotation and provides a specific and actionable solution by suggesting the addition of an entry to the `autodoc_type_aliases` configuration in `conf.py`. This solution is directly relevant to the problem described in the PROMPT and could potentially resolve the documentation generation issue. The RESPONSE also provides links to the Sphinx codebase that may be related to the issue, which could be useful for further investigation if the initial solution does not work. However, the RESPONSE does not address the fact that the user is using Sphinx version 3.2.1, and the provided links are for version 3.5, which may not be entirely applicable. This discrepancy prevents the RESPONSE from scoring a perfect 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711703245.215179,
        "result": "- The issue is that Sphinx is not resolving the `struct.Struct` type annotation correctly, resulting in the error message `class reference target not found: Struct`.\n- The relevant code snippet is:\n  ```python\n  import struct\n\n  def consume_struct(_: struct.Struct) -> None:\n      pass\n\n  def make_struct() -> struct.Struct:\n      mystruct = struct.Struct('HH')\n      return mystruct\n  ```\n- The `struct.Struct` class is a built-in class that is incorrectly reported by its `__module__` attribute before Python 3.9, as indicated in the `sphinx/util/typing.py` file.\n- To resolve the issue, you can add an entry to the `autodoc_type_aliases` configuration in `conf.py` to map `struct.Struct` to the correct reference that Sphinx can resolve.\n\nSolution:\n- In your `conf.py` file, add the following configuration:\n  ```python\n  autodoc_type_aliases = {\n      'struct.Struct': 'struct.Struct',\n  }\n  ```\n- This will tell Sphinx to treat `struct.Struct` as a reference to the `Struct` class in the `struct` module, which should resolve the documentation generation issue.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx/util)- [Lines 1 - 94](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/util/typing.py#L1-L94)\n\n This snippet contains the definition of INVALID_BUILTIN_CLASSES which includes Struct from the struct module. The issue is related to struct.Struct not being resolved correctly, so this snippet is likely relevant to the issue.\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx) \u2192 [domains](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx/domains)- [Lines 1 - 102](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/domains/python.py#L1-L102)\n\n This snippet is from the Python domain of Sphinx and contains code related to parsing and resolving references in Python code. Since the issue is about Sphinx not resolving struct.Struct correctly, this code may be involved in the bug."
    }
}