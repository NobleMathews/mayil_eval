{
    "id": "sphinx-doc__sphinx-11109",
    "repo_name": "testbed/sphinx-doc__sphinx__6.2",
    "task_id": 5951354144692078395,
    "title": "sphinx.domains.python._parse_annotation should improve formatting of Union, Optional, Literal, constants",
    "body": "This is a sub-issue of #9523 split off here.\r\n\r\nWhen displayed normally, `Union`, `Optional`, and `Literal` add a lot of noise to the type signature and obscure the important information.  Instead, it is much cleaner to display them using the PEP 604 (https://www.python.org/dev/peps/pep-0604/) syntax:\r\n\r\n`Union[X, Y, Z]` -> `X | Y | Z`\r\n`Optional[X]` -> `X | None`\r\n\r\nAdditionally, for `Literal` it is cleaner to strip the text \"Literal\" and just display the literal value with normal Python syntax highlighting:\r\n\r\n`Literal[\"X\"]` -> `\"X\"`\r\n\r\nThis is implemented in the tensorstore documentation via an ast transformation:\r\n\r\nhttps://github.com/google/tensorstore/blob/1a59fcb310bc1feb13569f03f7134b4c3a5fa5f4/docs/tensorstore_sphinx_ext/autodoc.py#L259\r\n\r\nThis should be supported in Sphinx via a config option.  The other improvement, of using syntax highlighting for constants, should also be integrated.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__6.2.git",
    "requested_commit": "",
    "mayil_response": "To implement the requested feature in the Sphinx Python domain, you will need to modify the `_parse_annotation` function to handle the new formatting for `Union`, `Optional`, and `Literal` types, as well as syntax highlighting for constants. Here's a high-level overview of the steps to implement this feature:\n\n- Add a new configuration option in Sphinx to enable or disable the new formatting.\n- Modify the `_parse_annotation` function to apply the new formatting based on the configuration option.\n- Update the handling of `Literal` types to display only the literal value with syntax highlighting.\n- Ensure that constants are displayed with syntax highlighting.\n\nHere's a more detailed breakdown of the implementation:\n\n1. Add a new configuration option in `conf.py`:\n```python\n# conf.py\npython_use_pep604_syntax = True  # Add this line to enable the new formatting by default\n```\n\n2. Update the `sphinx/domains/python.py` file to use the new configuration option:\n```python\n# sphinx/domains/python.py\n\n# At the beginning of the file, add a new default config value\ndef setup(app: Sphinx):\n    app.add_config_value('python_use_pep604_syntax', False, 'env')\n\n# Modify the _parse_annotation function\ndef _parse_annotation(annotation: str, env: BuildEnvironment) -> list[Node]:\n    # ... existing code ...\n\n    # Check the new configuration option\n    use_pep604_syntax = env.config.python_use_pep604_syntax\n\n    # ... existing code ...\n\n    # Modify the handling of Union and Optional to use PEP 604 syntax if enabled\n    if use_pep604_syntax and isinstance(node, ast.Subscript) and getattr(node.value, 'id', '') in {'Optional', 'Union'}:\n        return _unparse_pep_604_annotation(node)\n\n    # Modify the handling of Literal to display only the literal value\n    if use_pep604_syntax and isinstance(node, ast.Subscript) and getattr(node.value, 'id', '') == 'Literal':\n        # Strip the \"Literal\" text and display the value with syntax highlighting\n        literal_value = unparse(node.slice)\n        return [nodes.literal('', '', nodes.Text(literal_value))]\n\n    # ... existing code ...\n\n    # Add syntax highlighting for constants\n    if isinstance(node, nodes.Text) and node.strip().isupper():\n        return [nodes.desc_sig_literal_string('', '', node)]\n\n    # ... existing code ...\n\n    return result\n```\n\n3. Update the `_unparse_pep_604_annotation` function to handle the new syntax:\n```python\n# sphinx/domains/python.py\n\ndef _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:\n    # ... existing code ...\n\n    # Modify the function to use PEP 604 syntax for Union and Optional\n    if isinstance(subscript, ast.Tuple):\n        # Use the '|' operator for Union types\n        flattened = [unparse(subscript.elts[0])]\n        for elt in subscript.elts[1:]:\n            flattened.append(nodes.desc_sig_operator('', '|'))\n            flattened.extend(unparse(elt))\n    else:\n        flattened.extend(unparse(subscript))\n\n    # Handle Optional types by appending '| None'\n    if getattr(node.value, 'id', '') == 'Optional':\n        flattened.append(nodes.desc_sig_operator('', '|'))\n        flattened.append(nodes.Text('None'))\n\n    return flattened\n```\n\n4. Test the changes by building the documentation and verifying that the new formatting is applied correctly.\n\nRemember to document the new configuration option and its behavior in the Sphinx documentation. Additionally, consider adding unit tests to ensure the feature works as expected and to prevent regressions in the future.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__6.2/tree//sphinx) \u2192 [domains](https://github.com/testbed/sphinx-doc__sphinx__6.2/tree//sphinx/domains)- [Lines 216 - 257](https://github.com/testbed/sphinx-doc__sphinx__6.2/blob//sphinx/domains/python.py#L216-L257)\n\n This snippet contains the function '_unparse_pep_604_annotation' which is directly related to the formatting of 'Union' and 'Optional' types as described in the issue. \n\n\n   - [Lines 184 - 216](https://github.com/testbed/sphinx-doc__sphinx__6.2/blob//sphinx/domains/python.py#L184-L216)\n\n This snippet checks for 'Optional', 'Union', and 'Literal' within an AST subscript and calls the relevant function to unparse them, which is relevant to the issue. \n\n\n   - [Lines 132 - 133](https://github.com/testbed/sphinx-doc__sphinx__6.2/blob//sphinx/domains/python.py#L132-L133)\n\n This snippet references a configuration option 'python_display_short_literal_types' which could be related to the display of 'Literal' types as mentioned in the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000318,
        "snippet_processor": 0.06099,
        "issue_star_creation": 0.020900000000000002,
        "issue_star_solver": 0.08223,
        "bouncer": 0.02631
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711701087.804791,
        "relevant_snippets": [
            {
                "code": "# unsupported syntax\n\n    def _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:\n        subscript = node.slice\n        if isinstance(subscript, ast.Index):\n            # py38 only\n            subscript = subscript.value  # type: ignore[assignment]\n\n        flattened: list[Node] = []\n        if isinstance(subscript, ast.Tuple):\n            flattened.extend(unparse(subscript.elts[0]))\n            for elt in subscript.elts[1:]:\n                flattened.extend(unparse(ast.BitOr()))\n                flattened.extend(unparse(elt))\n        else:\n            # e.g. a Union[] inside an Optional[]\n            flattened.extend(unparse(subscript))\n\n        if getattr(node.value, 'id', '') == 'Optional':\n            flattened.extend(unparse(ast.BitOr()))\n            flattened.append(nodes.Text('None'))\n\n        return flattened\n\n    try:\n        tree = ast.parse(annotation, type_comments=True)\n        result: list[Node] = []\n        for node in unparse(tree):\n            if isinstance(node, nodes.literal):\n                result.append(node[0])\n            elif isinstance(node, nodes.Text) and node.strip():\n                if (result and isinstance(result[-1], addnodes.desc_sig_punctuation) and\n                        result[-1].astext() == '~'):\n                    result.pop()\n                    result.append(type_to_xref(str(node), env, suppress_prefix=True))\n                else:\n                    result.append(type_to_xref(str(node), env))\n            else:\n                result.append(node)\n        return result\n    except SyntaxError:\n        return [type_to_xref(annotation, env)]",
                "filename": "sphinx/domains/python.py",
                "start_index": 8315,
                "end_index": 9934,
                "start_line": 216,
                "end_line": 257,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "\"\"\"The Python domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nimport builtins\nimport inspect\nimport re\nimport typing\nfrom inspect import Parameter\nfrom typing import Any, Iterable, Iterator, List, NamedTuple, Tuple, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node\nfrom docutils.parsers.rst import directives\nfrom docutils.parsers.rst.states import Inliner\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, Index, IndexEntry, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.roles import XRefRole\nfrom sphinx.util import logging\nfrom sphinx.util.docfields import Field, GroupedField, TypedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.inspect import signature_from_str\nfrom sphinx.util.nodes import (\n    find_pending_xref_condition,\n    make_id,\n    make_refnode,\n    nested_parse_with_titles,\n)\nfrom sphinx.util.typing import OptionSpec, TextlikeNode\n\nlogger = logging.getLogger(__name__)\n\n\n# REs for Python signatures\npy_sig_re = re.compile(\n    r'''^ ([\\w.]*\\.)?            # class name(s)\n          (\\w+)  \\s*             # thing name\n          (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n           (?:\\s* -> \\s* (.*))?  #           return annotation\n          )? $                   # and nothing more\n          ''', re.VERBOSE)\n\n\npairindextypes = {\n    'module':    _('module'),\n    'keyword':   _('keyword'),\n    'operator':  _('operator'),\n    'object':    _('object'),\n    'exception': _('exception'),\n    'statement': _('statement'),\n    'builtin':   _('built-in function'),\n}\n\n\nclass ObjectEntry(NamedTuple):\n    docname: str\n    node_id: str\n    objtype: str\n    aliased: bool\n\n\nclass ModuleEntry(NamedTuple):\n    docname: str\n    node_id: str\n    synopsis: str\n    platform: str\n    deprecated: bool\n\n\ndef parse_reftarget(reftarget: str, suppress_prefix: bool = False,\n                    ) -> tuple[str, str, str, bool]:\n    \"\"\"Parse a type string and return (reftype, reftarget, title, refspecific flag)\"\"\"\n    refspecific = False\n    if reftarget.startswith('.'):\n        reftarget = reftarget[1:]\n        title = reftarget\n        refspecific = True\n    elif reftarget.startswith('~'):\n        reftarget = reftarget[1:]\n        title = reftarget.split('.')[-1]\n    elif suppress_prefix:\n        title = reftarget.split('.')[-1]\n    elif reftarget.startswith('typing.'):\n        title = reftarget[7:]\n    else:\n        title = reftarget\n\n    if reftarget == 'None' or reftarget.startswith('typing.'):\n        # typing module provides non-class types.  Obj reference is good to refer them.\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    return reftype, reftarget, title, refspecific",
                "filename": "sphinx/domains/python.py",
                "start_index": 0,
                "end_index": 2948,
                "start_line": 1,
                "end_line": 102,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\n\nimport sys\nimport textwrap\nfrom difflib import unified_diff\nfrom typing import TYPE_CHECKING, Any\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node\nfrom docutils.parsers.rst import directives\nfrom docutils.statemachine import StringList\n\nfrom sphinx import addnodes\nfrom sphinx.config import Config\nfrom sphinx.directives import optional_int\nfrom sphinx.locale import __\nfrom sphinx.util import logging, parselinenos\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.typing import OptionSpec\n\nif TYPE_CHECKING:\n    from sphinx.application import Sphinx\n\nlogger = logging.getLogger(__name__)\n\n\nclass Highlight(SphinxDirective):\n    \"\"\"\n    Directive to set the highlighting language for code blocks, as well\n    as the threshold for line numbers.\n    \"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec: OptionSpec = {\n        'force': directives.flag,\n        'linenothreshold': directives.positive_int,\n    }\n\n    def run(self) -> list[Node]:\n        language = self.arguments[0].strip()\n        linenothreshold = self.options.get('linenothreshold', sys.maxsize)\n        force = 'force' in self.options\n\n        self.env.temp_data['highlight_language'] = language\n        return [addnodes.highlightlang(lang=language,\n                                       force=force,\n                                       linenothreshold=linenothreshold)]\n\n\ndef dedent_lines(\n    lines: list[str], dedent: int | None, location: tuple[str, int] | None = None,\n) -> list[str]:\n    if dedent is None:\n        return textwrap.dedent(''.join(lines)).splitlines(True)\n\n    if any(s[:dedent].strip() for s in lines):\n        logger.warning(__('non-whitespace stripped by dedent'), location=location)\n\n    new_lines = []\n    for line in lines:\n        new_line = line[dedent:]\n        if line.endswith('\\n') and not new_line:\n            new_line = '\\n'  # keep CRLF\n        new_lines.append(new_line)\n\n    return new_lines\n\n\ndef container_wrapper(\n    directive: SphinxDirective, literal_node: Node, caption: str,\n) -> nodes.container:\n    container_node = nodes.container('', literal_block=True,\n                                     classes=['literal-block-wrapper'])\n    parsed = nodes.Element()\n    directive.state.nested_parse(StringList([caption], source=''),\n                                 directive.content_offset, parsed)\n    if isinstance(parsed[0], nodes.system_message):\n        msg = __('Invalid caption: %s' % parsed[0].astext())\n        raise ValueError(msg)\n    if isinstance(parsed[0], nodes.Element):\n        caption_node = nodes.caption(parsed[0].rawsource, '',\n                                     *parsed[0].children)\n        caption_node.source = literal_node.source\n        caption_node.line = literal_node.line\n        container_node += caption_node\n        container_node += literal_node\n        return container_node\n    raise RuntimeError",
                "filename": "sphinx/directives/code.py",
                "start_index": 0,
                "end_index": 3003,
                "start_line": 1,
                "end_line": 91,
                "max_line": 481,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "\"\"\"Parse type annotation.\"\"\"\n    short_literals = env.config.python_display_short_literal_types",
                "filename": "sphinx/domains/python.py",
                "start_index": 4225,
                "end_index": 4320,
                "start_line": 132,
                "end_line": 133,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "if isinstance(node, ast.Subscript):\n            if getattr(node.value, 'id', '') in {'Optional', 'Union'}:\n                return _unparse_pep_604_annotation(node)\n            if short_literals and getattr(node.value, 'id', '') == 'Literal':\n                return _unparse_pep_604_annotation(node)\n            result = unparse(node.value)\n            result.append(addnodes.desc_sig_punctuation('', '['))\n            result.extend(unparse(node.slice))\n            result.append(addnodes.desc_sig_punctuation('', ']'))\n\n            # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal\n            if result[0] in ('Literal', 'typing.Literal'):\n                for i, subnode in enumerate(result[1:], start=1):\n                    if isinstance(subnode, nodes.Text):\n                        result[i] = nodes.literal('', '', subnode)\n            return result\n        if isinstance(node, ast.UnaryOp):\n            return unparse(node.op) + unparse(node.operand)\n        if isinstance(node, ast.Tuple):\n            if node.elts:\n                result = []\n                for elem in node.elts:\n                    result.extend(unparse(elem))\n                    result.append(addnodes.desc_sig_punctuation('', ','))\n                    result.append(addnodes.desc_sig_space())\n                result.pop()\n                result.pop()\n            else:\n                result = [addnodes.desc_sig_punctuation('', '('),\n                          addnodes.desc_sig_punctuation('', ')')]\n\n            return result\n        raise SyntaxError",
                "filename": "sphinx/domains/python.py",
                "start_index": 6744,
                "end_index": 8313,
                "start_line": 184,
                "end_line": 216,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "class desc_returns(desc_type):\n    \"\"\"Node for a \"returns\" annotation (a la -> in Python).\"\"\"\n\n    def astext(self) -> str:\n        return ' -> ' + super().astext()\n\n\nclass desc_parameterlist(nodes.Part, nodes.Inline, nodes.FixedTextElement):\n    \"\"\"Node for a general parameter list.\"\"\"\n    child_text_separator = ', '\n\n    def astext(self):\n        return f'({super().astext()})'\n\n\nclass desc_parameter(nodes.Part, nodes.Inline, nodes.FixedTextElement):\n    \"\"\"Node for a single parameter.\"\"\"\n\n\nclass desc_optional(nodes.Part, nodes.Inline, nodes.FixedTextElement):\n    \"\"\"Node for marking optional parts of the parameter list.\"\"\"\n    child_text_separator = ', '\n\n    def astext(self) -> str:\n        return '[' + super().astext() + ']'\n\n\nclass desc_annotation(nodes.Part, nodes.Inline, nodes.FixedTextElement):\n    \"\"\"Node for signature annotations (not Python 3-style annotations).\"\"\"\n\n\n# Leaf nodes for markup of text fragments\n#########################################\n\n# Signature text elements, generally translated to node.inline\n# in SigElementFallbackTransform.\n# When adding a new one, add it to SIG_ELEMENTS.\n\nclass desc_sig_element(nodes.inline, _desc_classes_injector):\n    \"\"\"Common parent class of nodes for inline text of a signature.\"\"\"\n    classes: list[str] = []\n\n    def __init__(self, rawsource: str = '', text: str = '',\n                 *children: Element, **attributes: Any) -> None:\n        super().__init__(rawsource, text, *children, **attributes)\n        self['classes'].extend(self.classes)\n\n\n# to not reinvent the wheel, the classes in the following desc_sig classes\n# are based on those used in Pygments\n\nclass desc_sig_space(desc_sig_element):\n    \"\"\"Node for a space in a signature.\"\"\"\n    classes = [\"w\"]\n\n    def __init__(self, rawsource: str = '', text: str = ' ',\n                 *children: Element, **attributes: Any) -> None:\n        super().__init__(rawsource, text, *children, **attributes)\n\n\nclass desc_sig_name(desc_sig_element):\n    \"\"\"Node for an identifier in a signature.\"\"\"\n    classes = [\"n\"]\n\n\nclass desc_sig_operator(desc_sig_element):\n    \"\"\"Node for an operator in a signature.\"\"\"\n    classes = [\"o\"]\n\n\nclass desc_sig_punctuation(desc_sig_element):\n    \"\"\"Node for punctuation in a signature.\"\"\"\n    classes = [\"p\"]\n\n\nclass desc_sig_keyword(desc_sig_element):\n    \"\"\"Node for a general keyword in a signature.\"\"\"\n    classes = [\"k\"]\n\n\nclass desc_sig_keyword_type(desc_sig_element):\n    \"\"\"Node for a keyword which is a built-in type in a signature.\"\"\"\n    classes = [\"kt\"]\n\n\nclass desc_sig_literal_number(desc_sig_element):\n    \"\"\"Node for a numeric literal in a signature.\"\"\"\n    classes = [\"m\"]\n\n\nclass desc_sig_literal_string(desc_sig_element):\n    \"\"\"Node for a string literal in a signature.\"\"\"\n    classes = [\"s\"]\n\n\nclass desc_sig_literal_char(desc_sig_element):\n    \"\"\"Node for a character literal in a signature.\"\"\"\n    classes = [\"sc\"]",
                "filename": "sphinx/addnodes.py",
                "start_index": 7868,
                "end_index": 10768,
                "start_line": 241,
                "end_line": 338,
                "max_line": 568,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\n    \"\"\"\"Parse\" a list of arguments separated by commas.\n\n    Arguments can have \"optional\" annotations given by enclosing them in\n    brackets.  Currently, this will split at any comma, even if it's inside a\n    string literal (e.g. default argument value).\n    \"\"\"\n    paramlist = addnodes.desc_parameterlist()\n    stack: list[Element] = [paramlist]\n    try:\n        for argument in arglist.split(','):\n            argument = argument.strip()\n            ends_open = ends_close = 0\n            while argument.startswith('['):\n                stack.append(addnodes.desc_optional())\n                stack[-2] += stack[-1]\n                argument = argument[1:].strip()\n            while argument.startswith(']'):\n                stack.pop()\n                argument = argument[1:].strip()\n            while argument.endswith(']') and not argument.endswith('[]'):\n                ends_close += 1\n                argument = argument[:-1].strip()\n            while argument.endswith('['):\n                ends_open += 1\n                argument = argument[:-1].strip()\n            if argument:\n                stack[-1] += addnodes.desc_parameter(\n                    '', '', addnodes.desc_sig_name(argument, argument))\n            while ends_open:\n                stack.append(addnodes.desc_optional())\n                stack[-2] += stack[-1]\n                ends_open -= 1\n            while ends_close:\n                stack.pop()\n                ends_close -= 1\n        if len(stack) != 1:\n            raise IndexError\n    except IndexError:\n        # if there are too few or too many elements on the stack, just give up\n        # and treat the whole argument list as one argument, discarding the\n        # already partially populated paramlist node\n        paramlist = addnodes.desc_parameterlist()\n        paramlist += addnodes.desc_parameter(arglist, arglist)\n        signode += paramlist\n    else:\n        signode += paramlist\n\n\n# This override allows our inline type specifiers to behave like :class: link\n# when it comes to handling \".\" and \"~\" prefixes.",
                "filename": "sphinx/domains/python.py",
                "start_index": 12385,
                "end_index": 14518,
                "start_line": 312,
                "end_line": 362,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "\"\"\"The C language domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any, Callable, Generator, Iterator, TypeVar, Union, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node, TextElement, system_message\nfrom docutils.parsers.rst import directives\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import pending_xref\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.roles import SphinxRole, XRefRole\nfrom sphinx.transforms import SphinxTransform\nfrom sphinx.transforms.post_transforms import ReferencesResolver\nfrom sphinx.util import logging\nfrom sphinx.util.cfamily import (\n    ASTAttributeList,\n    ASTBaseBase,\n    ASTBaseParenExprList,\n    BaseParser,\n    DefinitionError,\n    NoOldIdError,\n    StringifyTransform,\n    UnsupportedMultiCharacterCharLiteral,\n    anon_identifier_re,\n    binary_literal_re,\n    char_literal_re,\n    float_literal_re,\n    float_literal_suffix_re,\n    hex_literal_re,\n    identifier_re,\n    integer_literal_re,\n    integers_literal_suffix_re,\n    octal_literal_re,\n    verify_description_mode,\n)\nfrom sphinx.util.docfields import Field, GroupedField, TypedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.nodes import make_refnode\nfrom sphinx.util.typing import OptionSpec\n\nlogger = logging.getLogger(__name__)\nT = TypeVar('T')\n\nDeclarationType = Union[\n    \"ASTStruct\", \"ASTUnion\", \"ASTEnum\", \"ASTEnumerator\",\n    \"ASTType\", \"ASTTypeWithInit\", \"ASTMacro\",\n]\n\n# https://en.cppreference.com/w/c/keyword\n_keywords = [\n    'auto', 'break', 'case', 'char', 'const', 'continue', 'default', 'do', 'double',\n    'else', 'enum', 'extern', 'float', 'for', 'goto', 'if', 'inline', 'int', 'long',\n    'register', 'restrict', 'return', 'short', 'signed', 'sizeof', 'static', 'struct',\n    'switch', 'typedef', 'union', 'unsigned', 'void', 'volatile', 'while',\n    '_Alignas', '_Alignof', '_Atomic', '_Bool', '_Complex',\n    '_Decimal32', '_Decimal64', '_Decimal128',\n    '_Generic', '_Imaginary', '_Noreturn', '_Static_assert', '_Thread_local',\n]\n# These are only keyword'y when the corresponding headers are included.\n# They are used as default value for c_extra_keywords.\n_macroKeywords = [\n    'alignas', 'alignof', 'bool', 'complex', 'imaginary', 'noreturn', 'static_assert',\n    'thread_local',\n]\n\n# these are ordered by preceedence\n_expression_bin_ops = [\n    ['||', 'or'],\n    ['&&', 'and'],\n    ['|', 'bitor'],\n    ['^', 'xor'],\n    ['&', 'bitand'],\n    ['==', '!=', 'not_eq'],\n    ['<=', '>=', '<', '>'],\n    ['<<', '>>'],\n    ['+', '-'],\n    ['*', '/', '%'],\n    ['.*', '->*'],\n]\n_expression_unary_ops = [\"++\", \"--\", \"*\", \"&\", \"+\", \"-\", \"!\", \"not\", \"~\", \"compl\"]",
                "filename": "sphinx/domains/c.py",
                "start_index": 0,
                "end_index": 2872,
                "start_line": 1,
                "end_line": 89,
                "max_line": 3876,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "if annotation_qualname or (annotation_module_is_typing and not annotation_forward_arg):\n        if mode == 'smart':\n            module_prefix = '~' + module_prefix\n        if annotation_module_is_typing and mode == 'fully-qualified-except-typing':\n            module_prefix = ''\n    else:\n        module_prefix = ''\n\n    if annotation_module_is_typing:\n        if annotation_forward_arg:\n            # handle ForwardRefs\n            qualname = annotation_forward_arg\n        else:\n            _name = getattr(annotation, '_name', '')\n            if _name:\n                qualname = _name\n            elif annotation_qualname:\n                qualname = annotation_qualname\n            else:\n                qualname = stringify_annotation(\n                    annotation.__origin__, 'fully-qualified-except-typing',\n                ).replace('typing.', '')  # ex. Union\n    elif annotation_qualname:\n        qualname = annotation_qualname\n    elif hasattr(annotation, '__origin__'):\n        # instantiated generic provided by a user\n        qualname = stringify_annotation(annotation.__origin__, mode)\n    elif UnionType and isinstance(annotation, UnionType):  # types.UnionType (for py3.10+)\n        qualname = 'types.UnionType'\n    else:\n        # we weren't able to extract the base type, appending arguments would\n        # only make them appear twice\n        return repr(annotation)\n\n    annotation_args = getattr(annotation, '__args__', None)\n    if annotation_args:\n        if not isinstance(annotation_args, (list, tuple)):\n            # broken __args__ found\n            pass\n        elif qualname in {'Optional', 'Union', 'types.UnionType'}:\n            return ' | '.join(stringify_annotation(a, mode) for a in annotation_args)\n        elif qualname == 'Callable':\n            args = ', '.join(stringify_annotation(a, mode) for a in annotation_args[:-1])\n            returns = stringify_annotation(annotation_args[-1], mode)\n            return f'{module_prefix}Callable[[{args}], {returns}]'\n        elif qualname == 'Literal':\n            args = ', '.join(repr(a) for a in annotation_args)\n            return f'{module_prefix}Literal[{args}]'\n        elif str(annotation).startswith('typing.Annotated'):  # for py39+\n            return stringify_annotation(annotation_args[0], mode)\n        elif all(is_system_TypeVar(a) for a in annotation_args):\n            # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])\n            return module_prefix + qualname\n        else:\n            args = ', '.join(stringify_annotation(a, mode) for a in annotation_args)\n            return f'{module_prefix}{qualname}[{args}]'\n\n    return module_prefix + qualname",
                "filename": "sphinx/util/typing.py",
                "start_index": 11752,
                "end_index": 14430,
                "start_line": 287,
                "end_line": 344,
                "max_line": 361,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            },
            {
                "code": "\"\"\"Highlight code blocks using Pygments.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\nfrom importlib import import_module\nfrom typing import Any\n\nfrom pygments import highlight\nfrom pygments.filters import ErrorToken\nfrom pygments.formatter import Formatter\nfrom pygments.formatters import HtmlFormatter, LatexFormatter\nfrom pygments.lexer import Lexer\nfrom pygments.lexers import (\n    CLexer,\n    PythonConsoleLexer,\n    PythonLexer,\n    RstLexer,\n    TextLexer,\n    get_lexer_by_name,\n    guess_lexer,\n)\nfrom pygments.style import Style\nfrom pygments.styles import get_style_by_name\nfrom pygments.util import ClassNotFound\n\nfrom sphinx.locale import __\nfrom sphinx.pygments_styles import NoneStyle, SphinxStyle\nfrom sphinx.util import logging, texescape\n\nlogger = logging.getLogger(__name__)\n\nlexers: dict[str, Lexer] = {}\nlexer_classes: dict[str, type[Lexer] | partial[Lexer]] = {\n    'none': partial(TextLexer, stripnl=False),\n    'python': partial(PythonLexer, stripnl=False),\n    'pycon': partial(PythonConsoleLexer, stripnl=False),\n    'rest': partial(RstLexer, stripnl=False),\n    'c': partial(CLexer, stripnl=False),\n}\n\n\nescape_hl_chars = {ord('\\\\'): '\\\\PYGZbs{}',\n                   ord('{'): '\\\\PYGZob{}',\n                   ord('}'): '\\\\PYGZcb{}'}\n\n# used if Pygments is available\n# MEMO: no use of \\protected here to avoid having to do hyperref extras,\n# (if in future code highlighting in sectioning titles is activated):\n# the definitions here use only robust, protected or chardef tokens,\n# which are all known to the hyperref re-encoding for bookmarks.\n# The \" is troublesome because we would like to use \\text\\textquotedbl\n# but \\textquotedbl is *defined to raise an error* (!) if the font\n# encoding is OT1.  This however could happen from 'fontenc' key.\n# MEMO: the Pygments escapes with \\char`\\<char> syntax, if the document\n# uses old OT1 font encoding, work correctly only in monospace font.\n# MEMO: the Pygmentize output mark-up is always with a {} after.\n_LATEX_ADD_STYLES = r'''\n% Sphinx redefinitions\n% Originally to obtain a straight single quote via package textcomp, then\n% to fix problems for the 5.0.0 inline code highlighting (captions!).\n% The \\text is from amstext, a dependency of sphinx.sty.  It is here only\n% to avoid build errors if for some reason expansion is in math mode.\n\\def\\PYGZbs{\\text\\textbackslash}\n\\def\\PYGZus{\\_}\n\\def\\PYGZob{\\{}\n\\def\\PYGZcb{\\}}\n\\def\\PYGZca{\\text\\textasciicircum}\n\\def\\PYGZam{\\&}\n\\def\\PYGZlt{\\text\\textless}\n\\def\\PYGZgt{\\text\\textgreater}\n\\def\\PYGZsh{\\#}\n\\def\\PYGZpc{\\%}\n\\def\\PYGZdl{\\$}\n\\def\\PYGZhy{\\sphinxhyphen}% defined in sphinxlatexstyletext.sty\n\\def\\PYGZsq{\\text\\textquotesingle}\n\\def\\PYGZdq{\"}\n\\def\\PYGZti{\\text\\textasciitilde}\n\\makeatletter\n% use \\protected to allow syntax highlighting in captions\n\\protected\\def\\PYG#1#2{\\PYG@reset\\PYG@toks#1+\\relax+{\\PYG@do{#2}}}\n\\makeatother\n'''",
                "filename": "sphinx/highlighting.py",
                "start_index": 0,
                "end_index": 2884,
                "start_line": 1,
                "end_line": 83,
                "max_line": 191,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "sphinx/domains/python.py": [
                {
                    "chunk": {
                        "code": "# unsupported syntax\n\n    def _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:\n        subscript = node.slice\n        if isinstance(subscript, ast.Index):\n            # py38 only\n            subscript = subscript.value  # type: ignore[assignment]\n\n        flattened: list[Node] = []\n        if isinstance(subscript, ast.Tuple):\n            flattened.extend(unparse(subscript.elts[0]))\n            for elt in subscript.elts[1:]:\n                flattened.extend(unparse(ast.BitOr()))\n                flattened.extend(unparse(elt))\n        else:\n            # e.g. a Union[] inside an Optional[]\n            flattened.extend(unparse(subscript))\n\n        if getattr(node.value, 'id', '') == 'Optional':\n            flattened.extend(unparse(ast.BitOr()))\n            flattened.append(nodes.Text('None'))\n\n        return flattened\n\n    try:\n        tree = ast.parse(annotation, type_comments=True)\n        result: list[Node] = []\n        for node in unparse(tree):\n            if isinstance(node, nodes.literal):\n                result.append(node[0])\n            elif isinstance(node, nodes.Text) and node.strip():\n                if (result and isinstance(result[-1], addnodes.desc_sig_punctuation) and\n                        result[-1].astext() == '~'):\n                    result.pop()\n                    result.append(type_to_xref(str(node), env, suppress_prefix=True))\n                else:\n                    result.append(type_to_xref(str(node), env))\n            else:\n                result.append(node)\n        return result\n    except SyntaxError:\n        return [type_to_xref(annotation, env)]",
                        "filename": "sphinx/domains/python.py",
                        "start_index": 8315,
                        "end_index": 9934,
                        "start_line": 216,
                        "end_line": 257,
                        "max_line": 1517,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the function '_unparse_pep_604_annotation' which is directly related to the formatting of 'Union' and 'Optional' types as described in the issue."
                },
                {
                    "chunk": {
                        "code": "if isinstance(node, ast.Subscript):\n            if getattr(node.value, 'id', '') in {'Optional', 'Union'}:\n                return _unparse_pep_604_annotation(node)\n            if short_literals and getattr(node.value, 'id', '') == 'Literal':\n                return _unparse_pep_604_annotation(node)\n            result = unparse(node.value)\n            result.append(addnodes.desc_sig_punctuation('', '['))\n            result.extend(unparse(node.slice))\n            result.append(addnodes.desc_sig_punctuation('', ']'))\n\n            # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal\n            if result[0] in ('Literal', 'typing.Literal'):\n                for i, subnode in enumerate(result[1:], start=1):\n                    if isinstance(subnode, nodes.Text):\n                        result[i] = nodes.literal('', '', subnode)\n            return result\n        if isinstance(node, ast.UnaryOp):\n            return unparse(node.op) + unparse(node.operand)\n        if isinstance(node, ast.Tuple):\n            if node.elts:\n                result = []\n                for elem in node.elts:\n                    result.extend(unparse(elem))\n                    result.append(addnodes.desc_sig_punctuation('', ','))\n                    result.append(addnodes.desc_sig_space())\n                result.pop()\n                result.pop()\n            else:\n                result = [addnodes.desc_sig_punctuation('', '('),\n                          addnodes.desc_sig_punctuation('', ')')]\n\n            return result\n        raise SyntaxError",
                        "filename": "sphinx/domains/python.py",
                        "start_index": 6744,
                        "end_index": 8313,
                        "start_line": 184,
                        "end_line": 216,
                        "max_line": 1517,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet checks for 'Optional', 'Union', and 'Literal' within an AST subscript and calls the relevant function to unparse them, which is relevant to the issue."
                },
                {
                    "chunk": {
                        "code": "\"\"\"Parse type annotation.\"\"\"\n    short_literals = env.config.python_display_short_literal_types",
                        "filename": "sphinx/domains/python.py",
                        "start_index": 4225,
                        "end_index": 4320,
                        "start_line": 132,
                        "end_line": 133,
                        "max_line": 1517,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__6.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet references a configuration option 'python_display_short_literal_types' which could be related to the display of 'Literal' types as mentioned in the issue."
                }
            ]
        },
        "solution_task": "To implement the requested feature in the Sphinx Python domain, you will need to modify the `_parse_annotation` function to handle the new formatting for `Union`, `Optional`, and `Literal` types, as well as syntax highlighting for constants. Here's a high-level overview of the steps to implement this feature:\n\n- Add a new configuration option in Sphinx to enable or disable the new formatting.\n- Modify the `_parse_annotation` function to apply the new formatting based on the configuration option.\n- Update the handling of `Literal` types to display only the literal value with syntax highlighting.\n- Ensure that constants are displayed with syntax highlighting.\n\nHere's a more detailed breakdown of the implementation:\n\n1. Add a new configuration option in `conf.py`:\n```python\n# conf.py\npython_use_pep604_syntax = True  # Add this line to enable the new formatting by default\n```\n\n2. Update the `sphinx/domains/python.py` file to use the new configuration option:\n```python\n# sphinx/domains/python.py\n\n# At the beginning of the file, add a new default config value\ndef setup(app: Sphinx):\n    app.add_config_value('python_use_pep604_syntax', False, 'env')\n\n# Modify the _parse_annotation function\ndef _parse_annotation(annotation: str, env: BuildEnvironment) -> list[Node]:\n    # ... existing code ...\n\n    # Check the new configuration option\n    use_pep604_syntax = env.config.python_use_pep604_syntax\n\n    # ... existing code ...\n\n    # Modify the handling of Union and Optional to use PEP 604 syntax if enabled\n    if use_pep604_syntax and isinstance(node, ast.Subscript) and getattr(node.value, 'id', '') in {'Optional', 'Union'}:\n        return _unparse_pep_604_annotation(node)\n\n    # Modify the handling of Literal to display only the literal value\n    if use_pep604_syntax and isinstance(node, ast.Subscript) and getattr(node.value, 'id', '') == 'Literal':\n        # Strip the \"Literal\" text and display the value with syntax highlighting\n        literal_value = unparse(node.slice)\n        return [nodes.literal('', '', nodes.Text(literal_value))]\n\n    # ... existing code ...\n\n    # Add syntax highlighting for constants\n    if isinstance(node, nodes.Text) and node.strip().isupper():\n        return [nodes.desc_sig_literal_string('', '', node)]\n\n    # ... existing code ...\n\n    return result\n```\n\n3. Update the `_unparse_pep_604_annotation` function to handle the new syntax:\n```python\n# sphinx/domains/python.py\n\ndef _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:\n    # ... existing code ...\n\n    # Modify the function to use PEP 604 syntax for Union and Optional\n    if isinstance(subscript, ast.Tuple):\n        # Use the '|' operator for Union types\n        flattened = [unparse(subscript.elts[0])]\n        for elt in subscript.elts[1:]:\n            flattened.append(nodes.desc_sig_operator('', '|'))\n            flattened.extend(unparse(elt))\n    else:\n        flattened.extend(unparse(subscript))\n\n    # Handle Optional types by appending '| None'\n    if getattr(node.value, 'id', '') == 'Optional':\n        flattened.append(nodes.desc_sig_operator('', '|'))\n        flattened.append(nodes.Text('None'))\n\n    return flattened\n```\n\n4. Test the changes by building the documentation and verifying that the new formatting is applied correctly.\n\nRemember to document the new configuration option and its behavior in the Sphinx documentation. Additionally, consider adding unit tests to ensure the feature works as expected and to prevent regressions in the future.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant suggestions that can directly lead to the successful implementation or improvement of the requested feature.",
            "supporting_evidence": "The RESPONSE provides a comprehensive and detailed plan for implementing the requested feature in Sphinx. It includes the creation of a new configuration option, modifications to the `_parse_annotation` function, and updates to the handling of `Literal` types and constants with syntax highlighting. The RESPONSE also includes code snippets and references to the relevant sections of the Sphinx codebase, which are highly valuable for developers looking to implement this feature. The RESPONSE does not address all aspects of the feature request, such as the specifics of integrating syntax highlighting for constants, but it covers the majority of the necessary steps.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711701193.3316312,
        "result": "To implement the requested feature in the Sphinx Python domain, you will need to modify the `_parse_annotation` function to handle the new formatting for `Union`, `Optional`, and `Literal` types, as well as syntax highlighting for constants. Here's a high-level overview of the steps to implement this feature:\n\n- Add a new configuration option in Sphinx to enable or disable the new formatting.\n- Modify the `_parse_annotation` function to apply the new formatting based on the configuration option.\n- Update the handling of `Literal` types to display only the literal value with syntax highlighting.\n- Ensure that constants are displayed with syntax highlighting.\n\nHere's a more detailed breakdown of the implementation:\n\n1. Add a new configuration option in `conf.py`:\n```python\n# conf.py\npython_use_pep604_syntax = True  # Add this line to enable the new formatting by default\n```\n\n2. Update the `sphinx/domains/python.py` file to use the new configuration option:\n```python\n# sphinx/domains/python.py\n\n# At the beginning of the file, add a new default config value\ndef setup(app: Sphinx):\n    app.add_config_value('python_use_pep604_syntax', False, 'env')\n\n# Modify the _parse_annotation function\ndef _parse_annotation(annotation: str, env: BuildEnvironment) -> list[Node]:\n    # ... existing code ...\n\n    # Check the new configuration option\n    use_pep604_syntax = env.config.python_use_pep604_syntax\n\n    # ... existing code ...\n\n    # Modify the handling of Union and Optional to use PEP 604 syntax if enabled\n    if use_pep604_syntax and isinstance(node, ast.Subscript) and getattr(node.value, 'id', '') in {'Optional', 'Union'}:\n        return _unparse_pep_604_annotation(node)\n\n    # Modify the handling of Literal to display only the literal value\n    if use_pep604_syntax and isinstance(node, ast.Subscript) and getattr(node.value, 'id', '') == 'Literal':\n        # Strip the \"Literal\" text and display the value with syntax highlighting\n        literal_value = unparse(node.slice)\n        return [nodes.literal('', '', nodes.Text(literal_value))]\n\n    # ... existing code ...\n\n    # Add syntax highlighting for constants\n    if isinstance(node, nodes.Text) and node.strip().isupper():\n        return [nodes.desc_sig_literal_string('', '', node)]\n\n    # ... existing code ...\n\n    return result\n```\n\n3. Update the `_unparse_pep_604_annotation` function to handle the new syntax:\n```python\n# sphinx/domains/python.py\n\ndef _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:\n    # ... existing code ...\n\n    # Modify the function to use PEP 604 syntax for Union and Optional\n    if isinstance(subscript, ast.Tuple):\n        # Use the '|' operator for Union types\n        flattened = [unparse(subscript.elts[0])]\n        for elt in subscript.elts[1:]:\n            flattened.append(nodes.desc_sig_operator('', '|'))\n            flattened.extend(unparse(elt))\n    else:\n        flattened.extend(unparse(subscript))\n\n    # Handle Optional types by appending '| None'\n    if getattr(node.value, 'id', '') == 'Optional':\n        flattened.append(nodes.desc_sig_operator('', '|'))\n        flattened.append(nodes.Text('None'))\n\n    return flattened\n```\n\n4. Test the changes by building the documentation and verifying that the new formatting is applied correctly.\n\nRemember to document the new configuration option and its behavior in the Sphinx documentation. Additionally, consider adding unit tests to ensure the feature works as expected and to prevent regressions in the future.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__6.2/tree//sphinx) \u2192 [domains](https://github.com/testbed/sphinx-doc__sphinx__6.2/tree//sphinx/domains)- [Lines 216 - 257](https://github.com/testbed/sphinx-doc__sphinx__6.2/blob//sphinx/domains/python.py#L216-L257)\n\n This snippet contains the function '_unparse_pep_604_annotation' which is directly related to the formatting of 'Union' and 'Optional' types as described in the issue. \n\n\n   - [Lines 184 - 216](https://github.com/testbed/sphinx-doc__sphinx__6.2/blob//sphinx/domains/python.py#L184-L216)\n\n This snippet checks for 'Optional', 'Union', and 'Literal' within an AST subscript and calls the relevant function to unparse them, which is relevant to the issue. \n\n\n   - [Lines 132 - 133](https://github.com/testbed/sphinx-doc__sphinx__6.2/blob//sphinx/domains/python.py#L132-L133)\n\n This snippet references a configuration option 'python_display_short_literal_types' which could be related to the display of 'Literal' types as mentioned in the issue."
    }
}