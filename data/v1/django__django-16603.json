{
    "id": "django__django-16603",
    "repo_name": "testbed/django__django__5.0",
    "task_id": 2950173591730496371,
    "title": "ASGI http.disconnect not handled on requests with body.",
    "body": "Description\n\t\nNoticed whilst reviewing \u200bPR 15704 for #33699, we're not handling the ASGI http.disconnect message correctly. Since it's only dealt with whilst reading the request body, http.disconnect is not processed on a request that includes a body. \n\u200bhttps://github.com/django/django/blob/241fe59b74bb6031fa644f3ad55e6ad6a9187510/django/core/handlers/asgi.py#L189\n\tasync def read_body(self, receive):\n\t\t\"\"\"Reads an HTTP body from an ASGI connection.\"\"\"\n\t\t# Use the tempfile that auto rolls-over to a disk file as it fills up.\n\t\tbody_file = tempfile.SpooledTemporaryFile(\n\t\t\tmax_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode=\"w+b\"\n\t\t)\n\t\twhile True:\n\t\t\tmessage = await receive()\n\t\t\tif message[\"type\"] == \"http.disconnect\":\t# This is the only place `http.disconnect` is handled. \n\t\t\t\tbody_file.close()\n\t\t\t\t# Early client disconnect.\n\t\t\t\traise RequestAborted()\n\t\t\t# Add a body chunk from the message, if provided.\n\t\t\tif \"body\" in message:\n\t\t\t\tbody_file.write(message[\"body\"])\n\t\t\t# Quit out if that's the end.\n\t\t\tif not message.get(\"more_body\", False):\n\t\t\t\tbreak\n\t\tbody_file.seek(0)\n\t\treturn body_file\nhttp.disconnect is designed for long-polling \u2014 so we imagine a client opening a request, with a request body, and then disconnecting before the response is generated. \nThe protocol server (Daphne/uvicorn/...) will send the http.diconnect message, but it's not handled.\nThis test fails on main (at 9f5548952906c6ea97200c016734b4f519520a64 \u2014 4.2 pre-alpha)\ndiff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex ef7b55724e..a68ca8a473 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -188,6 +188,18 @@ class ASGITest(SimpleTestCase):\n\t\t with self.assertRaises(asyncio.TimeoutError):\n\t\t\t await communicator.receive_output()\n \n+\tasync def test_disconnect_with_body(self):\n+\t\tapplication = get_asgi_application()\n+\t\tscope = self.async_request_factory._base_scope(path=\"/\")\n+\t\tcommunicator = ApplicationCommunicator(application, scope)\n+\t\tawait communicator.send_input({\n+\t\t\t\"type\": \"http.request\",\n+\t\t\t\"body\": b\"some body\",\n+\t\t})\n+\t\tawait communicator.send_input({\"type\": \"http.disconnect\"})\n+\t\twith self.assertRaises(asyncio.TimeoutError):\n+\t\t\tawait communicator.receive_output()\n+\n\t async def test_wrong_connection_type(self):\n\t\t application = get_asgi_application()\n\t\t scope = self.async_request_factory._base_scope(path=\"/\", type=\"other\")\nTo handle this correctly it looks like we'd need something like Channel's \u200b`await_many_dispatch()` to keep receiving from the input queue whilst dispatching the request. \ud83e\udd14\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__5.0.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `read_body` function in `django/core/handlers/asgi.py` to handle `http.disconnect` messages correctly.\n- Add a check for `http.disconnect` message type before the loop that reads the body chunks.\n- If an `http.disconnect` message is received, close the `body_file` and raise `RequestAborted` before reading any body chunks.\n\n```python\nasync def read_body(self, receive):\n    \"\"\"Reads an HTTP body from an ASGI connection.\"\"\"\n    body_file = tempfile.SpooledTemporaryFile(\n        max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode=\"w+b\"\n    )\n    while True:\n        message = await receive()\n        if message[\"type\"] == \"http.disconnect\":\n            body_file.close()\n            raise RequestAborted()\n        if \"body\" in message:\n            body_file.write(message[\"body\"])\n        if not message.get(\"more_body\", False):\n            break\n    body_file.seek(0)\n    return body_file\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__5.0/tree//django) \u2192 [core](https://github.com/testbed/django__django__5.0/tree//django/core) \u2192 [handlers](https://github.com/testbed/django__django__5.0/tree//django/core/handlers)- [Lines 148 - 221](https://github.com/testbed/django__django__5.0/blob//django/core/handlers/asgi.py#L148-L221)\n\n This snippet contains the main ASGI handler logic, including the handling of the 'http.disconnect' message and the 'read_body' method where the issue is located. \n\n\n   - [Lines 223 - 354](https://github.com/testbed/django__django__5.0/blob//django/core/handlers/asgi.py#L223-L354)\n\n This snippet includes the 'read_body' method where 'http.disconnect' is handled, which is directly related to the issue. \n\n\n   - [Lines 1 - 35](https://github.com/testbed/django__django__5.0/blob//django/core/handlers/asgi.py#L1-L35)\n\n This snippet includes imports and definitions that are relevant to the ASGI handler, including 'RequestAborted' which is raised when 'http.disconnect' is received.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000425,
        "snippet_processor": 0.04505000000000001,
        "issue_star_creation": 0.029089999999999998,
        "issue_star_solver": 0.05791,
        "bouncer": 0.024120000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711705848.615127,
        "relevant_snippets": [
            {
                "code": "\"\"\"Handler for ASGI requests.\"\"\"\n\n    request_class = ASGIRequest\n    # Size to chunk response bodies into for multiple response messages.\n    chunk_size = 2**16\n\n    def __init__(self):\n        super().__init__()\n        self.load_middleware(is_async=True)\n\n    async def __call__(self, scope, receive, send):\n        \"\"\"\n        Async entrypoint - parses the request and hands off to get_response.\n        \"\"\"\n        # Serve only HTTP connections.\n        # FIXME: Allow to override this.\n        if scope[\"type\"] != \"http\":\n            raise ValueError(\n                \"Django can only handle ASGI/HTTP connections, not %s.\" % scope[\"type\"]\n            )\n\n        async with ThreadSensitiveContext():\n            await self.handle(scope, receive, send)\n\n    async def handle(self, scope, receive, send):\n        \"\"\"\n        Handles the ASGI request. Called via the __call__ method.\n        \"\"\"\n        # Receive the HTTP request body as a stream object.\n        try:\n            body_file = await self.read_body(receive)\n        except RequestAborted:\n            return\n        # Request is complete and can be served.\n        set_script_prefix(get_script_prefix(scope))\n        await signals.request_started.asend(sender=self.__class__, scope=scope)\n        # Get the request and check for basic issues.\n        request, error_response = self.create_request(scope, body_file)\n        if request is None:\n            body_file.close()\n            await self.send_response(error_response, send)\n            return\n        # Try to catch a disconnect while getting response.\n        tasks = [\n            asyncio.create_task(self.run_get_response(request)),\n            asyncio.create_task(self.listen_for_disconnect(receive)),\n        ]\n        done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n        done, pending = done.pop(), pending.pop()\n        # Allow views to handle cancellation.\n        pending.cancel()\n        try:\n            await pending\n        except asyncio.CancelledError:\n            # Task re-raised the CancelledError as expected.\n            pass\n        try:\n            response = done.result()\n        except RequestAborted:\n            body_file.close()\n            return\n        except AssertionError:\n            body_file.close()\n            raise\n        # Send the response.\n        await self.send_response(response, send)\n\n    async def listen_for_disconnect(self, receive):\n        \"\"\"Listen for disconnect from the client.\"\"\"\n        message = await receive()\n        if message[\"type\"] == \"http.disconnect\":\n            raise RequestAborted()\n        # This should never happen.\n        assert False, \"Invalid ASGI message after request body: %s\" % message[\"type\"]",
                "filename": "django/core/handlers/asgi.py",
                "start_index": 4875,
                "end_index": 7613,
                "start_line": 148,
                "end_line": 221,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Custom request subclass that decodes from an ASGI-standard request dict\n    and wraps request body handling.\n    \"\"\"\n\n    # Number of seconds until a Request gives up on trying to read a request\n    # body and aborts.\n    body_receive_timeout = 60",
                "filename": "django/core/handlers/asgi.py",
                "start_index": 933,
                "end_index": 1188,
                "start_line": 30,
                "end_line": 46,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "class ASGIHandler(base.BaseHandler):",
                "filename": "django/core/handlers/asgi.py",
                "start_index": 4834,
                "end_index": 4870,
                "start_line": 147,
                "end_line": 147,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "class ASGIRequest(HttpRequest):",
                "filename": "django/core/handlers/asgi.py",
                "start_index": 897,
                "end_index": 928,
                "start_line": 38,
                "end_line": 38,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "class ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        if (\n            self.environ[\"REQUEST_METHOD\"] == \"HEAD\"\n            and \"Content-Length\" in self.headers\n        ):\n            del self.headers[\"Content-Length\"]\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if (\n            self.environ[\"REQUEST_METHOD\"] != \"HEAD\"\n            and \"Content-Length\" not in self.headers\n        ):\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n\n    def finish_response(self):\n        if self.environ[\"REQUEST_METHOD\"] == \"HEAD\":\n            try:\n                deque(self.result, maxlen=0)  # Consume iterator.\n                # Don't call self.finish_content() as, if the headers have not\n                # been sent and Content-Length isn't set, it'll default to \"0\"\n                # which will prevent omission of the Content-Length header with\n                # HEAD requests as permitted by RFC 9110 Section 9.3.2.\n                # Instead, send the headers, if not sent yet.\n                if not self.headers_sent:\n                    self.send_headers()\n            finally:\n                self.close()\n        else:\n            super().finish_response()",
                "filename": "django/core/servers/basehttp.py",
                "start_index": 3688,
                "end_index": 6224,
                "start_line": 114,
                "end_line": 173,
                "max_line": 281,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "import asyncio\nimport logging\nimport types\n\nfrom asgiref.sync import async_to_sync, iscoroutinefunction, sync_to_async\n\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured, MiddlewareNotUsed\nfrom django.core.signals import request_finished\nfrom django.db import connections, transaction\nfrom django.urls import get_resolver, set_urlconf\nfrom django.utils.log import log_response\nfrom django.utils.module_loading import import_string\n\nfrom .exception import convert_exception_to_response\n\nlogger = logging.getLogger(\"django.request\")",
                "filename": "django/core/handlers/base.py",
                "start_index": 0,
                "end_index": 569,
                "start_line": 1,
                "end_line": 17,
                "max_line": 373,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "from io import IOBase\n\nfrom django.conf import settings\nfrom django.core import signals\nfrom django.core.handlers import base\nfrom django.http import HttpRequest, QueryDict, parse_cookie\nfrom django.urls import set_script_prefix\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.functional import cached_property\nfrom django.utils.regex_helper import _lazy_re_compile\n\n_slashes_re = _lazy_re_compile(rb\"/+\")\n\n\nclass LimitedStream(IOBase):\n    \"\"\"\n    Wrap another stream to disallow reading it past a number of bytes.\n\n    Based on the implementation from werkzeug.wsgi.LimitedStream\n    See https://github.com/pallets/werkzeug/blob/dbf78f67/src/werkzeug/wsgi.py#L828\n    \"\"\"\n\n    def __init__(self, stream, limit):\n        self._read = stream.read\n        self._readline = stream.readline\n        self._pos = 0\n        self.limit = limit\n\n    def read(self, size=-1, /):\n        _pos = self._pos\n        limit = self.limit\n        if _pos >= limit:\n            return b\"\"\n        if size == -1 or size is None:\n            size = limit - _pos\n        else:\n            size = min(size, limit - _pos)\n        data = self._read(size)\n        self._pos += len(data)\n        return data\n\n    def readline(self, size=-1, /):\n        _pos = self._pos\n        limit = self.limit\n        if _pos >= limit:\n            return b\"\"\n        if size == -1 or size is None:\n            size = limit - _pos\n        else:\n            size = min(size, limit - _pos)\n        line = self._readline(size)\n        self._pos += len(line)\n        return line",
                "filename": "django/core/handlers/wsgi.py",
                "start_index": 0,
                "end_index": 1563,
                "start_line": 1,
                "end_line": 53,
                "max_line": 207,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "async def run_get_response(self, request):\n        \"\"\"Get async response.\"\"\"\n        # Use the async mode of BaseHandler.\n        response = await self.get_response_async(request)\n        response._handler_class = self.__class__\n        # Increase chunk size on file responses (ASGI servers handles low-level\n        # chunking).\n        if isinstance(response, FileResponse):\n            response.block_size = self.chunk_size\n        return response\n\n    async def read_body(self, receive):\n        \"\"\"Reads an HTTP body from an ASGI connection.\"\"\"\n        # Use the tempfile that auto rolls-over to a disk file as it fills up.\n        body_file = tempfile.SpooledTemporaryFile(\n            max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode=\"w+b\"\n        )\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"http.disconnect\":\n                body_file.close()\n                # Early client disconnect.\n                raise RequestAborted()\n            # Add a body chunk from the message, if provided.\n            if \"body\" in message:\n                body_file.write(message[\"body\"])\n            # Quit out if that's the end.\n            if not message.get(\"more_body\", False):\n                break\n        body_file.seek(0)\n        return body_file\n\n    def create_request(self, scope, body_file):\n        \"\"\"\n        Create the Request object and returns either (request, None) or\n        (None, response) if there is an error response.\n        \"\"\"\n        try:\n            return self.request_class(scope, body_file), None\n        except UnicodeDecodeError:\n            logger.warning(\n                \"Bad Request (UnicodeDecodeError)\",\n                exc_info=sys.exc_info(),\n                extra={\"status_code\": 400},\n            )\n            return None, HttpResponseBadRequest()\n        except RequestDataTooBig:\n            return None, HttpResponse(\"413 Payload too large\", status=413)\n\n    def handle_uncaught_exception(self, request, resolver, exc_info):\n        \"\"\"Last-chance handler for exceptions.\"\"\"\n        # There's no WSGI server to catch the exception further up\n        # if this fails, so translate it into a plain text response.\n        try:\n            return super().handle_uncaught_exception(request, resolver, exc_info)\n        except Exception:\n            return HttpResponseServerError(\n                traceback.format_exc() if settings.DEBUG else \"Internal Server Error\",\n                content_type=\"text/plain\",\n            )",
                "filename": "django/core/handlers/asgi.py",
                "start_index": 7619,
                "end_index": 10132,
                "start_line": 223,
                "end_line": 354,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "import asyncio\nimport logging\nimport sys\nimport tempfile\nimport traceback\nfrom contextlib import aclosing\n\nfrom asgiref.sync import ThreadSensitiveContext, sync_to_async\n\nfrom django.conf import settings\nfrom django.core import signals\nfrom django.core.exceptions import RequestAborted, RequestDataTooBig\nfrom django.core.handlers import base\nfrom django.http import (\n    FileResponse,\n    HttpRequest,\n    HttpResponse,\n    HttpResponseBadRequest,\n    HttpResponseServerError,\n    QueryDict,\n    parse_cookie,\n)\nfrom django.urls import set_script_prefix\nfrom django.utils.functional import cached_property\n\nlogger = logging.getLogger(\"django.request\")\n\n\ndef get_script_prefix(scope):\n    \"\"\"\n    Return the script prefix to use from either the scope or a setting.\n    \"\"\"\n    if settings.FORCE_SCRIPT_NAME:\n        return settings.FORCE_SCRIPT_NAME\n    return scope.get(\"root_path\", \"\") or \"\"",
                "filename": "django/core/handlers/asgi.py",
                "start_index": 0,
                "end_index": 894,
                "start_line": 1,
                "end_line": 35,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            },
            {
                "code": "class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n    protocol_version = \"HTTP/1.1\"\n\n    def address_string(self):\n        # Short-circuit parent method to not call socket.getfqdn\n        return self.client_address[0]\n\n    def log_message(self, format, *args):\n        extra = {\n            \"request\": self.request,\n            \"server_time\": self.log_date_time_string(),\n        }\n        if args[1][0] == \"4\":\n            # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n            if args[0].startswith(\"\\x16\\x03\"):\n                extra[\"status_code\"] = 500\n                logger.error(\n                    \"You're accessing the development server over HTTPS, but \"\n                    \"it only supports HTTP.\",\n                    extra=extra,\n                )\n                return\n\n        if args[1].isdigit() and len(args[1]) == 3:\n            status_code = int(args[1])\n            extra[\"status_code\"] = status_code\n\n            if status_code >= 500:\n                level = logger.error\n            elif status_code >= 400:\n                level = logger.warning\n            else:\n                level = logger.info\n        else:\n            level = logger.info\n\n        level(format, *args, extra=extra)\n\n    def get_environ(self):\n        # Strip all headers with underscores in the name before constructing\n        # the WSGI environ. This prevents header-spoofing based on ambiguity\n        # between underscores and dashes both normalized to underscores in WSGI\n        # env vars. Nginx and Apache 2.4+ both do this as well.\n        for k in self.headers:\n            if \"_\" in k:\n                del self.headers[k]\n\n        return super().get_environ()\n\n    def handle(self):\n        self.close_connection = True\n        self.handle_one_request()\n        while not self.close_connection:\n            self.handle_one_request()\n        try:\n            self.connection.shutdown(socket.SHUT_WR)\n        except (AttributeError, OSError):\n            pass\n\n    def handle_one_request(self):\n        \"\"\"Copy of WSGIRequestHandler.handle() but with different ServerHandler\"\"\"\n        self.raw_requestline = self.rfile.readline(65537)\n        if len(self.raw_requestline) > 65536:\n            self.requestline = \"\"\n            self.request_version = \"\"\n            self.command = \"\"\n            self.send_error(414)\n            return\n\n        if not self.parse_request():  # An error code has been sent, just exit\n            return\n\n        handler = ServerHandler(\n            self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n        )\n        handler.request_handler = self  # backpointer for logging & connection closing\n        handler.run(self.server.get_app())",
                "filename": "django/core/servers/basehttp.py",
                "start_index": 6227,
                "end_index": 8933,
                "start_line": 176,
                "end_line": 252,
                "max_line": 281,
                "git_instance": "github",
                "repo_name": "testbed/django__django__5.0",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/core/handlers/asgi.py": [
                {
                    "chunk": {
                        "code": "\"\"\"Handler for ASGI requests.\"\"\"\n\n    request_class = ASGIRequest\n    # Size to chunk response bodies into for multiple response messages.\n    chunk_size = 2**16\n\n    def __init__(self):\n        super().__init__()\n        self.load_middleware(is_async=True)\n\n    async def __call__(self, scope, receive, send):\n        \"\"\"\n        Async entrypoint - parses the request and hands off to get_response.\n        \"\"\"\n        # Serve only HTTP connections.\n        # FIXME: Allow to override this.\n        if scope[\"type\"] != \"http\":\n            raise ValueError(\n                \"Django can only handle ASGI/HTTP connections, not %s.\" % scope[\"type\"]\n            )\n\n        async with ThreadSensitiveContext():\n            await self.handle(scope, receive, send)\n\n    async def handle(self, scope, receive, send):\n        \"\"\"\n        Handles the ASGI request. Called via the __call__ method.\n        \"\"\"\n        # Receive the HTTP request body as a stream object.\n        try:\n            body_file = await self.read_body(receive)\n        except RequestAborted:\n            return\n        # Request is complete and can be served.\n        set_script_prefix(get_script_prefix(scope))\n        await signals.request_started.asend(sender=self.__class__, scope=scope)\n        # Get the request and check for basic issues.\n        request, error_response = self.create_request(scope, body_file)\n        if request is None:\n            body_file.close()\n            await self.send_response(error_response, send)\n            return\n        # Try to catch a disconnect while getting response.\n        tasks = [\n            asyncio.create_task(self.run_get_response(request)),\n            asyncio.create_task(self.listen_for_disconnect(receive)),\n        ]\n        done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n        done, pending = done.pop(), pending.pop()\n        # Allow views to handle cancellation.\n        pending.cancel()\n        try:\n            await pending\n        except asyncio.CancelledError:\n            # Task re-raised the CancelledError as expected.\n            pass\n        try:\n            response = done.result()\n        except RequestAborted:\n            body_file.close()\n            return\n        except AssertionError:\n            body_file.close()\n            raise\n        # Send the response.\n        await self.send_response(response, send)\n\n    async def listen_for_disconnect(self, receive):\n        \"\"\"Listen for disconnect from the client.\"\"\"\n        message = await receive()\n        if message[\"type\"] == \"http.disconnect\":\n            raise RequestAborted()\n        # This should never happen.\n        assert False, \"Invalid ASGI message after request body: %s\" % message[\"type\"]",
                        "filename": "django/core/handlers/asgi.py",
                        "start_index": 4875,
                        "end_index": 7613,
                        "start_line": 148,
                        "end_line": 221,
                        "max_line": 355,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the main ASGI handler logic, including the handling of the 'http.disconnect' message and the 'read_body' method where the issue is located."
                },
                {
                    "chunk": {
                        "code": "async def run_get_response(self, request):\n        \"\"\"Get async response.\"\"\"\n        # Use the async mode of BaseHandler.\n        response = await self.get_response_async(request)\n        response._handler_class = self.__class__\n        # Increase chunk size on file responses (ASGI servers handles low-level\n        # chunking).\n        if isinstance(response, FileResponse):\n            response.block_size = self.chunk_size\n        return response\n\n    async def read_body(self, receive):\n        \"\"\"Reads an HTTP body from an ASGI connection.\"\"\"\n        # Use the tempfile that auto rolls-over to a disk file as it fills up.\n        body_file = tempfile.SpooledTemporaryFile(\n            max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode=\"w+b\"\n        )\n        while True:\n            message = await receive()\n            if message[\"type\"] == \"http.disconnect\":\n                body_file.close()\n                # Early client disconnect.\n                raise RequestAborted()\n            # Add a body chunk from the message, if provided.\n            if \"body\" in message:\n                body_file.write(message[\"body\"])\n            # Quit out if that's the end.\n            if not message.get(\"more_body\", False):\n                break\n        body_file.seek(0)\n        return body_file\n\n    def create_request(self, scope, body_file):\n        \"\"\"\n        Create the Request object and returns either (request, None) or\n        (None, response) if there is an error response.\n        \"\"\"\n        try:\n            return self.request_class(scope, body_file), None\n        except UnicodeDecodeError:\n            logger.warning(\n                \"Bad Request (UnicodeDecodeError)\",\n                exc_info=sys.exc_info(),\n                extra={\"status_code\": 400},\n            )\n            return None, HttpResponseBadRequest()\n        except RequestDataTooBig:\n            return None, HttpResponse(\"413 Payload too large\", status=413)\n\n    def handle_uncaught_exception(self, request, resolver, exc_info):\n        \"\"\"Last-chance handler for exceptions.\"\"\"\n        # There's no WSGI server to catch the exception further up\n        # if this fails, so translate it into a plain text response.\n        try:\n            return super().handle_uncaught_exception(request, resolver, exc_info)\n        except Exception:\n            return HttpResponseServerError(\n                traceback.format_exc() if settings.DEBUG else \"Internal Server Error\",\n                content_type=\"text/plain\",\n            )",
                        "filename": "django/core/handlers/asgi.py",
                        "start_index": 7619,
                        "end_index": 10132,
                        "start_line": 223,
                        "end_line": 354,
                        "max_line": 355,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the 'read_body' method where 'http.disconnect' is handled, which is directly related to the issue."
                },
                {
                    "chunk": {
                        "code": "import asyncio\nimport logging\nimport sys\nimport tempfile\nimport traceback\nfrom contextlib import aclosing\n\nfrom asgiref.sync import ThreadSensitiveContext, sync_to_async\n\nfrom django.conf import settings\nfrom django.core import signals\nfrom django.core.exceptions import RequestAborted, RequestDataTooBig\nfrom django.core.handlers import base\nfrom django.http import (\n    FileResponse,\n    HttpRequest,\n    HttpResponse,\n    HttpResponseBadRequest,\n    HttpResponseServerError,\n    QueryDict,\n    parse_cookie,\n)\nfrom django.urls import set_script_prefix\nfrom django.utils.functional import cached_property\n\nlogger = logging.getLogger(\"django.request\")\n\n\ndef get_script_prefix(scope):\n    \"\"\"\n    Return the script prefix to use from either the scope or a setting.\n    \"\"\"\n    if settings.FORCE_SCRIPT_NAME:\n        return settings.FORCE_SCRIPT_NAME\n    return scope.get(\"root_path\", \"\") or \"\"",
                        "filename": "django/core/handlers/asgi.py",
                        "start_index": 0,
                        "end_index": 894,
                        "start_line": 1,
                        "end_line": 35,
                        "max_line": 355,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes imports and definitions that are relevant to the ASGI handler, including 'RequestAborted' which is raised when 'http.disconnect' is received."
                }
            ]
        },
        "solution_task": "- Modify the `read_body` function in `django/core/handlers/asgi.py` to handle `http.disconnect` messages correctly.\n- Add a check for `http.disconnect` message type before the loop that reads the body chunks.\n- If an `http.disconnect` message is received, close the `body_file` and raise `RequestAborted` before reading any body chunks.\n\n```python\nasync def read_body(self, receive):\n    \"\"\"Reads an HTTP body from an ASGI connection.\"\"\"\n    body_file = tempfile.SpooledTemporaryFile(\n        max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode=\"w+b\"\n    )\n    while True:\n        message = await receive()\n        if message[\"type\"] == \"http.disconnect\":\n            body_file.close()\n            raise RequestAborted()\n        if \"body\" in message:\n            body_file.write(message[\"body\"])\n        if not message.get(\"more_body\", False):\n            break\n    body_file.seek(0)\n    return body_file\n```",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a direct and actionable solution to the problem described in the PROMPT by suggesting modifications to the `read_body` function to handle `http.disconnect` messages correctly. It correctly identifies that the `http.disconnect` message should be checked before the loop that reads the body chunks and that the `body_file` should be closed and `RequestAborted` raised if such a message is received. This is in line with the issue described in the PROMPT, which is about not handling `http.disconnect` messages correctly when a request includes a body. The RESPONSE also includes the correct code snippet where the issue is located and suggests the necessary changes. However, it does not address the part of the PROMPT that suggests the need for something like Channel's `await_many_dispatch()` to keep receiving from the input queue while dispatching the request. This part of the PROMPT hints at a more complex solution that might involve changes to the request dispatch mechanism, which the RESPONSE does not cover.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711705971.934936,
        "result": "- Modify the `read_body` function in `django/core/handlers/asgi.py` to handle `http.disconnect` messages correctly.\n- Add a check for `http.disconnect` message type before the loop that reads the body chunks.\n- If an `http.disconnect` message is received, close the `body_file` and raise `RequestAborted` before reading any body chunks.\n\n```python\nasync def read_body(self, receive):\n    \"\"\"Reads an HTTP body from an ASGI connection.\"\"\"\n    body_file = tempfile.SpooledTemporaryFile(\n        max_size=settings.FILE_UPLOAD_MAX_MEMORY_SIZE, mode=\"w+b\"\n    )\n    while True:\n        message = await receive()\n        if message[\"type\"] == \"http.disconnect\":\n            body_file.close()\n            raise RequestAborted()\n        if \"body\" in message:\n            body_file.write(message[\"body\"])\n        if not message.get(\"more_body\", False):\n            break\n    body_file.seek(0)\n    return body_file\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__5.0/tree//django) \u2192 [core](https://github.com/testbed/django__django__5.0/tree//django/core) \u2192 [handlers](https://github.com/testbed/django__django__5.0/tree//django/core/handlers)- [Lines 148 - 221](https://github.com/testbed/django__django__5.0/blob//django/core/handlers/asgi.py#L148-L221)\n\n This snippet contains the main ASGI handler logic, including the handling of the 'http.disconnect' message and the 'read_body' method where the issue is located. \n\n\n   - [Lines 223 - 354](https://github.com/testbed/django__django__5.0/blob//django/core/handlers/asgi.py#L223-L354)\n\n This snippet includes the 'read_body' method where 'http.disconnect' is handled, which is directly related to the issue. \n\n\n   - [Lines 1 - 35](https://github.com/testbed/django__django__5.0/blob//django/core/handlers/asgi.py#L1-L35)\n\n This snippet includes imports and definitions that are relevant to the ASGI handler, including 'RequestAborted' which is raised when 'http.disconnect' is received."
    }
}