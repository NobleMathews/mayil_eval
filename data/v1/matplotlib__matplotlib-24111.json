{
    "id": "matplotlib__matplotlib-24111",
    "repo_name": "testbed/matplotlib__matplotlib__3.6",
    "task_id": 3528751876697183269,
    "title": "[ENH]: Default `matplotlib.colormaps[None]` to call `matplotlib.colormaps[matplotlib.rcParams['image.cmap']]`?",
    "body": "### Problem\n\nWhile addressing the `matplotlib.cm.get_cmap` deprecation in 3.6:\r\n\r\n```\r\nPendingDeprecationWarning: The get_cmap function will be deprecated in a future version. Use ``matplotlib.colormaps[name]`` instead.\r\n```\r\nI noticed that `None` isn't directly migrate-able \r\n\r\n```\r\nIn [1]: import matplotlib\r\n\r\nIn [2]: matplotlib.cm.get_cmap(None)\r\nOut[2]: <matplotlib.colors.ListedColormap at 0x11e609e20>\r\n\r\nIn [3]: matplotlib.colormaps[None]\r\nKeyError: 'None is not a known colormap name'\r\n```\n\n### Proposed solution\n\nIt appears from the source that `get_cmap(None)` defaults to  `matplotlib.rcParams['image.cmap']` so it would be nice if `colormaps[None]` could default to that as well.\r\n\r\nOtherwise, it would be nice if this was better documented.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.6.git",
    "requested_commit": "",
    "mayil_response": "To implement the requested feature, you can modify the `_ensure_cmap` function in `lib/matplotlib/cm.py` to handle `None` by returning the default colormap specified in `matplotlib.rcParams['image.cmap']`. Here's how you can do it:\n\n- Modify the `_ensure_cmap` function to check if `cmap` is `None` and, if so, use the default colormap.\n- Use `mpl.colormaps` to access the colormap registry and retrieve the default colormap.\n\nHere's the modified `_ensure_cmap` function:\n\n```python\ndef _ensure_cmap(cmap):\n    \"\"\"\n    Ensure that we have a `.Colormap` object.\n\n    For internal use to preserve type stability of errors.\n\n    Parameters\n    ----------\n    cmap : None, str, Colormap\n\n        - if a `Colormap`, return it\n        - if a string, look it up in mpl.colormaps\n        - if None, look up the default color map in mpl.colormaps\n\n    Returns\n    -------\n    Colormap\n\n    \"\"\"\n    if isinstance(cmap, colors.Colormap):\n        return cmap\n    if cmap is None:\n        cmap = mpl.rcParams[\"image.cmap\"]\n    # use check_in_list to ensure type stability of the exception raised by\n    # the internal usage of this (ValueError vs KeyError)\n    if cmap not in mpl.colormaps:\n        _api.check_in_list(sorted(mpl.colormaps), cmap=cmap)\n    return mpl.colormaps[cmap]\n```\n\nThis change ensures that if `None` is passed to `_ensure_cmap`, it will return the default colormap as specified in `matplotlib.rcParams['image.cmap']`.\n\nAdditionally, you should update the documentation to reflect this behavior:\n\n- Update the docstring of `_ensure_cmap` to include the new behavior when `cmap` is `None`.\n- Consider adding a note in the documentation where `matplotlib.colormaps` is mentioned, indicating that passing `None` will return the default colormap.\n\nRemember to add tests to verify that the new behavior works as expected and does not break existing functionality.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 684 - 740](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/cm.py#L684-L740)\n\n This snippet contains the _ensure_cmap function which is directly related to the handling of the 'None' value for colormaps, and it is where the proposed change should be implemented. \n\n\n   - [Lines 227 - 307](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/cm.py#L227-L307)\n\n This snippet includes the _get_cmap function which is also relevant to the handling of the 'None' value for colormaps and is part of the deprecation path that users are being directed away from. \n\n\n   - [Lines 308 - 382](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/cm.py#L308-L382)\n\n This snippet shows the deprecation of get_cmap, which is the function users are being directed away from, and it suggests the new usage which is causing the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0004085,
        "snippet_processor": 0.05766,
        "issue_star_creation": 0.03822,
        "issue_star_solver": 0.053630000000000004,
        "bouncer": 0.034140000000000004
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711697695.319694,
        "relevant_snippets": [
            {
                "code": "# The docstrings here must be generic enough to apply to all relevant methods.\nmpl._docstring.interpd.update(\n    cmap_doc=\"\"\"\\\ncmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n    The Colormap instance or registered colormap name used to map scalar data\n    to colors.\"\"\",\n    norm_doc=\"\"\"\\\nnorm : str or `~matplotlib.colors.Normalize`, optional\n    The normalization method used to scale scalar data to the [0, 1] range\n    before mapping to colors using *cmap*. By default, a linear scaling is\n    used, mapping the lowest value to 0 and the highest to 1.\n\n    If given, this can be one of the following:\n\n    - An instance of `.Normalize` or one of its subclasses\n      (see :ref:`colormapnorms`).\n    - A scale name, i.e. one of \"linear\", \"log\", \"symlog\", \"logit\", etc.  For a\n      list of available scales, call `matplotlib.scale.get_scale_names()`.\n      In that case, a suitable `.Normalize` subclass is dynamically generated\n      and instantiated.\"\"\",\n    vmin_vmax_doc=\"\"\"\\\nvmin, vmax : float, optional\n    When using scalar data and no explicit *norm*, *vmin* and *vmax* define\n    the data range that the colormap covers. By default, the colormap covers\n    the complete value range of the supplied data. It is an error to use\n    *vmin*/*vmax* when a *norm* instance is given (but using a `str` *norm*\n    name together with *vmin*/*vmax* is acceptable).\"\"\",\n)\n\n\ndef _ensure_cmap(cmap):\n    \"\"\"\n    Ensure that we have a `.Colormap` object.\n\n    For internal use to preserve type stability of errors.\n\n    Parameters\n    ----------\n    cmap : None, str, Colormap\n\n        - if a `Colormap`, return it\n        - if a string, look it up in mpl.colormaps\n        - if None, look up the default color map in mpl.colormaps\n\n    Returns\n    -------\n    Colormap\n\n    \"\"\"\n    if isinstance(cmap, colors.Colormap):\n        return cmap\n    cmap_name = cmap if cmap is not None else mpl.rcParams[\"image.cmap\"]\n    # use check_in_list to ensure type stability of the exception raised by\n    # the internal usage of this (ValueError vs KeyError)\n    if cmap_name not in _colormaps:\n        _api.check_in_list(sorted(_colormaps), cmap=cmap_name)\n    return mpl.colormaps[cmap_name]",
                "filename": "lib/matplotlib/cm.py",
                "start_index": 23823,
                "end_index": 26028,
                "start_line": 684,
                "end_line": 740,
                "max_line": 740,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "# public access to the colormaps should be via `matplotlib.colormaps`. For now,\n# we still create the registry here, but that should stay an implementation\n# detail.\n_colormaps = ColormapRegistry(_gen_cmap_registry())\nglobals().update(_colormaps)\n\n\n@_api.deprecated(\"3.7\", alternative=\"``matplotlib.colormaps.register(name)``\")\ndef register_cmap(name=None, cmap=None, *, override_builtin=False):\n    \"\"\"\n    Add a colormap to the set recognized by :func:`get_cmap`.\n\n    Register a new colormap to be accessed by name ::\n\n        LinearSegmentedColormap('swirly', data, lut)\n        register_cmap(cmap=swirly_cmap)\n\n    Parameters\n    ----------\n    name : str, optional\n       The name that can be used in :func:`get_cmap` or :rc:`image.cmap`\n\n       If absent, the name will be the :attr:`~matplotlib.colors.Colormap.name`\n       attribute of the *cmap*.\n\n    cmap : matplotlib.colors.Colormap\n       Despite being the second argument and having a default value, this\n       is a required argument.\n\n    override_builtin : bool\n\n        Allow built-in colormaps to be overridden by a user-supplied\n        colormap.\n\n        Please do not use this unless you are sure you need it.\n    \"\"\"\n    _api.check_isinstance((str, None), name=name)\n    if name is None:\n        try:\n            name = cmap.name\n        except AttributeError as err:\n            raise ValueError(\"Arguments must include a name or a \"\n                             \"Colormap\") from err\n    # override_builtin is allowed here for backward compatibility\n    # this is just a shim to enable that to work privately in\n    # the global ColormapRegistry\n    _colormaps._allow_override_builtin = override_builtin\n    _colormaps.register(cmap, name=name, force=override_builtin)\n    _colormaps._allow_override_builtin = False\n\n\ndef _get_cmap(name=None, lut=None):\n    \"\"\"\n    Get a colormap instance, defaulting to rc values if *name* is None.\n\n    Parameters\n    ----------\n    name : `~matplotlib.colors.Colormap` or str or None, default: None\n        If a `.Colormap` instance, it will be returned. Otherwise, the name of\n        a colormap known to Matplotlib, which will be resampled by *lut*. The\n        default, None, means :rc:`image.cmap`.\n    lut : int or None, default: None\n        If *name* is not already a Colormap instance and *lut* is not None, the\n        colormap will be resampled to have *lut* entries in the lookup table.\n\n    Returns\n    -------\n    Colormap\n    \"\"\"\n    if name is None:\n        name = mpl.rcParams['image.cmap']\n    if isinstance(name, colors.Colormap):\n        return name\n    _api.check_in_list(sorted(_colormaps), name=name)\n    if lut is None:\n        return _colormaps[name]\n    else:\n        return _colormaps[name].resampled(lut)\n\n# do it in two steps like this so we can have an un-deprecated version in\n# pyplot.",
                "filename": "lib/matplotlib/cm.py",
                "start_index": 7622,
                "end_index": 10450,
                "start_line": 227,
                "end_line": 307,
                "max_line": 740,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def _get_pyplot_commands() -> list[str]:\n    # This works by searching for all functions in this module and removing\n    # a few hard-coded exclusions, as well as all of the colormap-setting\n    # functions, and anything marked as private with a preceding underscore.\n    exclude = {'colormaps', 'colors', 'get_plot_commands', *colormaps}\n    this_module = inspect.getmodule(get_plot_commands)\n    return sorted(\n        name for name, obj in globals().items()\n        if not name.startswith('_') and name not in exclude\n           and inspect.isfunction(obj)\n           and inspect.getmodule(obj) is this_module)\n\n\n## Plotting part 1: manually generated functions and wrappers ##\n\n\n@_copy_docstring_and_deprecators(Figure.colorbar)\ndef colorbar(\n    mappable: ScalarMappable | None = None,\n    cax: matplotlib.axes.Axes | None = None,\n    ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | None = None,\n    **kwargs\n) -> Colorbar:\n    if mappable is None:\n        mappable = gci()\n        if mappable is None:\n            raise RuntimeError('No mappable was found to use for colorbar '\n                               'creation. First define a mappable such as '\n                               'an image (with imshow) or a contour set ('\n                               'with contourf).')\n    ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)\n    return ret\n\n\ndef clim(vmin: float | None = None, vmax: float | None = None) -> None:\n    \"\"\"\n    Set the color limits of the current image.\n\n    If either *vmin* or *vmax* is None, the image min/max respectively\n    will be used for color scaling.\n\n    If you want to set the clim of multiple images, use\n    `~.ScalarMappable.set_clim` on every image, for example::\n\n      for im in gca().get_images():\n          im.set_clim(0, 0.5)\n\n    \"\"\"\n    im = gci()\n    if im is None:\n        raise RuntimeError('You must first define an image, e.g., with imshow')\n\n    im.set_clim(vmin, vmax)\n\n\n# eventually this implementation should move here, use indirection for now to\n# avoid having two copies of the code floating around.\ndef get_cmap(\n    name: Colormap | str | None = None,\n    lut: int | None = None\n) -> Colormap:\n    return cm._get_cmap(name=name, lut=lut)  # type: ignore\nget_cmap.__doc__ = cm._get_cmap.__doc__  # type: ignore\n\n\ndef set_cmap(cmap: Colormap | str) -> None:\n    \"\"\"\n    Set the default colormap, and applies it to the current image if any.\n\n    Parameters\n    ----------\n    cmap : `~matplotlib.colors.Colormap` or str\n        A colormap instance or the name of a registered colormap.\n\n    See Also\n    --------\n    colormaps\n    matplotlib.cm.register_cmap\n    matplotlib.cm.get_cmap\n    \"\"\"\n    cmap = get_cmap(cmap)\n\n    rc('image', cmap=cmap.name)\n    im = gci()\n\n    if im is not None:\n        im.set_cmap(cmap)",
                "filename": "lib/matplotlib/pyplot.py",
                "start_index": 76986,
                "end_index": 79785,
                "start_line": 2240,
                "end_line": 2326,
                "max_line": 4320,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def plot_color_gradients(cmap_category, cmap_list):\n    fig, axs = plt.subplots(nrows=len(cmap_list), ncols=2)\n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99,\n                        wspace=0.05)\n    fig.suptitle(cmap_category + ' colormaps', fontsize=14, y=1.0, x=0.6)\n\n    for ax, name in zip(axs, cmap_list):\n\n        # Get RGB values for colormap.\n        rgb = mpl.colormaps[name](x)[np.newaxis, :, :3]\n\n        # Get colormap in CAM02-UCS colorspace. We want the lightness.\n        lab = cspace_converter(\"sRGB1\", \"CAM02-UCS\")(rgb)\n        L = lab[0, :, 0]\n        L = np.float32(np.vstack((L, L, L)))\n\n        ax[0].imshow(gradient, aspect='auto', cmap=mpl.colormaps[name])\n        ax[1].imshow(L, aspect='auto', cmap='binary_r', vmin=0., vmax=100.)\n        pos = list(ax[0].get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3]/2.\n        fig.text(x_text, y_text, name, va='center', ha='right', fontsize=10)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs.flat:\n        ax.set_axis_off()\n\n    plt.show()\n\n\nfor cmap_category, cmap_list in cmaps.items():\n\n    plot_color_gradients(cmap_category, cmap_list)\n\n# %%\n# Color vision deficiencies\n# =========================\n#\n# There is a lot of information available about color blindness (*e.g.*,\n# [colorblindness]_). Additionally, there are tools available to convert images\n# to how they look for different types of color vision deficiencies.\n#\n# The most common form of color vision deficiency involves differentiating\n# between red and green. Thus, avoiding colormaps with both red and green will\n# avoid many problems in general.\n#\n#\n# References\n# ==========\n#\n# .. _Third-party colormaps: https://matplotlib.org/mpl-third-party/#colormaps-and-styles\n# .. [Ware] http://ccom.unh.edu/sites/default/files/publications/Ware_1988_CGA_Color_sequences_univariate_maps.pdf\n# .. [Moreland] http://www.kennethmoreland.com/color-maps/ColorMapsExpanded.pdf\n# .. [list-colormaps] https://gist.github.com/endolith/2719900#id7\n# .. [mycarta-banding] https://mycarta.wordpress.com/2012/10/14/the-rainbow-is-deadlong-live-the-rainbow-part-4-cie-lab-heated-body/\n# .. [mycarta-jet] https://mycarta.wordpress.com/2012/10/06/the-rainbow-is-deadlong-live-the-rainbow-part-3/\n# .. [kovesi-colormaps] https://arxiv.org/abs/1509.03700\n# .. [bw] https://tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n# .. [colorblindness] http://www.color-blindness.com/\n# .. [IBM] https://doi.org/10.1109/VISUAL.1995.480803\n# .. [turbo] https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html",
                "filename": "galleries/users_explain/colors/colormaps.py",
                "start_index": 15484,
                "end_index": 18119,
                "start_line": 378,
                "end_line": 438,
                "max_line": 438,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n.. redirect-from:: /tutorials/colors/colormaps\n\n.. _colormaps:\n\n********************************\nChoosing Colormaps in Matplotlib\n********************************\n\nMatplotlib has a number of built-in colormaps accessible via\n`.matplotlib.colormaps`.  There are also external libraries that\nhave many extra colormaps, which can be viewed in the\n`Third-party colormaps`_ section of the Matplotlib documentation.\nHere we briefly discuss how to choose between the many options.  For\nhelp on creating your own colormaps, see\n:ref:`colormap-manipulation`.\n\nOverview\n========\n\nThe idea behind choosing a good colormap is to find a good representation in 3D\ncolorspace for your data set. The best colormap for any given data set depends\non many things including:\n\n- Whether representing form or metric data ([Ware]_)\n\n- Your knowledge of the data set (*e.g.*, is there a critical value\n  from which the other values deviate?)\n\n- If there is an intuitive color scheme for the parameter you are plotting\n\n- If there is a standard in the field the audience may be expecting\n\nFor many applications, a perceptually uniform colormap is the best choice;\ni.e. a colormap in which equal steps in data are perceived as equal\nsteps in the color space. Researchers have found that the human brain\nperceives changes in the lightness parameter as changes in the data\nmuch better than, for example, changes in hue. Therefore, colormaps\nwhich have monotonically increasing lightness through the colormap\nwill be better interpreted by the viewer. Wonderful examples of\nperceptually uniform colormaps can be found in the\n`Third-party colormaps`_ section as well.\n\nColor can be represented in 3D space in various ways. One way to represent color\nis using CIELAB. In CIELAB, color space is represented by lightness,\n:math:`L^*`; red-green, :math:`a^*`; and yellow-blue, :math:`b^*`. The lightness\nparameter :math:`L^*` can then be used to learn more about how the matplotlib\ncolormaps will be perceived by viewers.\n\nAn excellent starting resource for learning about human perception of colormaps\nis from [IBM]_.\n\n\n.. _color-colormaps_reference:\n\nClasses of colormaps\n====================\n\nColormaps are often split into several categories based on their function (see,\n*e.g.*, [Moreland]_):\n\n1. Sequential: change in lightness and often saturation of color\n   incrementally, often using a single hue; should be used for\n   representing information that has ordering.\n\n2. Diverging: change in lightness and possibly saturation of two\n   different colors that meet in the middle at an unsaturated color;\n   should be used when the information being plotted has a critical\n   middle value, such as topography or when the data deviates around\n   zero.\n\n3. Cyclic: change in lightness of two different colors that meet in\n   the middle and beginning/end at an unsaturated color; should be\n   used for values that wrap around at the endpoints, such as phase\n   angle, wind direction, or time of day.\n\n4. Qualitative: often are miscellaneous colors; should be used to\n   represent information which does not have ordering or\n   relationships.\n\"\"\"",
                "filename": "galleries/users_explain/colors/colormaps.py",
                "start_index": 0,
                "end_index": 3115,
                "start_line": 1,
                "end_line": 80,
                "max_line": 438,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "get_cmap = _api.deprecated(\n    '3.7',\n    name='get_cmap',\n    alternative=(\n        \"``matplotlib.colormaps[name]`` \" +\n        \"or ``matplotlib.colormaps.get_cmap(obj)``\"\n    )\n)(_get_cmap)\n\n\n@_api.deprecated(\"3.7\",\n                 alternative=\"``matplotlib.colormaps.unregister(name)``\")\ndef unregister_cmap(name):\n    \"\"\"\n    Remove a colormap recognized by :func:`get_cmap`.\n\n    You may not remove built-in colormaps.\n\n    If the named colormap is not registered, returns with no error, raises\n    if you try to de-register a default colormap.\n\n    .. warning::\n\n      Colormap names are currently a shared namespace that may be used\n      by multiple packages. Use `unregister_cmap` only if you know you\n      have registered that name before. In particular, do not\n      unregister just in case to clean the name before registering a\n      new colormap.\n\n    Parameters\n    ----------\n    name : str\n        The name of the colormap to be un-registered\n\n    Returns\n    -------\n    ColorMap or None\n        If the colormap was registered, return it if not return `None`\n\n    Raises\n    ------\n    ValueError\n       If you try to de-register a default built-in colormap.\n    \"\"\"\n    cmap = _colormaps.get(name, None)\n    _colormaps.unregister(name)\n    return cmap\n\n\ndef _auto_norm_from_scale(scale_cls):\n    \"\"\"\n    Automatically generate a norm class from *scale_cls*.\n\n    This differs from `.colors.make_norm_from_scale` in the following points:\n\n    - This function is not a class decorator, but directly returns a norm class\n      (as if decorating `.Normalize`).\n    - The scale is automatically constructed with ``nonpositive=\"mask\"``, if it\n      supports such a parameter, to work around the difference in defaults\n      between standard scales (which use \"clip\") and norms (which use \"mask\").\n\n    Note that ``make_norm_from_scale`` caches the generated norm classes\n    (not the instances) and reuses them for later calls.  For example,\n    ``type(_auto_norm_from_scale(\"log\")) == LogNorm``.\n    \"\"\"\n    # Actually try to construct an instance, to verify whether\n    # ``nonpositive=\"mask\"`` is supported.\n    try:\n        norm = colors.make_norm_from_scale(\n            functools.partial(scale_cls, nonpositive=\"mask\"))(\n            colors.Normalize)()\n    except TypeError:\n        norm = colors.make_norm_from_scale(scale_cls)(\n            colors.Normalize)()\n    return type(norm)",
                "filename": "lib/matplotlib/cm.py",
                "start_index": 10451,
                "end_index": 12856,
                "start_line": 308,
                "end_line": 382,
                "max_line": 740,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "cmaps = {\n    name: ListedColormap(data, name=name) for name, data in [\n        ('magma', _magma_data),\n        ('inferno', _inferno_data),\n        ('plasma', _plasma_data),\n        ('viridis', _viridis_data),\n        ('cividis', _cividis_data),\n        ('twilight', _twilight_data),\n        ('twilight_shifted', _twilight_shifted_data),\n        ('turbo', _turbo_data),\n    ]}",
                "filename": "lib/matplotlib/_cm_listed.py",
                "start_index": 109085,
                "end_index": 109461,
                "start_line": 2061,
                "end_line": 2071,
                "max_line": 2071,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n==================\nColormap reference\n==================\n\nReference for colormaps included with Matplotlib.\n\nA reversed version of each of these colormaps is available by appending\n``_r`` to the name, as shown in :ref:`reverse-cmap`.\n\nSee :ref:`colormaps` for an in-depth discussion about\ncolormaps, including colorblind-friendliness, and\n:ref:`colormap-manipulation` for a guide to creating\ncolormaps.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncmaps = [('Perceptually Uniform Sequential', [\n            'viridis', 'plasma', 'inferno', 'magma', 'cividis']),\n         ('Sequential', [\n            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',\n            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',\n            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']),\n         ('Sequential (2)', [\n            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',\n            'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',\n            'hot', 'afmhot', 'gist_heat', 'copper']),\n         ('Diverging', [\n            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',\n            'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic']),\n         ('Cyclic', ['twilight', 'twilight_shifted', 'hsv']),\n         ('Qualitative', [\n            'Pastel1', 'Pastel2', 'Paired', 'Accent',\n            'Dark2', 'Set1', 'Set2', 'Set3',\n            'tab10', 'tab20', 'tab20b', 'tab20c']),\n         ('Miscellaneous', [\n            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',\n            'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg',\n            'gist_rainbow', 'rainbow', 'jet', 'turbo', 'nipy_spectral',\n            'gist_ncar'])]\n\ngradient = np.linspace(0, 1, 256)\ngradient = np.vstack((gradient, gradient))\n\n\ndef plot_color_gradients(cmap_category, cmap_list):\n    # Create figure and adjust figure height to number of colormaps\n    nrows = len(cmap_list)\n    figh = 0.35 + 0.15 + (nrows + (nrows-1)*0.1)*0.22\n    fig, axs = plt.subplots(nrows=nrows, figsize=(6.4, figh))\n    fig.subplots_adjust(top=1-.35/figh, bottom=.15/figh, left=0.2, right=0.99)\n\n    axs[0].set_title(f\"{cmap_category} colormaps\", fontsize=14)\n\n    for ax, cmap_name in zip(axs, cmap_list):\n        ax.imshow(gradient, aspect='auto', cmap=cmap_name)\n        ax.text(-.01, .5, cmap_name, va='center', ha='right', fontsize=10,\n                transform=ax.transAxes)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs:\n        ax.set_axis_off()\n\n\nfor cmap_category, cmap_list in cmaps:\n    plot_color_gradients(cmap_category, cmap_list)\n\n\n# %%\n# .. _reverse-cmap:\n#\n# Reversed colormaps\n# ------------------\n#\n# Append ``_r`` to the name of any built-in colormap to get the reversed\n# version:\n\nplot_color_gradients(\"Original and reversed \", ['viridis', 'viridis_r'])\n\n# %%\n# The built-in reversed colormaps are generated using `.Colormap.reversed`.\n# For an example, see :ref:`reversing-colormap`\n\n# %%\n#",
                "filename": "galleries/examples/color/colormap_reference.py",
                "start_index": 0,
                "end_index": 2985,
                "start_line": 1,
                "end_line": 96,
                "max_line": 96,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def magma() -> None:\n    \"\"\"\n    Set the colormap to 'magma'.\n\n    This changes the default colormap as well as the colormap of the current\n    image if there is one. See ``help(colormaps)`` for more information.\n    \"\"\"\n    set_cmap(\"magma\")\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\ndef inferno() -> None:\n    \"\"\"\n    Set the colormap to 'inferno'.\n\n    This changes the default colormap as well as the colormap of the current\n    image if there is one. See ``help(colormaps)`` for more information.\n    \"\"\"\n    set_cmap(\"inferno\")\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\ndef plasma() -> None:\n    \"\"\"\n    Set the colormap to 'plasma'.\n\n    This changes the default colormap as well as the colormap of the current\n    image if there is one. See ``help(colormaps)`` for more information.\n    \"\"\"\n    set_cmap(\"plasma\")\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\ndef viridis() -> None:\n    \"\"\"\n    Set the colormap to 'viridis'.\n\n    This changes the default colormap as well as the colormap of the current\n    image if there is one. See ``help(colormaps)`` for more information.\n    \"\"\"\n    set_cmap(\"viridis\")\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\ndef nipy_spectral() -> None:\n    \"\"\"\n    Set the colormap to 'nipy_spectral'.\n\n    This changes the default colormap as well as the colormap of the current\n    image if there is one. See ``help(colormaps)`` for more information.\n    \"\"\"\n    set_cmap(\"nipy_spectral\")",
                "filename": "lib/matplotlib/pyplot.py",
                "start_index": 135358,
                "end_index": 136911,
                "start_line": 4269,
                "end_line": 4320,
                "max_line": 4320,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "# sphinx_gallery_thumbnail_number = 2\n\nfrom colorspacious import cspace_converter\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\n# %%\n#\n# First, we'll show the range of each colormap. Note that some seem\n# to change more \"quickly\" than others.\n\ncmaps = {}\n\ngradient = np.linspace(0, 1, 256)\ngradient = np.vstack((gradient, gradient))\n\n\ndef plot_color_gradients(category, cmap_list):\n    # Create figure and adjust figure height to number of colormaps\n    nrows = len(cmap_list)\n    figh = 0.35 + 0.15 + (nrows + (nrows - 1) * 0.1) * 0.22\n    fig, axs = plt.subplots(nrows=nrows + 1, figsize=(6.4, figh))\n    fig.subplots_adjust(top=1 - 0.35 / figh, bottom=0.15 / figh,\n                        left=0.2, right=0.99)\n    axs[0].set_title(f'{category} colormaps', fontsize=14)\n\n    for ax, name in zip(axs, cmap_list):\n        ax.imshow(gradient, aspect='auto', cmap=mpl.colormaps[name])\n        ax.text(-0.01, 0.5, name, va='center', ha='right', fontsize=10,\n                transform=ax.transAxes)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs:\n        ax.set_axis_off()\n\n    # Save colormap list for later.\n    cmaps[category] = cmap_list\n\n\n# %%\n# Sequential\n# ----------\n#\n# For the Sequential plots, the lightness value increases monotonically through\n# the colormaps. This is good. Some of the :math:`L^*` values in the colormaps\n# span from 0 to 100 (binary and the other grayscale), and others start around\n# :math:`L^*=20`. Those that have a smaller range of :math:`L^*` will accordingly\n# have a smaller perceptual range. Note also that the :math:`L^*` function varies\n# amongst the colormaps: some are approximately linear in :math:`L^*` and others\n# are more curved.\n\nplot_color_gradients('Perceptually Uniform Sequential',\n                     ['viridis', 'plasma', 'inferno', 'magma', 'cividis'])\n\n# %%\n\nplot_color_gradients('Sequential',\n                     ['Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',\n                      'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',\n                      'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn'])\n\n# %%\n# Sequential2\n# -----------\n#\n# Many of the :math:`L^*` values from the Sequential2 plots are monotonically\n# increasing, but some (autumn, cool, spring, and winter) plateau or even go both\n# up and down in :math:`L^*` space. Others (afmhot, copper, gist_heat, and hot)\n# have kinks in the :math:`L^*` functions. Data that is being represented in a\n# region of the colormap that is at a plateau or kink will lead to a perception of\n# banding of the data in those values in the colormap (see [mycarta-banding]_ for\n# an excellent example of this).\n\nplot_color_gradients('Sequential (2)',\n                     ['binary', 'gist_yarg', 'gist_gray', 'gray', 'bone',\n                      'pink', 'spring', 'summer', 'autumn', 'winter', 'cool',\n                      'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper'])\n\n# %%\n# Diverging",
                "filename": "galleries/users_explain/colors/colormaps.py",
                "start_index": 3117,
                "end_index": 6107,
                "start_line": 82,
                "end_line": 164,
                "max_line": 438,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "lib/matplotlib/cm.py": [
                {
                    "chunk": {
                        "code": "# The docstrings here must be generic enough to apply to all relevant methods.\nmpl._docstring.interpd.update(\n    cmap_doc=\"\"\"\\\ncmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n    The Colormap instance or registered colormap name used to map scalar data\n    to colors.\"\"\",\n    norm_doc=\"\"\"\\\nnorm : str or `~matplotlib.colors.Normalize`, optional\n    The normalization method used to scale scalar data to the [0, 1] range\n    before mapping to colors using *cmap*. By default, a linear scaling is\n    used, mapping the lowest value to 0 and the highest to 1.\n\n    If given, this can be one of the following:\n\n    - An instance of `.Normalize` or one of its subclasses\n      (see :ref:`colormapnorms`).\n    - A scale name, i.e. one of \"linear\", \"log\", \"symlog\", \"logit\", etc.  For a\n      list of available scales, call `matplotlib.scale.get_scale_names()`.\n      In that case, a suitable `.Normalize` subclass is dynamically generated\n      and instantiated.\"\"\",\n    vmin_vmax_doc=\"\"\"\\\nvmin, vmax : float, optional\n    When using scalar data and no explicit *norm*, *vmin* and *vmax* define\n    the data range that the colormap covers. By default, the colormap covers\n    the complete value range of the supplied data. It is an error to use\n    *vmin*/*vmax* when a *norm* instance is given (but using a `str` *norm*\n    name together with *vmin*/*vmax* is acceptable).\"\"\",\n)\n\n\ndef _ensure_cmap(cmap):\n    \"\"\"\n    Ensure that we have a `.Colormap` object.\n\n    For internal use to preserve type stability of errors.\n\n    Parameters\n    ----------\n    cmap : None, str, Colormap\n\n        - if a `Colormap`, return it\n        - if a string, look it up in mpl.colormaps\n        - if None, look up the default color map in mpl.colormaps\n\n    Returns\n    -------\n    Colormap\n\n    \"\"\"\n    if isinstance(cmap, colors.Colormap):\n        return cmap\n    cmap_name = cmap if cmap is not None else mpl.rcParams[\"image.cmap\"]\n    # use check_in_list to ensure type stability of the exception raised by\n    # the internal usage of this (ValueError vs KeyError)\n    if cmap_name not in _colormaps:\n        _api.check_in_list(sorted(_colormaps), cmap=cmap_name)\n    return mpl.colormaps[cmap_name]",
                        "filename": "lib/matplotlib/cm.py",
                        "start_index": 23823,
                        "end_index": 26028,
                        "start_line": 684,
                        "end_line": 740,
                        "max_line": 740,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the _ensure_cmap function which is directly related to the handling of the 'None' value for colormaps, and it is where the proposed change should be implemented."
                },
                {
                    "chunk": {
                        "code": "# public access to the colormaps should be via `matplotlib.colormaps`. For now,\n# we still create the registry here, but that should stay an implementation\n# detail.\n_colormaps = ColormapRegistry(_gen_cmap_registry())\nglobals().update(_colormaps)\n\n\n@_api.deprecated(\"3.7\", alternative=\"``matplotlib.colormaps.register(name)``\")\ndef register_cmap(name=None, cmap=None, *, override_builtin=False):\n    \"\"\"\n    Add a colormap to the set recognized by :func:`get_cmap`.\n\n    Register a new colormap to be accessed by name ::\n\n        LinearSegmentedColormap('swirly', data, lut)\n        register_cmap(cmap=swirly_cmap)\n\n    Parameters\n    ----------\n    name : str, optional\n       The name that can be used in :func:`get_cmap` or :rc:`image.cmap`\n\n       If absent, the name will be the :attr:`~matplotlib.colors.Colormap.name`\n       attribute of the *cmap*.\n\n    cmap : matplotlib.colors.Colormap\n       Despite being the second argument and having a default value, this\n       is a required argument.\n\n    override_builtin : bool\n\n        Allow built-in colormaps to be overridden by a user-supplied\n        colormap.\n\n        Please do not use this unless you are sure you need it.\n    \"\"\"\n    _api.check_isinstance((str, None), name=name)\n    if name is None:\n        try:\n            name = cmap.name\n        except AttributeError as err:\n            raise ValueError(\"Arguments must include a name or a \"\n                             \"Colormap\") from err\n    # override_builtin is allowed here for backward compatibility\n    # this is just a shim to enable that to work privately in\n    # the global ColormapRegistry\n    _colormaps._allow_override_builtin = override_builtin\n    _colormaps.register(cmap, name=name, force=override_builtin)\n    _colormaps._allow_override_builtin = False\n\n\ndef _get_cmap(name=None, lut=None):\n    \"\"\"\n    Get a colormap instance, defaulting to rc values if *name* is None.\n\n    Parameters\n    ----------\n    name : `~matplotlib.colors.Colormap` or str or None, default: None\n        If a `.Colormap` instance, it will be returned. Otherwise, the name of\n        a colormap known to Matplotlib, which will be resampled by *lut*. The\n        default, None, means :rc:`image.cmap`.\n    lut : int or None, default: None\n        If *name* is not already a Colormap instance and *lut* is not None, the\n        colormap will be resampled to have *lut* entries in the lookup table.\n\n    Returns\n    -------\n    Colormap\n    \"\"\"\n    if name is None:\n        name = mpl.rcParams['image.cmap']\n    if isinstance(name, colors.Colormap):\n        return name\n    _api.check_in_list(sorted(_colormaps), name=name)\n    if lut is None:\n        return _colormaps[name]\n    else:\n        return _colormaps[name].resampled(lut)\n\n# do it in two steps like this so we can have an un-deprecated version in\n# pyplot.",
                        "filename": "lib/matplotlib/cm.py",
                        "start_index": 7622,
                        "end_index": 10450,
                        "start_line": 227,
                        "end_line": 307,
                        "max_line": 740,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the _get_cmap function which is also relevant to the handling of the 'None' value for colormaps and is part of the deprecation path that users are being directed away from."
                },
                {
                    "chunk": {
                        "code": "get_cmap = _api.deprecated(\n    '3.7',\n    name='get_cmap',\n    alternative=(\n        \"``matplotlib.colormaps[name]`` \" +\n        \"or ``matplotlib.colormaps.get_cmap(obj)``\"\n    )\n)(_get_cmap)\n\n\n@_api.deprecated(\"3.7\",\n                 alternative=\"``matplotlib.colormaps.unregister(name)``\")\ndef unregister_cmap(name):\n    \"\"\"\n    Remove a colormap recognized by :func:`get_cmap`.\n\n    You may not remove built-in colormaps.\n\n    If the named colormap is not registered, returns with no error, raises\n    if you try to de-register a default colormap.\n\n    .. warning::\n\n      Colormap names are currently a shared namespace that may be used\n      by multiple packages. Use `unregister_cmap` only if you know you\n      have registered that name before. In particular, do not\n      unregister just in case to clean the name before registering a\n      new colormap.\n\n    Parameters\n    ----------\n    name : str\n        The name of the colormap to be un-registered\n\n    Returns\n    -------\n    ColorMap or None\n        If the colormap was registered, return it if not return `None`\n\n    Raises\n    ------\n    ValueError\n       If you try to de-register a default built-in colormap.\n    \"\"\"\n    cmap = _colormaps.get(name, None)\n    _colormaps.unregister(name)\n    return cmap\n\n\ndef _auto_norm_from_scale(scale_cls):\n    \"\"\"\n    Automatically generate a norm class from *scale_cls*.\n\n    This differs from `.colors.make_norm_from_scale` in the following points:\n\n    - This function is not a class decorator, but directly returns a norm class\n      (as if decorating `.Normalize`).\n    - The scale is automatically constructed with ``nonpositive=\"mask\"``, if it\n      supports such a parameter, to work around the difference in defaults\n      between standard scales (which use \"clip\") and norms (which use \"mask\").\n\n    Note that ``make_norm_from_scale`` caches the generated norm classes\n    (not the instances) and reuses them for later calls.  For example,\n    ``type(_auto_norm_from_scale(\"log\")) == LogNorm``.\n    \"\"\"\n    # Actually try to construct an instance, to verify whether\n    # ``nonpositive=\"mask\"`` is supported.\n    try:\n        norm = colors.make_norm_from_scale(\n            functools.partial(scale_cls, nonpositive=\"mask\"))(\n            colors.Normalize)()\n    except TypeError:\n        norm = colors.make_norm_from_scale(scale_cls)(\n            colors.Normalize)()\n    return type(norm)",
                        "filename": "lib/matplotlib/cm.py",
                        "start_index": 10451,
                        "end_index": 12856,
                        "start_line": 308,
                        "end_line": 382,
                        "max_line": 740,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the deprecation of get_cmap, which is the function users are being directed away from, and it suggests the new usage which is causing the issue."
                }
            ]
        },
        "solution_task": "To implement the requested feature, you can modify the `_ensure_cmap` function in `lib/matplotlib/cm.py` to handle `None` by returning the default colormap specified in `matplotlib.rcParams['image.cmap']`. Here's how you can do it:\n\n- Modify the `_ensure_cmap` function to check if `cmap` is `None` and, if so, use the default colormap.\n- Use `mpl.colormaps` to access the colormap registry and retrieve the default colormap.\n\nHere's the modified `_ensure_cmap` function:\n\n```python\ndef _ensure_cmap(cmap):\n    \"\"\"\n    Ensure that we have a `.Colormap` object.\n\n    For internal use to preserve type stability of errors.\n\n    Parameters\n    ----------\n    cmap : None, str, Colormap\n\n        - if a `Colormap`, return it\n        - if a string, look it up in mpl.colormaps\n        - if None, look up the default color map in mpl.colormaps\n\n    Returns\n    -------\n    Colormap\n\n    \"\"\"\n    if isinstance(cmap, colors.Colormap):\n        return cmap\n    if cmap is None:\n        cmap = mpl.rcParams[\"image.cmap\"]\n    # use check_in_list to ensure type stability of the exception raised by\n    # the internal usage of this (ValueError vs KeyError)\n    if cmap not in mpl.colormaps:\n        _api.check_in_list(sorted(mpl.colormaps), cmap=cmap)\n    return mpl.colormaps[cmap]\n```\n\nThis change ensures that if `None` is passed to `_ensure_cmap`, it will return the default colormap as specified in `matplotlib.rcParams['image.cmap']`.\n\nAdditionally, you should update the documentation to reflect this behavior:\n\n- Update the docstring of `_ensure_cmap` to include the new behavior when `cmap` is `None`.\n- Consider adding a note in the documentation where `matplotlib.colormaps` is mentioned, indicating that passing `None` will return the default colormap.\n\nRemember to add tests to verify that the new behavior works as expected and does not break existing functionality.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the feature request by suggesting modifications to the `_ensure_cmap` function to handle `None` by returning the default colormap. It includes a code snippet with the proposed changes, which is directly relevant and actionable. The RESPONSE also addresses the need for updating the documentation to reflect the new behavior and suggests adding tests to ensure the new functionality works correctly. The RESPONSE is comprehensive and addresses all aspects of the feature request, including the technical implementation and documentation updates. The only reason it does not score a 10 is that it does not explicitly mention the need to handle potential backward compatibility issues or other edge cases that might arise from the change, which would be the final step in ensuring a successful implementation.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711697754.706418,
        "result": "To implement the requested feature, you can modify the `_ensure_cmap` function in `lib/matplotlib/cm.py` to handle `None` by returning the default colormap specified in `matplotlib.rcParams['image.cmap']`. Here's how you can do it:\n\n- Modify the `_ensure_cmap` function to check if `cmap` is `None` and, if so, use the default colormap.\n- Use `mpl.colormaps` to access the colormap registry and retrieve the default colormap.\n\nHere's the modified `_ensure_cmap` function:\n\n```python\ndef _ensure_cmap(cmap):\n    \"\"\"\n    Ensure that we have a `.Colormap` object.\n\n    For internal use to preserve type stability of errors.\n\n    Parameters\n    ----------\n    cmap : None, str, Colormap\n\n        - if a `Colormap`, return it\n        - if a string, look it up in mpl.colormaps\n        - if None, look up the default color map in mpl.colormaps\n\n    Returns\n    -------\n    Colormap\n\n    \"\"\"\n    if isinstance(cmap, colors.Colormap):\n        return cmap\n    if cmap is None:\n        cmap = mpl.rcParams[\"image.cmap\"]\n    # use check_in_list to ensure type stability of the exception raised by\n    # the internal usage of this (ValueError vs KeyError)\n    if cmap not in mpl.colormaps:\n        _api.check_in_list(sorted(mpl.colormaps), cmap=cmap)\n    return mpl.colormaps[cmap]\n```\n\nThis change ensures that if `None` is passed to `_ensure_cmap`, it will return the default colormap as specified in `matplotlib.rcParams['image.cmap']`.\n\nAdditionally, you should update the documentation to reflect this behavior:\n\n- Update the docstring of `_ensure_cmap` to include the new behavior when `cmap` is `None`.\n- Consider adding a note in the documentation where `matplotlib.colormaps` is mentioned, indicating that passing `None` will return the default colormap.\n\nRemember to add tests to verify that the new behavior works as expected and does not break existing functionality.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 684 - 740](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/cm.py#L684-L740)\n\n This snippet contains the _ensure_cmap function which is directly related to the handling of the 'None' value for colormaps, and it is where the proposed change should be implemented. \n\n\n   - [Lines 227 - 307](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/cm.py#L227-L307)\n\n This snippet includes the _get_cmap function which is also relevant to the handling of the 'None' value for colormaps and is part of the deprecation path that users are being directed away from. \n\n\n   - [Lines 308 - 382](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/cm.py#L308-L382)\n\n This snippet shows the deprecation of get_cmap, which is the function users are being directed away from, and it suggests the new usage which is causing the issue."
    }
}