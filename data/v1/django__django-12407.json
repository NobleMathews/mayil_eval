{
    "id": "django__django-12407",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 3465701701840360285,
    "title": "{% include %} uses get_template where it could select_template",
    "body": "Description\n\t\nIt'd be nice if the Include template tag was sensible enough to allow fallbacks by selecting the most appropriate template, as things like render/render_to_response/render_to_string do. It's tripped me up on more than one occasion, and it seems a trivial feature to support, from my limited testing.\n>>> from django.template import Template, Context\n>>> tmpl = Template('{% include var %}')\n>>> ctx = Context({'var':'admin/base.html'})\n>>> ctx\n[{'var': 'admin/base.html'}]\n>>> tmpl.render(ctx)\n... some HTML output ...\n>>> ctx.update({'var':['admin/base.html', 'admin/fail.html']})\n{'var': ['admin/base.html', 'admin/fail.html']}\n>>> tmpl.render(ctx)\nTraceback (most recent call last):\n File \"<console>\", line 1, in <module>\n File \"/path/django/template/base.py\", line 140, in render\n\treturn self._render(context)\n File \"/path/django/template/base.py\", line 134, in _render\n\treturn self.nodelist.render(context)\n File \"/path/django/template/base.py\", line 823, in render\n\tbit = self.render_node(node, context)\n File \"/path/django/template/debug.py\", line 74, in render_node\n\treturn node.render(context)\n File \"/path/django/template/loader_tags.py\", line 165, in render\n\ttemplate = get_template(template_name)\n File \"/path/django/template/loader.py\", line 145, in get_template\n\ttemplate, origin = find_template(template_name)\n File \"/path/django/template/loader.py\", line 138, in find_template\n\traise TemplateDoesNotExist(name)\nTemplateDoesNotExist: ['admin/base.html', 'admin/fail.html']\nThe 'fix' is to change \u200bthis line from get_template to select_template, though this might now be slightly complicated by the recent changes in 5cdacbda034af928f5033c9afc7b50ee0b13f75c to allow for rendering of Template instances.\nChanging to select_template on 1.4 yields the results I'd expect:\n>>> from django.template import Template, Context \n>>> tmpl = Template('{% include var %}')\n>>> ctx = Context({'var':['admin/base.html', 'admin/fail.html']})\n>>> tmpl.render(ctx)\n... some HTML output ...\nBoth the above shell sessions assume django.contrib.admin is in INSTALLED_APPS.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "- Update the `IncludeNode` class in `django/template/loader_tags.py` to use `select_template` instead of `get_template` when handling a list of templates.\n- Add exception handling for `TemplateDoesNotExist` within the `IncludeNode` class to provide a fallback mechanism.\n- Ensure that the `render` method of `IncludeNode` correctly processes the list of templates and returns the rendered content of the first template that exists.\n\n```python\n# django/template/loader_tags.py\n\n@register.tag(\"include\")\ndef do_include(parser, token):\n    # ... (existing code) ...\n\n    return IncludeNode(\n        parser.compile_filter(bits[1]),\n        extra_context=namemap,\n        isolated_context=isolated_context,\n    )\n\nclass IncludeNode(Node):\n    def __init__(self, template, extra_context=None, isolated_context=False):\n        self.template = template\n        self.extra_context = extra_context\n        self.isolated_context = isolated_context\n\n    def render(self, context):\n        try:\n            # If self.template is a list, select_template is used to find the first existing template\n            if isinstance(self.template.var, list):\n                t = select_template(self.template.var)\n            else:\n                t = get_template(self.template.var)\n        except TemplateDoesNotExist:\n            return ''  # or any other fallback logic\n\n        # ... (existing code for rendering the template) ...\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__3.1/tree//django/template)- [Lines 279 - 354](https://github.com/testbed/django__django__3.1/blob//django/template/loader_tags.py#L279-L354)\n\n This snippet contains the implementation of the {% include %} template tag which is directly related to the issue. The 'fix' mentioned in the issue description refers to changing the get_template call to select_template within this tag's implementation.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__3.1/tree//django/template)- [Lines 1 - 7](https://github.com/testbed/django__django__3.1/blob//django/template/response.py#L1-L7)\n\n This snippet imports the get_template and select_template functions, which are relevant to the issue as the fix involves changing the usage of one for the other in the {% include %} tag.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__3.1/tree//django/template) \u2192 [backends](https://github.com/testbed/django__django__3.1/tree//django/template/backends)- [Lines 1 - 84](https://github.com/testbed/django__django__3.1/blob//django/template/backends/django.py#L1-L84)\n\n This snippet includes the get_template method within the DjangoTemplates class, which may be relevant for understanding how templates are retrieved and could be affected by the change from get_template to select_template.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0009895,
        "snippet_processor": 0.046430000000000006,
        "issue_star_creation": 0.04236,
        "issue_star_solver": 0.05262,
        "bouncer": 0.024470000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711731398.0041878,
        "relevant_snippets": [
            {
                "code": "@register.tag(\"extends\")\ndef do_extends(parser, token):\n    \"\"\"\n    Signal that this template extends a parent template.\n\n    This tag may be used in two ways: ``{% extends \"base\" %}`` (with quotes)\n    uses the literal value \"base\" as the name of the parent template to extend,\n    or ``{% extends variable %}`` uses the value of ``variable`` as either the\n    name of the parent template to extend (if it evaluates to a string) or as\n    the parent template itself (if it evaluates to a Template object).\n    \"\"\"\n    bits = token.split_contents()\n    if len(bits) != 2:\n        raise TemplateSyntaxError(\"'%s' takes one argument\" % bits[0])\n    bits[1] = construct_relative_path(parser.origin.template_name, bits[1])\n    parent_name = parser.compile_filter(bits[1])\n    nodelist = parser.parse()\n    if nodelist.get_nodes_by_type(ExtendsNode):\n        raise TemplateSyntaxError(\n            \"'%s' cannot appear more than once in the same template\" % bits[0]\n        )\n    return ExtendsNode(nodelist, parent_name)\n\n\n@register.tag(\"include\")\ndef do_include(parser, token):\n    \"\"\"\n    Load a template and render it with the current context. You can pass\n    additional context using keyword arguments.\n\n    Example::\n\n        {% include \"foo/some_include\" %}\n        {% include \"foo/some_include\" with bar=\"BAZZ!\" baz=\"BING!\" %}\n\n    Use the ``only`` argument to exclude the current context when rendering\n    the included template::\n\n        {% include \"foo/some_include\" only %}\n        {% include \"foo/some_include\" with bar=\"1\" only %}\n    \"\"\"\n    bits = token.split_contents()\n    if len(bits) < 2:\n        raise TemplateSyntaxError(\n            \"%r tag takes at least one argument: the name of the template to \"\n            \"be included.\" % bits[0]\n        )\n    options = {}\n    remaining_bits = bits[2:]\n    while remaining_bits:\n        option = remaining_bits.pop(0)\n        if option in options:\n            raise TemplateSyntaxError(\n                \"The %r option was specified more than once.\" % option\n            )\n        if option == \"with\":\n            value = token_kwargs(remaining_bits, parser, support_legacy=False)\n            if not value:\n                raise TemplateSyntaxError(\n                    '\"with\" in %r tag needs at least one keyword argument.' % bits[0]\n                )\n        elif option == \"only\":\n            value = True\n        else:\n            raise TemplateSyntaxError(\n                \"Unknown argument for %r tag: %r.\" % (bits[0], option)\n            )\n        options[option] = value\n    isolated_context = options.get(\"only\", False)\n    namemap = options.get(\"with\", {})\n    bits[1] = construct_relative_path(parser.origin.template_name, bits[1])\n    return IncludeNode(\n        parser.compile_filter(bits[1]),\n        extra_context=namemap,\n        isolated_context=isolated_context,\n    )",
                "filename": "django/template/loader_tags.py",
                "start_index": 10272,
                "end_index": 13118,
                "start_line": 279,
                "end_line": 354,
                "max_line": 354,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from inspect import getfullargspec\n\nfrom django.template.library import InclusionNode, parse_bits\n\n\nclass InclusionAdminNode(InclusionNode):\n    \"\"\"\n    Template tag that allows its template to be overridden per model, per app,\n    or globally.\n    \"\"\"\n\n    def __init__(self, parser, token, func, template_name, takes_context=True):\n        self.template_name = template_name\n        params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(\n            func\n        )\n        bits = token.split_contents()\n        args, kwargs = parse_bits(\n            parser,\n            bits[1:],\n            params,\n            varargs,\n            varkw,\n            defaults,\n            kwonly,\n            kwonly_defaults,\n            takes_context,\n            bits[0],\n        )\n        super().__init__(func, takes_context, args, kwargs, filename=None)\n\n    def render(self, context):\n        opts = context[\"opts\"]\n        app_label = opts.app_label.lower()\n        object_name = opts.object_name.lower()\n        # Load template for this render call. (Setting self.filename isn't\n        # thread-safe.)\n        context.render_context[self] = context.template.engine.select_template(\n            [\n                \"admin/%s/%s/%s\" % (app_label, object_name, self.template_name),\n                \"admin/%s/%s\" % (app_label, self.template_name),\n                \"admin/%s\" % self.template_name,\n            ]\n        )\n        return super().render(context)",
                "filename": "django/contrib/admin/templatetags/base.py",
                "start_index": 0,
                "end_index": 1473,
                "start_line": 1,
                "end_line": 45,
                "max_line": 45,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from django.http import HttpResponse\n\nfrom .loader import get_template, select_template\n\n\nclass ContentNotRenderedError(Exception):\n    pass",
                "filename": "django/template/response.py",
                "start_index": 0,
                "end_index": 140,
                "start_line": 1,
                "end_line": 7,
                "max_line": 164,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "import functools\n\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.utils.functional import cached_property\nfrom django.utils.module_loading import import_string\n\nfrom .base import Template\nfrom .context import Context, _builtin_context_processors\nfrom .exceptions import TemplateDoesNotExist\nfrom .library import import_library",
                "filename": "django/template/engine.py",
                "start_index": 0,
                "end_index": 346,
                "start_line": 1,
                "end_line": 10,
                "max_line": 212,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "import functools\nimport warnings\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.template.backends.django import DjangoTemplates\nfrom django.template.loader import get_template\nfrom django.utils.deprecation import RemovedInDjango60Warning\nfrom django.utils.functional import cached_property\nfrom django.utils.module_loading import import_string\n\n\n@functools.lru_cache\ndef get_default_renderer():\n    renderer_class = import_string(settings.FORM_RENDERER)\n    return renderer_class()\n\n\nclass BaseRenderer:\n    form_template_name = \"django/forms/div.html\"\n    formset_template_name = \"django/forms/formsets/div.html\"\n    field_template_name = \"django/forms/field.html\"\n\n    def get_template(self, template_name):\n        raise NotImplementedError(\"subclasses must implement get_template()\")\n\n    def render(self, template_name, context, request=None):\n        template = self.get_template(template_name)\n        return template.render(context, request=request).strip()\n\n\nclass EngineMixin:\n    def get_template(self, template_name):\n        return self.engine.get_template(template_name)\n\n    @cached_property\n    def engine(self):\n        return self.backend(\n            {\n                \"APP_DIRS\": True,\n                \"DIRS\": [Path(__file__).parent / self.backend.app_dirname],\n                \"NAME\": \"djangoforms\",\n                \"OPTIONS\": {},\n            }\n        )\n\n\nclass DjangoTemplates(EngineMixin, BaseRenderer):\n    \"\"\"\n    Load Django templates from the built-in widget templates in\n    django/forms/templates and from apps' 'templates' directory.\n    \"\"\"\n\n    backend = DjangoTemplates\n\n\nclass Jinja2(EngineMixin, BaseRenderer):\n    \"\"\"\n    Load Jinja2 templates from the built-in widget templates in\n    django/forms/jinja2 and from apps' 'jinja2' directory.\n    \"\"\"\n\n    @cached_property\n    def backend(self):\n        from django.template.backends.jinja2 import Jinja2\n\n        return Jinja2\n\n\n# RemovedInDjango60Warning.\nclass DjangoDivFormRenderer(DjangoTemplates):\n    \"\"\"\n    Load Django templates from django/forms/templates and from apps'\n    'templates' directory and use the 'div.html' template to render forms and\n    formsets.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"The DjangoDivFormRenderer transitional form renderer is deprecated. Use \"\n            \"DjangoTemplates instead.\",\n            RemovedInDjango60Warning,\n        )\n        super().__init__(*args, **kwargs)\n\n\n# RemovedInDjango60Warning.\nclass Jinja2DivFormRenderer(Jinja2):\n    \"\"\"\n    Load Jinja2 templates from the built-in widget templates in\n    django/forms/jinja2 and from apps' 'jinja2' directory.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"The Jinja2DivFormRenderer transitional form renderer is deprecated. Use \"\n            \"Jinja2 instead.\",\n            RemovedInDjango60Warning,\n        )\n        super().__init__(*args, **kwargs)",
                "filename": "django/forms/renderers.py",
                "start_index": 0,
                "end_index": 2950,
                "start_line": 1,
                "end_line": 100,
                "max_line": 110,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "try:  # catch-all for silent variable failures\n            for bit in self.lookups:\n                try:  # dictionary lookup\n                    current = current[bit]\n                    # ValueError/IndexError are for numpy.array lookup on\n                    # numpy < 1.9 and 1.9+ respectively\n                except (TypeError, AttributeError, KeyError, ValueError, IndexError):\n                    try:  # attribute lookup\n                        # Don't return class attributes if the class is the context:\n                        if isinstance(current, BaseContext) and getattr(\n                            type(current), bit\n                        ):\n                            raise AttributeError\n                        current = getattr(current, bit)\n                    except (TypeError, AttributeError):\n                        # Reraise if the exception was raised by a @property\n                        if not isinstance(current, BaseContext) and bit in dir(current):\n                            raise\n                        try:  # list-index lookup\n                            current = current[int(bit)]\n                        except (\n                            IndexError,  # list index out of range\n                            ValueError,  # invalid literal for int()\n                            KeyError,  # current is a dict without `int(bit)` key\n                            TypeError,\n                        ):  # unsubscriptable object\n                            raise VariableDoesNotExist(\n                                \"Failed lookup for key [%s] in %r\",\n                                (bit, current),\n                            )  # missing attribute\n                if callable(current):\n                    if getattr(current, \"do_not_call_in_templates\", False):\n                        pass\n                    elif getattr(current, \"alters_data\", False):\n                        current = context.template.engine.string_if_invalid\n                    else:\n                        try:  # method call (assuming no args required)\n                            current = current()\n                        except TypeError:\n                            try:\n                                signature = inspect.signature(current)\n                            except ValueError:  # No signature found.\n                                current = context.template.engine.string_if_invalid\n                            else:\n                                try:\n                                    signature.bind()\n                                except TypeError:  # Arguments *were* required.\n                                    # Invalid method call.\n                                    current = context.template.engine.string_if_invalid\n                                else:\n                                    raise",
                "filename": "django/template/base.py",
                "start_index": 31189,
                "end_index": 34044,
                "start_line": 872,
                "end_line": 922,
                "max_line": 1116,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "class TemplateResponseMixin:\n    \"\"\"A mixin that can be used to render a template.\"\"\"\n\n    template_name = None\n    template_engine = None\n    response_class = TemplateResponse\n    content_type = None\n\n    def render_to_response(self, context, **response_kwargs):\n        \"\"\"\n        Return a response, using the `response_class` for this view, with a\n        template rendered with the given context.\n\n        Pass response_kwargs to the constructor of the response class.\n        \"\"\"\n        response_kwargs.setdefault(\"content_type\", self.content_type)\n        return self.response_class(\n            request=self.request,\n            template=self.get_template_names(),\n            context=context,\n            using=self.template_engine,\n            **response_kwargs,\n        )\n\n    def get_template_names(self):\n        \"\"\"\n        Return a list of template names to be used for the request. Must return\n        a list. May not be called if render_to_response() is overridden.\n        \"\"\"\n        if self.template_name is None:\n            raise ImproperlyConfigured(\n                \"TemplateResponseMixin requires either a definition of \"\n                \"'template_name' or an implementation of 'get_template_names()'\"\n            )\n        else:\n            return [self.template_name]\n\n\nclass TemplateView(TemplateResponseMixin, ContextMixin, View):\n    \"\"\"\n    Render a template. Pass keyword arguments from the URLconf to the context.\n    \"\"\"\n\n    def get(self, request, *args, **kwargs):\n        context = self.get_context_data(**kwargs)\n        return self.render_to_response(context)",
                "filename": "django/views/generic/base.py",
                "start_index": 5873,
                "end_index": 7473,
                "start_line": 182,
                "end_line": 227,
                "max_line": 285,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from django import template\n\nregister = template.Library()\n\n\nclass AdminLogNode(template.Node):\n    def __init__(self, limit, varname, user):\n        self.limit = limit\n        self.varname = varname\n        self.user = user\n\n    def __repr__(self):\n        return \"<GetAdminLog Node>\"\n\n    def render(self, context):\n        entries = context[\"log_entries\"]\n        if self.user is not None:\n            user_id = self.user\n            if not user_id.isdigit():\n                user_id = context[self.user].pk\n            entries = entries.filter(user__pk=user_id)\n        context[self.varname] = entries[: int(self.limit)]\n        return \"\"\n\n\n@register.tag\ndef get_admin_log(parser, token):\n    \"\"\"\n    Populate a template variable with the admin log for the given criteria.\n\n    Usage::\n\n        {% get_admin_log [limit] as [varname] for_user [context_var_with_user_obj] %}\n\n    Examples::\n\n        {% get_admin_log 10 as admin_log for_user 23 %}\n        {% get_admin_log 10 as admin_log for_user user %}\n        {% get_admin_log 10 as admin_log %}\n\n    Note that ``context_var_containing_user_obj`` can be a hard-coded integer\n    (user ID) or the name of a template context variable containing the user\n    object whose ID you want.\n    \"\"\"\n    tokens = token.contents.split()\n    if len(tokens) < 4:\n        raise template.TemplateSyntaxError(\n            \"'get_admin_log' statements require two arguments\"\n        )\n    if not tokens[1].isdigit():\n        raise template.TemplateSyntaxError(\n            \"First argument to 'get_admin_log' must be an integer\"\n        )\n    if tokens[2] != \"as\":\n        raise template.TemplateSyntaxError(\n            \"Second argument to 'get_admin_log' must be 'as'\"\n        )\n    if len(tokens) > 4:\n        if tokens[4] != \"for_user\":\n            raise template.TemplateSyntaxError(\n                \"Fourth argument to 'get_admin_log' must be 'for_user'\"\n            )\n    return AdminLogNode(\n        limit=tokens[1],\n        varname=tokens[3],\n        user=(tokens[5] if len(tokens) > 5 else None),\n    )",
                "filename": "django/contrib/admin/templatetags/log.py",
                "start_index": 0,
                "end_index": 2049,
                "start_line": 1,
                "end_line": 67,
                "max_line": 67,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from importlib import import_module\nfrom pkgutil import walk_packages\n\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.template import TemplateDoesNotExist\nfrom django.template.context import make_context\nfrom django.template.engine import Engine\nfrom django.template.library import InvalidTemplateLibrary\n\nfrom .base import BaseEngine\n\n\nclass DjangoTemplates(BaseEngine):\n    app_dirname = \"templates\"\n\n    def __init__(self, params):\n        params = params.copy()\n        options = params.pop(\"OPTIONS\").copy()\n        options.setdefault(\"autoescape\", True)\n        options.setdefault(\"debug\", settings.DEBUG)\n        options.setdefault(\"file_charset\", \"utf-8\")\n        libraries = options.get(\"libraries\", {})\n        options[\"libraries\"] = self.get_templatetag_libraries(libraries)\n        super().__init__(params)\n        self.engine = Engine(self.dirs, self.app_dirs, **options)\n\n    def from_string(self, template_code):\n        return Template(self.engine.from_string(template_code), self)\n\n    def get_template(self, template_name):\n        try:\n            return Template(self.engine.get_template(template_name), self)\n        except TemplateDoesNotExist as exc:\n            reraise(exc, self)\n\n    def get_templatetag_libraries(self, custom_libraries):\n        \"\"\"\n        Return a collation of template tag libraries from installed\n        applications and the supplied custom_libraries argument.\n        \"\"\"\n        libraries = get_installed_libraries()\n        libraries.update(custom_libraries)\n        return libraries\n\n\nclass Template:\n    def __init__(self, template, backend):\n        self.template = template\n        self.backend = backend\n\n    @property\n    def origin(self):\n        return self.template.origin\n\n    def render(self, context=None, request=None):\n        context = make_context(\n            context, request, autoescape=self.backend.engine.autoescape\n        )\n        try:\n            return self.template.render(context)\n        except TemplateDoesNotExist as exc:\n            reraise(exc, self.backend)\n\n\ndef copy_exception(exc, backend=None):\n    \"\"\"\n    Create a new TemplateDoesNotExist. Preserve its declared attributes and\n    template debug data but discard __traceback__, __context__, and __cause__\n    to make this object suitable for keeping around (in a cache, for example).\n    \"\"\"\n    backend = backend or exc.backend\n    new = exc.__class__(*exc.args, tried=exc.tried, backend=backend, chain=exc.chain)\n    if hasattr(exc, \"template_debug\"):\n        new.template_debug = exc.template_debug\n    return new\n\n\ndef reraise(exc, backend):\n    \"\"\"\n    Reraise TemplateDoesNotExist while maintaining template debug information.\n    \"\"\"\n    new = copy_exception(exc, backend)\n    raise new from exc",
                "filename": "django/template/backends/django.py",
                "start_index": 0,
                "end_index": 2771,
                "start_line": 1,
                "end_line": 84,
                "max_line": 136,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"Default tags used by the template system, available to all templates.\"\"\"\nimport re\nimport sys\nimport warnings\nfrom collections import namedtuple\nfrom datetime import datetime\nfrom itertools import cycle as itertools_cycle\nfrom itertools import groupby\n\nfrom django.conf import settings\nfrom django.utils import timezone\nfrom django.utils.html import conditional_escape, escape, format_html\nfrom django.utils.lorem_ipsum import paragraphs, words\nfrom django.utils.safestring import mark_safe\n\nfrom .base import (\n    BLOCK_TAG_END,\n    BLOCK_TAG_START,\n    COMMENT_TAG_END,\n    COMMENT_TAG_START,\n    FILTER_SEPARATOR,\n    SINGLE_BRACE_END,\n    SINGLE_BRACE_START,\n    VARIABLE_ATTRIBUTE_SEPARATOR,\n    VARIABLE_TAG_END,\n    VARIABLE_TAG_START,\n    Node,\n    NodeList,\n    TemplateSyntaxError,\n    VariableDoesNotExist,\n    kwarg_re,\n    render_value_in_context,\n    token_kwargs,\n)\nfrom .context import Context\nfrom .defaultfilters import date\nfrom .library import Library\nfrom .smartif import IfParser, Literal\n\nregister = Library()\n\n\nclass AutoEscapeControlNode(Node):\n    \"\"\"Implement the actions of the autoescape tag.\"\"\"\n\n    def __init__(self, setting, nodelist):\n        self.setting = setting\n        self.nodelist = nodelist\n\n    def render(self, context):\n        old_setting = context.autoescape\n        context.autoescape = self.setting\n        output = self.nodelist.render(context)\n        context.autoescape = old_setting\n        if self.setting:\n            return mark_safe(output)\n        else:\n            return output\n\n\nclass CommentNode(Node):\n    child_nodelists = ()\n\n    def render(self, context):\n        return \"\"\n\n\nclass CsrfTokenNode(Node):\n    child_nodelists = ()\n\n    def render(self, context):\n        csrf_token = context.get(\"csrf_token\")\n        if csrf_token:\n            if csrf_token == \"NOTPROVIDED\":\n                return format_html(\"\")\n            else:\n                return format_html(\n                    '<input type=\"hidden\" name=\"csrfmiddlewaretoken\" value=\"{}\">',\n                    csrf_token,\n                )\n        else:\n            # It's very probable that the token is missing because of\n            # misconfiguration, so we raise a warning\n            if settings.DEBUG:\n                warnings.warn(\n                    \"A {% csrf_token %} was used in a template, but the context \"\n                    \"did not provide the value.  This is usually caused by not \"\n                    \"using RequestContext.\"\n                )\n            return \"\"",
                "filename": "django/template/defaulttags.py",
                "start_index": 0,
                "end_index": 2516,
                "start_line": 1,
                "end_line": 528,
                "max_line": 1500,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            }
        ],
        "classification": "other",
        "snippet_processor_task": {
            "django/template/loader_tags.py": [
                {
                    "chunk": {
                        "code": "@register.tag(\"extends\")\ndef do_extends(parser, token):\n    \"\"\"\n    Signal that this template extends a parent template.\n\n    This tag may be used in two ways: ``{% extends \"base\" %}`` (with quotes)\n    uses the literal value \"base\" as the name of the parent template to extend,\n    or ``{% extends variable %}`` uses the value of ``variable`` as either the\n    name of the parent template to extend (if it evaluates to a string) or as\n    the parent template itself (if it evaluates to a Template object).\n    \"\"\"\n    bits = token.split_contents()\n    if len(bits) != 2:\n        raise TemplateSyntaxError(\"'%s' takes one argument\" % bits[0])\n    bits[1] = construct_relative_path(parser.origin.template_name, bits[1])\n    parent_name = parser.compile_filter(bits[1])\n    nodelist = parser.parse()\n    if nodelist.get_nodes_by_type(ExtendsNode):\n        raise TemplateSyntaxError(\n            \"'%s' cannot appear more than once in the same template\" % bits[0]\n        )\n    return ExtendsNode(nodelist, parent_name)\n\n\n@register.tag(\"include\")\ndef do_include(parser, token):\n    \"\"\"\n    Load a template and render it with the current context. You can pass\n    additional context using keyword arguments.\n\n    Example::\n\n        {% include \"foo/some_include\" %}\n        {% include \"foo/some_include\" with bar=\"BAZZ!\" baz=\"BING!\" %}\n\n    Use the ``only`` argument to exclude the current context when rendering\n    the included template::\n\n        {% include \"foo/some_include\" only %}\n        {% include \"foo/some_include\" with bar=\"1\" only %}\n    \"\"\"\n    bits = token.split_contents()\n    if len(bits) < 2:\n        raise TemplateSyntaxError(\n            \"%r tag takes at least one argument: the name of the template to \"\n            \"be included.\" % bits[0]\n        )\n    options = {}\n    remaining_bits = bits[2:]\n    while remaining_bits:\n        option = remaining_bits.pop(0)\n        if option in options:\n            raise TemplateSyntaxError(\n                \"The %r option was specified more than once.\" % option\n            )\n        if option == \"with\":\n            value = token_kwargs(remaining_bits, parser, support_legacy=False)\n            if not value:\n                raise TemplateSyntaxError(\n                    '\"with\" in %r tag needs at least one keyword argument.' % bits[0]\n                )\n        elif option == \"only\":\n            value = True\n        else:\n            raise TemplateSyntaxError(\n                \"Unknown argument for %r tag: %r.\" % (bits[0], option)\n            )\n        options[option] = value\n    isolated_context = options.get(\"only\", False)\n    namemap = options.get(\"with\", {})\n    bits[1] = construct_relative_path(parser.origin.template_name, bits[1])\n    return IncludeNode(\n        parser.compile_filter(bits[1]),\n        extra_context=namemap,\n        isolated_context=isolated_context,\n    )",
                        "filename": "django/template/loader_tags.py",
                        "start_index": 10272,
                        "end_index": 13118,
                        "start_line": 279,
                        "end_line": 354,
                        "max_line": 354,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of the {% include %} template tag which is directly related to the issue. The 'fix' mentioned in the issue description refers to changing the get_template call to select_template within this tag's implementation."
                }
            ],
            "django/template/response.py": [
                {
                    "chunk": {
                        "code": "from django.http import HttpResponse\n\nfrom .loader import get_template, select_template\n\n\nclass ContentNotRenderedError(Exception):\n    pass",
                        "filename": "django/template/response.py",
                        "start_index": 0,
                        "end_index": 140,
                        "start_line": 1,
                        "end_line": 7,
                        "max_line": 164,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet imports the get_template and select_template functions, which are relevant to the issue as the fix involves changing the usage of one for the other in the {% include %} tag."
                }
            ],
            "django/template/backends/django.py": [
                {
                    "chunk": {
                        "code": "from importlib import import_module\nfrom pkgutil import walk_packages\n\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.template import TemplateDoesNotExist\nfrom django.template.context import make_context\nfrom django.template.engine import Engine\nfrom django.template.library import InvalidTemplateLibrary\n\nfrom .base import BaseEngine\n\n\nclass DjangoTemplates(BaseEngine):\n    app_dirname = \"templates\"\n\n    def __init__(self, params):\n        params = params.copy()\n        options = params.pop(\"OPTIONS\").copy()\n        options.setdefault(\"autoescape\", True)\n        options.setdefault(\"debug\", settings.DEBUG)\n        options.setdefault(\"file_charset\", \"utf-8\")\n        libraries = options.get(\"libraries\", {})\n        options[\"libraries\"] = self.get_templatetag_libraries(libraries)\n        super().__init__(params)\n        self.engine = Engine(self.dirs, self.app_dirs, **options)\n\n    def from_string(self, template_code):\n        return Template(self.engine.from_string(template_code), self)\n\n    def get_template(self, template_name):\n        try:\n            return Template(self.engine.get_template(template_name), self)\n        except TemplateDoesNotExist as exc:\n            reraise(exc, self)\n\n    def get_templatetag_libraries(self, custom_libraries):\n        \"\"\"\n        Return a collation of template tag libraries from installed\n        applications and the supplied custom_libraries argument.\n        \"\"\"\n        libraries = get_installed_libraries()\n        libraries.update(custom_libraries)\n        return libraries\n\n\nclass Template:\n    def __init__(self, template, backend):\n        self.template = template\n        self.backend = backend\n\n    @property\n    def origin(self):\n        return self.template.origin\n\n    def render(self, context=None, request=None):\n        context = make_context(\n            context, request, autoescape=self.backend.engine.autoescape\n        )\n        try:\n            return self.template.render(context)\n        except TemplateDoesNotExist as exc:\n            reraise(exc, self.backend)\n\n\ndef copy_exception(exc, backend=None):\n    \"\"\"\n    Create a new TemplateDoesNotExist. Preserve its declared attributes and\n    template debug data but discard __traceback__, __context__, and __cause__\n    to make this object suitable for keeping around (in a cache, for example).\n    \"\"\"\n    backend = backend or exc.backend\n    new = exc.__class__(*exc.args, tried=exc.tried, backend=backend, chain=exc.chain)\n    if hasattr(exc, \"template_debug\"):\n        new.template_debug = exc.template_debug\n    return new\n\n\ndef reraise(exc, backend):\n    \"\"\"\n    Reraise TemplateDoesNotExist while maintaining template debug information.\n    \"\"\"\n    new = copy_exception(exc, backend)\n    raise new from exc",
                        "filename": "django/template/backends/django.py",
                        "start_index": 0,
                        "end_index": 2771,
                        "start_line": 1,
                        "end_line": 84,
                        "max_line": 136,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the get_template method within the DjangoTemplates class, which may be relevant for understanding how templates are retrieved and could be affected by the change from get_template to select_template."
                }
            ]
        },
        "solution_task": "- Update the `IncludeNode` class in `django/template/loader_tags.py` to use `select_template` instead of `get_template` when handling a list of templates.\n- Add exception handling for `TemplateDoesNotExist` within the `IncludeNode` class to provide a fallback mechanism.\n- Ensure that the `render` method of `IncludeNode` correctly processes the list of templates and returns the rendered content of the first template that exists.\n\n```python\n# django/template/loader_tags.py\n\n@register.tag(\"include\")\ndef do_include(parser, token):\n    # ... (existing code) ...\n\n    return IncludeNode(\n        parser.compile_filter(bits[1]),\n        extra_context=namemap,\n        isolated_context=isolated_context,\n    )\n\nclass IncludeNode(Node):\n    def __init__(self, template, extra_context=None, isolated_context=False):\n        self.template = template\n        self.extra_context = extra_context\n        self.isolated_context = isolated_context\n\n    def render(self, context):\n        try:\n            # If self.template is a list, select_template is used to find the first existing template\n            if isinstance(self.template.var, list):\n                t = select_template(self.template.var)\n            else:\n                t = get_template(self.template.var)\n        except TemplateDoesNotExist:\n            return ''  # or any other fallback logic\n\n        # ... (existing code for rendering the template) ...\n```",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the issue described in the PROMPT. It suggests updating the IncludeNode class to use select_template instead of get_template, which aligns with the desired behavior of allowing fallbacks for template selection. The RESPONSE also includes exception handling for TemplateDoesNotExist, which is a direct response to the error encountered in the PROMPT. Additionally, the RESPONSE ensures that the render method processes the list of templates correctly, which is necessary for the fix to work as expected. The inclusion of code snippets and references to the relevant sections of the Django codebase adds to the utility of the RESPONSE by guiding the implementer to the exact locations that need modification.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711731663.4472299,
        "result": "- Update the `IncludeNode` class in `django/template/loader_tags.py` to use `select_template` instead of `get_template` when handling a list of templates.\n- Add exception handling for `TemplateDoesNotExist` within the `IncludeNode` class to provide a fallback mechanism.\n- Ensure that the `render` method of `IncludeNode` correctly processes the list of templates and returns the rendered content of the first template that exists.\n\n```python\n# django/template/loader_tags.py\n\n@register.tag(\"include\")\ndef do_include(parser, token):\n    # ... (existing code) ...\n\n    return IncludeNode(\n        parser.compile_filter(bits[1]),\n        extra_context=namemap,\n        isolated_context=isolated_context,\n    )\n\nclass IncludeNode(Node):\n    def __init__(self, template, extra_context=None, isolated_context=False):\n        self.template = template\n        self.extra_context = extra_context\n        self.isolated_context = isolated_context\n\n    def render(self, context):\n        try:\n            # If self.template is a list, select_template is used to find the first existing template\n            if isinstance(self.template.var, list):\n                t = select_template(self.template.var)\n            else:\n                t = get_template(self.template.var)\n        except TemplateDoesNotExist:\n            return ''  # or any other fallback logic\n\n        # ... (existing code for rendering the template) ...\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__3.1/tree//django/template)- [Lines 279 - 354](https://github.com/testbed/django__django__3.1/blob//django/template/loader_tags.py#L279-L354)\n\n This snippet contains the implementation of the {% include %} template tag which is directly related to the issue. The 'fix' mentioned in the issue description refers to changing the get_template call to select_template within this tag's implementation.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__3.1/tree//django/template)- [Lines 1 - 7](https://github.com/testbed/django__django__3.1/blob//django/template/response.py#L1-L7)\n\n This snippet imports the get_template and select_template functions, which are relevant to the issue as the fix involves changing the usage of one for the other in the {% include %} tag.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__3.1/tree//django/template) \u2192 [backends](https://github.com/testbed/django__django__3.1/tree//django/template/backends)- [Lines 1 - 84](https://github.com/testbed/django__django__3.1/blob//django/template/backends/django.py#L1-L84)\n\n This snippet includes the get_template method within the DjangoTemplates class, which may be relevant for understanding how templates are retrieved and could be affected by the change from get_template to select_template."
    }
}