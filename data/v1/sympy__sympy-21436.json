{
    "id": "sympy__sympy-21436",
    "repo_name": "testbed/sympy__sympy__1.9",
    "task_id": 3948327807210407918,
    "title": "Support orienting adjacent reference frames in arbitrary orders",
    "body": "Suppose you want to establish relative orientation among frames A, B, C, D, and E as such:\r\n\r\n```\r\nA ----- B\r\n|\r\n|-------C----D\r\n        |\r\n        |----E\r\n```\r\n\r\nA is the root of the tree, B, D, and E are leaves. You do this now with code that looks like:\r\n\r\n```python\r\nB.orient(A)\r\nC.orient(A)\r\nD.orient(C)\r\nE.orient(C)\r\n```\r\n\r\nThis will establish rotation matrices for each connection in the above graph. But a user may, for whatever reason, do something like (call this the alternative use case):\r\n\r\n```python\r\nB.orient(A)\r\nA.orient(C)\r\nC.orient(D)\r\nE.orient(C)\r\n```\r\nThis currently does not work because with every call of `X.orient()` all adjacent relationships to `X` will be cleared. That is, calling `.orient()` assumes `self`'s orientation relationships should be overwritten. This is sometimes needed, for example if I do:\r\n\r\n```python\r\nB.orient(A, ...)\r\nA.orient(B, ...)\r\n```\r\n\r\nAnything that was defined in `B.orient(A, ...)` should be fully replaced with the relationships established with `A.orient(B, ...)` because they may be inconsistent with each other. Or if a user tries to do a loop:\r\n\r\n```python\r\nB.orient(A)\r\nC.orient(B)\r\nA.orient(C)\r\n```\r\n\r\nThe last line should raise an error and say something like \"Loops in graph not allowed\", but what it does is overwrites all relationships to `A` in the last line, effectively undoing the first line.\r\n\r\nThe alternative use case should work. There is no reason we shouldn't allow construction of the graph in any sequence. Overwriting the relationships to `self` in calls to `orient()` is unnecessary. I think it was implemented like that because it was easier than checking the graph for consistency in a more thorough way.\r\n\r\nI think the relationships between points do not have this issue and you can establish them in any order you like. It would be nice if frames also allowed that.\r\n\r\nHere is some code that shows how the method `ReferenceFrame._dcm()` wipes relationships of `self`:\r\n\r\n```ipython\r\nIPython 7.21.0 -- An enhanced Interactive Python. Type '?' for help.\r\n\r\nIn [1]: import sympy as sm\r\n\r\nIn [2]: import sympy.physics.mechanics as me\r\n\r\nIn [3]: A, B, C = sm.symbols(\"A, B, C\", cls=me.ReferenceFrame)\r\n\r\nIn [4]: a, b, c = sm.symbols('a, b, c')\r\n\r\nIn [5]: B.orient(A, 'Axis', (a, A.x))\r\n\r\nIn [6]: A._dcm_dict\r\nOut[6]: \r\n{B: Matrix([\r\n [1,      0,       0],\r\n [0, cos(a), -sin(a)],\r\n [0, sin(a),  cos(a)]])}\r\n\r\nIn [7]: B._dcm_dict\r\nOut[7]: \r\n{A: Matrix([\r\n [1,       0,      0],\r\n [0,  cos(a), sin(a)],\r\n [0, -sin(a), cos(a)]])}\r\n\r\nIn [8]: C._dcm_dict\r\nOut[8]: {}\r\n\r\nIn [9]: B.orient(C, 'Axis', (b, C.x))\r\n\r\nIn [10]: A._dcm_dict\r\nOut[10]: {}\r\n\r\nIn [11]: B._dcm_dict\r\nOut[11]: \r\n{C: Matrix([\r\n [1,       0,      0],\r\n [0,  cos(b), sin(b)],\r\n [0, -sin(b), cos(b)]])}\r\n\r\nIn [12]: C._dcm_dict\r\nOut[12]: \r\n{B: Matrix([\r\n [1,      0,       0],\r\n [0, cos(b), -sin(b)],\r\n [0, sin(b),  cos(b)]])}\r\n\r\nIn [13]: sm.__version__\r\nOut[13]: '1.7.1'\r\n```\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sympy__sympy__1.9.git",
    "requested_commit": "",
    "mayil_response": "- The issue is related to the `orient` method in the `ReferenceFrame` class, which is causing a \"Loops in graph not allowed\" error.\n- The problem seems to be that the `orient` method is clearing all adjacent relationships when called, which can lead to loops in the orientation graph if the method is called multiple times to establish different relationships.\n\nTo resolve the issue:\n- Modify the `orient` method in the `ReferenceFrame` class to ensure that it does not indiscriminately clear the `_dcm_dict` and `_dcm_cache` of the frames it is linked to.\n- Implement a check to prevent the creation of loops in the orientation graph. This could involve checking for the existence of a path between the current frame and the `other` frame before updating the `_dcm_dict` and `_dcm_cache`.\n- Update the logic that deletes entries from `_dcm_dict` and `_dcm_cache` to only remove the relevant entries instead of clearing the entire dictionary or cache.\n- Ensure that the `orient` method updates the orientation relationships in a way that supports constructing the graph in any sequence without creating loops.\n\nHere is a possible solution:\n\n```python\nclass ReferenceFrame:\n    # ... existing methods ...\n\n    def orient(self, other, rotation_type, rotation_parameters, rot_order=''):\n        # ... existing code ...\n\n        # Check for existing path to prevent loops before updating _dcm_dict\n        if self._exists_path_to(other):\n            raise ValueError(\"Loops in graph not allowed\")\n\n        # Update the dcm relationship to _dcm_dict without clearing all relationships\n        self._dcm_dict.update({other: parent_orient.T})\n        other._dcm_dict.update({self: parent_orient})\n\n        # ... rest of the existing code ...\n\n    def _exists_path_to(self, other):\n        \"\"\"\n        Check if there is a path from self to other in the orientation graph.\n        \"\"\"\n        visited = set()\n\n        def visit(frame):\n            if frame in visited:\n                return False\n            visited.add(frame)\n            for adjacent in frame._dcm_dict.keys():\n                if adjacent == other or visit(adjacent):\n                    return True\n            return False\n\n        return visit(self)\n```\n\n- Add the `_exists_path_to` helper method to the `ReferenceFrame` class to check for the existence of a path between two frames.\n- Call this method in the `orient` method before updating `_dcm_dict` to ensure no loops are created.\n- Update the `_dcm_dict` and `_dcm_cache` dictionaries by adding only the new relationships instead of resetting them entirely.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [physics](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/physics) \u2192 [vector](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/physics/vector)- [Lines 784 - 837](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/physics/vector/frame.py#L784-L837)\n\n This snippet contains the logic that clears the relationships of `self` when `orient()` is called, which is the core issue described. \n\n\n   - [Lines 728 - 783](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/physics/vector/frame.py#L728-L783)\n\n This snippet shows the implementation of the 'AXIS' rotation type in the `orient()` method, which is relevant to the issue as it is one of the rotation types affected by the clearing of relationships. \n\n\n   - [Lines 480 - 1043](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/physics/vector/frame.py#L480-L1043)\n\n This snippet provides the documentation for the `orient()` method, which is important for understanding how the method is intended to be used and how it relates to the issue.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [vector](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/vector)- [Lines 1 - 98](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/vector/orienters.py#L1-L98)\n\n This snippet defines the `AxisOrienter` class, which is used in the `orient()` method for 'AXIS' type rotations and is relevant to the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00029299999999999997,
        "snippet_processor": 0.08825000000000001,
        "issue_star_creation": 0.02848,
        "issue_star_solver": 0.0763,
        "bouncer": 0.032920000000000005
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711744099.591043,
        "relevant_snippets": [
            {
                "code": "frames = self._dcm_cache.keys()\n        dcm_dict_del = []\n        dcm_cache_del = []\n        for frame in frames:\n            if frame in self._dcm_dict:\n                dcm_dict_del += [frame]\n            dcm_cache_del += [frame]\n        for frame in dcm_dict_del:\n            del frame._dcm_dict[self]\n        for frame in dcm_cache_del:\n            del frame._dcm_cache[self]\n        # Add the dcm relationship to _dcm_dict\n        self._dcm_dict = self._dlist[0] = {}\n        self._dcm_dict.update({parent: parent_orient.T})\n        parent._dcm_dict.update({self: parent_orient})\n        # Also update the dcm cache after resetting it\n        self._dcm_cache = {}\n        self._dcm_cache.update({parent: parent_orient.T})\n        parent._dcm_cache.update({self: parent_orient})\n        if rot_type == 'QUATERNION':\n            t = dynamicsymbols._t\n            q0, q1, q2, q3 = amounts\n            q0d = diff(q0, t)\n            q1d = diff(q1, t)\n            q2d = diff(q2, t)\n            q3d = diff(q3, t)\n            w1 = 2 * (q1d * q0 + q2d * q3 - q3d * q2 - q0d * q1)\n            w2 = 2 * (q2d * q0 + q3d * q1 - q1d * q3 - q0d * q2)\n            w3 = 2 * (q3d * q0 + q1d * q2 - q2d * q1 - q0d * q3)\n            wvec = Vector([(Matrix([w1, w2, w3]), self)])\n        elif rot_type == 'AXIS':\n            thetad = (amounts[0]).diff(dynamicsymbols._t)\n            wvec = thetad * amounts[1].express(parent).normalize()\n        elif rot_type == 'DCM':\n            wvec = self._w_diff_dcm(parent)\n        else:\n            try:\n                from sympy.polys.polyerrors import CoercionFailed\n                from sympy.physics.vector.functions import kinematic_equations\n                q1, q2, q3 = amounts\n                u1, u2, u3 = symbols('u1, u2, u3', cls=Dummy)\n                templist = kinematic_equations([u1, u2, u3], [q1, q2, q3],\n                                               rot_type, rot_order)\n                templist = [expand(i) for i in templist]\n                td = solve(templist, [u1, u2, u3])\n                u1 = expand(td[u1])\n                u2 = expand(td[u2])\n                u3 = expand(td[u3])\n                wvec = u1 * self.x + u2 * self.y + u3 * self.z\n            except (CoercionFailed, AssertionError):\n                wvec = self._w_diff_dcm(parent)\n        self._ang_vel_dict.update({parent: wvec})\n        parent._ang_vel_dict.update({self: -wvec})\n        self._var_dict = {}",
                "filename": "sympy/physics/vector/frame.py",
                "start_index": 30776,
                "end_index": 33199,
                "start_line": 784,
                "end_line": 837,
                "max_line": 1057,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "from sympy.physics.vector.functions import dynamicsymbols\n        _check_frame(parent)\n\n        # Allow passing a rotation matrix manually.\n        if rot_type == 'DCM':\n            # When rot_type == 'DCM', then amounts must be a Matrix type object\n            # (e.g. sympy.matrices.dense.MutableDenseMatrix).\n            if not isinstance(amounts, MatrixBase):\n                raise TypeError(\"Amounts must be a sympy Matrix type object.\")\n        else:\n            amounts = list(amounts)\n            for i, v in enumerate(amounts):\n                if not isinstance(v, Vector):\n                    amounts[i] = sympify(v)\n\n        def _rot(axis, angle):\n            \"\"\"DCM for simple axis 1,2,or 3 rotations. \"\"\"\n            if axis == 1:\n                return Matrix([[1, 0, 0],\n                               [0, cos(angle), -sin(angle)],\n                               [0, sin(angle), cos(angle)]])\n            elif axis == 2:\n                return Matrix([[cos(angle), 0, sin(angle)],\n                               [0, 1, 0],\n                               [-sin(angle), 0, cos(angle)]])\n            elif axis == 3:\n                return Matrix([[cos(angle), -sin(angle), 0],\n                               [sin(angle), cos(angle), 0],\n                               [0, 0, 1]])\n\n        approved_orders = ('123', '231', '312', '132', '213', '321', '121',\n                           '131', '212', '232', '313', '323', '')\n        # make sure XYZ => 123 and rot_type is in upper case\n        rot_order = translate(str(rot_order), 'XYZxyz', '123123')\n        rot_type = rot_type.upper()\n        if rot_order not in approved_orders:\n            raise TypeError('The supplied order is not an approved type')\n        parent_orient = []",
                "filename": "sympy/physics/vector/frame.py",
                "start_index": 26015,
                "end_index": 27758,
                "start_line": 276,
                "end_line": 727,
                "max_line": 1057,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "if rot_type == 'AXIS':\n            if not rot_order == '':\n                raise TypeError('Axis orientation takes no rotation order')\n            if not (isinstance(amounts, (list, tuple)) & (len(amounts) == 2)):\n                raise TypeError('Amounts are a list or tuple of length 2')\n            theta = amounts[0]\n            axis = amounts[1]\n            axis = _check_vector(axis)\n            if not axis.dt(parent) == 0:\n                raise ValueError('Axis cannot be time-varying')\n            axis = axis.express(parent).normalize()\n            axis = axis.args[0][0]\n            parent_orient = ((eye(3) - axis * axis.T) * cos(theta) +\n                             Matrix([[0, -axis[2], axis[1]],\n                                     [axis[2], 0, -axis[0]],\n                                     [-axis[1], axis[0], 0]]) *\n                             sin(theta) + axis * axis.T)\n        elif rot_type == 'QUATERNION':\n            if not rot_order == '':\n                raise TypeError(\n                    'Quaternion orientation takes no rotation order')\n            if not (isinstance(amounts, (list, tuple)) & (len(amounts) == 4)):\n                raise TypeError('Amounts are a list or tuple of length 4')\n            q0, q1, q2, q3 = amounts\n            parent_orient = (Matrix([[q0**2 + q1**2 - q2**2 - q3**2,\n                                      2 * (q1 * q2 - q0 * q3),\n                                      2 * (q0 * q2 + q1 * q3)],\n                                     [2 * (q1 * q2 + q0 * q3),\n                                      q0**2 - q1**2 + q2**2 - q3**2,\n                                      2 * (q2 * q3 - q0 * q1)],\n                                     [2 * (q1 * q3 - q0 * q2),\n                                      2 * (q0 * q1 + q2 * q3),\n                                      q0**2 - q1**2 - q2**2 + q3**2]]))\n        elif rot_type == 'BODY':\n            if not (len(amounts) == 3 & len(rot_order) == 3):\n                raise TypeError('Body orientation takes 3 values & 3 orders')\n            a1 = int(rot_order[0])\n            a2 = int(rot_order[1])\n            a3 = int(rot_order[2])\n            parent_orient = (_rot(a1, amounts[0]) * _rot(a2, amounts[1]) *\n                             _rot(a3, amounts[2]))\n        elif rot_type == 'SPACE':\n            if not (len(amounts) == 3 & len(rot_order) == 3):\n                raise TypeError('Space orientation takes 3 values & 3 orders')\n            a1 = int(rot_order[0])\n            a2 = int(rot_order[1])\n            a3 = int(rot_order[2])\n            parent_orient = (_rot(a3, amounts[2]) * _rot(a2, amounts[1]) *\n                             _rot(a1, amounts[0]))\n        elif rot_type == 'DCM':\n            parent_orient = amounts\n        else:\n            raise NotImplementedError('That is not an implemented rotation')\n        # Reset the _dcm_cache of this frame, and remove it from the\n        # _dcm_caches of the frames it is linked to. Also remove it from the\n        # _dcm_dict of its parent",
                "filename": "sympy/physics/vector/frame.py",
                "start_index": 27767,
                "end_index": 30767,
                "start_line": 728,
                "end_line": 783,
                "max_line": 1057,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "\"\"\"Sets the orientation of this reference frame relative to another\n        (parent) reference frame.\n\n        Parameters\n        ==========\n\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        rot_type : str\n            The method used to generate the direction cosine matrix. Supported\n            methods are:\n\n            - ``'Axis'``: simple rotations about a single common axis\n            - ``'DCM'``: for setting the direction cosine matrix directly\n            - ``'Body'``: three successive rotations about new intermediate\n              axes, also called \"Euler and Tait-Bryan angles\"\n            - ``'Space'``: three successive rotations about the parent\n              frames' unit vectors\n            - ``'Quaternion'``: rotations defined by four parameters which\n              result in a singularity free direction cosine matrix\n\n        amounts :\n            Expressions defining the rotation angles or direction cosine\n            matrix. These must match the ``rot_type``. See examples below for\n            details. The input types are:\n\n            - ``'Axis'``: 2-tuple (expr/sym/func, Vector)\n            - ``'DCM'``: Matrix, shape(3,3)\n            - ``'Body'``: 3-tuple of expressions, symbols, or functions\n            - ``'Space'``: 3-tuple of expressions, symbols, or functions\n            - ``'Quaternion'``: 4-tuple of expressions, symbols, or\n              functions\n\n        rot_order : str or int, optional\n            If applicable, the order of the successive of rotations. The string\n            ``'123'`` and integer ``123`` are equivalent, for example. Required\n            for ``'Body'`` and ``'Space'``.\n\n        Examples\n        ========\n\n        Setup variables for the examples:\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n        >>> B1 = ReferenceFrame('B')\n        >>> B2 = ReferenceFrame('B2')\n\n        Axis\n        ----\n\n        ``rot_type='Axis'`` creates a direction cosine matrix defined by a\n        simple rotation about a single axis fixed in both reference frames.\n        This is a rotation about an arbitrary, non-time-varying\n        axis by some angle. The axis is supplied as a Vector. This is how\n        simple rotations are defined.\n\n        >>> B.orient(N, 'Axis', (q1, N.x))\n\n        The ``orient()`` method generates a direction cosine matrix and its\n        transpose which defines the orientation of B relative to N and vice\n        versa. Once orient is called, ``dcm()`` outputs the appropriate\n        direction cosine matrix.\n\n        >>> B.dcm(N)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(q1), sin(q1)],\n        [0, -sin(q1), cos(q1)]])\n\n        The following two lines show how the sense of the rotation can be\n        defined. Both lines produce the same result.\n\n        >>> B.orient(N, 'Axis', (q1, -N.x))\n        >>> B.orient(N, 'Axis', (-q1, N.x))\n\n        The axis does not have to be defined by a unit vector, it can be any\n        vector in the parent frame.\n\n        >>> B.orient(N, 'Axis', (q1, N.x + 2 * N.y))\n\n        DCM\n        ---\n\n        The direction cosine matrix can be set directly. The orientation of a\n        frame A can be set to be the same as the frame B above like so:\n\n        >>> B.orient(N, 'Axis', (q1, N.x))\n        >>> A = ReferenceFrame('A')\n        >>> A.orient(N, 'DCM', N.dcm(B))\n        >>> A.dcm(N)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(q1), sin(q1)],\n        [0, -sin(q1), cos(q1)]])\n\n        **Note carefully that** ``N.dcm(B)`` **was passed into** ``orient()``\n        **for** ``A.dcm(N)`` **to match** ``B.dcm(N)``.\n\n        Body\n        ----\n\n        ``rot_type='Body'`` rotates this reference frame relative to the\n        provided reference frame by rotating through three successive simple\n        rotations.  Each subsequent axis of rotation is about the \"body fixed\"\n        unit vectors of the new intermediate reference frame. This type of\n        rotation is also referred to rotating through the `Euler and Tait-Bryan\n        Angles <https://en.wikipedia.org/wiki/Euler_angles>`_.\n\n        For example, the classic Euler Angle rotation can be done by:\n\n        >>> B.orient(N, 'Body', (q1, q2, q3), 'XYX')\n        >>> B.dcm(N)\n        Matrix([\n        [        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n        [sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n        [sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]])\n\n        This rotates B relative to N through ``q1`` about ``N.x``, then rotates\n        B again through q2 about B.y, and finally through q3 about B.x. It is\n        equivalent to:\n\n        >>> B1.orient(N, 'Axis', (q1, N.x))\n        >>> B2.orient(B1, 'Axis', (q2, B1.y))\n        >>> B.orient(B2, 'Axis', (q3, B2.x))\n        >>> B.dcm(N)\n        Matrix([\n        [        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n        [sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n        [sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]])\n\n        Acceptable rotation orders are of length 3, expressed in as a string\n        ``'XYZ'`` or ``'123'`` or integer ``123``. Rotations about an axis\n        twice in a row are prohibited.\n\n        >>> B.orient(N, 'Body', (q1, q2, 0), 'ZXZ')\n        >>> B.orient(N, 'Body', (q1, q2, 0), '121')\n        >>> B.orient(N, 'Body', (q1, q2, q3), 123)\n\n        Space\n        -----\n\n        ``rot_type='Space'`` also rotates the reference frame in three\n        successive simple rotations but the axes of rotation are the\n        \"Space-fixed\" axes. For example:\n\n        >>> B.orient(N, 'Space', (q1, q2, q3), '312')\n        >>> B.dcm(N)\n        Matrix([\n        [ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n        [-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n        [                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]])\n\n        is equivalent to:\n\n        >>> B1.orient(N, 'Axis', (q1, N.z))\n        >>> B2.orient(B1, 'Axis', (q2, N.x))\n        >>> B.orient(B2, 'Axis', (q3, N.y))\n        >>> B.dcm(N).simplify()  # doctest: +SKIP\n        Matrix([\n        [ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n        [-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n        [                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]])\n\n        It is worth noting that space-fixed and body-fixed rotations are\n        related by the order of the rotations, i.e. the reverse order of body\n        fixed will give space fixed and vice versa.\n\n        >>> B.orient(N, 'Space', (q1, q2, q3), '231')\n        >>> B.dcm(N)\n        Matrix([\n        [cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n        [       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n        [sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]])\n\n        >>> B.orient(N, 'Body', (q3, q2, q1), '132')\n        >>> B.dcm(N)\n        Matrix([\n        [cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n        [       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n        [sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]])\n\n        Quaternion\n        ----------\n\n        ``rot_type='Quaternion'`` orients the reference frame using\n        quaternions. Quaternion rotation is defined as a finite rotation about\n        lambda, a unit vector, by an amount theta. This orientation is\n        described by four parameters:\n\n        - ``q0 = cos(theta/2)``\n        - ``q1 = lambda_x sin(theta/2)``\n        - ``q2 = lambda_y sin(theta/2)``\n        - ``q3 = lambda_z sin(theta/2)``\n\n        This type does not need a ``rot_order``.\n\n        >>> B.orient(N, 'Quaternion', (q0, q1, q2, q3))\n        >>> B.dcm(N)\n        Matrix([\n        [q0**2 + q1**2 - q2**2 - q3**2,             2*q0*q3 + 2*q1*q2,            -2*q0*q2 + 2*q1*q3],\n        [           -2*q0*q3 + 2*q1*q2, q0**2 - q1**2 + q2**2 - q3**2,             2*q0*q1 + 2*q2*q3],\n        [            2*q0*q2 + 2*q1*q3,            -2*q0*q1 + 2*q2*q3, q0**2 - q1**2 - q2**2 + q3**2]])\n\n        \"\"\"",
                "filename": "sympy/physics/vector/frame.py",
                "start_index": 16917,
                "end_index": 26005,
                "start_line": 480,
                "end_line": 1043,
                "max_line": 1057,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "class ReferenceFrame(object):",
                "filename": "sympy/physics/vector/frame.py",
                "start_index": 2323,
                "end_index": 2352,
                "start_line": 79,
                "end_line": 79,
                "max_line": 1057,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "elif func_name == \"simprot\":\n                    # A.orient(N, 'Axis', qA, N.z)\n                    if self.type2[ctx.expr(0).getText().lower()] == \"frame\":\n                        frame1 = self.symbol_table2[ctx.expr(0).getText().lower()]\n                    elif self.type2[ctx.expr(0).getText().lower()] == \"bodies\":\n                        frame1 = self.symbol_table2[ctx.expr(0).getText().lower()] + \"_f\"\n                    if self.type2[ctx.expr(1).getText().lower()] == \"frame\":\n                        frame2 = self.symbol_table2[ctx.expr(1).getText().lower()]\n                    elif self.type2[ctx.expr(1).getText().lower()] == \"bodies\":\n                        frame2 = self.symbol_table2[ctx.expr(1).getText().lower()] + \"_f\"\n                    e2 = \"\"\n                    if ctx.expr(2).getText()[0] == \"-\":\n                        e2 = \"-1*\"\n                    if ctx.expr(2).getText() in (\"1\", \"-1\"):\n                        e = frame1 + \".x\"\n                    elif ctx.expr(2).getText() in (\"2\", \"-2\"):\n                        e = frame1 + \".y\"\n                    elif ctx.expr(2).getText() in (\"3\", \"-3\"):\n                        e = frame1 + \".z\"\n                    else:\n                        e = self.getValue(ctx.expr(2))\n                        e2 = \"\"\n\n                    if \"degrees\" in self.settings.keys() and self.settings[\"degrees\"] == \"off\":\n                        value = self.getValue(ctx.expr(3))\n                    else:\n                        if ctx.expr(3) in self.numeric_expr:\n                            value = \"np.deg2rad(\" + self.getValue(ctx.expr(3)) + \")\"\n                        else:\n                            value = self.getValue(ctx.expr(3))\n                    self.write(frame2 + \".orient(\" + frame1 +\n                               \", \" + \"'Axis'\" + \", \" + \"[\" + value +\n                               \", \" + e2 + e + \"]\" + \")\\n\")\n\n                # Express(A2>, B) *",
                "filename": "sympy/parsing/autolev/_listener_autolev_antlr.py",
                "start_index": 89585,
                "end_index": 91519,
                "start_line": 1826,
                "end_line": 1860,
                "max_line": 2083,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "from sympy.core.basic import Basic\nfrom sympy import (sympify, eye, sin, cos, rot_axis1, rot_axis2,\n                   rot_axis3, ImmutableMatrix as Matrix, Symbol)\nfrom sympy.core.cache import cacheit\nimport sympy.vector\n\n\nclass Orienter(Basic):\n    \"\"\"\n    Super-class for all orienter classes.\n    \"\"\"\n\n    def rotation_matrix(self):\n        \"\"\"\n        The rotation matrix corresponding to this orienter\n        instance.\n        \"\"\"\n        return self._parent_orient\n\n\nclass AxisOrienter(Orienter):\n    \"\"\"\n    Class to denote an axis orienter.\n    \"\"\"\n\n    def __new__(cls, angle, axis):\n        if not isinstance(axis, sympy.vector.Vector):\n            raise TypeError(\"axis should be a Vector\")\n        angle = sympify(angle)\n\n        obj = super().__new__(cls, angle, axis)\n        obj._angle = angle\n        obj._axis = axis\n\n        return obj\n\n    def __init__(self, angle, axis):\n        \"\"\"\n        Axis rotation is a rotation about an arbitrary axis by\n        some angle. The angle is supplied as a SymPy expr scalar, and\n        the axis is supplied as a Vector.\n\n        Parameters\n        ==========\n\n        angle : Expr\n            The angle by which the new system is to be rotated\n\n        axis : Vector\n            The axis around which the rotation has to be performed\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q1 = symbols('q1')\n        >>> N = CoordSys3D('N')\n        >>> from sympy.vector import AxisOrienter\n        >>> orienter = AxisOrienter(q1, N.i + 2 * N.j)\n        >>> B = N.orient_new('B', (orienter, ))\n\n        \"\"\"\n        # Dummy initializer for docstrings\n        pass\n\n    @cacheit\n    def rotation_matrix(self, system):\n        \"\"\"\n        The rotation matrix corresponding to this orienter\n        instance.\n\n        Parameters\n        ==========\n\n        system : CoordSys3D\n            The coordinate system wrt which the rotation matrix\n            is to be computed\n        \"\"\"\n\n        axis = sympy.vector.express(self.axis, system).normalize()\n        axis = axis.to_matrix(system)\n        theta = self.angle\n        parent_orient = ((eye(3) - axis * axis.T) * cos(theta) +\n                         Matrix([[0, -axis[2], axis[1]],\n                                 [axis[2], 0, -axis[0]],\n                                 [-axis[1], axis[0], 0]]) * sin(theta) +\n                         axis * axis.T)\n        parent_orient = parent_orient.T\n        return parent_orient\n\n    @property\n    def angle(self):\n        return self._angle\n\n    @property\n    def axis(self):\n        return self._axis",
                "filename": "sympy/vector/orienters.py",
                "start_index": 0,
                "end_index": 2635,
                "start_line": 1,
                "end_line": 98,
                "max_line": 395,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "def _check_frame(other):\n    from .vector import VectorTypeError\n    if not isinstance(other, ReferenceFrame):\n        raise VectorTypeError(other, ReferenceFrame('A'))",
                "filename": "sympy/physics/vector/frame.py",
                "start_index": 40597,
                "end_index": 40765,
                "start_line": 1054,
                "end_line": 1057,
                "max_line": 1057,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "if isinstance(orienters, Orienter):\n            if isinstance(orienters, AxisOrienter):\n                final_matrix = orienters.rotation_matrix(self)\n            else:\n                final_matrix = orienters.rotation_matrix()\n            # TODO: trigsimp is needed here so that the matrix becomes\n            # canonical (scalar_map also calls trigsimp; without this, you can\n            # end up with the same CoordinateSystem that compares differently\n            # due to a differently formatted matrix). However, this is\n            # probably not so good for performance.\n            final_matrix = trigsimp(final_matrix)\n        else:\n            final_matrix = Matrix(eye(3))\n            for orienter in orienters:\n                if isinstance(orienter, AxisOrienter):\n                    final_matrix *= orienter.rotation_matrix(self)\n                else:\n                    final_matrix *= orienter.rotation_matrix()\n\n        return CoordSys3D(name, rotation_matrix=final_matrix,\n                          vector_names=vector_names,\n                          variable_names=variable_names,\n                          location=location,\n                          parent=self)",
                "filename": "sympy/vector/coordsysrect.py",
                "start_index": 25269,
                "end_index": 26456,
                "start_line": 718,
                "end_line": 741,
                "max_line": 1052,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "class ThreeAngleOrienter(Orienter):\n    \"\"\"\n    Super-class for Body and Space orienters.\n    \"\"\"\n\n    def __new__(cls, angle1, angle2, angle3, rot_order):\n        if isinstance(rot_order, Symbol):\n            rot_order = rot_order.name\n\n        approved_orders = ('123', '231', '312', '132', '213',\n                           '321', '121', '131', '212', '232',\n                           '313', '323', '')\n        original_rot_order = rot_order\n        rot_order = str(rot_order).upper()\n        if not (len(rot_order) == 3):\n            raise TypeError('rot_order should be a str of length 3')\n        rot_order = [i.replace('X', '1') for i in rot_order]\n        rot_order = [i.replace('Y', '2') for i in rot_order]\n        rot_order = [i.replace('Z', '3') for i in rot_order]\n        rot_order = ''.join(rot_order)\n        if rot_order not in approved_orders:\n            raise TypeError('Invalid rot_type parameter')\n        a1 = int(rot_order[0])\n        a2 = int(rot_order[1])\n        a3 = int(rot_order[2])\n        angle1 = sympify(angle1)\n        angle2 = sympify(angle2)\n        angle3 = sympify(angle3)\n        if cls._in_order:\n            parent_orient = (_rot(a1, angle1) *\n                             _rot(a2, angle2) *\n                             _rot(a3, angle3))\n        else:\n            parent_orient = (_rot(a3, angle3) *\n                             _rot(a2, angle2) *\n                             _rot(a1, angle1))\n        parent_orient = parent_orient.T\n\n        obj = super().__new__(\n            cls, angle1, angle2, angle3, Symbol(rot_order))\n        obj._angle1 = angle1\n        obj._angle2 = angle2\n        obj._angle3 = angle3\n        obj._rot_order = original_rot_order\n        obj._parent_orient = parent_orient\n\n        return obj\n\n    @property\n    def angle1(self):\n        return self._angle1\n\n    @property\n    def angle2(self):\n        return self._angle2\n\n    @property\n    def angle3(self):\n        return self._angle3\n\n    @property\n    def rot_order(self):\n        return self._rot_order",
                "filename": "sympy/vector/orienters.py",
                "start_index": 2638,
                "end_index": 4668,
                "start_line": 101,
                "end_line": 163,
                "max_line": 395,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            }
        ],
        "classification": "other",
        "snippet_processor_task": {
            "sympy/physics/vector/frame.py": [
                {
                    "chunk": {
                        "code": "frames = self._dcm_cache.keys()\n        dcm_dict_del = []\n        dcm_cache_del = []\n        for frame in frames:\n            if frame in self._dcm_dict:\n                dcm_dict_del += [frame]\n            dcm_cache_del += [frame]\n        for frame in dcm_dict_del:\n            del frame._dcm_dict[self]\n        for frame in dcm_cache_del:\n            del frame._dcm_cache[self]\n        # Add the dcm relationship to _dcm_dict\n        self._dcm_dict = self._dlist[0] = {}\n        self._dcm_dict.update({parent: parent_orient.T})\n        parent._dcm_dict.update({self: parent_orient})\n        # Also update the dcm cache after resetting it\n        self._dcm_cache = {}\n        self._dcm_cache.update({parent: parent_orient.T})\n        parent._dcm_cache.update({self: parent_orient})\n        if rot_type == 'QUATERNION':\n            t = dynamicsymbols._t\n            q0, q1, q2, q3 = amounts\n            q0d = diff(q0, t)\n            q1d = diff(q1, t)\n            q2d = diff(q2, t)\n            q3d = diff(q3, t)\n            w1 = 2 * (q1d * q0 + q2d * q3 - q3d * q2 - q0d * q1)\n            w2 = 2 * (q2d * q0 + q3d * q1 - q1d * q3 - q0d * q2)\n            w3 = 2 * (q3d * q0 + q1d * q2 - q2d * q1 - q0d * q3)\n            wvec = Vector([(Matrix([w1, w2, w3]), self)])\n        elif rot_type == 'AXIS':\n            thetad = (amounts[0]).diff(dynamicsymbols._t)\n            wvec = thetad * amounts[1].express(parent).normalize()\n        elif rot_type == 'DCM':\n            wvec = self._w_diff_dcm(parent)\n        else:\n            try:\n                from sympy.polys.polyerrors import CoercionFailed\n                from sympy.physics.vector.functions import kinematic_equations\n                q1, q2, q3 = amounts\n                u1, u2, u3 = symbols('u1, u2, u3', cls=Dummy)\n                templist = kinematic_equations([u1, u2, u3], [q1, q2, q3],\n                                               rot_type, rot_order)\n                templist = [expand(i) for i in templist]\n                td = solve(templist, [u1, u2, u3])\n                u1 = expand(td[u1])\n                u2 = expand(td[u2])\n                u3 = expand(td[u3])\n                wvec = u1 * self.x + u2 * self.y + u3 * self.z\n            except (CoercionFailed, AssertionError):\n                wvec = self._w_diff_dcm(parent)\n        self._ang_vel_dict.update({parent: wvec})\n        parent._ang_vel_dict.update({self: -wvec})\n        self._var_dict = {}",
                        "filename": "sympy/physics/vector/frame.py",
                        "start_index": 30776,
                        "end_index": 33199,
                        "start_line": 784,
                        "end_line": 837,
                        "max_line": 1057,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.9",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the logic that clears the relationships of `self` when `orient()` is called, which is the core issue described."
                },
                {
                    "chunk": {
                        "code": "if rot_type == 'AXIS':\n            if not rot_order == '':\n                raise TypeError('Axis orientation takes no rotation order')\n            if not (isinstance(amounts, (list, tuple)) & (len(amounts) == 2)):\n                raise TypeError('Amounts are a list or tuple of length 2')\n            theta = amounts[0]\n            axis = amounts[1]\n            axis = _check_vector(axis)\n            if not axis.dt(parent) == 0:\n                raise ValueError('Axis cannot be time-varying')\n            axis = axis.express(parent).normalize()\n            axis = axis.args[0][0]\n            parent_orient = ((eye(3) - axis * axis.T) * cos(theta) +\n                             Matrix([[0, -axis[2], axis[1]],\n                                     [axis[2], 0, -axis[0]],\n                                     [-axis[1], axis[0], 0]]) *\n                             sin(theta) + axis * axis.T)\n        elif rot_type == 'QUATERNION':\n            if not rot_order == '':\n                raise TypeError(\n                    'Quaternion orientation takes no rotation order')\n            if not (isinstance(amounts, (list, tuple)) & (len(amounts) == 4)):\n                raise TypeError('Amounts are a list or tuple of length 4')\n            q0, q1, q2, q3 = amounts\n            parent_orient = (Matrix([[q0**2 + q1**2 - q2**2 - q3**2,\n                                      2 * (q1 * q2 - q0 * q3),\n                                      2 * (q0 * q2 + q1 * q3)],\n                                     [2 * (q1 * q2 + q0 * q3),\n                                      q0**2 - q1**2 + q2**2 - q3**2,\n                                      2 * (q2 * q3 - q0 * q1)],\n                                     [2 * (q1 * q3 - q0 * q2),\n                                      2 * (q0 * q1 + q2 * q3),\n                                      q0**2 - q1**2 - q2**2 + q3**2]]))\n        elif rot_type == 'BODY':\n            if not (len(amounts) == 3 & len(rot_order) == 3):\n                raise TypeError('Body orientation takes 3 values & 3 orders')\n            a1 = int(rot_order[0])\n            a2 = int(rot_order[1])\n            a3 = int(rot_order[2])\n            parent_orient = (_rot(a1, amounts[0]) * _rot(a2, amounts[1]) *\n                             _rot(a3, amounts[2]))\n        elif rot_type == 'SPACE':\n            if not (len(amounts) == 3 & len(rot_order) == 3):\n                raise TypeError('Space orientation takes 3 values & 3 orders')\n            a1 = int(rot_order[0])\n            a2 = int(rot_order[1])\n            a3 = int(rot_order[2])\n            parent_orient = (_rot(a3, amounts[2]) * _rot(a2, amounts[1]) *\n                             _rot(a1, amounts[0]))\n        elif rot_type == 'DCM':\n            parent_orient = amounts\n        else:\n            raise NotImplementedError('That is not an implemented rotation')\n        # Reset the _dcm_cache of this frame, and remove it from the\n        # _dcm_caches of the frames it is linked to. Also remove it from the\n        # _dcm_dict of its parent",
                        "filename": "sympy/physics/vector/frame.py",
                        "start_index": 27767,
                        "end_index": 30767,
                        "start_line": 728,
                        "end_line": 783,
                        "max_line": 1057,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.9",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the implementation of the 'AXIS' rotation type in the `orient()` method, which is relevant to the issue as it is one of the rotation types affected by the clearing of relationships."
                },
                {
                    "chunk": {
                        "code": "\"\"\"Sets the orientation of this reference frame relative to another\n        (parent) reference frame.\n\n        Parameters\n        ==========\n\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        rot_type : str\n            The method used to generate the direction cosine matrix. Supported\n            methods are:\n\n            - ``'Axis'``: simple rotations about a single common axis\n            - ``'DCM'``: for setting the direction cosine matrix directly\n            - ``'Body'``: three successive rotations about new intermediate\n              axes, also called \"Euler and Tait-Bryan angles\"\n            - ``'Space'``: three successive rotations about the parent\n              frames' unit vectors\n            - ``'Quaternion'``: rotations defined by four parameters which\n              result in a singularity free direction cosine matrix\n\n        amounts :\n            Expressions defining the rotation angles or direction cosine\n            matrix. These must match the ``rot_type``. See examples below for\n            details. The input types are:\n\n            - ``'Axis'``: 2-tuple (expr/sym/func, Vector)\n            - ``'DCM'``: Matrix, shape(3,3)\n            - ``'Body'``: 3-tuple of expressions, symbols, or functions\n            - ``'Space'``: 3-tuple of expressions, symbols, or functions\n            - ``'Quaternion'``: 4-tuple of expressions, symbols, or\n              functions\n\n        rot_order : str or int, optional\n            If applicable, the order of the successive of rotations. The string\n            ``'123'`` and integer ``123`` are equivalent, for example. Required\n            for ``'Body'`` and ``'Space'``.\n\n        Examples\n        ========\n\n        Setup variables for the examples:\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n        >>> B1 = ReferenceFrame('B')\n        >>> B2 = ReferenceFrame('B2')\n\n        Axis\n        ----\n\n        ``rot_type='Axis'`` creates a direction cosine matrix defined by a\n        simple rotation about a single axis fixed in both reference frames.\n        This is a rotation about an arbitrary, non-time-varying\n        axis by some angle. The axis is supplied as a Vector. This is how\n        simple rotations are defined.\n\n        >>> B.orient(N, 'Axis', (q1, N.x))\n\n        The ``orient()`` method generates a direction cosine matrix and its\n        transpose which defines the orientation of B relative to N and vice\n        versa. Once orient is called, ``dcm()`` outputs the appropriate\n        direction cosine matrix.\n\n        >>> B.dcm(N)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(q1), sin(q1)],\n        [0, -sin(q1), cos(q1)]])\n\n        The following two lines show how the sense of the rotation can be\n        defined. Both lines produce the same result.\n\n        >>> B.orient(N, 'Axis', (q1, -N.x))\n        >>> B.orient(N, 'Axis', (-q1, N.x))\n\n        The axis does not have to be defined by a unit vector, it can be any\n        vector in the parent frame.\n\n        >>> B.orient(N, 'Axis', (q1, N.x + 2 * N.y))\n\n        DCM\n        ---\n\n        The direction cosine matrix can be set directly. The orientation of a\n        frame A can be set to be the same as the frame B above like so:\n\n        >>> B.orient(N, 'Axis', (q1, N.x))\n        >>> A = ReferenceFrame('A')\n        >>> A.orient(N, 'DCM', N.dcm(B))\n        >>> A.dcm(N)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(q1), sin(q1)],\n        [0, -sin(q1), cos(q1)]])\n\n        **Note carefully that** ``N.dcm(B)`` **was passed into** ``orient()``\n        **for** ``A.dcm(N)`` **to match** ``B.dcm(N)``.\n\n        Body\n        ----\n\n        ``rot_type='Body'`` rotates this reference frame relative to the\n        provided reference frame by rotating through three successive simple\n        rotations.  Each subsequent axis of rotation is about the \"body fixed\"\n        unit vectors of the new intermediate reference frame. This type of\n        rotation is also referred to rotating through the `Euler and Tait-Bryan\n        Angles <https://en.wikipedia.org/wiki/Euler_angles>`_.\n\n        For example, the classic Euler Angle rotation can be done by:\n\n        >>> B.orient(N, 'Body', (q1, q2, q3), 'XYX')\n        >>> B.dcm(N)\n        Matrix([\n        [        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n        [sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n        [sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]])\n\n        This rotates B relative to N through ``q1`` about ``N.x``, then rotates\n        B again through q2 about B.y, and finally through q3 about B.x. It is\n        equivalent to:\n\n        >>> B1.orient(N, 'Axis', (q1, N.x))\n        >>> B2.orient(B1, 'Axis', (q2, B1.y))\n        >>> B.orient(B2, 'Axis', (q3, B2.x))\n        >>> B.dcm(N)\n        Matrix([\n        [        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n        [sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n        [sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]])\n\n        Acceptable rotation orders are of length 3, expressed in as a string\n        ``'XYZ'`` or ``'123'`` or integer ``123``. Rotations about an axis\n        twice in a row are prohibited.\n\n        >>> B.orient(N, 'Body', (q1, q2, 0), 'ZXZ')\n        >>> B.orient(N, 'Body', (q1, q2, 0), '121')\n        >>> B.orient(N, 'Body', (q1, q2, q3), 123)\n\n        Space\n        -----\n\n        ``rot_type='Space'`` also rotates the reference frame in three\n        successive simple rotations but the axes of rotation are the\n        \"Space-fixed\" axes. For example:\n\n        >>> B.orient(N, 'Space', (q1, q2, q3), '312')\n        >>> B.dcm(N)\n        Matrix([\n        [ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n        [-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n        [                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]])\n\n        is equivalent to:\n\n        >>> B1.orient(N, 'Axis', (q1, N.z))\n        >>> B2.orient(B1, 'Axis', (q2, N.x))\n        >>> B.orient(B2, 'Axis', (q3, N.y))\n        >>> B.dcm(N).simplify()  # doctest: +SKIP\n        Matrix([\n        [ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n        [-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n        [                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]])\n\n        It is worth noting that space-fixed and body-fixed rotations are\n        related by the order of the rotations, i.e. the reverse order of body\n        fixed will give space fixed and vice versa.\n\n        >>> B.orient(N, 'Space', (q1, q2, q3), '231')\n        >>> B.dcm(N)\n        Matrix([\n        [cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n        [       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n        [sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]])\n\n        >>> B.orient(N, 'Body', (q3, q2, q1), '132')\n        >>> B.dcm(N)\n        Matrix([\n        [cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n        [       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n        [sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]])\n\n        Quaternion\n        ----------\n\n        ``rot_type='Quaternion'`` orients the reference frame using\n        quaternions. Quaternion rotation is defined as a finite rotation about\n        lambda, a unit vector, by an amount theta. This orientation is\n        described by four parameters:\n\n        - ``q0 = cos(theta/2)``\n        - ``q1 = lambda_x sin(theta/2)``\n        - ``q2 = lambda_y sin(theta/2)``\n        - ``q3 = lambda_z sin(theta/2)``\n\n        This type does not need a ``rot_order``.\n\n        >>> B.orient(N, 'Quaternion', (q0, q1, q2, q3))\n        >>> B.dcm(N)\n        Matrix([\n        [q0**2 + q1**2 - q2**2 - q3**2,             2*q0*q3 + 2*q1*q2,            -2*q0*q2 + 2*q1*q3],\n        [           -2*q0*q3 + 2*q1*q2, q0**2 - q1**2 + q2**2 - q3**2,             2*q0*q1 + 2*q2*q3],\n        [            2*q0*q2 + 2*q1*q3,            -2*q0*q1 + 2*q2*q3, q0**2 - q1**2 - q2**2 + q3**2]])\n\n        \"\"\"",
                        "filename": "sympy/physics/vector/frame.py",
                        "start_index": 16917,
                        "end_index": 26005,
                        "start_line": 480,
                        "end_line": 1043,
                        "max_line": 1057,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.9",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet provides the documentation for the `orient()` method, which is important for understanding how the method is intended to be used and how it relates to the issue."
                }
            ],
            "sympy/vector/orienters.py": [
                {
                    "chunk": {
                        "code": "from sympy.core.basic import Basic\nfrom sympy import (sympify, eye, sin, cos, rot_axis1, rot_axis2,\n                   rot_axis3, ImmutableMatrix as Matrix, Symbol)\nfrom sympy.core.cache import cacheit\nimport sympy.vector\n\n\nclass Orienter(Basic):\n    \"\"\"\n    Super-class for all orienter classes.\n    \"\"\"\n\n    def rotation_matrix(self):\n        \"\"\"\n        The rotation matrix corresponding to this orienter\n        instance.\n        \"\"\"\n        return self._parent_orient\n\n\nclass AxisOrienter(Orienter):\n    \"\"\"\n    Class to denote an axis orienter.\n    \"\"\"\n\n    def __new__(cls, angle, axis):\n        if not isinstance(axis, sympy.vector.Vector):\n            raise TypeError(\"axis should be a Vector\")\n        angle = sympify(angle)\n\n        obj = super().__new__(cls, angle, axis)\n        obj._angle = angle\n        obj._axis = axis\n\n        return obj\n\n    def __init__(self, angle, axis):\n        \"\"\"\n        Axis rotation is a rotation about an arbitrary axis by\n        some angle. The angle is supplied as a SymPy expr scalar, and\n        the axis is supplied as a Vector.\n\n        Parameters\n        ==========\n\n        angle : Expr\n            The angle by which the new system is to be rotated\n\n        axis : Vector\n            The axis around which the rotation has to be performed\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q1 = symbols('q1')\n        >>> N = CoordSys3D('N')\n        >>> from sympy.vector import AxisOrienter\n        >>> orienter = AxisOrienter(q1, N.i + 2 * N.j)\n        >>> B = N.orient_new('B', (orienter, ))\n\n        \"\"\"\n        # Dummy initializer for docstrings\n        pass\n\n    @cacheit\n    def rotation_matrix(self, system):\n        \"\"\"\n        The rotation matrix corresponding to this orienter\n        instance.\n\n        Parameters\n        ==========\n\n        system : CoordSys3D\n            The coordinate system wrt which the rotation matrix\n            is to be computed\n        \"\"\"\n\n        axis = sympy.vector.express(self.axis, system).normalize()\n        axis = axis.to_matrix(system)\n        theta = self.angle\n        parent_orient = ((eye(3) - axis * axis.T) * cos(theta) +\n                         Matrix([[0, -axis[2], axis[1]],\n                                 [axis[2], 0, -axis[0]],\n                                 [-axis[1], axis[0], 0]]) * sin(theta) +\n                         axis * axis.T)\n        parent_orient = parent_orient.T\n        return parent_orient\n\n    @property\n    def angle(self):\n        return self._angle\n\n    @property\n    def axis(self):\n        return self._axis",
                        "filename": "sympy/vector/orienters.py",
                        "start_index": 0,
                        "end_index": 2635,
                        "start_line": 1,
                        "end_line": 98,
                        "max_line": 395,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.9",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the `AxisOrienter` class, which is used in the `orient()` method for 'AXIS' type rotations and is relevant to the issue."
                }
            ]
        },
        "solution_task": "- The issue is related to the `orient` method in the `ReferenceFrame` class, which is causing a \"Loops in graph not allowed\" error.\n- The problem seems to be that the `orient` method is clearing all adjacent relationships when called, which can lead to loops in the orientation graph if the method is called multiple times to establish different relationships.\n\nTo resolve the issue:\n- Modify the `orient` method in the `ReferenceFrame` class to ensure that it does not indiscriminately clear the `_dcm_dict` and `_dcm_cache` of the frames it is linked to.\n- Implement a check to prevent the creation of loops in the orientation graph. This could involve checking for the existence of a path between the current frame and the `other` frame before updating the `_dcm_dict` and `_dcm_cache`.\n- Update the logic that deletes entries from `_dcm_dict` and `_dcm_cache` to only remove the relevant entries instead of clearing the entire dictionary or cache.\n- Ensure that the `orient` method updates the orientation relationships in a way that supports constructing the graph in any sequence without creating loops.\n\nHere is a possible solution:\n\n```python\nclass ReferenceFrame:\n    # ... existing methods ...\n\n    def orient(self, other, rotation_type, rotation_parameters, rot_order=''):\n        # ... existing code ...\n\n        # Check for existing path to prevent loops before updating _dcm_dict\n        if self._exists_path_to(other):\n            raise ValueError(\"Loops in graph not allowed\")\n\n        # Update the dcm relationship to _dcm_dict without clearing all relationships\n        self._dcm_dict.update({other: parent_orient.T})\n        other._dcm_dict.update({self: parent_orient})\n\n        # ... rest of the existing code ...\n\n    def _exists_path_to(self, other):\n        \"\"\"\n        Check if there is a path from self to other in the orientation graph.\n        \"\"\"\n        visited = set()\n\n        def visit(frame):\n            if frame in visited:\n                return False\n            visited.add(frame)\n            for adjacent in frame._dcm_dict.keys():\n                if adjacent == other or visit(adjacent):\n                    return True\n            return False\n\n        return visit(self)\n```\n\n- Add the `_exists_path_to` helper method to the `ReferenceFrame` class to check for the existence of a path between two frames.\n- Call this method in the `orient` method before updating `_dcm_dict` to ensure no loops are created.\n- Update the `_dcm_dict` and `_dcm_cache` dictionaries by adding only the new relationships instead of resetting them entirely.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the problem described in the PROMPT. It correctly identifies the issue with the `orient` method in the `ReferenceFrame` class and suggests modifying the method to prevent the clearing of all adjacent relationships. The RESPONSE also proposes implementing a check to prevent the creation of loops in the orientation graph, which is a direct response to the problem of overwriting relationships. The provided code snippet for the `orient` method and the new `_exists_path_to` helper method are relevant and actionable, offering a clear path to resolving the issue. The RESPONSE also includes references to specific code snippets in the Sympy repository, which could be useful for developers working on the issue. However, the RESPONSE does not address the need for a more thorough consistency check in the graph, which was mentioned in the PROMPT as a potential underlying cause for the current implementation. Therefore, while the RESPONSE is highly relevant and provides a good solution, it is not entirely comprehensive in addressing all aspects of the described bug.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711744301.877206,
        "result": "- The issue is related to the `orient` method in the `ReferenceFrame` class, which is causing a \"Loops in graph not allowed\" error.\n- The problem seems to be that the `orient` method is clearing all adjacent relationships when called, which can lead to loops in the orientation graph if the method is called multiple times to establish different relationships.\n\nTo resolve the issue:\n- Modify the `orient` method in the `ReferenceFrame` class to ensure that it does not indiscriminately clear the `_dcm_dict` and `_dcm_cache` of the frames it is linked to.\n- Implement a check to prevent the creation of loops in the orientation graph. This could involve checking for the existence of a path between the current frame and the `other` frame before updating the `_dcm_dict` and `_dcm_cache`.\n- Update the logic that deletes entries from `_dcm_dict` and `_dcm_cache` to only remove the relevant entries instead of clearing the entire dictionary or cache.\n- Ensure that the `orient` method updates the orientation relationships in a way that supports constructing the graph in any sequence without creating loops.\n\nHere is a possible solution:\n\n```python\nclass ReferenceFrame:\n    # ... existing methods ...\n\n    def orient(self, other, rotation_type, rotation_parameters, rot_order=''):\n        # ... existing code ...\n\n        # Check for existing path to prevent loops before updating _dcm_dict\n        if self._exists_path_to(other):\n            raise ValueError(\"Loops in graph not allowed\")\n\n        # Update the dcm relationship to _dcm_dict without clearing all relationships\n        self._dcm_dict.update({other: parent_orient.T})\n        other._dcm_dict.update({self: parent_orient})\n\n        # ... rest of the existing code ...\n\n    def _exists_path_to(self, other):\n        \"\"\"\n        Check if there is a path from self to other in the orientation graph.\n        \"\"\"\n        visited = set()\n\n        def visit(frame):\n            if frame in visited:\n                return False\n            visited.add(frame)\n            for adjacent in frame._dcm_dict.keys():\n                if adjacent == other or visit(adjacent):\n                    return True\n            return False\n\n        return visit(self)\n```\n\n- Add the `_exists_path_to` helper method to the `ReferenceFrame` class to check for the existence of a path between two frames.\n- Call this method in the `orient` method before updating `_dcm_dict` to ensure no loops are created.\n- Update the `_dcm_dict` and `_dcm_cache` dictionaries by adding only the new relationships instead of resetting them entirely.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [physics](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/physics) \u2192 [vector](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/physics/vector)- [Lines 784 - 837](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/physics/vector/frame.py#L784-L837)\n\n This snippet contains the logic that clears the relationships of `self` when `orient()` is called, which is the core issue described. \n\n\n   - [Lines 728 - 783](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/physics/vector/frame.py#L728-L783)\n\n This snippet shows the implementation of the 'AXIS' rotation type in the `orient()` method, which is relevant to the issue as it is one of the rotation types affected by the clearing of relationships. \n\n\n   - [Lines 480 - 1043](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/physics/vector/frame.py#L480-L1043)\n\n This snippet provides the documentation for the `orient()` method, which is important for understanding how the method is intended to be used and how it relates to the issue.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [vector](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/vector)- [Lines 1 - 98](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/vector/orienters.py#L1-L98)\n\n This snippet defines the `AxisOrienter` class, which is used in the `orient()` method for 'AXIS' type rotations and is relevant to the issue."
    }
}