{
    "id": "sphinx-doc__sphinx-7910",
    "repo_name": "testbed/sphinx-doc__sphinx__3.2",
    "task_id": 6824484298564268319,
    "title": "Decorated __init__ doesn't show up in docs",
    "body": "Subject: Decorated __init__ won't be documented. I'm working on [tensorpack](github.com/ppwwyyxx/tensorpack)\r\n\r\n### Problem\r\n- I have `napoleon_include_init_with_doc = True`, so `__init__` will be documented. But if I decorate the `__init__` method, it will not show up in docs.\r\nI decorate it with `functools.wraps`, so the decorated object still has the same `__doc__`.\r\nI've found that the bug is due to this commit: https://github.com/sphinx-doc/sphinx/commit/bbfd0d058aecf85bd3b711a846c83e2fe00fa136\r\nI've printed the relevant variables in that function:\r\n```\r\nqualname='DistributedTrainerReplicated.__init__'\r\nname='__init__'\r\nobj.__doc__ has contents\r\n```\r\nAnd the root cause of the issue is in this line of code:\r\n```python\r\ncls = obj.__globals__[cls_path]\r\n```\r\nBecause `obj` now is not the method itself, but a decorated method, its `__globals__` does not contain the class anymore. This makes sphinx think it's not a method, i.e. `cls_is_owner=False`.\r\n\r\n\r\n### Environment info\r\n- OS: <Unix/Linux/Mac/Win/other with version>: ArchLinux\r\n- Python version: 3.6\r\n- Sphinx version:1.6.5\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__3.2.git",
    "requested_commit": "",
    "mayil_response": "Based on the provided information, the issue is that the `__init__` method documentation of a class decorated with `functools.wraps` is not showing up in the Sphinx documentation. The problematic line of code is `cls = obj.__globals__[cls_path]` and `cls_is_owner=False` is set when it should not be.\n\nTo resolve the issue:\n\n- Modify the `process_method` function in the `sphinx.ext.napoleon` extension to correctly handle decorated `__init__` methods.\n- Replace the problematic line `cls = obj.__globals__[cls_path]` with a more reliable way to get the class object of the method.\n- Ensure that `cls_is_owner` is set to `True` when the class is indeed the owner of the `__init__` method.\n\nHere is a potential solution:\n\n```python\n# In sphinx/ext/napoleon/__init__.py\n\nif name != '__weakref__' and has_doc and is_member:\n    cls_is_owner = False\n    if what in ('class', 'exception'):\n        qualname = getattr(obj, '__qualname__', '')\n        cls_path, _, _ = qualname.rpartition('.')\n        if cls_path:\n            try:\n                cls = inspect.unwrap(obj)\n                if hasattr(cls, '__name__') and cls.__name__ == cls_path.split('.')[-1]:\n                    cls_is_owner = True\n            except Exception:\n                cls_is_owner = False\n    # ... rest of the code remains unchanged\n```\n\nThis solution uses `inspect.unwrap` to retrieve the original function object from the decorated `__init__` method and then checks if the class name matches the last part of `cls_path`. If it does, `cls_is_owner` is set to `True`, allowing the `__init__` method to be documented.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.2/tree//sphinx) \u2192 [ext](https://github.com/testbed/sphinx-doc__sphinx__3.2/tree//sphinx/ext) \u2192 [napoleon](https://github.com/testbed/sphinx-doc__sphinx__3.2/tree//sphinx/ext/napoleon)- [Lines 437 - 474](https://github.com/testbed/sphinx-doc__sphinx__3.2/blob//sphinx/ext/napoleon/__init__.py#L437-L474)\n\n This snippet contains the code where the issue is occurring, specifically the line with 'cls = inspect.unwrap(obj).__globals__[cls_path]' which is causing the decorated __init__ method to not be documented correctly.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000338,
        "snippet_processor": 0.11353,
        "issue_star_creation": 0.02701,
        "issue_star_solver": 0.05892,
        "bouncer": 0.022850000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711703859.1016278,
        "relevant_snippets": [
            {
                "code": "if name != '__weakref__' and has_doc and is_member:\n        cls_is_owner = False\n        if what in ('class', 'exception'):\n            qualname = getattr(obj, '__qualname__', '')\n            cls_path, _, _ = qualname.rpartition('.')\n            if cls_path:\n                try:\n                    if '.' in cls_path:\n                        import functools\n                        import importlib\n\n                        mod = importlib.import_module(obj.__module__)\n                        mod_path = cls_path.split('.')\n                        cls = functools.reduce(getattr, mod_path, mod)\n                    else:\n                        cls = inspect.unwrap(obj).__globals__[cls_path]\n                except Exception:\n                    cls_is_owner = False\n                else:\n                    cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore\n                                    name in cls.__dict__)\n            else:\n                cls_is_owner = False\n\n        if what == 'module' or cls_is_owner:\n            is_init = (name == '__init__')\n            is_special = (not is_init and name.startswith('__') and\n                          name.endswith('__'))\n            is_private = (not is_init and not is_special and\n                          name.startswith('_'))\n            inc_init = app.config.napoleon_include_init_with_doc\n            inc_special = app.config.napoleon_include_special_with_doc\n            inc_private = app.config.napoleon_include_private_with_doc\n            if ((is_special and inc_special) or\n                    (is_private and inc_private) or\n                    (is_init and inc_init)):\n                return False\n    return None",
                "filename": "sphinx/ext/napoleon/__init__.py",
                "start_index": 16236,
                "end_index": 17935,
                "start_line": 437,
                "end_line": 474,
                "max_line": 474,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "if undoc['classes']:\n                        op.write('Classes:\\n')\n                        for class_name, methods in sorted(\n                                undoc['classes'].items()):\n                            if not methods:\n                                op.write(' * %s\\n' % class_name)\n                                if self.config.coverage_show_missing_items:\n                                    if self.app.quiet or self.app.warningiserror:\n                                        logger.warning(\n                                            __('undocumented python class: %s :: %s'),\n                                            name, class_name)\n                                    else:\n                                        logger.info(red('undocumented  ') + 'py  ' +\n                                                    'class     ' + '%-30s' % class_name +\n                                                    red(' - in module ') + name)\n                            else:\n                                op.write(' * %s -- missing methods:\\n\\n' % class_name)\n                                op.writelines('   - %s\\n' % x for x in methods)\n                                if self.config.coverage_show_missing_items:\n                                    if self.app.quiet or self.app.warningiserror:\n                                        for meth in methods:\n                                            logger.warning(\n                                                __('undocumented python method:' +\n                                                   ' %s :: %s :: %s'),\n                                                name, class_name, meth)\n                                    else:\n                                        for meth in methods:\n                                            logger.info(red('undocumented  ') + 'py  ' +\n                                                        'method    ' + '%-30s' %\n                                                        (class_name + '.' + meth) +\n                                                        red(' - in module ') + name)\n                        op.write('\\n')",
                "filename": "sphinx/ext/coverage.py",
                "start_index": 10707,
                "end_index": 12849,
                "start_line": 259,
                "end_line": 290,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    # I need autodoc\n    app.setup_extension('sphinx.ext.autodoc')\n    app.add_node(autosummary_toc,\n                 html=(autosummary_toc_visit_html, autosummary_noop),\n                 latex=(autosummary_noop, autosummary_noop),\n                 text=(autosummary_noop, autosummary_noop),\n                 man=(autosummary_noop, autosummary_noop),\n                 texinfo=(autosummary_noop, autosummary_noop))\n    app.add_node(autosummary_table,\n                 html=(autosummary_table_visit_html, autosummary_noop),\n                 latex=(autosummary_noop, autosummary_noop),\n                 text=(autosummary_noop, autosummary_noop),\n                 man=(autosummary_noop, autosummary_noop),\n                 texinfo=(autosummary_noop, autosummary_noop))\n    app.add_directive('autosummary', Autosummary)\n    app.add_role('autolink', AutoLink())\n    app.connect('builder-inited', process_generate_options)\n    app.add_config_value('autosummary_context', {}, True)\n    app.add_config_value('autosummary_filename_map', {}, 'html')\n    app.add_config_value('autosummary_generate', True, True, [bool, list])\n    app.add_config_value('autosummary_generate_overwrite', True, False)\n    app.add_config_value('autosummary_mock_imports',\n                         lambda config: config.autodoc_mock_imports, 'env')\n    app.add_config_value('autosummary_imported_members', [], False, [bool])\n    app.add_config_value('autosummary_ignore_module_all', True, 'env', bool)\n\n    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}",
                "filename": "sphinx/ext/autosummary/__init__.py",
                "start_index": 29466,
                "end_index": 31055,
                "start_line": 814,
                "end_line": 841,
                "max_line": 841,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "class PyDecoratorMethod(PyMethod):\n    \"\"\"Description of a decoratormethod.\"\"\"\n\n    def run(self) -> list[Node]:\n        self.name = 'py:method'\n        return super().run()\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> tuple[str, str]:\n        ret = super().handle_signature(sig, signode)\n        signode.insert(0, addnodes.desc_addname('@', '@'))\n        return ret\n\n    def needs_arglist(self) -> bool:\n        return False\n\n\nclass PyAttribute(PyObject):\n    \"\"\"Description of an attribute.\"\"\"\n\n    option_spec: OptionSpec = PyObject.option_spec.copy()\n    option_spec.update({\n        'type': directives.unchanged,\n        'value': directives.unchanged,\n    })\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> tuple[str, str]:\n        fullname, prefix = super().handle_signature(sig, signode)\n\n        typ = self.options.get('type')\n        if typ:\n            annotations = _parse_annotation(typ, self.env)\n            signode += addnodes.desc_annotation(typ, '',\n                                                addnodes.desc_sig_punctuation('', ':'),\n                                                addnodes.desc_sig_space(),\n                                                *annotations)\n\n        value = self.options.get('value')\n        if value:\n            signode += addnodes.desc_annotation(value, '',\n                                                addnodes.desc_sig_space(),\n                                                addnodes.desc_sig_punctuation('', '='),\n                                                addnodes.desc_sig_space(),\n                                                nodes.Text(value))\n\n        return fullname, prefix\n\n    def get_index_text(self, modname: str, name_cls: tuple[str, str]) -> str:\n        name, cls = name_cls\n        try:\n            clsname, attrname = name.rsplit('.', 1)\n            if modname and self.env.config.add_module_names:\n                clsname = '.'.join([modname, clsname])\n        except ValueError:\n            if modname:\n                return _('%s (in module %s)') % (name, modname)\n            else:\n                return name\n\n        return _('%s (%s attribute)') % (attrname, clsname)",
                "filename": "sphinx/domains/python.py",
                "start_index": 35001,
                "end_index": 37208,
                "start_line": 902,
                "end_line": 960,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "if not undoc['classes'] and not undoc['funcs']:\n                        continue\n\n                    write_header(op, name)\n                    if undoc['funcs']:\n                        op.write('Functions:\\n')\n                        op.writelines(' * %s\\n' % x for x in undoc['funcs'])\n                        if self.config.coverage_show_missing_items:\n                            if self.app.quiet or self.app.warningiserror:\n                                for func in undoc['funcs']:\n                                    logger.warning(\n                                        __('undocumented python function: %s :: %s'),\n                                        name, func)\n                            else:\n                                for func in undoc['funcs']:\n                                    logger.info(red('undocumented  ') + 'py  ' + 'function  ' +\n                                                '%-30s' % func + red(' - in module ') + name)\n                        op.write('\\n')",
                "filename": "sphinx/ext/coverage.py",
                "start_index": 9682,
                "end_index": 10686,
                "start_line": 241,
                "end_line": 290,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "for name, obj in inspect.getmembers(mod):\n                # diverse module attributes are ignored:\n                if name[0] == '_':\n                    # begins in an underscore\n                    continue\n                if not hasattr(obj, '__module__'):\n                    # cannot be attributed to a module\n                    continue\n                if obj.__module__ != mod_name:\n                    # is not defined in this module\n                    continue\n\n                full_name = f'{mod_name}.{name}'\n                if self.ignore_pyobj(full_name):\n                    continue\n\n                if inspect.isfunction(obj):\n                    if full_name not in objects:\n                        for exp in self.fun_ignorexps:\n                            if exp.match(name):\n                                break\n                        else:\n                            if skip_undoc and not obj.__doc__:\n                                continue\n                            funcs.append(name)\n                elif inspect.isclass(obj):\n                    for exp in self.cls_ignorexps:\n                        if exp.match(name):\n                            break\n                    else:\n                        if full_name not in objects:\n                            if skip_undoc and not obj.__doc__:\n                                continue\n                            # not documented at all\n                            classes[name] = []\n                            continue\n\n                        attrs: list[str] = []\n\n                        for attr_name in dir(obj):\n                            if attr_name not in obj.__dict__:\n                                continue\n                            try:\n                                attr = safe_getattr(obj, attr_name)\n                            except AttributeError:\n                                continue\n                            if not (inspect.ismethod(attr) or\n                                    inspect.isfunction(attr)):\n                                continue\n                            if attr_name[0] == '_':\n                                # starts with an underscore, ignore it\n                                continue\n                            if skip_undoc and not attr.__doc__:\n                                # skip methods without docstring if wished\n                                continue\n                            full_attr_name = f'{full_name}.{attr_name}'\n                            if self.ignore_pyobj(full_attr_name):\n                                continue\n                            if full_attr_name not in objects:\n                                attrs.append(attr_name)\n                        if attrs:\n                            # some attributes are undocumented\n                            classes[name] = attrs\n\n            self.py_undoc[mod_name] = {'funcs': funcs, 'classes': classes}",
                "filename": "sphinx/ext/coverage.py",
                "start_index": 6188,
                "end_index": 9119,
                "start_line": 163,
                "end_line": 227,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "\"\"\"Support for NumPy and Google style docstrings.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nimport sphinx\nfrom sphinx.application import Sphinx\nfrom sphinx.ext.napoleon.docstring import GoogleDocstring, NumpyDocstring\nfrom sphinx.util import inspect",
                "filename": "sphinx/ext/napoleon/__init__.py",
                "start_index": 0,
                "end_index": 271,
                "start_line": 1,
                "end_line": 10,
                "max_line": 474,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "display_name = name\n            if name.startswith('~'):\n                name = name[1:]\n                display_name = name.split('.')[-1]\n\n            try:\n                real_name, obj, parent, modname = self.import_by_name(name, prefixes=prefixes)\n            except ImportExceptionGroup as exc:\n                errors = list({f\"* {type(e).__name__}: {e}\" for e in exc.exceptions})\n                logger.warning(__('autosummary: failed to import %s.\\nPossible hints:\\n%s'),\n                               name, '\\n'.join(errors), location=self.get_location())\n                continue\n\n            self.bridge.result = StringList()  # initialize for each documenter\n            full_name = real_name\n            if not isinstance(obj, ModuleType):\n                # give explicitly separated module name, so that members\n                # of inner classes can be documented\n                full_name = modname + '::' + full_name[len(modname) + 1:]\n            # NB. using full_name here is important, since Documenters\n            #     handle module prefixes slightly differently\n            documenter = self.create_documenter(self.env.app, obj, parent, full_name)\n            if not documenter.parse_name():\n                logger.warning(__('failed to parse name %s'), real_name,\n                               location=self.get_location())\n                items.append((display_name, '', '', real_name))\n                continue\n            if not documenter.import_object():\n                logger.warning(__('failed to import object %s'), real_name,\n                               location=self.get_location())\n                items.append((display_name, '', '', real_name))\n                continue\n\n            # try to also get a source code analyzer for attribute docs\n            try:\n                documenter.analyzer = ModuleAnalyzer.for_module(\n                    documenter.get_real_modname())\n                # parse right now, to get PycodeErrors on parsing (results will\n                # be cached anyway)\n                documenter.analyzer.find_attr_docs()\n            except PycodeError as err:\n                logger.debug('[autodoc] module analyzer failed: %s', err)\n                # no source file -- e.g. for builtin and C modules\n                documenter.analyzer = None\n\n            # -- Grab the signature\n\n            try:\n                sig = documenter.format_signature(show_annotation=False)\n            except TypeError:\n                # the documenter does not support ``show_annotation`` option\n                sig = documenter.format_signature()\n\n            if not sig:\n                sig = ''\n            else:\n                max_chars = max(10, max_item_chars - len(display_name))\n                sig = mangle_signature(sig, max_chars=max_chars)\n\n            # -- Grab the summary\n\n            # bodge for ModuleDocumenter\n            documenter._extra_indent = ''  # type: ignore[attr-defined]\n\n            documenter.add_content(None)",
                "filename": "sphinx/ext/autosummary/__init__.py",
                "start_index": 10578,
                "end_index": 13571,
                "start_line": 309,
                "end_line": 373,
                "max_line": 841,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "\"\"\"Document tree nodes that Sphinx defines on top of those in Docutils.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Sequence\n\nfrom docutils import nodes\nfrom docutils.nodes import Element\n\nif TYPE_CHECKING:\n    from sphinx.application import Sphinx\n\n# deprecated name -> (object to return, canonical path or empty string)\n_DEPRECATED_OBJECTS = {\n    'meta': (nodes.meta, 'docutils.nodes.meta'),  # type: ignore[attr-defined]\n    'docutils_meta': (nodes.meta, 'docutils.nodes.meta'),  # type: ignore[attr-defined]\n}\n\n\ndef __getattr__(name):\n    if name not in _DEPRECATED_OBJECTS:\n        raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\n\n    from sphinx.deprecation import _deprecation_warning\n\n    deprecated_object, canonical_name = _DEPRECATED_OBJECTS[name]\n    _deprecation_warning(__name__, name, canonical_name, remove=(7, 0))\n    return deprecated_object\n\n\nclass document(nodes.document):\n    \"\"\"The document root element patched by Sphinx.\n\n    This fixes that document.set_id() does not support a node having multiple node Ids.\n    see https://sourceforge.net/p/docutils/patches/167/\n\n    .. important:: This is only for Sphinx internal use.  Please don't use this\n                   in your extensions.  It will be removed without deprecation period.\n    \"\"\"\n\n    def set_id(self, node: Element, msgnode: Element | None = None,\n               suggested_prefix: str = '') -> str:\n        return super().set_id(node, msgnode, suggested_prefix)  # type: ignore\n\n\nclass translatable(nodes.Node):\n    \"\"\"Node which supports translation.\n\n    The translation goes forward with following steps:\n\n    1. Preserve original translatable messages\n    2. Apply translated messages from message catalog\n    3. Extract preserved messages (for gettext builder)\n\n    The translatable nodes MUST preserve original messages.\n    And these messages should not be overridden at applying step.\n    Because they are used at final step; extraction.\n    \"\"\"\n\n    def preserve_original_messages(self) -> None:\n        \"\"\"Preserve original translatable messages.\"\"\"\n        raise NotImplementedError\n\n    def apply_translated_message(self, original_message: str, translated_message: str) -> None:\n        \"\"\"Apply translated message.\"\"\"\n        raise NotImplementedError\n\n    def extract_original_messages(self) -> Sequence[str]:\n        \"\"\"Extract translation messages.\n\n        :returns: list of extracted messages or messages generator\n        \"\"\"\n        raise NotImplementedError\n\n\nclass not_smartquotable:\n    \"\"\"A node which does not support smart-quotes.\"\"\"\n    support_smartquotes = False",
                "filename": "sphinx/addnodes.py",
                "start_index": 0,
                "end_index": 2638,
                "start_line": 1,
                "end_line": 78,
                "max_line": 568,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            },
            {
                "code": "# -- autosummary_toc node ------------------------------------------------------\n\nclass autosummary_toc(nodes.comment):\n    pass\n\n\ndef autosummary_toc_visit_html(self: nodes.NodeVisitor, node: autosummary_toc) -> None:\n    \"\"\"Hide autosummary toctree list in HTML output.\"\"\"\n    raise nodes.SkipNode\n\n\ndef autosummary_noop(self: nodes.NodeVisitor, node: Node) -> None:\n    pass\n\n\n# -- autosummary_table node ----------------------------------------------------\n\nclass autosummary_table(nodes.comment):\n    pass\n\n\ndef autosummary_table_visit_html(self: HTML5Translator, node: autosummary_table) -> None:\n    \"\"\"Make the first column of the table non-breaking.\"\"\"\n    try:\n        table = cast(nodes.table, node[0])\n        tgroup = cast(nodes.tgroup, table[0])\n        tbody = cast(nodes.tbody, tgroup[-1])\n        rows = cast(List[nodes.row], tbody)\n        for row in rows:\n            col1_entry = cast(nodes.entry, row[0])\n            par = cast(nodes.paragraph, col1_entry[0])\n            for j, subnode in enumerate(list(par)):\n                if isinstance(subnode, nodes.Text):\n                    new_text = subnode.astext().replace(\" \", \"\\u00a0\")\n                    par[j] = nodes.Text(new_text)\n    except IndexError:\n        pass\n\n\n# -- autodoc integration -------------------------------------------------------\n\nclass FakeApplication:\n    def __init__(self) -> None:\n        self.doctreedir = None\n        self.events = None\n        self.extensions: dict[str, Extension] = {}\n        self.srcdir = None\n        self.config = Config()\n        self.project = Project(None, None)\n        self.registry = SphinxComponentRegistry()\n\n\nclass FakeDirective(DocumenterBridge):\n    def __init__(self) -> None:\n        settings = Struct(tab_width=8)\n        document = Struct(settings=settings)\n        app = FakeApplication()\n        app.config.add('autodoc_class_signature', 'mixed', True, None)\n        env = BuildEnvironment(app)  # type: ignore\n        state = Struct(document=document)\n        super().__init__(env, None, Options(), 0, state)",
                "filename": "sphinx/ext/autosummary/__init__.py",
                "start_index": 2965,
                "end_index": 5016,
                "start_line": 103,
                "end_line": 163,
                "max_line": 841,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sphinx/ext/napoleon/__init__.py": [
                {
                    "chunk": {
                        "code": "if name != '__weakref__' and has_doc and is_member:\n        cls_is_owner = False\n        if what in ('class', 'exception'):\n            qualname = getattr(obj, '__qualname__', '')\n            cls_path, _, _ = qualname.rpartition('.')\n            if cls_path:\n                try:\n                    if '.' in cls_path:\n                        import functools\n                        import importlib\n\n                        mod = importlib.import_module(obj.__module__)\n                        mod_path = cls_path.split('.')\n                        cls = functools.reduce(getattr, mod_path, mod)\n                    else:\n                        cls = inspect.unwrap(obj).__globals__[cls_path]\n                except Exception:\n                    cls_is_owner = False\n                else:\n                    cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore\n                                    name in cls.__dict__)\n            else:\n                cls_is_owner = False\n\n        if what == 'module' or cls_is_owner:\n            is_init = (name == '__init__')\n            is_special = (not is_init and name.startswith('__') and\n                          name.endswith('__'))\n            is_private = (not is_init and not is_special and\n                          name.startswith('_'))\n            inc_init = app.config.napoleon_include_init_with_doc\n            inc_special = app.config.napoleon_include_special_with_doc\n            inc_private = app.config.napoleon_include_private_with_doc\n            if ((is_special and inc_special) or\n                    (is_private and inc_private) or\n                    (is_init and inc_init)):\n                return False\n    return None",
                        "filename": "sphinx/ext/napoleon/__init__.py",
                        "start_index": 16236,
                        "end_index": 17935,
                        "start_line": 437,
                        "end_line": 474,
                        "max_line": 474,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__3.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the code where the issue is occurring, specifically the line with 'cls = inspect.unwrap(obj).__globals__[cls_path]' which is causing the decorated __init__ method to not be documented correctly."
                }
            ]
        },
        "solution_task": "Based on the provided information, the issue is that the `__init__` method documentation of a class decorated with `functools.wraps` is not showing up in the Sphinx documentation. The problematic line of code is `cls = obj.__globals__[cls_path]` and `cls_is_owner=False` is set when it should not be.\n\nTo resolve the issue:\n\n- Modify the `process_method` function in the `sphinx.ext.napoleon` extension to correctly handle decorated `__init__` methods.\n- Replace the problematic line `cls = obj.__globals__[cls_path]` with a more reliable way to get the class object of the method.\n- Ensure that `cls_is_owner` is set to `True` when the class is indeed the owner of the `__init__` method.\n\nHere is a potential solution:\n\n```python\n# In sphinx/ext/napoleon/__init__.py\n\nif name != '__weakref__' and has_doc and is_member:\n    cls_is_owner = False\n    if what in ('class', 'exception'):\n        qualname = getattr(obj, '__qualname__', '')\n        cls_path, _, _ = qualname.rpartition('.')\n        if cls_path:\n            try:\n                cls = inspect.unwrap(obj)\n                if hasattr(cls, '__name__') and cls.__name__ == cls_path.split('.')[-1]:\n                    cls_is_owner = True\n            except Exception:\n                cls_is_owner = False\n    # ... rest of the code remains unchanged\n```\n\nThis solution uses `inspect.unwrap` to retrieve the original function object from the decorated `__init__` method and then checks if the class name matches the last part of `cls_path`. If it does, `cls_is_owner` is set to `True`, allowing the `__init__` method to be documented.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT. It suggests modifying the 'process_method' function in the 'sphinx.ext.napoleon' extension to handle decorated '__init__' methods correctly. The RESPONSE also offers a potential solution using 'inspect.unwrap' to retrieve the original function object from the decorated '__init__' method, which is a valid approach to the problem. The RESPONSE includes a code snippet that could potentially fix the issue and references the exact location in the Sphinx repository where the problematic code resides. However, the RESPONSE does not address the specific commit mentioned in the PROMPT that introduced the bug, nor does it provide a complete solution that could be directly implemented without further testing and validation.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711704567.348456,
        "result": "Based on the provided information, the issue is that the `__init__` method documentation of a class decorated with `functools.wraps` is not showing up in the Sphinx documentation. The problematic line of code is `cls = obj.__globals__[cls_path]` and `cls_is_owner=False` is set when it should not be.\n\nTo resolve the issue:\n\n- Modify the `process_method` function in the `sphinx.ext.napoleon` extension to correctly handle decorated `__init__` methods.\n- Replace the problematic line `cls = obj.__globals__[cls_path]` with a more reliable way to get the class object of the method.\n- Ensure that `cls_is_owner` is set to `True` when the class is indeed the owner of the `__init__` method.\n\nHere is a potential solution:\n\n```python\n# In sphinx/ext/napoleon/__init__.py\n\nif name != '__weakref__' and has_doc and is_member:\n    cls_is_owner = False\n    if what in ('class', 'exception'):\n        qualname = getattr(obj, '__qualname__', '')\n        cls_path, _, _ = qualname.rpartition('.')\n        if cls_path:\n            try:\n                cls = inspect.unwrap(obj)\n                if hasattr(cls, '__name__') and cls.__name__ == cls_path.split('.')[-1]:\n                    cls_is_owner = True\n            except Exception:\n                cls_is_owner = False\n    # ... rest of the code remains unchanged\n```\n\nThis solution uses `inspect.unwrap` to retrieve the original function object from the decorated `__init__` method and then checks if the class name matches the last part of `cls_path`. If it does, `cls_is_owner` is set to `True`, allowing the `__init__` method to be documented.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.2/tree//sphinx) \u2192 [ext](https://github.com/testbed/sphinx-doc__sphinx__3.2/tree//sphinx/ext) \u2192 [napoleon](https://github.com/testbed/sphinx-doc__sphinx__3.2/tree//sphinx/ext/napoleon)- [Lines 437 - 474](https://github.com/testbed/sphinx-doc__sphinx__3.2/blob//sphinx/ext/napoleon/__init__.py#L437-L474)\n\n This snippet contains the code where the issue is occurring, specifically the line with 'cls = inspect.unwrap(obj).__globals__[cls_path]' which is causing the decorated __init__ method to not be documented correctly."
    }
}