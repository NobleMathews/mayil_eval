{
    "id": "matplotlib__matplotlib-25430",
    "repo_name": "testbed/matplotlib__matplotlib__3.7",
    "task_id": 3558564400985586454,
    "title": "[Bug]: savefig + jpg + metadata fails with inscrutable error message",
    "body": "### Bug summary\n\nIf we call `savefig` with a `filename` with a `.jpg` extension, with the `metadata` kwarg specified, the error message is inscrutable.\n\n### Code for reproduction\n\n```python\n#!/usr/bin/env python3\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\nplt.style.use('_mpl-gallery')\r\n\r\n# make data\r\nx = np.linspace(0, 10, 100)\r\ny = 4 + 2 * np.sin(2 * x)\r\n\r\n# plot\r\nfig, ax = plt.subplots()\r\n\r\nax.plot(x, y, linewidth=2.0)\r\n\r\nax.set(xlim=(0, 8), xticks=np.arange(1, 8),\r\n       ylim=(0, 8), yticks=np.arange(1, 8))\r\n\r\nplt.savefig(\"sin.jpg\", metadata={})\n```\n\n\n### Actual outcome\n\n```\r\nTraceback (most recent call last):\r\n  File \"/private/tmp/./reproduce.py\", line 19, in <module>\r\n    plt.savefig(\"sin.jpg\", metadata={})\r\n  File \"/private/tmp/lib/python3.11/site-packages/matplotlib/pyplot.py\", line 1023, in savefig\r\n    res = fig.savefig(*args, **kwargs)\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/private/tmp/lib/python3.11/site-packages/matplotlib/figure.py\", line 3343, in savefig\r\n    self.canvas.print_figure(fname, **kwargs)\r\n  File \"/private/tmp/lib/python3.11/site-packages/matplotlib/backend_bases.py\", line 2366, in print_figure\r\n    result = print_method(\r\n             ^^^^^^^^^^^^^\r\n  File \"/private/tmp/lib/python3.11/site-packages/matplotlib/backend_bases.py\", line 2232, in <lambda>\r\n    print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\r\n                                                                 ^^^^^\r\nTypeError: FigureCanvasAgg.print_jpg() got an unexpected keyword argument 'metadata'\r\n```\n\n### Expected outcome\n\nEither metadata should be added, the argument ignored, or a more informative error message.\n\n### Additional information\n\n_No response_\n\n### Operating system\n\nOS/X\n\n### Matplotlib Version\n\n3.7.1\n\n### Matplotlib Backend\n\nMacOSX\n\n### Python version\n\nPython 3.11.2\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\npip\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.7.git",
    "requested_commit": "",
    "mayil_response": "- Check if the `metadata` argument is being passed to the `print_jpg` method inappropriately.\n- Modify the `savefig` function to ensure that `metadata` is not passed to `print_jpg` or any other method that does not support it.\n- Implement a check within `savefig` to only include `metadata` in the call to the print method if the output format supports it.\n- If the format is `.jpg`, either remove the `metadata` argument before calling `print_jpg` or update the documentation to clearly state that metadata is not supported for JPEG files.\n\nHere is a possible solution:\n\n```python\ndef savefig(fname, *, metadata=None, **kwargs):\n    # ... [rest of the savefig code] ...\n\n    # Determine the format based on the extension of the file name\n    _, ext = os.path.splitext(fname)\n    format = ext[1:].lower() if ext else None\n\n    # Check if the format supports metadata\n    if format not in ['png', 'pdf', 'svg', 'eps', 'ps']:\n        metadata = None  # Do not pass metadata to formats that do not support it\n\n    # ... [code to call the appropriate print method, e.g., print_jpg, print_png, etc.] ...\n\n    # Example of calling a print method without passing metadata if not supported\n    if format == 'jpg':\n        self.canvas.print_jpg(fname, **kwargs)\n    else:\n        self.canvas.print_figure(fname, metadata=metadata, **kwargs)\n\n    # ... [rest of the savefig code] ...\n```\n\n- Ensure that the `metadata` argument is not included in the call to `print_jpg` if the file format is JPEG.\n- Update the documentation of `savefig` to reflect that metadata is not supported for JPEG files.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib/backends)- [Lines 450 - 521](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_agg.py#L450-L521)\n\n This snippet contains the implementation of the `print_png` method which handles metadata for PNG files. It is relevant because the issue is related to handling metadata, and a similar implementation or error handling might be needed for JPG files. \n\n\n   - [Lines 523 - 537](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_agg.py#L523-L537)\n\n This snippet shows the `print_jpg` method which is directly related to the error message in the issue. It is relevant because it is the method that needs to be modified to either handle metadata correctly or provide a better error message.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib)- [Lines 1 - 3531](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/figure.py#L1-L3531)\n\n This snippet from 'lib/matplotlib/figure.py' contains the `savefig` method which is the entry point for saving figures and includes the `metadata` parameter. It is relevant because the issue occurs when calling `savefig` with metadata for a JPG file.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00026,
        "snippet_processor": 0.051089999999999997,
        "issue_star_creation": 0.03065,
        "issue_star_solver": 0.08149,
        "bouncer": 0.0324
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711696931.0821388,
        "relevant_snippets": [
            {
                "code": "if metadata is None:\n            metadata = {}\n        metadata = {\n            'Format': 'image/svg+xml',\n            'Type': 'http://purl.org/dc/dcmitype/StillImage',\n            'Creator':\n                f'Matplotlib v{mpl.__version__}, https://matplotlib.org/',\n            **metadata\n        }\n        writer = self.writer\n\n        if 'Title' in metadata:\n            title = metadata['Title']\n            _check_is_str(title, 'Title')\n            writer.element('title', text=title)\n\n        # Special handling.\n        date = metadata.get('Date', None)\n        if date is not None:\n            if isinstance(date, str):\n                dates = [date]\n            elif isinstance(date, (datetime.datetime, datetime.date)):\n                dates = [date.isoformat()]\n            elif np.iterable(date):\n                dates = []\n                for d in date:\n                    if isinstance(d, str):\n                        dates.append(d)\n                    elif isinstance(d, (datetime.datetime, datetime.date)):\n                        dates.append(d.isoformat())\n                    else:\n                        raise TypeError(\n                            f'Invalid type for Date metadata. '\n                            f'Expected iterable of str, date, or datetime, '\n                            f'not {type(d)}.')\n            else:\n                raise TypeError(f'Invalid type for Date metadata. '\n                                f'Expected str, date, datetime, or iterable '\n                                f'of the same, not {type(date)}.')\n            metadata['Date'] = '/'.join(dates)\n        elif 'Date' not in metadata:\n            # Do not add `Date` if the user explicitly set `Date` to `None`\n            # Get source date from SOURCE_DATE_EPOCH, if set.\n            # See https://reproducible-builds.org/specs/source-date-epoch/\n            date = os.getenv(\"SOURCE_DATE_EPOCH\")\n            if date:\n                date = datetime.datetime.fromtimestamp(int(date), datetime.timezone.utc)\n                metadata['Date'] = date.replace(tzinfo=UTC).isoformat()\n            else:\n                metadata['Date'] = datetime.datetime.today().isoformat()\n\n        mid = None\n        def ensure_metadata(mid):\n            if mid is not None:\n                return mid\n            mid = writer.start('metadata')\n            writer.start('rdf:RDF', attrib={\n                'xmlns:dc': \"http://purl.org/dc/elements/1.1/\",\n                'xmlns:cc': \"http://creativecommons.org/ns#\",\n                'xmlns:rdf': \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n            })\n            writer.start('cc:Work')\n            return mid\n\n        uri = metadata.pop('Type', None)\n        if uri is not None:\n            mid = ensure_metadata(mid)\n            writer.element('dc:type', attrib={'rdf:resource': uri})\n\n        # Single value only.",
                "filename": "lib/matplotlib/backends/backend_svg.py",
                "start_index": 10508,
                "end_index": 13375,
                "start_line": 337,
                "end_line": 406,
                "max_line": 1367,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "name: Bug Report\ndescription: Report a bug or issue with Matplotlib.\ntitle: \"[Bug]: \"\nbody:\n  - type: textarea\n    id: summary\n    attributes:\n      label: Bug summary\n      description:  Describe the bug in 1-2 short sentences\n      placeholder:\n      value:\n    validations:\n      required: true\n  - type: textarea\n    id: reproduction\n    attributes:\n      label: Code for reproduction\n      description: |\n        If possible, please provide a minimum self-contained example.\n      placeholder: Paste your code here. This field is automatically formatted as Python code.\n      render: python\n    validations:\n      required: true\n  - type: textarea\n    id: actual\n    attributes:\n      label: Actual outcome\n      description: |\n        Paste the output produced by the code provided above, e.g.\n        console output, images/videos produced by the code, any relevant screenshots/screencasts, etc.\n    validations:\n      required: true\n  - type: textarea\n    id: expected\n    attributes:\n      label: Expected outcome\n      description: Describe (or provide a visual example of) the expected outcome from the code snippet.\n    validations:\n      required: true\n  - type: textarea\n    id: details\n    attributes:\n      label: Additional information\n      description: |\n        - What are the conditions under which this bug happens? input parameters, edge cases, etc?\n        - Has this worked in earlier versions?\n        - Do you know why this bug is happening?\n        - Do you maybe even know a fix?\n  - type: input\n    id: operating-system\n    attributes:\n      label: Operating system\n      description: Windows, OS/X, Arch, Debian, Ubuntu, etc.\n  - type: input\n    id: matplotlib-version\n    attributes:\n      label: Matplotlib Version\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.__version__)`\"\n    validations:\n      required: true\n  - type: input\n    id: matplotlib-backend\n    attributes:\n      label: Matplotlib Backend\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.get_backend())`\"\n  - type: input\n    id: python-version\n    attributes:\n      label: Python version\n      description: \"In console: `python --version`\"\n  - type: input\n    id: jupyter-version\n    attributes:\n      label: Jupyter version\n      description: \"In console: `jupyter notebook --version` or `jupyter lab --version`\"\n  - type: dropdown\n    id: install\n    attributes:\n      label: Installation\n      description: How did you install matplotlib?\n      options:\n        - pip\n        - conda\n        - Linux package manager\n        - from source (.tar.gz)\n        - git checkout",
                "filename": ".github/ISSUE_TEMPLATE/bug_report.yml",
                "start_index": 0,
                "end_index": 2631,
                "start_line": 1,
                "end_line": 86,
                "max_line": 86,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "class FigureCanvasSVG(FigureCanvasBase):\n    filetypes = {'svg': 'Scalable Vector Graphics',\n                 'svgz': 'Scalable Vector Graphics'}\n\n    fixed_dpi = 72\n\n    def print_svg(self, filename, *, bbox_inches_restore=None, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict[str, Any], optional\n            Metadata in the SVG file defined as key-value pairs of strings,\n            datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n            The standard keys and their value types are:\n\n            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n              ``'Title'``, and ``'Type'``.\n            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n              non-*str*, then it will be formatted as ISO 8601.\n\n            Values have been predefined for ``'Creator'``, ``'Date'``,\n            ``'Format'``, and ``'Type'``. They can be removed by setting them\n            to `None`.\n\n            Information is encoded as `Dublin Core Metadata`__.\n\n            .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n            __ DC_\n        \"\"\"\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n            if not cbook.file_requires_unicode(fh):\n                fh = codecs.getwriter('utf-8')(fh)\n            dpi = self.figure.dpi\n            self.figure.dpi = 72\n            width, height = self.figure.get_size_inches()\n            w, h = width * 72, height * 72\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererSVG(w, h, fh, image_dpi=dpi, metadata=metadata),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n\n    def print_svgz(self, filename, **kwargs):\n        with cbook.open_file_cm(filename, \"wb\") as fh, \\\n                gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter:\n            return self.print_svg(gzipwriter, **kwargs)\n\n    def get_default_filetype(self):\n        return 'svg'\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()\n\n\nFigureManagerSVG = FigureManagerBase\n\n\nsvgProlog = \"\"\"\\\n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n  \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n\"\"\"\n\n\n@_Backend.export\nclass _BackendSVG(_Backend):\n    backend_version = mpl.__version__\n    FigureCanvas = FigureCanvasSVG",
                "filename": "lib/matplotlib/backends/backend_svg.py",
                "start_index": 46928,
                "end_index": 49848,
                "start_line": 1289,
                "end_line": 1367,
                "max_line": 1367,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "def print_webp(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs, metadata)\n\n    print_jpg.__doc__, print_tif.__doc__, print_webp.__doc__ = map(\n        \"\"\"\n        Write the figure to a {} file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n        \"\"\".format, [\"JPEG\", \"TIFF\", \"WebP\"])",
                "filename": "lib/matplotlib/backends/backend_agg.py",
                "start_index": 19763,
                "end_index": 20357,
                "start_line": 523,
                "end_line": 537,
                "max_line": 544,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "def save(self, filename, writer=None, fps=None, dpi=None, codec=None,\n             bitrate=None, extra_args=None, metadata=None, extra_anim=None,\n             savefig_kwargs=None, *, progress_callback=None):",
                "filename": "lib/matplotlib/animation.py",
                "start_index": 34499,
                "end_index": 34706,
                "start_line": 927,
                "end_line": 929,
                "max_line": 1804,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "def _write_metadata(self, metadata):\n        # Add metadata following the Dublin Core Metadata Initiative, and the\n        # Creative Commons Rights Expression Language. This is mainly for\n        # compatibility with Inkscape.",
                "filename": "lib/matplotlib/backends/backend_svg.py",
                "start_index": 10272,
                "end_index": 10499,
                "start_line": 333,
                "end_line": 336,
                "max_line": 1367,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "\"\"\"\n        Save the current figure.\n\n        Call signature::\n\n          savefig(fname, *, dpi='figure', format=None, metadata=None,\n                  bbox_inches=None, pad_inches=0.1,\n                  facecolor='auto', edgecolor='auto',\n                  backend=None, **kwargs\n                 )\n\n        The available output formats depend on the backend being used.\n\n        Parameters\n        ----------\n        fname : str or path-like or binary file-like\n            A path, or a Python file-like object, or\n            possibly some backend-dependent object such as\n            `matplotlib.backends.backend_pdf.PdfPages`.\n\n            If *format* is set, it determines the output format, and the file\n            is saved as *fname*.  Note that *fname* is used verbatim, and there\n            is no attempt to make the extension, if any, of *fname* match\n            *format*, and no extension is appended.\n\n            If *format* is not set, then the format is inferred from the\n            extension of *fname*, if there is one.  If *format* is not\n            set and *fname* has no extension, then the file is saved with\n            :rc:`savefig.format` and the appropriate extension is appended to\n            *fname*.\n\n        Other Parameters\n        ----------------\n        dpi : float or 'figure', default: :rc:`savefig.dpi`\n            The resolution in dots per inch.  If 'figure', use the figure's\n            dpi value.\n\n        format : str\n            The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n            this is unset is documented under *fname*.\n\n        metadata : dict, optional\n            Key/value pairs to store in the image metadata. The supported keys\n            and defaults depend on the image format and backend:\n\n            - 'png' with Agg backend: See the parameter ``metadata`` of\n              `~.FigureCanvasAgg.print_png`.\n            - 'pdf' with pdf backend: See the parameter ``metadata`` of\n              `~.backend_pdf.PdfPages`.\n            - 'svg' with svg backend: See the parameter ``metadata`` of\n              `~.FigureCanvasSVG.print_svg`.\n            - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n\n            Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support\n            embedding metadata.\n            Does not currently support 'jpg', 'tiff', or 'webp', but may include\n            embedding EXIF metadata in the future.\n\n        bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`\n            Bounding box in inches: only the given portion of the figure is\n            saved.  If 'tight', try to figure out the tight bbox of the figure.\n\n        pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`\n            Amount of padding in inches around the figure when bbox_inches is\n            'tight'. If 'layout' use the padding from the constrained or\n            compressed layout engine; ignored if one of those engines is not in\n            use.\n\n        facecolor : color or 'auto', default: :rc:`savefig.facecolor`\n            The facecolor of the figure.  If 'auto', use the current figure\n            facecolor.\n\n        edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`\n            The edgecolor of the figure.  If 'auto', use the current figure\n            edgecolor.\n\n        backend : str, optional\n            Use a non-default backend to render the file, e.g. to render a\n            png file with the \"cairo\" backend rather than the default \"agg\",\n            or a pdf file with the \"pgf\" backend rather than the default\n            \"pdf\".  Note that the default backend is normally sufficient.  See\n            :ref:`the-builtin-backends` for a list of valid backends for each\n            file format.  Custom backends can be referenced as \"module://...\".\n\n        orientation : {'landscape', 'portrait'}\n            Currently only supported by the postscript backend.\n\n        papertype : str\n            One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n            'a10', 'b0' through 'b10'. Only supported for postscript\n            output.\n\n        transparent : bool\n            If *True*, the Axes patches will all be transparent; the\n            Figure patch will also be transparent unless *facecolor*\n            and/or *edgecolor* are specified via kwargs.\n\n            If *False* has no effect and the color of the Axes and\n            Figure patches are unchanged (unless the Figure patch\n            is specified via the *facecolor* and/or *edgecolor* keyword\n            arguments in which case those colors are used).\n\n            The transparency of these patches will be restored to their\n            original values upon exit of this function.\n\n            This is useful, for example, for displaying\n            a plot on top of a colored background on a web page.\n\n        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n\n        \"\"\"",
                "filename": "lib/matplotlib/figure.py",
                "start_index": 120915,
                "end_index": 126139,
                "start_line": 1,
                "end_line": 3531,
                "max_line": 3625,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    def _print_ps(\n            self, fmt, outfile, *,\n            metadata=None, papertype=None, orientation='portrait',\n            bbox_inches_restore=None, **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.fromtimestamp(\n                int(source_date_epoch),\n                datetime.timezone.utc).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['figure', 'auto', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype,\n                bbox_inches_restore=bbox_inches_restore, **kwargs)",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 27430,
                "end_index": 29353,
                "start_line": 807,
                "end_line": 854,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "def print_png(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        self._print_pil(filename_or_obj, \"png\", pil_kwargs, metadata)\n\n    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))\n\n    # Note that these methods should typically be called via savefig() and\n    # print_figure(), and the latter ensures that `self.figure.dpi` already\n    # matches the dpi kwarg (if any).\n\n    def print_jpg(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        # savefig() has already applied savefig.facecolor; we now set it to\n        # white to make imsave() blend semi-transparent figures against an\n        # assumed white background.\n        with mpl.rc_context({\"savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs, metadata)\n\n    print_jpeg = print_jpg\n\n    def print_tif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs, metadata)\n\n    print_tiff = print_tif",
                "filename": "lib/matplotlib/backends/backend_agg.py",
                "start_index": 16813,
                "end_index": 19757,
                "start_line": 450,
                "end_line": 521,
                "max_line": 544,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            },
            {
                "code": "else:\n        # Don't bother creating an image; this avoids rounding errors on the\n        # size when dividing and then multiplying by dpi.\n        if origin is None:\n            origin = mpl.rcParams[\"image.origin\"]\n        else:\n            _api.check_in_list(('upper', 'lower'), origin=origin)\n        if origin == \"lower\":\n            arr = arr[::-1]\n        if (isinstance(arr, memoryview) and arr.format == \"B\"\n                and arr.ndim == 3 and arr.shape[-1] == 4):\n            # Such an ``arr`` would also be handled fine by sm.to_rgba below\n            # (after casting with asarray), but it is useful to special-case it\n            # because that's what backend_agg passes, and can be in fact used\n            # as is, saving a few operations.\n            rgba = arr\n        else:\n            sm = cm.ScalarMappable(cmap=cmap)\n            sm.set_clim(vmin, vmax)\n            rgba = sm.to_rgba(arr, bytes=True)\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        else:\n            # we modify this below, so make a copy (don't modify caller's dict)\n            pil_kwargs = pil_kwargs.copy()\n        pil_shape = (rgba.shape[1], rgba.shape[0])\n        image = PIL.Image.frombuffer(\n            \"RGBA\", pil_shape, rgba, \"raw\", \"RGBA\", 0, 1)\n        if format == \"png\":\n            # Only use the metadata kwarg if pnginfo is not set, because the\n            # semantics of duplicate keys in pnginfo is unclear.\n            if \"pnginfo\" in pil_kwargs:\n                if metadata:\n                    _api.warn_external(\"'metadata' is overridden by the \"\n                                       \"'pnginfo' entry in 'pil_kwargs'.\")\n            else:\n                metadata = {\n                    \"Software\": (f\"Matplotlib version{mpl.__version__}, \"\n                                 f\"https://matplotlib.org/\"),\n                    **(metadata if metadata is not None else {}),\n                }\n                pil_kwargs[\"pnginfo\"] = pnginfo = PIL.PngImagePlugin.PngInfo()\n                for k, v in metadata.items():\n                    if v is not None:\n                        pnginfo.add_text(k, v)\n        elif metadata is not None:\n            raise ValueError(f\"metadata not supported for format {format!r}\")\n        if format in [\"jpg\", \"jpeg\"]:\n            format = \"jpeg\"  # Pillow doesn't recognize \"jpg\".\n            facecolor = mpl.rcParams[\"savefig.facecolor\"]\n            if cbook._str_equal(facecolor, \"auto\"):\n                facecolor = mpl.rcParams[\"figure.facecolor\"]\n            color = tuple(int(x * 255) for x in mcolors.to_rgb(facecolor))\n            background = PIL.Image.new(\"RGB\", pil_shape, color)\n            background.paste(image, image)\n            image = background\n        pil_kwargs.setdefault(\"format\", format)\n        pil_kwargs.setdefault(\"dpi\", (dpi, dpi))\n        image.save(fname, **pil_kwargs)",
                "filename": "lib/matplotlib/image.py",
                "start_index": 63323,
                "end_index": 66189,
                "start_line": 133,
                "end_line": 1656,
                "max_line": 1785,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "lib/matplotlib/backends/backend_agg.py": [
                {
                    "chunk": {
                        "code": "def print_png(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        self._print_pil(filename_or_obj, \"png\", pil_kwargs, metadata)\n\n    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))\n\n    # Note that these methods should typically be called via savefig() and\n    # print_figure(), and the latter ensures that `self.figure.dpi` already\n    # matches the dpi kwarg (if any).\n\n    def print_jpg(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        # savefig() has already applied savefig.facecolor; we now set it to\n        # white to make imsave() blend semi-transparent figures against an\n        # assumed white background.\n        with mpl.rc_context({\"savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs, metadata)\n\n    print_jpeg = print_jpg\n\n    def print_tif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs, metadata)\n\n    print_tiff = print_tif",
                        "filename": "lib/matplotlib/backends/backend_agg.py",
                        "start_index": 16813,
                        "end_index": 19757,
                        "start_line": 450,
                        "end_line": 521,
                        "max_line": 544,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of the `print_png` method which handles metadata for PNG files. It is relevant because the issue is related to handling metadata, and a similar implementation or error handling might be needed for JPG files."
                },
                {
                    "chunk": {
                        "code": "def print_webp(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs, metadata)\n\n    print_jpg.__doc__, print_tif.__doc__, print_webp.__doc__ = map(\n        \"\"\"\n        Write the figure to a {} file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n        \"\"\".format, [\"JPEG\", \"TIFF\", \"WebP\"])",
                        "filename": "lib/matplotlib/backends/backend_agg.py",
                        "start_index": 19763,
                        "end_index": 20357,
                        "start_line": 523,
                        "end_line": 537,
                        "max_line": 544,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the `print_jpg` method which is directly related to the error message in the issue. It is relevant because it is the method that needs to be modified to either handle metadata correctly or provide a better error message."
                }
            ],
            "lib/matplotlib/figure.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\n        Save the current figure.\n\n        Call signature::\n\n          savefig(fname, *, dpi='figure', format=None, metadata=None,\n                  bbox_inches=None, pad_inches=0.1,\n                  facecolor='auto', edgecolor='auto',\n                  backend=None, **kwargs\n                 )\n\n        The available output formats depend on the backend being used.\n\n        Parameters\n        ----------\n        fname : str or path-like or binary file-like\n            A path, or a Python file-like object, or\n            possibly some backend-dependent object such as\n            `matplotlib.backends.backend_pdf.PdfPages`.\n\n            If *format* is set, it determines the output format, and the file\n            is saved as *fname*.  Note that *fname* is used verbatim, and there\n            is no attempt to make the extension, if any, of *fname* match\n            *format*, and no extension is appended.\n\n            If *format* is not set, then the format is inferred from the\n            extension of *fname*, if there is one.  If *format* is not\n            set and *fname* has no extension, then the file is saved with\n            :rc:`savefig.format` and the appropriate extension is appended to\n            *fname*.\n\n        Other Parameters\n        ----------------\n        dpi : float or 'figure', default: :rc:`savefig.dpi`\n            The resolution in dots per inch.  If 'figure', use the figure's\n            dpi value.\n\n        format : str\n            The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n            this is unset is documented under *fname*.\n\n        metadata : dict, optional\n            Key/value pairs to store in the image metadata. The supported keys\n            and defaults depend on the image format and backend:\n\n            - 'png' with Agg backend: See the parameter ``metadata`` of\n              `~.FigureCanvasAgg.print_png`.\n            - 'pdf' with pdf backend: See the parameter ``metadata`` of\n              `~.backend_pdf.PdfPages`.\n            - 'svg' with svg backend: See the parameter ``metadata`` of\n              `~.FigureCanvasSVG.print_svg`.\n            - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n\n            Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support\n            embedding metadata.\n            Does not currently support 'jpg', 'tiff', or 'webp', but may include\n            embedding EXIF metadata in the future.\n\n        bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`\n            Bounding box in inches: only the given portion of the figure is\n            saved.  If 'tight', try to figure out the tight bbox of the figure.\n\n        pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`\n            Amount of padding in inches around the figure when bbox_inches is\n            'tight'. If 'layout' use the padding from the constrained or\n            compressed layout engine; ignored if one of those engines is not in\n            use.\n\n        facecolor : color or 'auto', default: :rc:`savefig.facecolor`\n            The facecolor of the figure.  If 'auto', use the current figure\n            facecolor.\n\n        edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`\n            The edgecolor of the figure.  If 'auto', use the current figure\n            edgecolor.\n\n        backend : str, optional\n            Use a non-default backend to render the file, e.g. to render a\n            png file with the \"cairo\" backend rather than the default \"agg\",\n            or a pdf file with the \"pgf\" backend rather than the default\n            \"pdf\".  Note that the default backend is normally sufficient.  See\n            :ref:`the-builtin-backends` for a list of valid backends for each\n            file format.  Custom backends can be referenced as \"module://...\".\n\n        orientation : {'landscape', 'portrait'}\n            Currently only supported by the postscript backend.\n\n        papertype : str\n            One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n            'a10', 'b0' through 'b10'. Only supported for postscript\n            output.\n\n        transparent : bool\n            If *True*, the Axes patches will all be transparent; the\n            Figure patch will also be transparent unless *facecolor*\n            and/or *edgecolor* are specified via kwargs.\n\n            If *False* has no effect and the color of the Axes and\n            Figure patches are unchanged (unless the Figure patch\n            is specified via the *facecolor* and/or *edgecolor* keyword\n            arguments in which case those colors are used).\n\n            The transparency of these patches will be restored to their\n            original values upon exit of this function.\n\n            This is useful, for example, for displaying\n            a plot on top of a colored background on a web page.\n\n        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n\n        \"\"\"",
                        "filename": "lib/matplotlib/figure.py",
                        "start_index": 120915,
                        "end_index": 126139,
                        "start_line": 1,
                        "end_line": 3531,
                        "max_line": 3625,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from 'lib/matplotlib/figure.py' contains the `savefig` method which is the entry point for saving figures and includes the `metadata` parameter. It is relevant because the issue occurs when calling `savefig` with metadata for a JPG file."
                }
            ]
        },
        "solution_task": "- Check if the `metadata` argument is being passed to the `print_jpg` method inappropriately.\n- Modify the `savefig` function to ensure that `metadata` is not passed to `print_jpg` or any other method that does not support it.\n- Implement a check within `savefig` to only include `metadata` in the call to the print method if the output format supports it.\n- If the format is `.jpg`, either remove the `metadata` argument before calling `print_jpg` or update the documentation to clearly state that metadata is not supported for JPEG files.\n\nHere is a possible solution:\n\n```python\ndef savefig(fname, *, metadata=None, **kwargs):\n    # ... [rest of the savefig code] ...\n\n    # Determine the format based on the extension of the file name\n    _, ext = os.path.splitext(fname)\n    format = ext[1:].lower() if ext else None\n\n    # Check if the format supports metadata\n    if format not in ['png', 'pdf', 'svg', 'eps', 'ps']:\n        metadata = None  # Do not pass metadata to formats that do not support it\n\n    # ... [code to call the appropriate print method, e.g., print_jpg, print_png, etc.] ...\n\n    # Example of calling a print method without passing metadata if not supported\n    if format == 'jpg':\n        self.canvas.print_jpg(fname, **kwargs)\n    else:\n        self.canvas.print_figure(fname, metadata=metadata, **kwargs)\n\n    # ... [rest of the savefig code] ...\n```\n\n- Ensure that the `metadata` argument is not included in the call to `print_jpg` if the file format is JPEG.\n- Update the documentation of `savefig` to reflect that metadata is not supported for JPEG files.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the bug described in the PROMPT. It suggests checking if the 'metadata' argument is being passed incorrectly and modifying the 'savefig' function to handle the 'metadata' argument appropriately for different file formats. The RESPONSE also includes a code snippet that demonstrates how to implement the suggested changes, which is directly relevant to the bug. Additionally, the RESPONSE advises updating the documentation to reflect the support of metadata for different file formats, which is a comprehensive approach to resolving the issue and preventing future confusion. The RESPONSE also points to specific code snippets in the Matplotlib repository that are relevant to the issue, which can be very helpful for developers looking to fix the bug.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711697071.045681,
        "result": "- Check if the `metadata` argument is being passed to the `print_jpg` method inappropriately.\n- Modify the `savefig` function to ensure that `metadata` is not passed to `print_jpg` or any other method that does not support it.\n- Implement a check within `savefig` to only include `metadata` in the call to the print method if the output format supports it.\n- If the format is `.jpg`, either remove the `metadata` argument before calling `print_jpg` or update the documentation to clearly state that metadata is not supported for JPEG files.\n\nHere is a possible solution:\n\n```python\ndef savefig(fname, *, metadata=None, **kwargs):\n    # ... [rest of the savefig code] ...\n\n    # Determine the format based on the extension of the file name\n    _, ext = os.path.splitext(fname)\n    format = ext[1:].lower() if ext else None\n\n    # Check if the format supports metadata\n    if format not in ['png', 'pdf', 'svg', 'eps', 'ps']:\n        metadata = None  # Do not pass metadata to formats that do not support it\n\n    # ... [code to call the appropriate print method, e.g., print_jpg, print_png, etc.] ...\n\n    # Example of calling a print method without passing metadata if not supported\n    if format == 'jpg':\n        self.canvas.print_jpg(fname, **kwargs)\n    else:\n        self.canvas.print_figure(fname, metadata=metadata, **kwargs)\n\n    # ... [rest of the savefig code] ...\n```\n\n- Ensure that the `metadata` argument is not included in the call to `print_jpg` if the file format is JPEG.\n- Update the documentation of `savefig` to reflect that metadata is not supported for JPEG files.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib/backends)- [Lines 450 - 521](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_agg.py#L450-L521)\n\n This snippet contains the implementation of the `print_png` method which handles metadata for PNG files. It is relevant because the issue is related to handling metadata, and a similar implementation or error handling might be needed for JPG files. \n\n\n   - [Lines 523 - 537](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/backends/backend_agg.py#L523-L537)\n\n This snippet shows the `print_jpg` method which is directly related to the error message in the issue. It is relevant because it is the method that needs to be modified to either handle metadata correctly or provide a better error message.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib)- [Lines 1 - 3531](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/figure.py#L1-L3531)\n\n This snippet from 'lib/matplotlib/figure.py' contains the `savefig` method which is the entry point for saving figures and includes the `metadata` parameter. It is relevant because the issue occurs when calling `savefig` with metadata for a JPG file."
    }
}