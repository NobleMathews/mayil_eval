{
    "id": "pylint-dev__pylint-7114",
    "repo_name": "testbed/pylint-dev__pylint__2.15",
    "task_id": 4045198597518958577,
    "title": "Linting fails if module contains module of the same name",
    "body": "### Steps to reproduce\r\n\r\nGiven multiple files:\r\n```\r\n.\r\n`-- a/\r\n    |-- a.py\r\n    `-- b.py\r\n```\r\nWhich are all empty, running `pylint a` fails:\r\n\r\n```\r\n$ pylint a\r\n************* Module a\r\na/__init__.py:1:0: F0010: error while code parsing: Unable to load file a/__init__.py:\r\n[Errno 2] No such file or directory: 'a/__init__.py' (parse-error)\r\n$\r\n```\r\n\r\nHowever, if I rename `a.py`, `pylint a` succeeds:\r\n\r\n```\r\n$ mv a/a.py a/c.py\r\n$ pylint a\r\n$\r\n```\r\nAlternatively, I can also `touch a/__init__.py`, but that shouldn't be necessary anymore.\r\n\r\n### Current behavior\r\n\r\nRunning `pylint a` if `a/a.py` is present fails while searching for an `__init__.py` file.\r\n\r\n### Expected behavior\r\n\r\nRunning `pylint a` if `a/a.py` is present should succeed.\r\n\r\n### pylint --version output\r\n\r\nResult of `pylint --version` output:\r\n\r\n```\r\npylint 3.0.0a3\r\nastroid 2.5.6\r\nPython 3.8.5 (default, Jan 27 2021, 15:41:15) \r\n[GCC 9.3.0]\r\n```\r\n\r\n### Additional info\r\n\r\nThis also has some side-effects in module resolution. For example, if I create another file `r.py`:\r\n\r\n```\r\n.\r\n|-- a\r\n|   |-- a.py\r\n|   `-- b.py\r\n`-- r.py\r\n```\r\n\r\nWith the content:\r\n\r\n```\r\nfrom a import b\r\n```\r\n\r\nRunning `pylint -E r` will run fine, but `pylint -E r a` will fail. Not just for module a, but for module r as well.\r\n\r\n```\r\n************* Module r\r\nr.py:1:0: E0611: No name 'b' in module 'a' (no-name-in-module)\r\n************* Module a\r\na/__init__.py:1:0: F0010: error while code parsing: Unable to load file a/__init__.py:\r\n[Errno 2] No such file or directory: 'a/__init__.py' (parse-error)\r\n```\r\n\r\nAgain, if I rename `a.py` to `c.py`, `pylint -E r a` will work perfectly.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pylint-dev__pylint__2.15.git",
    "requested_commit": "",
    "mayil_response": "- Add an empty `__init__.py` file to the `a` directory to ensure that Pylint recognizes it as a package.\n- Modify the Pylint module loading and package recognition logic to handle cases where a directory and a module have the same name without requiring an `__init__.py` file.\n- Ensure that the `discover_package_path` function in `pylint/lint/expand_modules.py` correctly identifies the package root in the presence of naming conflicts between directories and modules.\n- Update the logic in `pylint/lint/pylinter.py` to handle module resolution correctly when a directory and a module share the same name, potentially by checking if a directory is a package based on more than just the presence of an `__init__.py` file.\n- Add test cases to cover the scenario where a directory and a module share the same name to prevent regressions in the future.\n\n### Code snippets to check\n\n-  \u2192 [pylint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint) \u2192 [lint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint/lint)- [Lines 655 - 704](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/lint/pylinter.py#L655-L704)\n\n This snippet contains the main checking entry function which is likely where the issue with module resolution and linting failure occurs.\n-  \u2192 [pylint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint) \u2192 [lint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint/lint)- [Lines 1 - 69](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/lint/expand_modules.py#L1-L69)\n\n This snippet includes functions related to module path discovery and could be involved in the incorrect handling of modules with the same name as their parent directory.\n-  \u2192 [pylint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint) \u2192 [checkers](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint/checkers)- [Lines 47 - 840](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/checkers/imports.py#L47-L840)\n\n This snippet defines error messages related to imports, which may need to be reviewed or updated to handle the described issue. \n\n\n   - [Lines 921 - 999](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/checkers/imports.py#L921-L999)\n\n This snippet contains functions that check for preferred modules and import aliases, which might be relevant to the issue if the linting process is incorrectly handling module names.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005614999999999999,
        "snippet_processor": 0.062290000000000005,
        "issue_star_creation": 0.02021,
        "issue_star_solver": 0.05824,
        "bouncer": 0.02295
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711699866.0772219,
        "relevant_snippets": [
            {
                "code": "{\n    \"E0401\": (\n        \"Unable to import %s\",\n        \"import-error\",\n        \"Used when pylint has been unable to import a module.\",\n        {\"old_names\": [(\"F0401\", \"old-import-error\")]},\n    ),\n    \"E0402\": (\n        \"Attempted relative import beyond top-level package\",\n        \"relative-beyond-top-level\",\n        \"Used when a relative import tries to access too many levels \"\n        \"in the current package.\",\n    ),\n    \"R0401\": (\n        \"Cyclic import (%s)\",\n        \"cyclic-import\",\n        \"Used when a cyclic import between two or more modules is detected.\",\n    ),\n    \"R0402\": (\n        \"Use 'from %s import %s' instead\",\n        \"consider-using-from-import\",\n        \"Emitted when a submodule of a package is imported and \"\n        \"aliased with the same name, \"\n        \"e.g., instead of ``import concurrent.futures as futures`` use \"\n        \"``from concurrent import futures``.\",\n    ),\n    \"W0401\": (\n        \"Wildcard import %s\",\n        \"wildcard-import\",\n        \"Used when `from module import *` is detected.\",\n    ),\n    \"W0404\": (\n        \"Reimport %r (imported line %s)\",\n        \"reimported\",\n        \"Used when a module is imported more than once.\",\n    ),\n    \"W0406\": (\n        \"Module import itself\",\n        \"import-self\",\n        \"Used when a module is importing itself.\",\n    ),\n    \"W0407\": (\n        \"Prefer importing %r instead of %r\",\n        \"preferred-module\",\n        \"Used when a module imported has a preferred replacement module.\",\n    ),\n    \"W0410\": (\n        \"__future__ import is not the first non docstring statement\",\n        \"misplaced-future\",\n        \"Python 2.5 and greater require __future__ import to be the \"\n        \"first non docstring statement in the module.\",\n    ),\n    \"C0410\": (\n        \"Multiple imports on one line (%s)\",\n        \"multiple-imports\",\n        \"Used when import statement importing multiple modules is detected.\",\n    ),\n    \"C0411\": (\n        \"%s should be placed before %s\",\n        \"wrong-import-order\",\n        \"Used when PEP8 import order is not respected (standard imports \"\n        \"first, then third-party libraries, then local imports).\",\n    ),\n    \"C0412\": (\n        \"Imports from package %s are not grouped\",\n        \"ungrouped-imports\",\n        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n    \"C0414\": (\n        \"Import alias does not rename original package\",\n        \"useless-import-alias\",\n        \"Used when an import alias is same as original package, \"\n        \"e.g., using import numpy as numpy instead of import numpy as np.\",\n    ),\n    \"C0415\": (\n        \"Import outside toplevel (%s)\",\n        \"import-outside-toplevel\",\n        \"Used when an import statement is used anywhere other than the module \"\n        \"toplevel. Move this import to the top of the file.\",\n    ),",
                "filename": "pylint/checkers/imports.py",
                "start_index": 7547,
                "end_index": 10506,
                "start_line": 47,
                "end_line": 840,
                "max_line": 1102,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "name: \u2728 Feature request\ndescription: Suggest an idea for pylint\nlabels: [\"Needs triage :inbox_tray:\"]\nbody:\n  - type: markdown\n    attributes:\n      value: |\n        **Thank you for wanting to make a suggestion for pylint!**\n\n        \u26a0 Please make sure that [this feature wasn't already requested][issue search] or already implemented in the main branch.\n\n\n        [issue search]: https://github.com/pylint-dev/pylint/issues?q=is%3Aissue+is%3Aopen+\n\n  - type: textarea\n    id: current-problem\n    attributes:\n      label: Current problem\n      description:\n        What are you trying to do, that you are unable to achieve with pylint as it\n        currently stands?\n      placeholder: >-\n        I'm trying to do X and I'm missing feature Y for this to be easily achievable.\n    validations:\n      required: true\n  - type: textarea\n    id: proposed-solution\n    attributes:\n      label: Desired solution\n      description: A clear and concise description of what you want to happen.\n      placeholder: >-\n        When I do X, I want to achieve Y in a situation when Z.\n    validations:\n      required: true\n  - type: textarea\n    attributes:\n      label: Additional context\n      description: >\n        Add any other context, links, etc. about the feature here. Describe how the\n        feature would be used, why it is needed and what it would solve.\n\n        **HINT:** You can paste https://gist.github.com links for larger files.\n      placeholder: >-\n        I asked on https://stackoverflow.com/... and the community advised me to do X, Y\n        and Z.",
                "filename": ".github/ISSUE_TEMPLATE/FEATURE-REQUEST.yml",
                "start_index": 0,
                "end_index": 1559,
                "start_line": 1,
                "end_line": 45,
                "max_line": 45,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "name: \ud83e\udd14 Support question\ndescription: Questions about pylint that are not covered in the documentation\nlabels: [\"Needs triage :inbox_tray:\", \"Question\", \"Documentation :green_book:\"]\nbody:\n  - type: markdown\n    attributes:\n      value: >\n        **Thank you for wanting to report a problem with pylint documentation!**\n\n\n        Please fill out your suggestions below. If the problem seems straightforward,\n        feel free to go ahead and submit a pull request instead!\n\n\n        \u26a0 Verify first that your issue is not [already reported on GitHub][issue\n        search].\n\n        \ud83d\udcac If you are seeking community support, please consider [starting a discussion\n        on Discord][Discussions].\n\n\n        [issue search]:\n        https://github.com/pylint-dev/pylint/issues?q=is%3Aissue+is%3Aopen+\n\n        [Discussions]: https://discord.com/invite/Egy6P8AMB5\n\n  - type: textarea\n    id: question\n    attributes:\n      label: Question\n    validations:\n      required: true\n  - type: textarea\n    id: documentation\n    attributes:\n      label: Documentation for future user\n      description:\n        Where did you expect this information to be? What do we need to add or what do\n        we need to reorganize?\n    validations:\n      required: true\n  - type: textarea\n    attributes:\n      label: Additional context\n      description: >\n        Add any other context, links, etc. about the question here.\n      placeholder: >-\n        I asked on https://stackoverflow.com/... and the community advised me to do X, Y\n        and Z.",
                "filename": ".github/ISSUE_TEMPLATE/QUESTION.yml",
                "start_index": 0,
                "end_index": 1528,
                "start_line": 1,
                "end_line": 49,
                "max_line": 49,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "def _check_preferred_module(self, node: ImportNode, mod_path: str) -> None:\n        \"\"\"Check if the module has a preferred replacement.\"\"\"\n\n        mod_compare = [mod_path]\n        # build a comparison list of possible names using importfrom\n        if isinstance(node, astroid.nodes.node_classes.ImportFrom):\n            mod_compare = [f\"{node.modname}.{name[0]}\" for name in node.names]\n\n        # find whether there are matches with the import vs preferred_modules keys\n        matches = [\n            k\n            for k in self.preferred_modules\n            for mod in mod_compare\n            # exact match\n            if k == mod\n            # checks for base module matches\n            or k in mod.split(\".\")[0]\n        ]\n\n        # if we have matches, add message\n        if matches:\n            self.add_message(\n                \"preferred-module\",\n                node=node,\n                args=(self.preferred_modules[matches[0]], matches[0]),\n            )\n\n    def _check_import_as_rename(self, node: ImportNode) -> None:\n        names = node.names\n        for name in names:\n            if not all(name):\n                return\n\n            splitted_packages = name[0].rsplit(\".\", maxsplit=1)\n            import_name = splitted_packages[-1]\n            aliased_name = name[1]\n            if import_name != aliased_name:\n                continue\n\n            if len(splitted_packages) == 1 and (\n                self._allow_reexport_package is False\n                or self._current_module_package is False\n            ):\n                self.add_message(\"useless-import-alias\", node=node, confidence=HIGH)\n            elif len(splitted_packages) == 2:\n                self.add_message(\n                    \"consider-using-from-import\",\n                    node=node,\n                    args=(splitted_packages[0], import_name),\n                )\n\n    def _check_reimport(\n        self,\n        node: ImportNode,\n        basename: str | None = None,\n        level: int | None = None,\n    ) -> None:\n        \"\"\"Check if a module with the same name is already imported or aliased.\"\"\"\n        if not self.linter.is_message_enabled(\n            \"reimported\"\n        ) and not self.linter.is_message_enabled(\"shadowed-import\"):\n            return\n\n        frame = node.frame()\n        root = node.root()\n        contexts = [(frame, level)]\n        if root is not frame:\n            contexts.append((root, None))\n\n        for known_context, known_level in contexts:\n            for name, alias in node.names:\n                first, msg = _get_first_import(\n                    node, known_context, name, basename, known_level, alias\n                )\n                if first is not None and msg is not None:\n                    name = name if msg == \"reimported\" else alias\n                    self.add_message(\n                        msg, node=node, args=(name, first.fromlineno), confidence=HIGH\n                    )",
                "filename": "pylint/checkers/imports.py",
                "start_index": 35171,
                "end_index": 38101,
                "start_line": 921,
                "end_line": 999,
                "max_line": 1102,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "def check(self, files_or_modules: Sequence[str]) -> None:\n        \"\"\"Main checking entry: check a list of files or modules from their name.\n\n        files_or_modules is either a string or list of strings presenting modules to check.\n        \"\"\"\n        self.initialize()\n        if self.config.recursive:\n            files_or_modules = tuple(self._discover_files(files_or_modules))\n        if self.config.from_stdin:\n            if len(files_or_modules) != 1:\n                raise exceptions.InvalidArgsError(\n                    \"Missing filename required for --from-stdin\"\n                )\n\n        extra_packages_paths = list(\n            {\n                discover_package_path(file_or_module, self.config.source_roots)\n                for file_or_module in files_or_modules\n            }\n        )\n\n        # TODO: Move the parallel invocation into step 3 of the checking process\n        if not self.config.from_stdin and self.config.jobs > 1:\n            original_sys_path = sys.path[:]\n            check_parallel(\n                self,\n                self.config.jobs,\n                self._iterate_file_descrs(files_or_modules),\n                extra_packages_paths,\n            )\n            sys.path = original_sys_path\n            return\n\n        # 1) Get all FileItems\n        with augmented_sys_path(extra_packages_paths):\n            if self.config.from_stdin:\n                fileitems = self._get_file_descr_from_stdin(files_or_modules[0])\n                data: str | None = _read_stdin()\n            else:\n                fileitems = self._iterate_file_descrs(files_or_modules)\n                data = None\n\n        # The contextmanager also opens all checkers and sets up the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data)\n\n                # 3) Lint each ast\n                self._lint_files(ast_per_fileitem, check_astroid_module)",
                "filename": "pylint/lint/pylinter.py",
                "start_index": 24627,
                "end_index": 26692,
                "start_line": 655,
                "end_line": 704,
                "max_line": 1310,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom collections.abc import Sequence\nfrom re import Pattern\n\nfrom astroid import modutils\n\nfrom pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n\n\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(  # type: ignore[no-any-return]\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n\n\ndef discover_package_path(modulepath: str, source_roots: Sequence[str]) -> str:\n    \"\"\"Discover package path from one its modules and source roots.\"\"\"\n    dirname = os.path.realpath(os.path.expanduser(modulepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n\n    # Look for a source root that contains the module directory\n    for source_root in source_roots:\n        source_root = os.path.realpath(os.path.expanduser(source_root))\n        if os.path.commonpath([source_root, dirname]) == source_root:\n            return source_root\n\n    # Fall back to legacy discovery by looking for __init__.py upwards as\n    # it's the only way given that source root was not found or was not provided\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n            return os.getcwd()\n\n\ndef _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n    \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n    return any(file_pattern.match(element) for file_pattern in ignore_list_re)\n\n\ndef _is_ignored_file(\n    element: str,\n    ignore_list: list[str],\n    ignore_list_re: list[Pattern[str]],\n    ignore_list_paths_re: list[Pattern[str]],\n) -> bool:\n    element = os.path.normpath(element)\n    basename = os.path.basename(element)\n    return (\n        basename in ignore_list\n        or _is_in_ignore_list_re(basename, ignore_list_re)\n        or _is_in_ignore_list_re(element, ignore_list_paths_re)\n    )\n\n\n# pylint: disable = too-many-locals, too-many-statements",
                "filename": "pylint/lint/expand_modules.py",
                "start_index": 0,
                "end_index": 2532,
                "start_line": 1,
                "end_line": 69,
                "max_line": 169,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Check for imports on private external modules and names.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nfrom astroid import nodes\n\nfrom pylint.checkers import BaseChecker, utils\nfrom pylint.interfaces import HIGH\n\nif TYPE_CHECKING:\n    from pylint.lint.pylinter import PyLinter",
                "filename": "pylint/extensions/private_import.py",
                "start_index": 0,
                "end_index": 564,
                "start_line": 1,
                "end_line": 18,
                "max_line": 264,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "name: \ud83d\udc1b Bug report\ndescription: Report a bug in pylint\nlabels: [\"Needs triage :inbox_tray:\"]\nbo",
                "filename": ".github/ISSUE_TEMPLATE/BUG-REPORT.yml",
                "start_index": 0,
                "end_index": 95,
                "start_line": 1,
                "end_line": 20,
                "max_line": 105,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "def __init__(self, linter: PyLinter) -> None:\n        super().__init__(linter)\n        self._name_group: dict[str, str] = {}\n        self._bad_names: dict[str, dict[str, list[_BadNamesTuple]]] = {}\n        self._name_regexps: dict[str, re.Pattern[str]] = {}\n        self._name_hints: dict[str, str] = {}\n        self._good_names_rgxs_compiled: list[re.Pattern[str]] = []\n        self._bad_names_rgxs_compiled: list[re.Pattern[str]] = []\n\n    def open(self) -> None:\n        self.linter.stats.reset_bad_names()\n        for group in self.linter.config.name_group:\n            for name_type in group.split(\":\"):\n                self._name_group[name_type] = f\"group_{group}\"\n\n        regexps, hints = self._create_naming_rules()\n        self._name_regexps = regexps\n        self._name_hints = hints\n        self._good_names_rgxs_compiled = [\n            re.compile(rgxp) for rgxp in self.linter.config.good_names_rgxs\n        ]\n        self._bad_names_rgxs_compiled = [\n            re.compile(rgxp) for rgxp in self.linter.config.bad_names_rgxs\n        ]\n\n    def _create_naming_rules(self) -> tuple[dict[str, Pattern[str]], dict[str, str]]:\n        regexps: dict[str, Pattern[str]] = {}\n        hints: dict[str, str] = {}\n\n        for name_type in KNOWN_NAME_TYPES:\n            if name_type in KNOWN_NAME_TYPES_WITH_STYLE:\n                naming_style_name = getattr(\n                    self.linter.config, f\"{name_type}_naming_style\"\n                )\n                regexps[name_type] = NAMING_STYLES[naming_style_name].get_regex(\n                    name_type\n                )\n            else:\n                naming_style_name = \"predefined\"\n                regexps[name_type] = DEFAULT_PATTERNS[name_type]\n\n            custom_regex_setting_name = f\"{name_type}_rgx\"\n            custom_regex = getattr(self.linter.config, custom_regex_setting_name, None)\n            if custom_regex is not None:\n                regexps[name_type] = custom_regex\n\n            if custom_regex is not None:\n                hints[name_type] = f\"{custom_regex.pattern!r} pattern\"\n            else:\n                hints[name_type] = f\"{naming_style_name} naming style\"\n\n        return regexps, hints\n\n    @utils.only_required_for_messages(\"disallowed-name\", \"invalid-name\")\n    def visit_module(self, node: nodes.Module) -> None:\n        self._check_name(\"module\", node.name.split(\".\")[-1], node)\n        self._bad_names = {}",
                "filename": "pylint/checkers/base/name_checker/checker.py",
                "start_index": 9353,
                "end_index": 11763,
                "start_line": 275,
                "end_line": 331,
                "max_line": 701,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            },
            {
                "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport configparser\nimport os\nimport sys\nfrom collections.abc import Iterator\nfrom pathlib import Path\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    import tomli as tomllib\n\nRC_NAMES = (Path(\"pylintrc\"), Path(\".pylintrc\"))\nPYPROJECT_NAME = Path(\"pyproject.toml\")\nCONFIG_NAMES = (*RC_NAMES, PYPROJECT_NAME, Path(\"setup.cfg\"))\n\n\ndef _find_pyproject() -> Path:\n    \"\"\"Search for file pyproject.toml in the parent directories recursively.\n\n    It resolves symlinks, so if there is any symlink up in the tree, it does not respect them\n    \"\"\"\n    current_dir = Path.cwd().resolve()\n    is_root = False\n    while not is_root:\n        if (current_dir / PYPROJECT_NAME).is_file():\n            return current_dir / PYPROJECT_NAME\n        is_root = (\n            current_dir == current_dir.parent\n            or (current_dir / \".git\").is_dir()\n            or (current_dir / \".hg\").is_dir()\n        )\n        current_dir = current_dir.parent\n\n    return current_dir\n\n\ndef _toml_has_config(path: Path | str) -> bool:\n    with open(path, mode=\"rb\") as toml_handle:\n        try:\n            content = tomllib.load(toml_handle)\n        except tomllib.TOMLDecodeError as error:\n            print(f\"Failed to load '{path}': {error}\")\n            return False\n    return \"pylint\" in content.get(\"tool\", [])\n\n\ndef _cfg_has_config(path: Path | str) -> bool:\n    parser = configparser.ConfigParser()\n    try:\n        parser.read(path, encoding=\"utf-8\")\n    except configparser.Error:\n        return False\n    return any(section.startswith(\"pylint.\") for section in parser.sections())\n\n\ndef _yield_default_files() -> Iterator[Path]:\n    \"\"\"Iterate over the default config file names and see if they exist.\"\"\"\n    for config_name in CONFIG_NAMES:\n        try:\n            if config_name.is_file():\n                if config_name.suffix == \".toml\" and not _toml_has_config(config_name):\n                    continue\n                if config_name.suffix == \".cfg\" and not _cfg_has_config(config_name):\n                    continue\n\n                yield config_name.resolve()\n        except OSError:\n            pass\n\n\ndef _find_project_config() -> Iterator[Path]:\n    \"\"\"Traverse up the directory tree to find a config file.\n\n    Stop if no '__init__' is found and thus we are no longer in a package.\n    \"\"\"\n    if Path(\"__init__.py\").is_file():\n        curdir = Path(os.getcwd()).resolve()\n        while (curdir / \"__init__.py\").is_file():\n            curdir = curdir.parent\n            for rc_name in RC_NAMES:\n                rc_path = curdir / rc_name\n                if rc_path.is_file():\n                    yield rc_path.resolve()",
                "filename": "pylint/config/find_default_config_files.py",
                "start_index": 0,
                "end_index": 2899,
                "start_line": 1,
                "end_line": 89,
                "max_line": 139,
                "git_instance": "github",
                "repo_name": "testbed/pylint-dev__pylint__2.15",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "pylint/lint/pylinter.py": [
                {
                    "chunk": {
                        "code": "def check(self, files_or_modules: Sequence[str]) -> None:\n        \"\"\"Main checking entry: check a list of files or modules from their name.\n\n        files_or_modules is either a string or list of strings presenting modules to check.\n        \"\"\"\n        self.initialize()\n        if self.config.recursive:\n            files_or_modules = tuple(self._discover_files(files_or_modules))\n        if self.config.from_stdin:\n            if len(files_or_modules) != 1:\n                raise exceptions.InvalidArgsError(\n                    \"Missing filename required for --from-stdin\"\n                )\n\n        extra_packages_paths = list(\n            {\n                discover_package_path(file_or_module, self.config.source_roots)\n                for file_or_module in files_or_modules\n            }\n        )\n\n        # TODO: Move the parallel invocation into step 3 of the checking process\n        if not self.config.from_stdin and self.config.jobs > 1:\n            original_sys_path = sys.path[:]\n            check_parallel(\n                self,\n                self.config.jobs,\n                self._iterate_file_descrs(files_or_modules),\n                extra_packages_paths,\n            )\n            sys.path = original_sys_path\n            return\n\n        # 1) Get all FileItems\n        with augmented_sys_path(extra_packages_paths):\n            if self.config.from_stdin:\n                fileitems = self._get_file_descr_from_stdin(files_or_modules[0])\n                data: str | None = _read_stdin()\n            else:\n                fileitems = self._iterate_file_descrs(files_or_modules)\n                data = None\n\n        # The contextmanager also opens all checkers and sets up the PyLinter class\n        with augmented_sys_path(extra_packages_paths):\n            with self._astroid_module_checker() as check_astroid_module:\n                # 2) Get the AST for each FileItem\n                ast_per_fileitem = self._get_asts(fileitems, data)\n\n                # 3) Lint each ast\n                self._lint_files(ast_per_fileitem, check_astroid_module)",
                        "filename": "pylint/lint/pylinter.py",
                        "start_index": 24627,
                        "end_index": 26692,
                        "start_line": 655,
                        "end_line": 704,
                        "max_line": 1310,
                        "git_instance": "github",
                        "repo_name": "testbed/pylint-dev__pylint__2.15",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the main checking entry function which is likely where the issue with module resolution and linting failure occurs."
                }
            ],
            "pylint/lint/expand_modules.py": [
                {
                    "chunk": {
                        "code": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom collections.abc import Sequence\nfrom re import Pattern\n\nfrom astroid import modutils\n\nfrom pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n\n\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(  # type: ignore[no-any-return]\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n\n\ndef discover_package_path(modulepath: str, source_roots: Sequence[str]) -> str:\n    \"\"\"Discover package path from one its modules and source roots.\"\"\"\n    dirname = os.path.realpath(os.path.expanduser(modulepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n\n    # Look for a source root that contains the module directory\n    for source_root in source_roots:\n        source_root = os.path.realpath(os.path.expanduser(source_root))\n        if os.path.commonpath([source_root, dirname]) == source_root:\n            return source_root\n\n    # Fall back to legacy discovery by looking for __init__.py upwards as\n    # it's the only way given that source root was not found or was not provided\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n            return os.getcwd()\n\n\ndef _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n    \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n    return any(file_pattern.match(element) for file_pattern in ignore_list_re)\n\n\ndef _is_ignored_file(\n    element: str,\n    ignore_list: list[str],\n    ignore_list_re: list[Pattern[str]],\n    ignore_list_paths_re: list[Pattern[str]],\n) -> bool:\n    element = os.path.normpath(element)\n    basename = os.path.basename(element)\n    return (\n        basename in ignore_list\n        or _is_in_ignore_list_re(basename, ignore_list_re)\n        or _is_in_ignore_list_re(element, ignore_list_paths_re)\n    )\n\n\n# pylint: disable = too-many-locals, too-many-statements",
                        "filename": "pylint/lint/expand_modules.py",
                        "start_index": 0,
                        "end_index": 2532,
                        "start_line": 1,
                        "end_line": 69,
                        "max_line": 169,
                        "git_instance": "github",
                        "repo_name": "testbed/pylint-dev__pylint__2.15",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes functions related to module path discovery and could be involved in the incorrect handling of modules with the same name as their parent directory."
                }
            ],
            "pylint/checkers/imports.py": [
                {
                    "chunk": {
                        "code": "{\n    \"E0401\": (\n        \"Unable to import %s\",\n        \"import-error\",\n        \"Used when pylint has been unable to import a module.\",\n        {\"old_names\": [(\"F0401\", \"old-import-error\")]},\n    ),\n    \"E0402\": (\n        \"Attempted relative import beyond top-level package\",\n        \"relative-beyond-top-level\",\n        \"Used when a relative import tries to access too many levels \"\n        \"in the current package.\",\n    ),\n    \"R0401\": (\n        \"Cyclic import (%s)\",\n        \"cyclic-import\",\n        \"Used when a cyclic import between two or more modules is detected.\",\n    ),\n    \"R0402\": (\n        \"Use 'from %s import %s' instead\",\n        \"consider-using-from-import\",\n        \"Emitted when a submodule of a package is imported and \"\n        \"aliased with the same name, \"\n        \"e.g., instead of ``import concurrent.futures as futures`` use \"\n        \"``from concurrent import futures``.\",\n    ),\n    \"W0401\": (\n        \"Wildcard import %s\",\n        \"wildcard-import\",\n        \"Used when `from module import *` is detected.\",\n    ),\n    \"W0404\": (\n        \"Reimport %r (imported line %s)\",\n        \"reimported\",\n        \"Used when a module is imported more than once.\",\n    ),\n    \"W0406\": (\n        \"Module import itself\",\n        \"import-self\",\n        \"Used when a module is importing itself.\",\n    ),\n    \"W0407\": (\n        \"Prefer importing %r instead of %r\",\n        \"preferred-module\",\n        \"Used when a module imported has a preferred replacement module.\",\n    ),\n    \"W0410\": (\n        \"__future__ import is not the first non docstring statement\",\n        \"misplaced-future\",\n        \"Python 2.5 and greater require __future__ import to be the \"\n        \"first non docstring statement in the module.\",\n    ),\n    \"C0410\": (\n        \"Multiple imports on one line (%s)\",\n        \"multiple-imports\",\n        \"Used when import statement importing multiple modules is detected.\",\n    ),\n    \"C0411\": (\n        \"%s should be placed before %s\",\n        \"wrong-import-order\",\n        \"Used when PEP8 import order is not respected (standard imports \"\n        \"first, then third-party libraries, then local imports).\",\n    ),\n    \"C0412\": (\n        \"Imports from package %s are not grouped\",\n        \"ungrouped-imports\",\n        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n    \"C0414\": (\n        \"Import alias does not rename original package\",\n        \"useless-import-alias\",\n        \"Used when an import alias is same as original package, \"\n        \"e.g., using import numpy as numpy instead of import numpy as np.\",\n    ),\n    \"C0415\": (\n        \"Import outside toplevel (%s)\",\n        \"import-outside-toplevel\",\n        \"Used when an import statement is used anywhere other than the module \"\n        \"toplevel. Move this import to the top of the file.\",\n    ),",
                        "filename": "pylint/checkers/imports.py",
                        "start_index": 7547,
                        "end_index": 10506,
                        "start_line": 47,
                        "end_line": 840,
                        "max_line": 1102,
                        "git_instance": "github",
                        "repo_name": "testbed/pylint-dev__pylint__2.15",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines error messages related to imports, which may need to be reviewed or updated to handle the described issue."
                },
                {
                    "chunk": {
                        "code": "def _check_preferred_module(self, node: ImportNode, mod_path: str) -> None:\n        \"\"\"Check if the module has a preferred replacement.\"\"\"\n\n        mod_compare = [mod_path]\n        # build a comparison list of possible names using importfrom\n        if isinstance(node, astroid.nodes.node_classes.ImportFrom):\n            mod_compare = [f\"{node.modname}.{name[0]}\" for name in node.names]\n\n        # find whether there are matches with the import vs preferred_modules keys\n        matches = [\n            k\n            for k in self.preferred_modules\n            for mod in mod_compare\n            # exact match\n            if k == mod\n            # checks for base module matches\n            or k in mod.split(\".\")[0]\n        ]\n\n        # if we have matches, add message\n        if matches:\n            self.add_message(\n                \"preferred-module\",\n                node=node,\n                args=(self.preferred_modules[matches[0]], matches[0]),\n            )\n\n    def _check_import_as_rename(self, node: ImportNode) -> None:\n        names = node.names\n        for name in names:\n            if not all(name):\n                return\n\n            splitted_packages = name[0].rsplit(\".\", maxsplit=1)\n            import_name = splitted_packages[-1]\n            aliased_name = name[1]\n            if import_name != aliased_name:\n                continue\n\n            if len(splitted_packages) == 1 and (\n                self._allow_reexport_package is False\n                or self._current_module_package is False\n            ):\n                self.add_message(\"useless-import-alias\", node=node, confidence=HIGH)\n            elif len(splitted_packages) == 2:\n                self.add_message(\n                    \"consider-using-from-import\",\n                    node=node,\n                    args=(splitted_packages[0], import_name),\n                )\n\n    def _check_reimport(\n        self,\n        node: ImportNode,\n        basename: str | None = None,\n        level: int | None = None,\n    ) -> None:\n        \"\"\"Check if a module with the same name is already imported or aliased.\"\"\"\n        if not self.linter.is_message_enabled(\n            \"reimported\"\n        ) and not self.linter.is_message_enabled(\"shadowed-import\"):\n            return\n\n        frame = node.frame()\n        root = node.root()\n        contexts = [(frame, level)]\n        if root is not frame:\n            contexts.append((root, None))\n\n        for known_context, known_level in contexts:\n            for name, alias in node.names:\n                first, msg = _get_first_import(\n                    node, known_context, name, basename, known_level, alias\n                )\n                if first is not None and msg is not None:\n                    name = name if msg == \"reimported\" else alias\n                    self.add_message(\n                        msg, node=node, args=(name, first.fromlineno), confidence=HIGH\n                    )",
                        "filename": "pylint/checkers/imports.py",
                        "start_index": 35171,
                        "end_index": 38101,
                        "start_line": 921,
                        "end_line": 999,
                        "max_line": 1102,
                        "git_instance": "github",
                        "repo_name": "testbed/pylint-dev__pylint__2.15",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains functions that check for preferred modules and import aliases, which might be relevant to the issue if the linting process is incorrectly handling module names."
                }
            ]
        },
        "solution_task": "- Add an empty `__init__.py` file to the `a` directory to ensure that Pylint recognizes it as a package.\n- Modify the Pylint module loading and package recognition logic to handle cases where a directory and a module have the same name without requiring an `__init__.py` file.\n- Ensure that the `discover_package_path` function in `pylint/lint/expand_modules.py` correctly identifies the package root in the presence of naming conflicts between directories and modules.\n- Update the logic in `pylint/lint/pylinter.py` to handle module resolution correctly when a directory and a module share the same name, potentially by checking if a directory is a package based on more than just the presence of an `__init__.py` file.\n- Add test cases to cover the scenario where a directory and a module share the same name to prevent regressions in the future.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a multi-step approach to address the bug described in the PROMPT. It suggests adding an empty `__init__.py` file as a temporary workaround, which is directly actionable and relevant. The RESPONSE also recommends modifying the Pylint module loading and package recognition logic, which is a more permanent solution to the problem. It specifically points to the `discover_package_path` function and the logic in `pylint/lint/pylinter.py` as potential areas to update, which is highly relevant given the nature of the bug. Additionally, the RESPONSE advises adding test cases to prevent future regressions, which is a best practice in software development. The inclusion of code snippets to check is particularly valuable as it guides the developer to the exact locations in the codebase that may require changes. The RESPONSE does not address all aspects of the bug, such as the side-effects in module resolution when running `pylint -E r a`, which prevents it from scoring a 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711699975.690391,
        "result": "- Add an empty `__init__.py` file to the `a` directory to ensure that Pylint recognizes it as a package.\n- Modify the Pylint module loading and package recognition logic to handle cases where a directory and a module have the same name without requiring an `__init__.py` file.\n- Ensure that the `discover_package_path` function in `pylint/lint/expand_modules.py` correctly identifies the package root in the presence of naming conflicts between directories and modules.\n- Update the logic in `pylint/lint/pylinter.py` to handle module resolution correctly when a directory and a module share the same name, potentially by checking if a directory is a package based on more than just the presence of an `__init__.py` file.\n- Add test cases to cover the scenario where a directory and a module share the same name to prevent regressions in the future.\n\n### Code snippets to check\n\n-  \u2192 [pylint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint) \u2192 [lint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint/lint)- [Lines 655 - 704](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/lint/pylinter.py#L655-L704)\n\n This snippet contains the main checking entry function which is likely where the issue with module resolution and linting failure occurs.\n-  \u2192 [pylint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint) \u2192 [lint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint/lint)- [Lines 1 - 69](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/lint/expand_modules.py#L1-L69)\n\n This snippet includes functions related to module path discovery and could be involved in the incorrect handling of modules with the same name as their parent directory.\n-  \u2192 [pylint](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint) \u2192 [checkers](https://github.com/testbed/pylint-dev__pylint__2.15/tree//pylint/checkers)- [Lines 47 - 840](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/checkers/imports.py#L47-L840)\n\n This snippet defines error messages related to imports, which may need to be reviewed or updated to handle the described issue. \n\n\n   - [Lines 921 - 999](https://github.com/testbed/pylint-dev__pylint__2.15/blob//pylint/checkers/imports.py#L921-L999)\n\n This snippet contains functions that check for preferred modules and import aliases, which might be relevant to the issue if the linting process is incorrectly handling module names."
    }
}