{
    "id": "scikit-learn__scikit-learn-19664",
    "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
    "task_id": 4688341834647540014,
    "title": "LabelPropagation raises TypeError: A sparse matrix was passed",
    "body": "#### Describe the bug\r\n\r\nLabelPropagation (and LabelSpreading) error out for sparse matrices.\r\n\r\n#### Steps/Code to Reproduce\r\n\r\n```\r\nimport sklearn\r\nfrom scipy.sparse import csr_matrix\r\nfrom sklearn.datasets import make_classification\r\nfrom sklearn.semi_supervised import LabelPropagation\r\n\r\nprint(sklearn.__version__)\r\n\r\nX, y = make_classification()\r\nclassifier = LabelPropagation(kernel='knn')\r\nclassifier.fit(X, y)\r\ny_pred = classifier.predict(X)\r\n\r\nX, y = make_classification()\r\nclassifier = LabelPropagation(kernel='knn')\r\nclassifier.fit(csr_matrix(X), y)\r\ny_pred = classifier.predict(csr_matrix(X))\r\n```\r\n\r\n#### Expected Results\r\n\r\nSparse case should work as does the dense one.\r\n\r\n#### Actual Results\r\n\r\n```\r\n0.22.2.post1\r\nTraceback (most recent call last):\r\n[...]\r\nTypeError: A sparse matrix was passed, but dense data is required. Use X.toarray() to convert to a dense numpy array.\r\n```\r\n\r\n#### Fix\r\n\r\nChanging \r\n\r\n```\r\n        X, y = check_X_y(X, y)\r\n```\r\n\r\nin _label_propagation.py line 224 to \r\n\r\n```\r\n        X, y = check_X_y(X, y, accept_sparse=['csc', 'csr', 'coo', 'dok',\r\n                                              'bsr', 'lil', 'dia'])\r\n```\r\n\r\nseems to fix the problem for me (BTW: a similar check accepting sparse matrices is done in BaseLabelPropagations predict_proba at line 189). This fix also heals LabelSpreading.\r\n\nFIX LabelPropagation handling of sparce matrices #17085\n#### Reference Issues/PRs\r\n\r\nFixes #17085\r\n\r\n#### What does this implement/fix? Explain your changes.\r\n\r\nLabel propagation and spreading allow to classify using sparse data according to documentation. Tests only covered the dense case. Newly added coverage for sparse matrices allows to reproduce the problem in #17085. The proposed fix in #17085 works for the extended tests.\r\n\r\n#### Any other comments?\r\n\r\n- Supporting scipy's dok_matrix produces the UserWarning \"Can't check dok sparse matrix for nan or inf.\". So this format seems to be unsuitable?\r\n- `test_label_propagation_closed_form` fails for sparse matrices \r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__1.3.git",
    "requested_commit": "",
    "mayil_response": "- Update the `fit` method in the `LabelPropagation` class to accept sparse matrices by modifying the `check_X_y` call to include the `accept_sparse` parameter with the appropriate list of sparse formats.\n\n```python\nfrom sklearn.utils.validation import check_X_y\n\nclass LabelPropagation(BaseLabelPropagation):\n    # ... existing code ...\n\n    def fit(self, X, y):\n        # ... existing code before check_X_y ...\n        X, y = check_X_y(X, y, accept_sparse=['csc', 'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'])\n        # ... existing code after check_X_y ...\n\n    # ... rest of the class ...\n```\n\n- Ensure that the `predict` method in the `LabelPropagation` class can handle sparse matrices if necessary. If changes are required, apply similar updates as in the `fit` method to handle sparse inputs.\n\n- Update the test `test_label_propagation_closed_form` to include cases with sparse matrices to ensure that the `LabelPropagation` algorithm works as expected with sparse data.\n\n- If the `predict_proba` method in `BaseLabelPropagation` already accepts sparse matrices, no changes are needed there. If not, ensure it can handle sparse inputs in a similar manner to the `fit` method.\n\n- Since the issue number and PR number are the same (#17085), ensure that the changes are linked to this issue/PR in the version control system for proper tracking.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn) \u2192 [semi_supervised](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn/semi_supervised)- [Lines 1 - 73](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/semi_supervised/_label_propagation.py#L1-L73)\n\n This snippet contains the module-level docstring for the LabelPropagation class, which provides context and an overview of the class's purpose and features. It is relevant for understanding the intended behavior of the class and the issue at hand. \n\n\n   - [Lines 338 - 338](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/semi_supervised/_label_propagation.py#L338-L338)\n\n This snippet marks the beginning of the LabelPropagation class definition. It is relevant because the issue is specifically with the LabelPropagation class, and changes to the class to handle sparse matrices would likely start here. \n\n\n   - [Lines 582 - 623](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/semi_supervised/_label_propagation.py#L582-L623)\n\n This snippet is from the LabelSpreading class, which is mentioned in the issue as also being affected by the sparse matrix problem. It is relevant because any changes to handle sparse matrices in LabelPropagation may also need to be reflected in LabelSpreading.\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn/utils)- [Lines 534 - 581](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/validation.py#L534-L581)\n\n This snippet is from 'sklearn/utils/validation.py' and shows the check for sparse matrix handling, which is directly related to the TypeError issue reported. It is relevant as it shows the current behavior when a sparse matrix is passed and the expected error message.",
    "ai_cost": {
        "search_embedding": 2.6e-07,
        "issue_classifier": 0.004554,
        "snippet_processor": 0.29709,
        "issue_star_creation": 0.02362,
        "issue_star_solver": 0.06302,
        "bouncer": 0.02704
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711738633.932265,
        "relevant_snippets": [
            {
                "code": "# coding=utf8\n\"\"\"\nLabel propagation in the context of this module refers to a set of\nsemi-supervised classification algorithms. At a high level, these algorithms\nwork by forming a fully-connected graph between all points given and solving\nfor the steady-state distribution of labels at each point.\n\nThese algorithms perform very well in practice. The cost of running can be very\nexpensive, at approximately O(N^3) where N is the number of (labeled and\nunlabeled) points. The theory (why they perform so well) is motivated by\nintuitions from random walk algorithms and geometric relationships in the data.\nFor more information see the references below.\n\nModel Features\n--------------\nLabel clamping:\n  The algorithm tries to learn distributions of labels over the dataset given\n  label assignments over an initial subset. In one variant, the algorithm does\n  not allow for any errors in the initial assignment (hard-clamping) while\n  in another variant, the algorithm allows for some wiggle room for the initial\n  assignments, allowing them to change by a fraction alpha in each iteration\n  (soft-clamping).\n\nKernel:\n  A function which projects a vector into some higher dimensional space. This\n  implementation supports RBF and KNN kernels. Using the RBF kernel generates\n  a dense matrix of size O(N^2). KNN kernel will generate a sparse matrix of\n  size O(k*N) which will run much faster. See the documentation for SVMs for\n  more info on kernels.\n\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn import datasets\n>>> from sklearn.semi_supervised import LabelPropagation\n>>> label_prop_model = LabelPropagation()\n>>> iris = datasets.load_iris()\n>>> rng = np.random.RandomState(42)\n>>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n>>> labels = np.copy(iris.target)\n>>> labels[random_unlabeled_points] = -1\n>>> label_prop_model.fit(iris.data, labels)\nLabelPropagation(...)\n\nNotes\n-----\nReferences:\n[1] Yoshua Bengio, Olivier Delalleau, Nicolas Le Roux. In Semi-Supervised\nLearning (2006), pp. 193-216\n\n[2] Olivier Delalleau, Yoshua Bengio, Nicolas Le Roux. Efficient\nNon-Parametric Function Induction in Semi-Supervised Learning. AISTAT 2005\n\"\"\"\n\n# Authors: Clay Woolam <clay@woolam.org>\n#          Utkarsh Upadhyay <mail@musicallyut.in>\n# License: BSD\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom numbers import Integral, Real\n\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import csgraph\n\nfrom ..base import BaseEstimator, ClassifierMixin, _fit_context\nfrom ..exceptions import ConvergenceWarning\nfrom ..metrics.pairwise import rbf_kernel\nfrom ..neighbors import NearestNeighbors\nfrom ..utils._param_validation import Interval, StrOptions\nfrom ..utils.extmath import safe_sparse_dot\nfrom ..utils.multiclass import check_classification_targets\nfrom ..utils.validation import check_is_fitted",
                "filename": "sklearn/semi_supervised/_label_propagation.py",
                "start_index": 0,
                "end_index": 2846,
                "start_line": 1,
                "end_line": 73,
                "max_line": 623,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "class LabelSpreading(BaseLabelPropagation):",
                "filename": "sklearn/semi_supervised/_label_propagation.py",
                "start_index": 16610,
                "end_index": 16653,
                "start_line": 486,
                "end_line": 486,
                "max_line": 623,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "if accept_sparse is False:\n        raise TypeError(\n            \"A sparse matrix was passed, but dense \"\n            \"data is required. Use X.toarray() to \"\n            \"convert to a dense numpy array.\"\n        )\n    elif isinstance(accept_sparse, (list, tuple)):\n        if len(accept_sparse) == 0:\n            raise ValueError(\n                \"When providing 'accept_sparse' \"\n                \"as a tuple or list, it must contain at \"\n                \"least one string value.\"\n            )\n        # ensure correct sparse format\n        if spmatrix.format not in accept_sparse:\n            # create new with correct sparse\n            spmatrix = spmatrix.asformat(accept_sparse[0])\n            changed_format = True\n    elif accept_sparse is not True:\n        # any other type\n        raise ValueError(\n            \"Parameter 'accept_sparse' should be a string, \"\n            \"boolean or list of strings. You provided \"\n            \"'accept_sparse={}'.\".format(accept_sparse)\n        )\n\n    if dtype != spmatrix.dtype:\n        # convert dtype\n        spmatrix = spmatrix.astype(dtype)\n    elif copy and not changed_format:\n        # force copy\n        spmatrix = spmatrix.copy()\n\n    if force_all_finite:\n        if not hasattr(spmatrix, \"data\"):\n            warnings.warn(\n                \"Can't check %s sparse matrix for nan or inf.\" % spmatrix.format,\n                stacklevel=2,\n            )\n        else:\n            _assert_all_finite(\n                spmatrix.data,\n                allow_nan=force_all_finite == \"allow-nan\",\n                estimator_name=estimator_name,\n                input_name=input_name,\n            )\n\n    return spmatrix",
                "filename": "sklearn/utils/validation.py",
                "start_index": 17856,
                "end_index": 19516,
                "start_line": 534,
                "end_line": 581,
                "max_line": 2282,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "\"\"\"\n===================================================\nLabel Propagation digits: Demonstrating performance\n===================================================\n\nThis example demonstrates the power of semisupervised learning by\ntraining a Label Spreading model to classify handwritten digits\nwith sets of very few labels.\n\nThe handwritten digit dataset has 1797 total points. The model will\nbe trained using all points, but only 30 will be labeled. Results\nin the form of a confusion matrix and a series of metrics over each\nclass will be very good.\n\nAt the end, the top 10 most uncertain predictions will be shown.\n\n\"\"\"\n\n# Authors: Clay Woolam <clay@woolam.org>\n# License: BSD\n\n# %%\n# Data generation\n# ---------------\n#\n# We use the digits dataset. We only use a subset of randomly selected samples.\nimport numpy as np\n\nfrom sklearn import datasets\n\ndigits = datasets.load_digits()\nrng = np.random.RandomState(2)\nindices = np.arange(len(digits.data))\nrng.shuffle(indices)\n\n# %%\n#\n# We selected 340 samples of which only 40 will be associated with a known label.\n# Therefore, we store the indices of the 300 other samples for which we are not\n# supposed to know their labels.\nX = digits.data[indices[:340]]\ny = digits.target[indices[:340]]\nimages = digits.images[indices[:340]]\n\nn_total_samples = len(y)\nn_labeled_points = 40\n\nindices = np.arange(n_total_samples)\n\nunlabeled_set = indices[n_labeled_points:]\n\n# %%\n# Shuffle everything around\ny_train = np.copy(y)\ny_train[unlabeled_set] = -1\n\n# %%\n# Semi-supervised learning\n# ------------------------\n#\n# We fit a :class:`~sklearn.semi_supervised.LabelSpreading` and use it to predict\n# the unknown labels.\nfrom sklearn.metrics import classification_report\nfrom sklearn.semi_supervised import LabelSpreading\n\nlp_model = LabelSpreading(gamma=0.25, max_iter=20)\nlp_model.fit(X, y_train)\npredicted_labels = lp_model.transduction_[unlabeled_set]\ntrue_labels = y[unlabeled_set]\n\nprint(\n    \"Label Spreading model: %d labeled & %d unlabeled points (%d total)\"\n    % (n_labeled_points, n_total_samples - n_labeled_points, n_total_samples)\n)\n\n# %%\n# Classification report\nprint(classification_report(true_labels, predicted_labels))\n\n# %%\n# Confusion matrix\nfrom sklearn.metrics import ConfusionMatrixDisplay\n\nConfusionMatrixDisplay.from_predictions(\n    true_labels, predicted_labels, labels=lp_model.classes_\n)\n\n# %%\n# Plot the most uncertain predictions\n# -----------------------------------\n#\n# Here, we will pick and show the 10 most uncertain predictions.\nfrom scipy import stats\n\npred_entropies = stats.distributions.entropy(lp_model.label_distributions_.T)\n\n# %%\n# Pick the top 10 most uncertain labels\nuncertainty_index = np.argsort(pred_entropies)[-10:]\n\n# %%\n# Plot\nimport matplotlib.pyplot as plt\n\nf = plt.figure(figsize=(7, 5))",
                "filename": "examples/semi_supervised/plot_label_propagation_digits.py",
                "start_index": 0,
                "end_index": 2781,
                "start_line": 1,
                "end_line": 105,
                "max_line": 118,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "_variant = \"spreading\"\n\n    _parameter_constraints: dict = {**BaseLabelPropagation._parameter_constraints}\n    _parameter_constraints[\"alpha\"] = [Interval(Real, 0, 1, closed=\"neither\")]\n\n    def __init__(\n        self,\n        kernel=\"rbf\",\n        *,\n        gamma=20,\n        n_neighbors=7,\n        alpha=0.2,\n        max_iter=30,\n        tol=1e-3,\n        n_jobs=None,\n    ):\n        # this one has different base parameters\n        super().__init__(\n            kernel=kernel,\n            gamma=gamma,\n            n_neighbors=n_neighbors,\n            alpha=alpha,\n            max_iter=max_iter,\n            tol=tol,\n            n_jobs=n_jobs,\n        )\n\n    def _build_graph(self):\n        \"\"\"Graph matrix for Label Spreading computes the graph laplacian\"\"\"\n        # compute affinity matrix (or gram matrix)\n        if self.kernel == \"knn\":\n            self.nn_fit = None\n        n_samples = self.X_.shape[0]\n        affinity_matrix = self._get_kernel(self.X_)\n        laplacian = csgraph.laplacian(affinity_matrix, normed=True)\n        laplacian = -laplacian\n        if sparse.issparse(laplacian):\n            diag_mask = laplacian.row == laplacian.col\n            laplacian.data[diag_mask] = 0.0\n        else:\n            laplacian.flat[:: n_samples + 1] = 0.0  # set diag to 0.0\n        return laplacian",
                "filename": "sklearn/semi_supervised/_label_propagation.py",
                "start_index": 19958,
                "end_index": 21269,
                "start_line": 582,
                "end_line": 623,
                "max_line": 623,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "\"\"\"\n==============================================\nLabel Propagation learning a complex structure\n==============================================\n\nExample of LabelPropagation learning a complex internal structure\nto demonstrate \"manifold learning\". The outer circle should be\nlabeled \"red\" and the inner circle \"blue\". Because both label groups\nlie inside their own distinct shape, we can see that the labels\npropagate correctly around the circle.\n\n\"\"\"\n\n# Authors: Clay Woolam <clay@woolam.org>\n#          Andreas Mueller <amueller@ais.uni-bonn.de>\n# License: BSD\n\n# %%\n# We generate a dataset with two concentric circles. In addition, a label\n# is associated with each sample of the dataset that is: 0 (belonging to\n# the outer circle), 1 (belonging to the inner circle), and -1 (unknown).\n# Here, all labels but two are tagged as unknown.\n\nimport numpy as np\n\nfrom sklearn.datasets import make_circles\n\nn_samples = 200\nX, y = make_circles(n_samples=n_samples, shuffle=False)\nouter, inner = 0, 1\nlabels = np.full(n_samples, -1.0)\nlabels[0] = outer\nlabels[-1] = inner\n\n# %%\n# Plot raw data\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(4, 4))\nplt.scatter(\n    X[labels == outer, 0],\n    X[labels == outer, 1],\n    color=\"navy\",\n    marker=\"s\",\n    lw=0,\n    label=\"outer labeled\",\n    s=10,\n)\nplt.scatter(\n    X[labels == inner, 0],\n    X[labels == inner, 1],\n    color=\"c\",\n    marker=\"s\",\n    lw=0,\n    label=\"inner labeled\",\n    s=10,\n)\nplt.scatter(\n    X[labels == -1, 0],\n    X[labels == -1, 1],\n    color=\"darkorange\",\n    marker=\".\",\n    label=\"unlabeled\",\n)\nplt.legend(scatterpoints=1, shadow=False, loc=\"center\")\n_ = plt.title(\"Raw data (2 classes=outer and inner)\")\n\n# %%\n#\n# The aim of :class:`~sklearn.semi_supervised.LabelSpreading` is to associate\n# a label to sample where the label is initially unknown.\nfrom sklearn.semi_supervised import LabelSpreading\n\nlabel_spread = LabelSpreading(kernel=\"knn\", alpha=0.8)\nlabel_spread.fit(X, labels)\n\n# %%\n# Now, we can check which labels have been associated with each sample\n# when the label was unknown.\noutput_labels = label_spread.transduction_\noutput_label_array = np.asarray(output_labels)\nouter_numbers = np.where(output_label_array == outer)[0]\ninner_numbers = np.where(output_label_array == inner)[0]\n\nplt.figure(figsize=(4, 4))\nplt.scatter(\n    X[outer_numbers, 0],\n    X[outer_numbers, 1],\n    color=\"navy\",\n    marker=\"s\",\n    lw=0,\n    s=10,\n    label=\"outer learned\",\n)\nplt.scatter(\n    X[inner_numbers, 0],\n    X[inner_numbers, 1],\n    color=\"c\",\n    marker=\"s\",\n    lw=0,\n    s=10,\n    label=\"inner learned\",\n)\nplt.legend(scatterpoints=1, shadow=False, loc=\"center\")\nplt.title(\"Labels learned with Label Spreading (KNN)\")\nplt.show()",
                "filename": "examples/semi_supervised/plot_label_propagation_structure.py",
                "start_index": 0,
                "end_index": 2710,
                "start_line": 1,
                "end_line": 106,
                "max_line": 106,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "class LabelPropagation(BaseLabelPropagation):",
                "filename": "sklearn/semi_supervised/_label_propagation.py",
                "start_index": 11833,
                "end_index": 11878,
                "start_line": 338,
                "end_line": 338,
                "max_line": 623,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "def check_array_api_input_and_values(\n    name,\n    estimator_orig,\n    array_namespace,\n    device=None,\n    dtype=\"float64\",\n):\n    return check_array_api_input(\n        name,\n        estimator_orig,\n        array_namespace=array_namespace,\n        device=device,\n        dtype=dtype,\n        check_values=True,\n    )\n\n\ndef check_estimator_sparse_data(name, estimator_orig):\n    rng = np.random.RandomState(0)\n    X = rng.uniform(size=(40, 3))\n    X[X < 0.8] = 0\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    X_csr = sparse.csr_matrix(X)\n    y = (4 * rng.uniform(size=40)).astype(int)\n    # catch deprecation warnings\n    with ignore_warnings(category=FutureWarning):\n        estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n    tags = _safe_tags(estimator_orig)\n    for matrix_format, X in _generate_sparse_matrix(X_csr):\n        # catch deprecation warnings\n        with ignore_warnings(category=FutureWarning):\n            estimator = clone(estimator_orig)\n            if name in [\"Scaler\", \"StandardScaler\"]:\n                estimator.set_params(with_mean=False)\n        # fit and predict\n        if \"64\" in matrix_format:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to support {matrix_format} \"\n                \"matrix, and is not failing gracefully, e.g. by using \"\n                \"check_array(X, accept_large_sparse=False)\"\n            )\n        else:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to fail gracefully on sparse \"\n                \"data: error message should state explicitly that sparse \"\n                \"input is not supported if this is not the case.\"\n            )\n        with raises(\n            (TypeError, ValueError),\n            match=[\"sparse\", \"Sparse\"],\n            may_pass=True,\n            err_msg=err_msg,\n        ):\n            with ignore_warnings(category=FutureWarning):\n                estimator.fit(X, y)\n            if hasattr(estimator, \"predict\"):\n                pred = estimator.predict(X)\n                if tags[\"multioutput_only\"]:\n                    assert pred.shape == (X.shape[0], 1)\n                else:\n                    assert pred.shape == (X.shape[0],)\n            if hasattr(estimator, \"predict_proba\"):\n                probs = estimator.predict_proba(X)\n                if tags[\"binary_only\"]:\n                    expected_probs_shape = (X.shape[0], 2)\n                else:\n                    expected_probs_shape = (X.shape[0], 4)\n                assert probs.shape == expected_probs_shape",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 36016,
                "end_index": 38577,
                "start_line": 1025,
                "end_line": 1093,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "# Authors: Manoj Kumar <manojkumarsivaraj334@gmail.com>\n#          Alexandre Gramfort <alexandre.gramfort@telecom-paristech.fr>\n#          Joel Nothman <joel.nothman@gmail.com>\n# License: BSD 3 clause\n\nimport warnings\nfrom math import sqrt\nfrom numbers import Integral, Real\n\nimport numpy as np\nfrom scipy import sparse\n\nfrom .._config import config_context\nfrom ..base import (\n    BaseEstimator,\n    ClassNamePrefixFeaturesOutMixin,\n    ClusterMixin,\n    TransformerMixin,\n    _fit_context,\n)\nfrom ..exceptions import ConvergenceWarning\nfrom ..metrics import pairwise_distances_argmin\nfrom ..metrics.pairwise import euclidean_distances\nfrom ..utils._param_validation import Interval\nfrom ..utils.extmath import row_norms\nfrom ..utils.validation import check_is_fitted\nfrom . import AgglomerativeClustering\n\n\ndef _iterate_sparse_X(X):\n    \"\"\"This little hack returns a densified row when iterating over a sparse\n    matrix, instead of constructing a sparse matrix for every row that is\n    expensive.\n    \"\"\"\n    n_samples = X.shape[0]\n    X_indices = X.indices\n    X_data = X.data\n    X_indptr = X.indptr\n\n    for i in range(n_samples):\n        row = np.zeros(X.shape[1])\n        startptr, endptr = X_indptr[i], X_indptr[i + 1]\n        nonzero_indices = X_indices[startptr:endptr]\n        row[nonzero_indices] = X_data[startptr:endptr]\n        yield row",
                "filename": "sklearn/cluster/_birch.py",
                "start_index": 0,
                "end_index": 1355,
                "start_line": 1,
                "end_line": 45,
                "max_line": 741,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            },
            {
                "code": "\"\"\"\n========================================\nLabel Propagation digits active learning\n========================================\n\nDemonstrates an active learning technique to learn handwritten digits\nusing label propagation.\n\nWe start by training a label propagation model with only 10 labeled points,\nthen we select the top five most uncertain points to label. Next, we train\nwith 15 labeled points (original 10 + 5 new ones). We repeat this process\nfour times to have a model trained with 30 labeled examples. Note you can\nincrease this to label more than 30 by changing `max_iterations`. Labeling\nmore than 30 can be useful to get a sense for the speed of convergence of\nthis active learning technique.\n\nA plot will appear showing the top 5 most uncertain digits for each iteration\nof training. These may or may not contain mistakes, but we will train the next\nmodel with their true labels.\n\n\"\"\"\n\n# Authors: Clay Woolam <clay@woolam.org>\n# License: BSD\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import stats\n\nfrom sklearn import datasets\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.semi_supervised import LabelSpreading\n\ndigits = datasets.load_digits()\nrng = np.random.RandomState(0)\nindices = np.arange(len(digits.data))\nrng.shuffle(indices)\n\nX = digits.data[indices[:330]]\ny = digits.target[indices[:330]]\nimages = digits.images[indices[:330]]\n\nn_total_samples = len(y)\nn_labeled_points = 40\nmax_iterations = 5\n\nunlabeled_indices = np.arange(n_total_samples)[n_labeled_points:]\nf = plt.figure()",
                "filename": "examples/semi_supervised/plot_label_propagation_digits_active_learning.py",
                "start_index": 0,
                "end_index": 1555,
                "start_line": 1,
                "end_line": 48,
                "max_line": 125,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sklearn/semi_supervised/_label_propagation.py": [
                {
                    "chunk": {
                        "code": "# coding=utf8\n\"\"\"\nLabel propagation in the context of this module refers to a set of\nsemi-supervised classification algorithms. At a high level, these algorithms\nwork by forming a fully-connected graph between all points given and solving\nfor the steady-state distribution of labels at each point.\n\nThese algorithms perform very well in practice. The cost of running can be very\nexpensive, at approximately O(N^3) where N is the number of (labeled and\nunlabeled) points. The theory (why they perform so well) is motivated by\nintuitions from random walk algorithms and geometric relationships in the data.\nFor more information see the references below.\n\nModel Features\n--------------\nLabel clamping:\n  The algorithm tries to learn distributions of labels over the dataset given\n  label assignments over an initial subset. In one variant, the algorithm does\n  not allow for any errors in the initial assignment (hard-clamping) while\n  in another variant, the algorithm allows for some wiggle room for the initial\n  assignments, allowing them to change by a fraction alpha in each iteration\n  (soft-clamping).\n\nKernel:\n  A function which projects a vector into some higher dimensional space. This\n  implementation supports RBF and KNN kernels. Using the RBF kernel generates\n  a dense matrix of size O(N^2). KNN kernel will generate a sparse matrix of\n  size O(k*N) which will run much faster. See the documentation for SVMs for\n  more info on kernels.\n\nExamples\n--------\n>>> import numpy as np\n>>> from sklearn import datasets\n>>> from sklearn.semi_supervised import LabelPropagation\n>>> label_prop_model = LabelPropagation()\n>>> iris = datasets.load_iris()\n>>> rng = np.random.RandomState(42)\n>>> random_unlabeled_points = rng.rand(len(iris.target)) < 0.3\n>>> labels = np.copy(iris.target)\n>>> labels[random_unlabeled_points] = -1\n>>> label_prop_model.fit(iris.data, labels)\nLabelPropagation(...)\n\nNotes\n-----\nReferences:\n[1] Yoshua Bengio, Olivier Delalleau, Nicolas Le Roux. In Semi-Supervised\nLearning (2006), pp. 193-216\n\n[2] Olivier Delalleau, Yoshua Bengio, Nicolas Le Roux. Efficient\nNon-Parametric Function Induction in Semi-Supervised Learning. AISTAT 2005\n\"\"\"\n\n# Authors: Clay Woolam <clay@woolam.org>\n#          Utkarsh Upadhyay <mail@musicallyut.in>\n# License: BSD\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom numbers import Integral, Real\n\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import csgraph\n\nfrom ..base import BaseEstimator, ClassifierMixin, _fit_context\nfrom ..exceptions import ConvergenceWarning\nfrom ..metrics.pairwise import rbf_kernel\nfrom ..neighbors import NearestNeighbors\nfrom ..utils._param_validation import Interval, StrOptions\nfrom ..utils.extmath import safe_sparse_dot\nfrom ..utils.multiclass import check_classification_targets\nfrom ..utils.validation import check_is_fitted",
                        "filename": "sklearn/semi_supervised/_label_propagation.py",
                        "start_index": 0,
                        "end_index": 2846,
                        "start_line": 1,
                        "end_line": 73,
                        "max_line": 623,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the module-level docstring for the LabelPropagation class, which provides context and an overview of the class's purpose and features. It is relevant for understanding the intended behavior of the class and the issue at hand."
                },
                {
                    "chunk": {
                        "code": "class LabelPropagation(BaseLabelPropagation):",
                        "filename": "sklearn/semi_supervised/_label_propagation.py",
                        "start_index": 11833,
                        "end_index": 11878,
                        "start_line": 338,
                        "end_line": 338,
                        "max_line": 623,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet marks the beginning of the LabelPropagation class definition. It is relevant because the issue is specifically with the LabelPropagation class, and changes to the class to handle sparse matrices would likely start here."
                },
                {
                    "chunk": {
                        "code": "_variant = \"spreading\"\n\n    _parameter_constraints: dict = {**BaseLabelPropagation._parameter_constraints}\n    _parameter_constraints[\"alpha\"] = [Interval(Real, 0, 1, closed=\"neither\")]\n\n    def __init__(\n        self,\n        kernel=\"rbf\",\n        *,\n        gamma=20,\n        n_neighbors=7,\n        alpha=0.2,\n        max_iter=30,\n        tol=1e-3,\n        n_jobs=None,\n    ):\n        # this one has different base parameters\n        super().__init__(\n            kernel=kernel,\n            gamma=gamma,\n            n_neighbors=n_neighbors,\n            alpha=alpha,\n            max_iter=max_iter,\n            tol=tol,\n            n_jobs=n_jobs,\n        )\n\n    def _build_graph(self):\n        \"\"\"Graph matrix for Label Spreading computes the graph laplacian\"\"\"\n        # compute affinity matrix (or gram matrix)\n        if self.kernel == \"knn\":\n            self.nn_fit = None\n        n_samples = self.X_.shape[0]\n        affinity_matrix = self._get_kernel(self.X_)\n        laplacian = csgraph.laplacian(affinity_matrix, normed=True)\n        laplacian = -laplacian\n        if sparse.issparse(laplacian):\n            diag_mask = laplacian.row == laplacian.col\n            laplacian.data[diag_mask] = 0.0\n        else:\n            laplacian.flat[:: n_samples + 1] = 0.0  # set diag to 0.0\n        return laplacian",
                        "filename": "sklearn/semi_supervised/_label_propagation.py",
                        "start_index": 19958,
                        "end_index": 21269,
                        "start_line": 582,
                        "end_line": 623,
                        "max_line": 623,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is from the LabelSpreading class, which is mentioned in the issue as also being affected by the sparse matrix problem. It is relevant because any changes to handle sparse matrices in LabelPropagation may also need to be reflected in LabelSpreading."
                }
            ],
            "sklearn/utils/validation.py": [
                {
                    "chunk": {
                        "code": "if accept_sparse is False:\n        raise TypeError(\n            \"A sparse matrix was passed, but dense \"\n            \"data is required. Use X.toarray() to \"\n            \"convert to a dense numpy array.\"\n        )\n    elif isinstance(accept_sparse, (list, tuple)):\n        if len(accept_sparse) == 0:\n            raise ValueError(\n                \"When providing 'accept_sparse' \"\n                \"as a tuple or list, it must contain at \"\n                \"least one string value.\"\n            )\n        # ensure correct sparse format\n        if spmatrix.format not in accept_sparse:\n            # create new with correct sparse\n            spmatrix = spmatrix.asformat(accept_sparse[0])\n            changed_format = True\n    elif accept_sparse is not True:\n        # any other type\n        raise ValueError(\n            \"Parameter 'accept_sparse' should be a string, \"\n            \"boolean or list of strings. You provided \"\n            \"'accept_sparse={}'.\".format(accept_sparse)\n        )\n\n    if dtype != spmatrix.dtype:\n        # convert dtype\n        spmatrix = spmatrix.astype(dtype)\n    elif copy and not changed_format:\n        # force copy\n        spmatrix = spmatrix.copy()\n\n    if force_all_finite:\n        if not hasattr(spmatrix, \"data\"):\n            warnings.warn(\n                \"Can't check %s sparse matrix for nan or inf.\" % spmatrix.format,\n                stacklevel=2,\n            )\n        else:\n            _assert_all_finite(\n                spmatrix.data,\n                allow_nan=force_all_finite == \"allow-nan\",\n                estimator_name=estimator_name,\n                input_name=input_name,\n            )\n\n    return spmatrix",
                        "filename": "sklearn/utils/validation.py",
                        "start_index": 17856,
                        "end_index": 19516,
                        "start_line": 534,
                        "end_line": 581,
                        "max_line": 2282,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is from 'sklearn/utils/validation.py' and shows the check for sparse matrix handling, which is directly related to the TypeError issue reported. It is relevant as it shows the current behavior when a sparse matrix is passed and the expected error message."
                }
            ]
        },
        "solution_task": "- Update the `fit` method in the `LabelPropagation` class to accept sparse matrices by modifying the `check_X_y` call to include the `accept_sparse` parameter with the appropriate list of sparse formats.\n\n```python\nfrom sklearn.utils.validation import check_X_y\n\nclass LabelPropagation(BaseLabelPropagation):\n    # ... existing code ...\n\n    def fit(self, X, y):\n        # ... existing code before check_X_y ...\n        X, y = check_X_y(X, y, accept_sparse=['csc', 'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'])\n        # ... existing code after check_X_y ...\n\n    # ... rest of the class ...\n```\n\n- Ensure that the `predict` method in the `LabelPropagation` class can handle sparse matrices if necessary. If changes are required, apply similar updates as in the `fit` method to handle sparse inputs.\n\n- Update the test `test_label_propagation_closed_form` to include cases with sparse matrices to ensure that the `LabelPropagation` algorithm works as expected with sparse data.\n\n- If the `predict_proba` method in `BaseLabelPropagation` already accepts sparse matrices, no changes are needed there. If not, ensure it can handle sparse inputs in a similar manner to the `fit` method.\n\n- Since the issue number and PR number are the same (#17085), ensure that the changes are linked to this issue/PR in the version control system for proper tracking.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the main issue described in the PROMPT, which is the TypeError raised when a sparse matrix is passed to the LabelPropagation class. The RESPONSE suggests updating the `fit` method to accept sparse matrices by modifying the `check_X_y` call, which is directly relevant to the bug. It also advises ensuring that the `predict` method can handle sparse matrices and updating the test cases to include sparse matrices, which are both relevant to ensuring the bug is fixed and does not recur. The RESPONSE also correctly identifies that the `predict_proba` method may not need changes if it already accepts sparse matrices. However, the RESPONSE does not address the specific concerns raised in the PROMPT about the suitability of the 'dok_matrix' format and the failure of the `test_label_propagation_closed_form` for sparse matrices, which prevents it from scoring higher.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711738729.151464,
        "result": "- Update the `fit` method in the `LabelPropagation` class to accept sparse matrices by modifying the `check_X_y` call to include the `accept_sparse` parameter with the appropriate list of sparse formats.\n\n```python\nfrom sklearn.utils.validation import check_X_y\n\nclass LabelPropagation(BaseLabelPropagation):\n    # ... existing code ...\n\n    def fit(self, X, y):\n        # ... existing code before check_X_y ...\n        X, y = check_X_y(X, y, accept_sparse=['csc', 'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'])\n        # ... existing code after check_X_y ...\n\n    # ... rest of the class ...\n```\n\n- Ensure that the `predict` method in the `LabelPropagation` class can handle sparse matrices if necessary. If changes are required, apply similar updates as in the `fit` method to handle sparse inputs.\n\n- Update the test `test_label_propagation_closed_form` to include cases with sparse matrices to ensure that the `LabelPropagation` algorithm works as expected with sparse data.\n\n- If the `predict_proba` method in `BaseLabelPropagation` already accepts sparse matrices, no changes are needed there. If not, ensure it can handle sparse inputs in a similar manner to the `fit` method.\n\n- Since the issue number and PR number are the same (#17085), ensure that the changes are linked to this issue/PR in the version control system for proper tracking.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn) \u2192 [semi_supervised](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn/semi_supervised)- [Lines 1 - 73](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/semi_supervised/_label_propagation.py#L1-L73)\n\n This snippet contains the module-level docstring for the LabelPropagation class, which provides context and an overview of the class's purpose and features. It is relevant for understanding the intended behavior of the class and the issue at hand. \n\n\n   - [Lines 338 - 338](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/semi_supervised/_label_propagation.py#L338-L338)\n\n This snippet marks the beginning of the LabelPropagation class definition. It is relevant because the issue is specifically with the LabelPropagation class, and changes to the class to handle sparse matrices would likely start here. \n\n\n   - [Lines 582 - 623](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/semi_supervised/_label_propagation.py#L582-L623)\n\n This snippet is from the LabelSpreading class, which is mentioned in the issue as also being affected by the sparse matrix problem. It is relevant because any changes to handle sparse matrices in LabelPropagation may also need to be reflected in LabelSpreading.\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn/utils)- [Lines 534 - 581](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/validation.py#L534-L581)\n\n This snippet is from 'sklearn/utils/validation.py' and shows the check for sparse matrix handling, which is directly related to the TypeError issue reported. It is relevant as it shows the current behavior when a sparse matrix is passed and the expected error message."
    }
}