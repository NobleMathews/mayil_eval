{
    "id": "django__django-11772",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 5036088511571984371,
    "title": "Template Cache \"make_template_fragment_key\" function speed up + simplify (also discussing switch to alternate hashes)",
    "body": "Description\n\t \n\t\t(last modified by Daniel)\n\t \nThe make_template_fragment_key function in django.core.cache.utils has the following (minor) issues:\nUsing urllib.quote for vary_on args, is not needed any more - it was originally added to make the unhashed strings safe to send to memcached and similar restricted systems. But since the value is hashed, this is now adding nothing. (See \u200bhttps://github.com/django/django/commit/ebc1325721e43808cef4334edaffc23a43f86614#diff-702b69be0100a594fd6fea1e4ab2feb1).\nUse of the MD5 hashing function is disallowed on certain (odd) systems, not being FIPS compliant. See (\u200bhttps://github.com/django/django/pull/10605).\nCreates a string of all joined vary_on args to send to the hashing function, rather than using the hashlib .update() method.\nHere is a version solving these, switching to SHA256, and speeding up the function quite a bit:\n\u200bhttps://github.com/danthedeckie/django/tree/simplified_make_template_fragment_key\nAnd PR: \u200bhttps://github.com/django/django/pull/11772\nAnd here's the repo showing performance improvement:\n\u200bhttps://github.com/danthedeckie/make_template_fragment_key_test\nWhich seems to be faster in every case.\nThe downside of this is that the cache key is now different from before. The tests have been updated to the new values.\nThere are other cache key generating functions used in other places which use MD5 still - if switching to SHA256 it would make sense to me to change those at the same time, meaning only one time invalidating keys on upgrade.\nThoughts?\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the requested feature, follow these steps:\n\n- Replace the MD5 hashing function with SHA256 for FIPS compliance.\n- Remove the use of `urllib.quote` since it's unnecessary after hashing.\n- Update the `make_template_fragment_key` function to use the `hashlib.update()` method directly with the `vary_on` arguments.\n\nHere's the updated `make_template_fragment_key` function:\n\n```python\nfrom hashlib import sha256\n\nTEMPLATE_FRAGMENT_KEY_TEMPLATE = \"template.cache.%s.%s\"\n\ndef make_template_fragment_key(fragment_name, vary_on=None):\n    hasher = sha256()\n    if vary_on is not None:\n        for arg in vary_on:\n            hasher.update(str(arg).encode())\n            hasher.update(b\":\")\n    return TEMPLATE_FRAGMENT_KEY_TEMPLATE % (fragment_name, hasher.hexdigest())\n```\n\n- Update all tests and any other code that depends on the `make_template_fragment_key` function to expect the new cache key format.\n- Consider updating other cache key generating functions in the project to use SHA256 for consistency and to avoid invalidating keys multiple times.\n- Review the pull request at \u200bhttps://github.com/django/django/pull/11772 for additional context and implementation details.\n- Benchmark the performance improvements using the repository at \u200bhttps://github.com/danthedeckie/make_template_fragment_key_test.\n- Update documentation to reflect the changes in the cache key generation method.\n\nNote: This change will invalidate existing cache keys. Plan for cache invalidation and a possible performance impact when deploying this change.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [cache](https://github.com/testbed/django__django__3.1/tree//django/core/cache)- [Lines 1 - 12](https://github.com/testbed/django__django__3.1/blob//django/core/cache/utils.py#L1-L12)\n\n This snippet contains the implementation of the 'make_template_fragment_key' function which is directly related to the issue. Changes to the hashing function and removal of unnecessary encoding will be made here.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [templatetags](https://github.com/testbed/django__django__3.1/tree//django/templatetags)- [Lines 1 - 55](https://github.com/testbed/django__django__3.1/blob//django/templatetags/cache.py#L1-L55)\n\n This snippet uses the 'make_template_fragment_key' function within the 'CacheNode' class. It is necessary to review this usage to ensure compatibility with the changes made to the key generation function.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 1 - 76](https://github.com/testbed/django__django__3.1/blob//django/utils/crypto.py#L1-L76)\n\n This snippet contains the 'salted_hmac' function which uses a hashing algorithm. If the decision is made to switch all hash functions to SHA256, this function may need to be reviewed for consistency.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 298 - 373](https://github.com/testbed/django__django__3.1/blob//django/utils/cache.py#L298-L373)\n\n This snippet includes a cache key generation method '_generate_cache_key' that uses MD5. If switching to SHA256, this method may need to be updated for consistency.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00033,
        "snippet_processor": 0.050890000000000005,
        "issue_star_creation": 0.023889999999999998,
        "issue_star_solver": 0.04168000000000001,
        "bouncer": 0.02727
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711732771.381975,
        "relevant_snippets": [
            {
                "code": "from hashlib import md5\n\nTEMPLATE_FRAGMENT_KEY_TEMPLATE = \"template.cache.%s.%s\"\n\n\ndef make_template_fragment_key(fragment_name, vary_on=None):\n    hasher = md5(usedforsecurity=False)\n    if vary_on is not None:\n        for arg in vary_on:\n            hasher.update(str(arg).encode())\n            hasher.update(b\":\")\n    return TEMPLATE_FRAGMENT_KEY_TEMPLATE % (fragment_name, hasher.hexdigest())",
                "filename": "django/core/cache/utils.py",
                "start_index": 0,
                "end_index": 396,
                "start_line": 1,
                "end_line": 12,
                "max_line": 12,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from django.core.cache import InvalidCacheBackendError, caches\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.template import Library, Node, TemplateSyntaxError, VariableDoesNotExist\n\nregister = Library()\n\n\nclass CacheNode(Node):\n    def __init__(self, nodelist, expire_time_var, fragment_name, vary_on, cache_name):\n        self.nodelist = nodelist\n        self.expire_time_var = expire_time_var\n        self.fragment_name = fragment_name\n        self.vary_on = vary_on\n        self.cache_name = cache_name\n\n    def render(self, context):\n        try:\n            expire_time = self.expire_time_var.resolve(context)\n        except VariableDoesNotExist:\n            raise TemplateSyntaxError(\n                '\"cache\" tag got an unknown variable: %r' % self.expire_time_var.var\n            )\n        if expire_time is not None:\n            try:\n                expire_time = int(expire_time)\n            except (ValueError, TypeError):\n                raise TemplateSyntaxError(\n                    '\"cache\" tag got a non-integer timeout value: %r' % expire_time\n                )\n        if self.cache_name:\n            try:\n                cache_name = self.cache_name.resolve(context)\n            except VariableDoesNotExist:\n                raise TemplateSyntaxError(\n                    '\"cache\" tag got an unknown variable: %r' % self.cache_name.var\n                )\n            try:\n                fragment_cache = caches[cache_name]\n            except InvalidCacheBackendError:\n                raise TemplateSyntaxError(\n                    \"Invalid cache name specified for cache tag: %r\" % cache_name\n                )\n        else:\n            try:\n                fragment_cache = caches[\"template_fragments\"]\n            except InvalidCacheBackendError:\n                fragment_cache = caches[\"default\"]\n\n        vary_on = [var.resolve(context) for var in self.vary_on]\n        cache_key = make_template_fragment_key(self.fragment_name, vary_on)\n        value = fragment_cache.get(cache_key)\n        if value is None:\n            value = self.nodelist.render(context)\n            fragment_cache.set(cache_key, value, expire_time)\n        return value",
                "filename": "django/templatetags/cache.py",
                "start_index": 0,
                "end_index": 2194,
                "start_line": 1,
                "end_line": 55,
                "max_line": 100,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "import base64\nimport datetime\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom email.utils import formatdate\nfrom urllib.parse import quote, unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlparse\n\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n# Based on RFC 9110 Appendix A.\nETAG_MATCH = _lazy_re_compile(\n    r\"\"\"\n    \\A(      # start of string and capture group\n    (?:W/)?  # optional weak indicator\n    \"        # opening quote\n    [^\"]*    # any sequence of non-quote characters\n    \"        # end quote\n    )\\Z      # end of string and capture group\n\"\"\",\n    re.X,\n)\n\nMONTHS = \"jan feb mar apr may jun jul aug sep oct nov dec\".split()\n__D = r\"(?P<day>[0-9]{2})\"\n__D2 = r\"(?P<day>[ 0-9][0-9])\"\n__M = r\"(?P<mon>\\w{3})\"\n__Y = r\"(?P<year>[0-9]{4})\"\n__Y2 = r\"(?P<year>[0-9]{2})\"\n__T = r\"(?P<hour>[0-9]{2}):(?P<min>[0-9]{2}):(?P<sec>[0-9]{2})\"\nRFC1123_DATE = _lazy_re_compile(r\"^\\w{3}, %s %s %s %s GMT$\" % (__D, __M, __Y, __T))\nRFC850_DATE = _lazy_re_compile(r\"^\\w{6,9}, %s-%s-%s %s GMT$\" % (__D, __M, __Y2, __T))\nASCTIME_DATE = _lazy_re_compile(r\"^\\w{3} %s %s %s %s$\" % (__M, __D2, __T, __Y))\n\nRFC3986_GENDELIMS = \":/?#[]@\"\nRFC3986_SUBDELIMS = \"!$&'()*+,;=\"\n\n\ndef urlencode(query, doseq=False):\n    \"\"\"\n    A version of Python's urllib.parse.urlencode() function that can operate on\n    MultiValueDict and non-string values.\n    \"\"\"\n    if isinstance(query, MultiValueDict):\n        query = query.lists()\n    elif hasattr(query, \"items\"):\n        query = query.items()\n    query_params = []\n    for key, value in query:\n        if value is None:\n            raise TypeError(\n                \"Cannot encode None for key '%s' in a query string. Did you \"\n                \"mean to pass an empty string or omit the value?\" % key\n            )\n        elif not doseq or isinstance(value, (str, bytes)):\n            query_val = value\n        else:\n            try:\n                itr = iter(value)\n            except TypeError:\n                query_val = value\n            else:\n                # Consume generators and iterators, when doseq=True, to\n                # work around https://bugs.python.org/issue31706.\n                query_val = []\n                for item in itr:\n                    if item is None:\n                        raise TypeError(\n                            \"Cannot encode None for key '%s' in a query \"\n                            \"string. Did you mean to pass an empty string or \"\n                            \"omit the value?\" % key\n                        )\n                    elif not isinstance(item, bytes):\n                        item = str(item)\n                    query_val.append(item)\n        query_params.append((key, query_val))\n    return original_urlencode(query_params, doseq)",
                "filename": "django/utils/http.py",
                "start_index": 0,
                "end_index": 2859,
                "start_line": 1,
                "end_line": 80,
                "max_line": 375,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\nThis module contains helper functions for controlling caching. It does so by\nmanaging the \"Vary\" header of responses. It includes functions to patch the\nheader of response objects directly and decorators that change functions to do\nthat header-patching themselves.\n\nFor information on the Vary header, see RFC 9110 Section 12.5.5.\n\nEssentially, the \"Vary\" HTTP header defines which headers a cache should take\ninto account when building its cache key. Requests with the same path but\ndifferent header content for headers named in \"Vary\" need to get different\ncache keys to prevent delivery of wrong content.\n\nAn example: i18n middleware would need to distinguish caches by the\n\"Accept-language\" header.\n\"\"\"\nimport time\nfrom collections import defaultdict\nfrom hashlib import md5\n\nfrom django.conf import settings\nfrom django.core.cache import caches\nfrom django.http import HttpResponse, HttpResponseNotModified\nfrom django.utils.http import http_date, parse_etags, parse_http_date_safe, quote_etag\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_current_timezone_name\nfrom django.utils.translation import get_language\n\ncc_delim_re = _lazy_re_compile(r\"\\s*,\\s*\")",
                "filename": "django/utils/cache.py",
                "start_index": 0,
                "end_index": 1253,
                "start_line": 1,
                "end_line": 30,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\nDjango's standard crypto functions and utilities.\n\"\"\"\nimport hashlib\nimport hmac\nimport secrets\n\nfrom django.conf import settings\nfrom django.utils.encoding import force_bytes\n\n\nclass InvalidAlgorithm(ValueError):\n    \"\"\"Algorithm is not supported by hashlib.\"\"\"\n\n    pass\n\n\ndef salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n    \"\"\"\n    Return the HMAC of 'value', using a key generated from key_salt and a\n    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n    but any algorithm name supported by hashlib can be passed.\n\n    A different key_salt should be passed in for every application of HMAC.\n    \"\"\"\n    if secret is None:\n        secret = settings.SECRET_KEY\n\n    key_salt = force_bytes(key_salt)\n    secret = force_bytes(secret)\n    try:\n        hasher = getattr(hashlib, algorithm)\n    except AttributeError as e:\n        raise InvalidAlgorithm(\n            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n        ) from e\n    # We need to generate a derived key from our base key.  We can do this by\n    # passing the key_salt and our base key through a pseudo-random function.\n    key = hasher(key_salt + secret).digest()\n    # If len(key_salt + secret) > block size of the hash algorithm, the above\n    # line is redundant and could be replaced by key = key_salt + secret, since\n    # the hmac module does the same thing for keys longer than the block size.\n    # However, we need to ensure that we *always* do this.\n    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n\n\nRANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\n\ndef get_random_string(length, allowed_chars=RANDOM_STRING_CHARS):\n    \"\"\"\n    Return a securely generated random string.\n\n    The bit length of the returned value can be calculated with the formula:\n        log_2(len(allowed_chars)^length)\n\n    For example, with default `allowed_chars` (26+26+10), this gives:\n      * length: 12, bit length =~ 71 bits\n      * length: 22, bit length =~ 131 bits\n    \"\"\"\n    return \"\".join(secrets.choice(allowed_chars) for i in range(length))\n\n\ndef constant_time_compare(val1, val2):\n    \"\"\"Return True if the two strings are equal, False otherwise.\"\"\"\n    return secrets.compare_digest(force_bytes(val1), force_bytes(val2))\n\n\ndef pbkdf2(password, salt, iterations, dklen=0, digest=None):\n    \"\"\"Return the hash of password using pbkdf2.\"\"\"\n    if digest is None:\n        digest = hashlib.sha256\n    dklen = dklen or None\n    password = force_bytes(password)\n    salt = force_bytes(salt)\n    return hashlib.pbkdf2_hmac(digest().name, password, salt, iterations, dklen)",
                "filename": "django/utils/crypto.py",
                "start_index": 0,
                "end_index": 2660,
                "start_line": 1,
                "end_line": 76,
                "max_line": 76,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "\"Base Cache class.\"\nimport time\nimport warnings\n\nfrom asgiref.sync import sync_to_async\n\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.utils.module_loading import import_string\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\nclass InvalidCacheBackendError(ImproperlyConfigured):\n    pass\n\n\nclass CacheKeyWarning(RuntimeWarning):\n    pass\n\n\nclass InvalidCacheKey(ValueError):\n    pass\n\n\n# Stub class to ensure not passing in a `timeout` argument results in\n# the default timeout\nDEFAULT_TIMEOUT = object()\n\n# Memcached does not accept keys longer than this.\nMEMCACHE_MAX_KEY_LENGTH = 250\n\n\ndef default_key_func(key, key_prefix, version):\n    \"\"\"\n    Default function to generate keys.\n\n    Construct the key used by all other methods. By default, prepend\n    the `key_prefix`. KEY_FUNCTION can be used to specify an alternate\n    function with custom key making behavior.\n    \"\"\"\n    return \"%s:%s:%s\" % (key_prefix, version, key)\n\n\ndef get_key_func(key_func):\n    \"\"\"\n    Function to decide which key function to use.\n\n    Default to ``default_key_func``.\n    \"\"\"\n    if key_func is not None:\n        if callable(key_func):\n            return key_func\n        else:\n            return import_string(key_func)\n    return default_key_func",
                "filename": "django/core/cache/backends/base.py",
                "start_index": 0,
                "end_index": 1267,
                "start_line": 1,
                "end_line": 54,
                "max_line": 405,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "def patch_vary_headers(response, newheaders):\n    \"\"\"\n    Add (or update) the \"Vary\" header in the given HttpResponse object.\n    newheaders is a list of header names that should be in \"Vary\". If headers\n    contains an asterisk, then \"Vary\" header will consist of a single asterisk\n    '*'. Otherwise, existing headers in \"Vary\" aren't removed.\n    \"\"\"\n    # Note that we need to keep the original order intact, because cache\n    # implementations may rely on the order of the Vary contents in, say,\n    # computing an MD5 hash.\n    if response.has_header(\"Vary\"):\n        vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    else:\n        vary_headers = []\n    # Use .lower() here so we treat headers as case-insensitive.\n    existing_headers = {header.lower() for header in vary_headers}\n    additional_headers = [\n        newheader\n        for newheader in newheaders\n        if newheader.lower() not in existing_headers\n    ]\n    vary_headers += additional_headers\n    if \"*\" in vary_headers:\n        response.headers[\"Vary\"] = \"*\"\n    else:\n        response.headers[\"Vary\"] = \", \".join(vary_headers)\n\n\ndef has_vary_header(response, header_query):\n    \"\"\"\n    Check to see if the response has a given header name in its Vary header.\n    \"\"\"\n    if not response.has_header(\"Vary\"):\n        return False\n    vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    existing_headers = {header.lower() for header in vary_headers}\n    return header_query.lower() in existing_headers\n\n\ndef _i18n_cache_key_suffix(request, cache_key):\n    \"\"\"If necessary, add the current locale or time zone to the cache key.\"\"\"\n    if settings.USE_I18N:\n        # first check if LocaleMiddleware or another middleware added\n        # LANGUAGE_CODE to request, then fall back to the active language\n        # which in turn can also fall back to settings.LANGUAGE_CODE\n        cache_key += \".%s\" % getattr(request, \"LANGUAGE_CODE\", get_language())\n    if settings.USE_TZ:\n        cache_key += \".%s\" % get_current_timezone_name()\n    return cache_key\n\n\ndef _generate_cache_key(request, method, headerlist, key_prefix):\n    \"\"\"Return a cache key from the headers given in the header list.\"\"\"\n    ctx = md5(usedforsecurity=False)\n    for header in headerlist:\n        value = request.META.get(header)\n        if value is not None:\n            ctx.update(value.encode())\n    url = md5(request.build_absolute_uri().encode(\"ascii\"), usedforsecurity=False)\n    cache_key = \"views.decorators.cache.cache_page.%s.%s.%s.%s\" % (\n        key_prefix,\n        method,\n        url.hexdigest(),\n        ctx.hexdigest(),\n    )\n    return _i18n_cache_key_suffix(request, cache_key)",
                "filename": "django/utils/cache.py",
                "start_index": 10415,
                "end_index": 13075,
                "start_line": 298,
                "end_line": 373,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "def clean_name(self, name):\n        return name.replace(\"\\\\\", \"/\")\n\n    def hash_key(self, name):\n        return name\n\n    def _stored_name(self, name, hashed_files):\n        # Normalize the path to avoid multiple names for the same file like\n        # ../foo/bar.css and ../foo/../foo/bar.css which normalize to the same\n        # path.\n        name = posixpath.normpath(name)\n        cleaned_name = self.clean_name(name)\n        hash_key = self.hash_key(cleaned_name)\n        cache_name = hashed_files.get(hash_key)\n        if cache_name is None:\n            cache_name = self.clean_name(self.hashed_name(name))\n        return cache_name\n\n    def stored_name(self, name):\n        cleaned_name = self.clean_name(name)\n        hash_key = self.hash_key(cleaned_name)\n        cache_name = self.hashed_files.get(hash_key)\n        if cache_name:\n            return cache_name\n        # No cached name found, recalculate it from the files.\n        intermediate_name = name\n        for i in range(self.max_post_process_passes + 1):\n            cache_name = self.clean_name(\n                self.hashed_name(name, content=None, filename=intermediate_name)\n            )\n            if intermediate_name == cache_name:\n                # Store the hashed name if there was a miss.\n                self.hashed_files[hash_key] = cache_name\n                return cache_name\n            else:\n                # Move on to the next intermediate file.\n                intermediate_name = cache_name\n        # If the cache name can't be determined after the max number of passes,\n        # the intermediate files on disk may be corrupt; avoid an infinite loop.\n        raise ValueError(\"The name '%s' could not be hashed with %r.\" % (name, self))",
                "filename": "django/contrib/staticfiles/storage.py",
                "start_index": 16005,
                "end_index": 17736,
                "start_line": 410,
                "end_line": 449,
                "max_line": 543,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "@register.tag(\"cache\")\ndef do_cache(parser, token):\n    \"\"\"\n    This will cache the contents of a template fragment for a given amount\n    of time.\n\n    Usage::\n\n        {% load cache %}\n        {% cache [expire_time] [fragment_name] %}\n            .. some expensive processing ..\n        {% endcache %}\n\n    This tag also supports varying by a list of arguments::\n\n        {% load cache %}\n        {% cache [expire_time] [fragment_name] [var1] [var2] .. %}\n            .. some expensive processing ..\n        {% endcache %}\n\n    Optionally the cache to use may be specified thus::\n\n        {% cache ....  using=\"cachename\" %}\n\n    Each unique set of arguments will result in a unique cache entry.\n    \"\"\"\n    nodelist = parser.parse((\"endcache\",))\n    parser.delete_first_token()\n    tokens = token.split_contents()\n    if len(tokens) < 3:\n        raise TemplateSyntaxError(\"'%r' tag requires at least 2 arguments.\" % tokens[0])\n    if len(tokens) > 3 and tokens[-1].startswith(\"using=\"):\n        cache_name = parser.compile_filter(tokens[-1].removeprefix(\"using=\"))\n        tokens = tokens[:-1]\n    else:\n        cache_name = None\n    return CacheNode(\n        nodelist,\n        parser.compile_filter(tokens[1]),\n        tokens[2],  # fragment_name can't be a variable.\n        [parser.compile_filter(t) for t in tokens[3:]],\n        cache_name,\n    )",
                "filename": "django/templatetags/cache.py",
                "start_index": 2197,
                "end_index": 3550,
                "start_line": 58,
                "end_line": 100,
                "max_line": 100,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "class UnsaltedMD5PasswordHasher(BasePasswordHasher):\n    \"\"\"\n    Incredibly insecure algorithm that you should *never* use; stores unsalted\n    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an\n    empty salt.\n\n    This class is implemented because Django used to store passwords this way\n    and to accept such password hashes. Some older Django installs still have\n    these values lingering around so we need to handle and upgrade them\n    properly.\n    \"\"\"\n\n    algorithm = \"unsalted_md5\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"django.contrib.auth.hashers.UnsaltedMD5PasswordHasher is deprecated.\",\n            RemovedInDjango51Warning,\n            stacklevel=2,\n        )\n        super().__init__(*args, **kwargs)\n\n    def salt(self):\n        return \"\"\n\n    def encode(self, password, salt):\n        if salt != \"\":\n            raise ValueError(\"salt must be empty.\")\n        return hashlib.md5(password.encode()).hexdigest()\n\n    def decode(self, encoded):\n        return {\n            \"algorithm\": self.algorithm,\n            \"hash\": encoded,\n            \"salt\": None,\n        }\n\n    def verify(self, password, encoded):\n        if len(encoded) == 37:\n            encoded = encoded.removeprefix(\"md5$$\")\n        encoded_2 = self.encode(password, \"\")\n        return constant_time_compare(encoded, encoded_2)\n\n    def safe_summary(self, encoded):\n        decoded = self.decode(encoded)\n        return {\n            _(\"algorithm\"): decoded[\"algorithm\"],\n            _(\"hash\"): mask_hash(decoded[\"hash\"], show=3),\n        }\n\n    def harden_runtime(self, password, encoded):\n        pass",
                "filename": "django/contrib/auth/hashers.py",
                "start_index": 26227,
                "end_index": 27877,
                "start_line": 791,
                "end_line": 842,
                "max_line": 842,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/core/cache/utils.py": [
                {
                    "chunk": {
                        "code": "from hashlib import md5\n\nTEMPLATE_FRAGMENT_KEY_TEMPLATE = \"template.cache.%s.%s\"\n\n\ndef make_template_fragment_key(fragment_name, vary_on=None):\n    hasher = md5(usedforsecurity=False)\n    if vary_on is not None:\n        for arg in vary_on:\n            hasher.update(str(arg).encode())\n            hasher.update(b\":\")\n    return TEMPLATE_FRAGMENT_KEY_TEMPLATE % (fragment_name, hasher.hexdigest())",
                        "filename": "django/core/cache/utils.py",
                        "start_index": 0,
                        "end_index": 396,
                        "start_line": 1,
                        "end_line": 12,
                        "max_line": 12,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of the 'make_template_fragment_key' function which is directly related to the issue. Changes to the hashing function and removal of unnecessary encoding will be made here."
                }
            ],
            "django/templatetags/cache.py": [
                {
                    "chunk": {
                        "code": "from django.core.cache import InvalidCacheBackendError, caches\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.template import Library, Node, TemplateSyntaxError, VariableDoesNotExist\n\nregister = Library()\n\n\nclass CacheNode(Node):\n    def __init__(self, nodelist, expire_time_var, fragment_name, vary_on, cache_name):\n        self.nodelist = nodelist\n        self.expire_time_var = expire_time_var\n        self.fragment_name = fragment_name\n        self.vary_on = vary_on\n        self.cache_name = cache_name\n\n    def render(self, context):\n        try:\n            expire_time = self.expire_time_var.resolve(context)\n        except VariableDoesNotExist:\n            raise TemplateSyntaxError(\n                '\"cache\" tag got an unknown variable: %r' % self.expire_time_var.var\n            )\n        if expire_time is not None:\n            try:\n                expire_time = int(expire_time)\n            except (ValueError, TypeError):\n                raise TemplateSyntaxError(\n                    '\"cache\" tag got a non-integer timeout value: %r' % expire_time\n                )\n        if self.cache_name:\n            try:\n                cache_name = self.cache_name.resolve(context)\n            except VariableDoesNotExist:\n                raise TemplateSyntaxError(\n                    '\"cache\" tag got an unknown variable: %r' % self.cache_name.var\n                )\n            try:\n                fragment_cache = caches[cache_name]\n            except InvalidCacheBackendError:\n                raise TemplateSyntaxError(\n                    \"Invalid cache name specified for cache tag: %r\" % cache_name\n                )\n        else:\n            try:\n                fragment_cache = caches[\"template_fragments\"]\n            except InvalidCacheBackendError:\n                fragment_cache = caches[\"default\"]\n\n        vary_on = [var.resolve(context) for var in self.vary_on]\n        cache_key = make_template_fragment_key(self.fragment_name, vary_on)\n        value = fragment_cache.get(cache_key)\n        if value is None:\n            value = self.nodelist.render(context)\n            fragment_cache.set(cache_key, value, expire_time)\n        return value",
                        "filename": "django/templatetags/cache.py",
                        "start_index": 0,
                        "end_index": 2194,
                        "start_line": 1,
                        "end_line": 55,
                        "max_line": 100,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet uses the 'make_template_fragment_key' function within the 'CacheNode' class. It is necessary to review this usage to ensure compatibility with the changes made to the key generation function."
                }
            ],
            "django/utils/crypto.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\nDjango's standard crypto functions and utilities.\n\"\"\"\nimport hashlib\nimport hmac\nimport secrets\n\nfrom django.conf import settings\nfrom django.utils.encoding import force_bytes\n\n\nclass InvalidAlgorithm(ValueError):\n    \"\"\"Algorithm is not supported by hashlib.\"\"\"\n\n    pass\n\n\ndef salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n    \"\"\"\n    Return the HMAC of 'value', using a key generated from key_salt and a\n    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n    but any algorithm name supported by hashlib can be passed.\n\n    A different key_salt should be passed in for every application of HMAC.\n    \"\"\"\n    if secret is None:\n        secret = settings.SECRET_KEY\n\n    key_salt = force_bytes(key_salt)\n    secret = force_bytes(secret)\n    try:\n        hasher = getattr(hashlib, algorithm)\n    except AttributeError as e:\n        raise InvalidAlgorithm(\n            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n        ) from e\n    # We need to generate a derived key from our base key.  We can do this by\n    # passing the key_salt and our base key through a pseudo-random function.\n    key = hasher(key_salt + secret).digest()\n    # If len(key_salt + secret) > block size of the hash algorithm, the above\n    # line is redundant and could be replaced by key = key_salt + secret, since\n    # the hmac module does the same thing for keys longer than the block size.\n    # However, we need to ensure that we *always* do this.\n    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n\n\nRANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\n\ndef get_random_string(length, allowed_chars=RANDOM_STRING_CHARS):\n    \"\"\"\n    Return a securely generated random string.\n\n    The bit length of the returned value can be calculated with the formula:\n        log_2(len(allowed_chars)^length)\n\n    For example, with default `allowed_chars` (26+26+10), this gives:\n      * length: 12, bit length =~ 71 bits\n      * length: 22, bit length =~ 131 bits\n    \"\"\"\n    return \"\".join(secrets.choice(allowed_chars) for i in range(length))\n\n\ndef constant_time_compare(val1, val2):\n    \"\"\"Return True if the two strings are equal, False otherwise.\"\"\"\n    return secrets.compare_digest(force_bytes(val1), force_bytes(val2))\n\n\ndef pbkdf2(password, salt, iterations, dklen=0, digest=None):\n    \"\"\"Return the hash of password using pbkdf2.\"\"\"\n    if digest is None:\n        digest = hashlib.sha256\n    dklen = dklen or None\n    password = force_bytes(password)\n    salt = force_bytes(salt)\n    return hashlib.pbkdf2_hmac(digest().name, password, salt, iterations, dklen)",
                        "filename": "django/utils/crypto.py",
                        "start_index": 0,
                        "end_index": 2660,
                        "start_line": 1,
                        "end_line": 76,
                        "max_line": 76,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'salted_hmac' function which uses a hashing algorithm. If the decision is made to switch all hash functions to SHA256, this function may need to be reviewed for consistency."
                }
            ],
            "django/utils/cache.py": [
                {
                    "chunk": {
                        "code": "def patch_vary_headers(response, newheaders):\n    \"\"\"\n    Add (or update) the \"Vary\" header in the given HttpResponse object.\n    newheaders is a list of header names that should be in \"Vary\". If headers\n    contains an asterisk, then \"Vary\" header will consist of a single asterisk\n    '*'. Otherwise, existing headers in \"Vary\" aren't removed.\n    \"\"\"\n    # Note that we need to keep the original order intact, because cache\n    # implementations may rely on the order of the Vary contents in, say,\n    # computing an MD5 hash.\n    if response.has_header(\"Vary\"):\n        vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    else:\n        vary_headers = []\n    # Use .lower() here so we treat headers as case-insensitive.\n    existing_headers = {header.lower() for header in vary_headers}\n    additional_headers = [\n        newheader\n        for newheader in newheaders\n        if newheader.lower() not in existing_headers\n    ]\n    vary_headers += additional_headers\n    if \"*\" in vary_headers:\n        response.headers[\"Vary\"] = \"*\"\n    else:\n        response.headers[\"Vary\"] = \", \".join(vary_headers)\n\n\ndef has_vary_header(response, header_query):\n    \"\"\"\n    Check to see if the response has a given header name in its Vary header.\n    \"\"\"\n    if not response.has_header(\"Vary\"):\n        return False\n    vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    existing_headers = {header.lower() for header in vary_headers}\n    return header_query.lower() in existing_headers\n\n\ndef _i18n_cache_key_suffix(request, cache_key):\n    \"\"\"If necessary, add the current locale or time zone to the cache key.\"\"\"\n    if settings.USE_I18N:\n        # first check if LocaleMiddleware or another middleware added\n        # LANGUAGE_CODE to request, then fall back to the active language\n        # which in turn can also fall back to settings.LANGUAGE_CODE\n        cache_key += \".%s\" % getattr(request, \"LANGUAGE_CODE\", get_language())\n    if settings.USE_TZ:\n        cache_key += \".%s\" % get_current_timezone_name()\n    return cache_key\n\n\ndef _generate_cache_key(request, method, headerlist, key_prefix):\n    \"\"\"Return a cache key from the headers given in the header list.\"\"\"\n    ctx = md5(usedforsecurity=False)\n    for header in headerlist:\n        value = request.META.get(header)\n        if value is not None:\n            ctx.update(value.encode())\n    url = md5(request.build_absolute_uri().encode(\"ascii\"), usedforsecurity=False)\n    cache_key = \"views.decorators.cache.cache_page.%s.%s.%s.%s\" % (\n        key_prefix,\n        method,\n        url.hexdigest(),\n        ctx.hexdigest(),\n    )\n    return _i18n_cache_key_suffix(request, cache_key)",
                        "filename": "django/utils/cache.py",
                        "start_index": 10415,
                        "end_index": 13075,
                        "start_line": 298,
                        "end_line": 373,
                        "max_line": 443,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes a cache key generation method '_generate_cache_key' that uses MD5. If switching to SHA256, this method may need to be updated for consistency."
                }
            ]
        },
        "solution_task": "To implement the requested feature, follow these steps:\n\n- Replace the MD5 hashing function with SHA256 for FIPS compliance.\n- Remove the use of `urllib.quote` since it's unnecessary after hashing.\n- Update the `make_template_fragment_key` function to use the `hashlib.update()` method directly with the `vary_on` arguments.\n\nHere's the updated `make_template_fragment_key` function:\n\n```python\nfrom hashlib import sha256\n\nTEMPLATE_FRAGMENT_KEY_TEMPLATE = \"template.cache.%s.%s\"\n\ndef make_template_fragment_key(fragment_name, vary_on=None):\n    hasher = sha256()\n    if vary_on is not None:\n        for arg in vary_on:\n            hasher.update(str(arg).encode())\n            hasher.update(b\":\")\n    return TEMPLATE_FRAGMENT_KEY_TEMPLATE % (fragment_name, hasher.hexdigest())\n```\n\n- Update all tests and any other code that depends on the `make_template_fragment_key` function to expect the new cache key format.\n- Consider updating other cache key generating functions in the project to use SHA256 for consistency and to avoid invalidating keys multiple times.\n- Review the pull request at \u200bhttps://github.com/django/django/pull/11772 for additional context and implementation details.\n- Benchmark the performance improvements using the repository at \u200bhttps://github.com/danthedeckie/make_template_fragment_key_test.\n- Update documentation to reflect the changes in the cache key generation method.\n\nNote: This change will invalidate existing cache keys. Plan for cache invalidation and a possible performance impact when deploying this change.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable step-by-step guide to implement the requested feature, including code snippets and considerations for updating tests and documentation. It addresses the switch from MD5 to SHA256 for FIPS compliance, the removal of unnecessary `urllib.quote` usage, and the use of `hashlib.update()` method. The RESPONSE also suggests reviewing related pull requests and benchmarking performance improvements, which are relevant to the feature request. Additionally, it provides a cautionary note about cache invalidation and potential performance impacts, which is a thoughtful inclusion for real-world application. The RESPONSE also includes links to code snippets that may need to be checked for consistency, showing a comprehensive approach to the feature enhancement. The only reason it does not score a 10 is that it does not explicitly mention the need to communicate the change to stakeholders due to the change in cache key format, which could be an important step in a real-world scenario.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711732974.2313,
        "result": "To implement the requested feature, follow these steps:\n\n- Replace the MD5 hashing function with SHA256 for FIPS compliance.\n- Remove the use of `urllib.quote` since it's unnecessary after hashing.\n- Update the `make_template_fragment_key` function to use the `hashlib.update()` method directly with the `vary_on` arguments.\n\nHere's the updated `make_template_fragment_key` function:\n\n```python\nfrom hashlib import sha256\n\nTEMPLATE_FRAGMENT_KEY_TEMPLATE = \"template.cache.%s.%s\"\n\ndef make_template_fragment_key(fragment_name, vary_on=None):\n    hasher = sha256()\n    if vary_on is not None:\n        for arg in vary_on:\n            hasher.update(str(arg).encode())\n            hasher.update(b\":\")\n    return TEMPLATE_FRAGMENT_KEY_TEMPLATE % (fragment_name, hasher.hexdigest())\n```\n\n- Update all tests and any other code that depends on the `make_template_fragment_key` function to expect the new cache key format.\n- Consider updating other cache key generating functions in the project to use SHA256 for consistency and to avoid invalidating keys multiple times.\n- Review the pull request at \u200bhttps://github.com/django/django/pull/11772 for additional context and implementation details.\n- Benchmark the performance improvements using the repository at \u200bhttps://github.com/danthedeckie/make_template_fragment_key_test.\n- Update documentation to reflect the changes in the cache key generation method.\n\nNote: This change will invalidate existing cache keys. Plan for cache invalidation and a possible performance impact when deploying this change.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [cache](https://github.com/testbed/django__django__3.1/tree//django/core/cache)- [Lines 1 - 12](https://github.com/testbed/django__django__3.1/blob//django/core/cache/utils.py#L1-L12)\n\n This snippet contains the implementation of the 'make_template_fragment_key' function which is directly related to the issue. Changes to the hashing function and removal of unnecessary encoding will be made here.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [templatetags](https://github.com/testbed/django__django__3.1/tree//django/templatetags)- [Lines 1 - 55](https://github.com/testbed/django__django__3.1/blob//django/templatetags/cache.py#L1-L55)\n\n This snippet uses the 'make_template_fragment_key' function within the 'CacheNode' class. It is necessary to review this usage to ensure compatibility with the changes made to the key generation function.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 1 - 76](https://github.com/testbed/django__django__3.1/blob//django/utils/crypto.py#L1-L76)\n\n This snippet contains the 'salted_hmac' function which uses a hashing algorithm. If the decision is made to switch all hash functions to SHA256, this function may need to be reviewed for consistency.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 298 - 373](https://github.com/testbed/django__django__3.1/blob//django/utils/cache.py#L298-L373)\n\n This snippet includes a cache key generation method '_generate_cache_key' that uses MD5. If switching to SHA256, this method may need to be updated for consistency."
    }
}