{
    "id": "django__django-11525",
    "repo_name": "testbed/django__django__3.0",
    "task_id": 4057518207384582064,
    "title": "Raise exceptions in mail_admins()/mail_managers() when settings are not in expected formats.",
    "body": "Description\n\t\nHi,\nFirst time writing a ticket so I apologize if I do anything improperly here. This issue just arose on a project I've been working on, and it goes as follows:\nOur MANAGERS setting was set like so:\nMANAGERS = ['one@example.com', 'two@example.com']\nAnd after calling mail_managers, the result was:\nsmtplib.SMTPRecipientsRefused: {'=?utf-8?q?h?=': (550, b'5.1.1 <=?utf-8?q?h?=>: Recipient address rejected: User unknown in local recipient table'), '=?utf-8?q?u?=': (550, b'5.1.1 <=?utf-8?q?u?=>: Recipient address rejected: User unknown in local recipient table')}\nAfter some investigation it became clear that this setting was in the improper format, but that was only because of \u200bthis StackOverflow post. It would be nice if Django failed early if this setting was detected but improperly set, rather than waiting until the consequences become apparent.\nThank you,\nKevin\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.0.git",
    "requested_commit": "",
    "mayil_response": "To resolve the `smtplib.SMTPRecipientsRefused` error caused by an incorrectly formatted `MANAGERS` setting, modify the `mail_managers` function in `django/core/mail/__init__.py` to validate the format of the `MANAGERS` setting before attempting to send emails:\n\n- Ensure that `MANAGERS` is a list of 2-tuples, where each tuple contains a name and an email address.\n- Raise an `ImproperlyConfigured` exception if the format is incorrect.\n\nHere is the updated `mail_managers` function:\n\n```python\nfrom django.core.exceptions import ImproperlyConfigured\n\ndef mail_managers(subject, message, fail_silently=False, connection=None, html_message=None):\n    \"\"\"Send a message to the managers, as defined by the MANAGERS setting.\"\"\"\n    if not settings.MANAGERS:\n        return\n    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.MANAGERS):\n        raise ImproperlyConfigured(\"The MANAGERS setting must be a list of 2-tuples.\")\n    mail = EmailMultiAlternatives(\n        \"%s%s\" % (settings.EMAIL_SUBJECT_PREFIX, subject),\n        message,\n        settings.SERVER_EMAIL,\n        [a[1] for a in settings.MANAGERS],\n        connection=connection,\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n    mail.send(fail_silently=fail_silently)\n```\n\nMake sure to import `ImproperlyConfigured` at the top of the file if it's not already imported.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.0/tree//django/core) \u2192 [mail](https://github.com/testbed/django__django__3.0/tree//django/core/mail)- [Lines 90 - 154](https://github.com/testbed/django__django__3.0/blob//django/core/mail/__init__.py#L90-L154)\n\n This snippet contains the mail_managers function which is directly related to the issue, as it is responsible for sending emails to managers. The issue describes a problem with the MANAGERS setting format, which is validated in this function.\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.0/tree//django/core) \u2192 [mail](https://github.com/testbed/django__django__3.0/tree//django/core/mail)- [Lines 1 - 75](https://github.com/testbed/django__django__3.0/blob//django/core/mail/message.py#L1-L75)\n\n This snippet includes the email message handling and header sanitization logic, which may be relevant to the issue since the problem could be related to how email addresses are processed and validated before sending.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0004595,
        "snippet_processor": 0.04646,
        "issue_star_creation": 0.024209999999999995,
        "issue_star_solver": 0.05283,
        "bouncer": 0.03115
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711728609.4166641,
        "relevant_snippets": [
            {
                "code": "# Mail backends shipped with Django.",
                "filename": "django/core/mail/backends/__init__.py",
                "start_index": 0,
                "end_index": 36,
                "start_line": 1,
                "end_line": 1,
                "max_line": 1,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "import re\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.core.exceptions import PermissionDenied\nfrom django.core.mail import mail_managers\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.urls import is_valid_path\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.http import escape_leading_slashes",
                "filename": "django/middleware/common.py",
                "start_index": 0,
                "end_index": 370,
                "start_line": 1,
                "end_line": 10,
                "max_line": 178,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "from django.conf import settings\nfrom django.utils.translation import get_supported_language_variant\nfrom django.utils.translation.trans_real import language_code_re\n\nfrom . import Error, Tags, register\n\nE001 = Error(\n    \"You have provided an invalid value for the LANGUAGE_CODE setting: {!r}.\",\n    id=\"translation.E001\",\n)\n\nE002 = Error(\n    \"You have provided an invalid language code in the LANGUAGES setting: {!r}.\",\n    id=\"translation.E002\",\n)\n\nE003 = Error(\n    \"You have provided an invalid language code in the LANGUAGES_BIDI setting: {!r}.\",\n    id=\"translation.E003\",\n)\n\nE004 = Error(\n    \"You have provided a value for the LANGUAGE_CODE setting that is not in \"\n    \"the LANGUAGES setting.\",\n    id=\"translation.E004\",\n)\n\n\n@register(Tags.translation)\ndef check_setting_language_code(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGE_CODE setting is invalid.\"\"\"\n    tag = settings.LANGUAGE_CODE\n    if not isinstance(tag, str) or not language_code_re.match(tag):\n        return [Error(E001.msg.format(tag), id=E001.id)]\n    return []\n\n\n@register(Tags.translation)\ndef check_setting_languages(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGES setting is invalid.\"\"\"\n    return [\n        Error(E002.msg.format(tag), id=E002.id)\n        for tag, _ in settings.LANGUAGES\n        if not isinstance(tag, str) or not language_code_re.match(tag)\n    ]\n\n\n@register(Tags.translation)\ndef check_setting_languages_bidi(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGES_BIDI setting is invalid.\"\"\"\n    return [\n        Error(E003.msg.format(tag), id=E003.id)\n        for tag in settings.LANGUAGES_BIDI\n        if not isinstance(tag, str) or not language_code_re.match(tag)\n    ]\n\n\n@register(Tags.translation)\ndef check_language_settings_consistent(app_configs, **kwargs):\n    \"\"\"Error if language settings are not consistent with each other.\"\"\"\n    try:\n        get_supported_language_variant(settings.LANGUAGE_CODE)\n    except LookupError:\n        return [E004]\n    else:\n        return []",
                "filename": "django/core/checks/translation.py",
                "start_index": 0,
                "end_index": 1989,
                "start_line": 1,
                "end_line": 66,
                "max_line": 66,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "from django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\n\nfrom .. import Error, Tags, Warning, register\n\nCROSS_ORIGIN_OPENER_POLICY_VALUES = {\n    \"same-origin\",\n    \"same-origin-allow-popups\",\n    \"unsafe-none\",\n}\nREFERRER_POLICY_VALUES = {\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"origin\",\n    \"origin-when-cross-origin\",\n    \"same-origin\",\n    \"strict-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\",\n}\n\nSECRET_KEY_INSECURE_PREFIX = \"django-insecure-\"\nSECRET_KEY_MIN_LENGTH = 50\nSECRET_KEY_MIN_UNIQUE_CHARACTERS = 5\n\nSECRET_KEY_WARNING_MSG = (\n    f\"Your %s has less than {SECRET_KEY_MIN_LENGTH} characters, less than \"\n    f\"{SECRET_KEY_MIN_UNIQUE_CHARACTERS} unique characters, or it's prefixed \"\n    f\"with '{SECRET_KEY_INSECURE_PREFIX}' indicating that it was generated \"\n    f\"automatically by Django. Please generate a long and random value, \"\n    f\"otherwise many of Django's security-critical features will be \"\n    f\"vulnerable to attack.\"\n)\n\nW001 = Warning(\n    \"You do not have 'django.middleware.security.SecurityMiddleware' \"\n    \"in your MIDDLEWARE so the SECURE_HSTS_SECONDS, \"\n    \"SECURE_CONTENT_TYPE_NOSNIFF, SECURE_REFERRER_POLICY, \"\n    \"SECURE_CROSS_ORIGIN_OPENER_POLICY, and SECURE_SSL_REDIRECT settings will \"\n    \"have no effect.\",\n    id=\"security.W001\",\n)\n\nW002 = Warning(\n    \"You do not have \"\n    \"'django.middleware.clickjacking.XFrameOptionsMiddleware' in your \"\n    \"MIDDLEWARE, so your pages will not be served with an \"\n    \"'x-frame-options' header. Unless there is a good reason for your \"\n    \"site to be served in a frame, you should consider enabling this \"\n    \"header to help prevent clickjacking attacks.\",\n    id=\"security.W002\",\n)\n\nW004 = Warning(\n    \"You have not set a value for the SECURE_HSTS_SECONDS setting. \"\n    \"If your entire site is served only over SSL, you may want to consider \"\n    \"setting a value and enabling HTTP Strict Transport Security. \"\n    \"Be sure to read the documentation first; enabling HSTS carelessly \"\n    \"can cause serious, irreversible problems.\",\n    id=\"security.W004\",\n)\n\nW005 = Warning(\n    \"You have not set the SECURE_HSTS_INCLUDE_SUBDOMAINS setting to True. \"\n    \"Without this, your site is potentially vulnerable to attack \"\n    \"via an insecure connection to a subdomain. Only set this to True if \"\n    \"you are certain that all subdomains of your domain should be served \"\n    \"exclusively via SSL.\",\n    id=\"security.W005\",\n)\n\nW006 = Warning(\n    \"Your SECURE_CONTENT_TYPE_NOSNIFF setting is not set to True, \"\n    \"so your pages will not be served with an \"\n    \"'X-Content-Type-Options: nosniff' header. \"\n    \"You should consider enabling this header to prevent the \"\n    \"browser from identifying content types incorrectly.\",\n    id=\"security.W006\",\n)",
                "filename": "django/core/checks/security/base.py",
                "start_index": 0,
                "end_index": 2816,
                "start_line": 1,
                "end_line": 281,
                "max_line": 283,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "import mimetypes\nfrom email import charset as Charset\nfrom email import encoders as Encoders\nfrom email import generator, message_from_string\nfrom email.errors import HeaderParseError\nfrom email.header import Header\nfrom email.headerregistry import Address, parser\nfrom email.message import Message\nfrom email.mime.base import MIMEBase\nfrom email.mime.message import MIMEMessage\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.utils import formataddr, formatdate, getaddresses, make_msgid\nfrom io import BytesIO, StringIO\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.core.mail.utils import DNS_NAME\nfrom django.utils.encoding import force_str, punycode\n\n# Don't BASE64-encode UTF-8 messages so that we avoid unwanted attention from\n# some spam filters.\nutf8_charset = Charset.Charset(\"utf-8\")\nutf8_charset.body_encoding = None  # Python defaults to BASE64\nutf8_charset_qp = Charset.Charset(\"utf-8\")\nutf8_charset_qp.body_encoding = Charset.QP\n\n# Default MIME type to use on attachments (if it is not explicitly given\n# and cannot be guessed).\nDEFAULT_ATTACHMENT_MIME_TYPE = \"application/octet-stream\"\n\nRFC5322_EMAIL_LINE_LENGTH_LIMIT = 998\n\n\nclass BadHeaderError(ValueError):\n    pass\n\n\n# Header names that contain structured address data (RFC 5322).\nADDRESS_HEADERS = {\n    \"from\",\n    \"sender\",\n    \"reply-to\",\n    \"to\",\n    \"cc\",\n    \"bcc\",\n    \"resent-from\",\n    \"resent-sender\",\n    \"resent-to\",\n    \"resent-cc\",\n    \"resent-bcc\",\n}\n\n\ndef forbid_multi_line_headers(name, val, encoding):\n    \"\"\"Forbid multi-line headers to prevent header injection.\"\"\"\n    encoding = encoding or settings.DEFAULT_CHARSET\n    val = str(val)  # val may be lazy\n    if \"\\n\" in val or \"\\r\" in val:\n        raise BadHeaderError(\n            \"Header values can't contain newlines (got %r for header %r)\" % (val, name)\n        )\n    try:\n        val.encode(\"ascii\")\n    except UnicodeEncodeError:\n        if name.lower() in ADDRESS_HEADERS:\n            val = \", \".join(\n                sanitize_address(addr, encoding) for addr in getaddresses((val,))\n            )\n        else:\n            val = Header(val, encoding).encode()\n    else:\n        if name.lower() == \"subject\":\n            val = Header(val).encode()\n    return name, val",
                "filename": "django/core/mail/message.py",
                "start_index": 0,
                "end_index": 2289,
                "start_line": 1,
                "end_line": 75,
                "max_line": 495,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "class AdminEmailHandler(logging.Handler):\n    \"\"\"An exception log handler that emails log entries to site admins.\n\n    If the request is passed as the first argument to the log record,\n    request data will be provided in the email report.\n    \"\"\"\n\n    def __init__(self, include_html=False, email_backend=None, reporter_class=None):\n        super().__init__()\n        self.include_html = include_html\n        self.email_backend = email_backend\n        self.reporter_class = import_string(\n            reporter_class or settings.DEFAULT_EXCEPTION_REPORTER\n        )\n\n    def emit(self, record):\n        try:\n            request = record.request\n            subject = \"%s (%s IP): %s\" % (\n                record.levelname,\n                (\n                    \"internal\"\n                    if request.META.get(\"REMOTE_ADDR\") in settings.INTERNAL_IPS\n                    else \"EXTERNAL\"\n                ),\n                record.getMessage(),\n            )\n        except Exception:\n            subject = \"%s: %s\" % (record.levelname, record.getMessage())\n            request = None\n        subject = self.format_subject(subject)\n\n        # Since we add a nicely formatted traceback on our own, create a copy\n        # of the log record without the exception data.\n        no_exc_record = copy(record)\n        no_exc_record.exc_info = None\n        no_exc_record.exc_text = None\n\n        if record.exc_info:\n            exc_info = record.exc_info\n        else:\n            exc_info = (None, record.getMessage(), None)\n\n        reporter = self.reporter_class(request, is_email=True, *exc_info)\n        message = \"%s\\n\\n%s\" % (\n            self.format(no_exc_record),\n            reporter.get_traceback_text(),\n        )\n        html_message = reporter.get_traceback_html() if self.include_html else None\n        self.send_mail(subject, message, fail_silently=True, html_message=html_message)\n\n    def send_mail(self, subject, message, *args, **kwargs):\n        mail.mail_admins(\n            subject, message, *args, connection=self.connection(), **kwargs\n        )\n\n    def connection(self):\n        return get_connection(backend=self.email_backend, fail_silently=True)\n\n    def format_subject(self, subject):\n        \"\"\"\n        Escape CR and LF characters.\n        \"\"\"\n        return subject.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")\n\n\nclass CallbackFilter(logging.Filter):\n    \"\"\"\n    A logging filter that checks the return value of a given callable (which\n    takes the record-to-be-logged as its only parameter) to decide whether to\n    log a record.\n    \"\"\"\n\n    def __init__(self, callback):\n        self.callback = callback\n\n    def filter(self, record):\n        if self.callback(record):\n            return 1\n        return 0\n\n\nclass RequireDebugFalse(logging.Filter):\n    def filter(self, record):\n        return not settings.DEBUG\n\n\nclass RequireDebugTrue(logging.Filter):\n    def filter(self, record):\n        return settings.DEBUG",
                "filename": "django/utils/log.py",
                "start_index": 2414,
                "end_index": 5356,
                "start_line": 79,
                "end_line": 168,
                "max_line": 250,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def _check_custom_error_handlers(self):\n        messages = []\n        # All handlers take (request, exception) arguments except handler500\n        # which takes (request).\n        for status_code, num_parameters in [(400, 2), (403, 2), (404, 2), (500, 1)]:\n            try:\n                handler = self.resolve_error_handler(status_code)\n            except (ImportError, ViewDoesNotExist) as e:\n                path = getattr(self.urlconf_module, \"handler%s\" % status_code)\n                msg = (\n                    \"The custom handler{status_code} view '{path}' could not be \"\n                    \"imported.\"\n                ).format(status_code=status_code, path=path)\n                messages.append(Error(msg, hint=str(e), id=\"urls.E008\"))\n                continue\n            signature = inspect.signature(handler)\n            args = [None] * num_parameters\n            try:\n                signature.bind(*args)\n            except TypeError:\n                msg = (\n                    \"The custom handler{status_code} view '{path}' does not \"\n                    \"take the correct number of arguments ({args}).\"\n                ).format(\n                    status_code=status_code,\n                    path=handler.__module__ + \".\" + handler.__qualname__,\n                    args=\"request, exception\" if num_parameters == 2 else \"request\",\n                )\n                messages.append(Error(msg, id=\"urls.E007\"))\n        return messages",
                "filename": "django/urls/resolvers.py",
                "start_index": 18017,
                "end_index": 19471,
                "start_line": 521,
                "end_line": 550,
                "max_line": 848,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "from django.conf import settings\n\nfrom .. import Error, Tags, register\n\n\n@register(Tags.compatibility)\ndef check_csrf_trusted_origins(app_configs, **kwargs):\n    errors = []\n    for origin in settings.CSRF_TRUSTED_ORIGINS:\n        if \"://\" not in origin:\n            errors.append(\n                Error(\n                    \"As of Django 4.0, the values in the CSRF_TRUSTED_ORIGINS \"\n                    \"setting must start with a scheme (usually http:// or \"\n                    \"https://) but found %s. See the release notes for details.\"\n                    % origin,\n                    id=\"4_0.E001\",\n                )\n            )\n    return errors",
                "filename": "django/core/checks/compatibility/django_4_0.py",
                "start_index": 0,
                "end_index": 656,
                "start_line": 1,
                "end_line": 20,
                "max_line": 20,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def send_mass_mail(\n    datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None\n):\n    \"\"\"\n    Given a datatuple of (subject, message, from_email, recipient_list), send\n    each message to each recipient list. Return the number of emails sent.\n\n    If from_email is None, use the DEFAULT_FROM_EMAIL setting.\n    If auth_user and auth_password are set, use them to log in.\n    If auth_user is None, use the EMAIL_HOST_USER setting.\n    If auth_password is None, use the EMAIL_HOST_PASSWORD setting.\n\n    Note: The API for this method is frozen. New code wanting to extend the\n    functionality should use the EmailMessage class directly.\n    \"\"\"\n    connection = connection or get_connection(\n        username=auth_user,\n        password=auth_password,\n        fail_silently=fail_silently,\n    )\n    messages = [\n        EmailMessage(subject, message, sender, recipient, connection=connection)\n        for subject, message, sender, recipient in datatuple\n    ]\n    return connection.send_messages(messages)\n\n\ndef mail_admins(\n    subject, message, fail_silently=False, connection=None, html_message=None\n):\n    \"\"\"Send a message to the admins, as defined by the ADMINS setting.\"\"\"\n    if not settings.ADMINS:\n        return\n    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.ADMINS):\n        raise ValueError(\"The ADMINS setting must be a list of 2-tuples.\")\n    mail = EmailMultiAlternatives(\n        \"%s%s\" % (settings.EMAIL_SUBJECT_PREFIX, subject),\n        message,\n        settings.SERVER_EMAIL,\n        [a[1] for a in settings.ADMINS],\n        connection=connection,\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n    mail.send(fail_silently=fail_silently)\n\n\ndef mail_managers(\n    subject, message, fail_silently=False, connection=None, html_message=None\n):\n    \"\"\"Send a message to the managers, as defined by the MANAGERS setting.\"\"\"\n    if not settings.MANAGERS:\n        return\n    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.MANAGERS):\n        raise ValueError(\"The MANAGERS setting must be a list of 2-tuples.\")\n    mail = EmailMultiAlternatives(\n        \"%s%s\" % (settings.EMAIL_SUBJECT_PREFIX, subject),\n        message,\n        settings.SERVER_EMAIL,\n        [a[1] for a in settings.MANAGERS],\n        connection=connection,\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n    mail.send(fail_silently=fail_silently)",
                "filename": "django/core/mail/__init__.py",
                "start_index": 2466,
                "end_index": 4957,
                "start_line": 90,
                "end_line": 154,
                "max_line": 154,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\nTools for sending email.\n\"\"\"\nfrom django.conf import settings\n\n# Imported for backwards compatibility and for the sake\n# of a cleaner namespace. These symbols used to be in\n# django/core/mail.py before the introduction of email\n# backends and the subsequent reorganization (See #10355)\nfrom django.core.mail.message import (\n    DEFAULT_ATTACHMENT_MIME_TYPE,\n    BadHeaderError,\n    EmailMessage,\n    EmailMultiAlternatives,\n    SafeMIMEMultipart,\n    SafeMIMEText,\n    forbid_multi_line_headers,\n    make_msgid,\n)\nfrom django.core.mail.utils import DNS_NAME, CachedDnsName\nfrom django.utils.module_loading import import_string\n\n__all__ = [\n    \"CachedDnsName\",\n    \"DNS_NAME\",\n    \"EmailMessage\",\n    \"EmailMultiAlternatives\",\n    \"SafeMIMEText\",\n    \"SafeMIMEMultipart\",\n    \"DEFAULT_ATTACHMENT_MIME_TYPE\",\n    \"make_msgid\",\n    \"BadHeaderError\",\n    \"forbid_multi_line_headers\",\n    \"get_connection\",\n    \"send_mail\",\n    \"send_mass_mail\",\n    \"mail_admins\",\n    \"mail_managers\",\n]\n\n\ndef get_connection(backend=None, fail_silently=False, **kwds):\n    \"\"\"Load an email backend and return an instance of it.\n\n    If backend is None (default), use settings.EMAIL_BACKEND.\n\n    Both fail_silently and other keyword arguments are used in the\n    constructor of the backend.\n    \"\"\"\n    klass = import_string(backend or settings.EMAIL_BACKEND)\n    return klass(fail_silently=fail_silently, **kwds)\n\n\ndef send_mail(\n    subject,\n    message,\n    from_email,\n    recipient_list,\n    fail_silently=False,\n    auth_user=None,\n    auth_password=None,\n    connection=None,\n    html_message=None,\n):\n    \"\"\"\n    Easy wrapper for sending a single message to a recipient list. All members\n    of the recipient list will see the other recipients in the 'To' field.\n\n    If from_email is None, use the DEFAULT_FROM_EMAIL setting.\n    If auth_user is None, use the EMAIL_HOST_USER setting.\n    If auth_password is None, use the EMAIL_HOST_PASSWORD setting.\n\n    Note: The API for this method is frozen. New code wanting to extend the\n    functionality should use the EmailMessage class directly.\n    \"\"\"\n    connection = connection or get_connection(\n        username=auth_user,\n        password=auth_password,\n        fail_silently=fail_silently,\n    )\n    mail = EmailMultiAlternatives(\n        subject, message, from_email, recipient_list, connection=connection\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n\n    return mail.send()",
                "filename": "django/core/mail/__init__.py",
                "start_index": 0,
                "end_index": 2463,
                "start_line": 1,
                "end_line": 87,
                "max_line": 154,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/core/mail/__init__.py": [
                {
                    "chunk": {
                        "code": "def send_mass_mail(\n    datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None\n):\n    \"\"\"\n    Given a datatuple of (subject, message, from_email, recipient_list), send\n    each message to each recipient list. Return the number of emails sent.\n\n    If from_email is None, use the DEFAULT_FROM_EMAIL setting.\n    If auth_user and auth_password are set, use them to log in.\n    If auth_user is None, use the EMAIL_HOST_USER setting.\n    If auth_password is None, use the EMAIL_HOST_PASSWORD setting.\n\n    Note: The API for this method is frozen. New code wanting to extend the\n    functionality should use the EmailMessage class directly.\n    \"\"\"\n    connection = connection or get_connection(\n        username=auth_user,\n        password=auth_password,\n        fail_silently=fail_silently,\n    )\n    messages = [\n        EmailMessage(subject, message, sender, recipient, connection=connection)\n        for subject, message, sender, recipient in datatuple\n    ]\n    return connection.send_messages(messages)\n\n\ndef mail_admins(\n    subject, message, fail_silently=False, connection=None, html_message=None\n):\n    \"\"\"Send a message to the admins, as defined by the ADMINS setting.\"\"\"\n    if not settings.ADMINS:\n        return\n    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.ADMINS):\n        raise ValueError(\"The ADMINS setting must be a list of 2-tuples.\")\n    mail = EmailMultiAlternatives(\n        \"%s%s\" % (settings.EMAIL_SUBJECT_PREFIX, subject),\n        message,\n        settings.SERVER_EMAIL,\n        [a[1] for a in settings.ADMINS],\n        connection=connection,\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n    mail.send(fail_silently=fail_silently)\n\n\ndef mail_managers(\n    subject, message, fail_silently=False, connection=None, html_message=None\n):\n    \"\"\"Send a message to the managers, as defined by the MANAGERS setting.\"\"\"\n    if not settings.MANAGERS:\n        return\n    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.MANAGERS):\n        raise ValueError(\"The MANAGERS setting must be a list of 2-tuples.\")\n    mail = EmailMultiAlternatives(\n        \"%s%s\" % (settings.EMAIL_SUBJECT_PREFIX, subject),\n        message,\n        settings.SERVER_EMAIL,\n        [a[1] for a in settings.MANAGERS],\n        connection=connection,\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n    mail.send(fail_silently=fail_silently)",
                        "filename": "django/core/mail/__init__.py",
                        "start_index": 2466,
                        "end_index": 4957,
                        "start_line": 90,
                        "end_line": 154,
                        "max_line": 154,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the mail_managers function which is directly related to the issue, as it is responsible for sending emails to managers. The issue describes a problem with the MANAGERS setting format, which is validated in this function."
                }
            ],
            "django/core/mail/message.py": [
                {
                    "chunk": {
                        "code": "import mimetypes\nfrom email import charset as Charset\nfrom email import encoders as Encoders\nfrom email import generator, message_from_string\nfrom email.errors import HeaderParseError\nfrom email.header import Header\nfrom email.headerregistry import Address, parser\nfrom email.message import Message\nfrom email.mime.base import MIMEBase\nfrom email.mime.message import MIMEMessage\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.utils import formataddr, formatdate, getaddresses, make_msgid\nfrom io import BytesIO, StringIO\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.core.mail.utils import DNS_NAME\nfrom django.utils.encoding import force_str, punycode\n\n# Don't BASE64-encode UTF-8 messages so that we avoid unwanted attention from\n# some spam filters.\nutf8_charset = Charset.Charset(\"utf-8\")\nutf8_charset.body_encoding = None  # Python defaults to BASE64\nutf8_charset_qp = Charset.Charset(\"utf-8\")\nutf8_charset_qp.body_encoding = Charset.QP\n\n# Default MIME type to use on attachments (if it is not explicitly given\n# and cannot be guessed).\nDEFAULT_ATTACHMENT_MIME_TYPE = \"application/octet-stream\"\n\nRFC5322_EMAIL_LINE_LENGTH_LIMIT = 998\n\n\nclass BadHeaderError(ValueError):\n    pass\n\n\n# Header names that contain structured address data (RFC 5322).\nADDRESS_HEADERS = {\n    \"from\",\n    \"sender\",\n    \"reply-to\",\n    \"to\",\n    \"cc\",\n    \"bcc\",\n    \"resent-from\",\n    \"resent-sender\",\n    \"resent-to\",\n    \"resent-cc\",\n    \"resent-bcc\",\n}\n\n\ndef forbid_multi_line_headers(name, val, encoding):\n    \"\"\"Forbid multi-line headers to prevent header injection.\"\"\"\n    encoding = encoding or settings.DEFAULT_CHARSET\n    val = str(val)  # val may be lazy\n    if \"\\n\" in val or \"\\r\" in val:\n        raise BadHeaderError(\n            \"Header values can't contain newlines (got %r for header %r)\" % (val, name)\n        )\n    try:\n        val.encode(\"ascii\")\n    except UnicodeEncodeError:\n        if name.lower() in ADDRESS_HEADERS:\n            val = \", \".join(\n                sanitize_address(addr, encoding) for addr in getaddresses((val,))\n            )\n        else:\n            val = Header(val, encoding).encode()\n    else:\n        if name.lower() == \"subject\":\n            val = Header(val).encode()\n    return name, val",
                        "filename": "django/core/mail/message.py",
                        "start_index": 0,
                        "end_index": 2289,
                        "start_line": 1,
                        "end_line": 75,
                        "max_line": 495,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the email message handling and header sanitization logic, which may be relevant to the issue since the problem could be related to how email addresses are processed and validated before sending."
                }
            ]
        },
        "solution_task": "To resolve the `smtplib.SMTPRecipientsRefused` error caused by an incorrectly formatted `MANAGERS` setting, modify the `mail_managers` function in `django/core/mail/__init__.py` to validate the format of the `MANAGERS` setting before attempting to send emails:\n\n- Ensure that `MANAGERS` is a list of 2-tuples, where each tuple contains a name and an email address.\n- Raise an `ImproperlyConfigured` exception if the format is incorrect.\n\nHere is the updated `mail_managers` function:\n\n```python\nfrom django.core.exceptions import ImproperlyConfigured\n\ndef mail_managers(subject, message, fail_silently=False, connection=None, html_message=None):\n    \"\"\"Send a message to the managers, as defined by the MANAGERS setting.\"\"\"\n    if not settings.MANAGERS:\n        return\n    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.MANAGERS):\n        raise ImproperlyConfigured(\"The MANAGERS setting must be a list of 2-tuples.\")\n    mail = EmailMultiAlternatives(\n        \"%s%s\" % (settings.EMAIL_SUBJECT_PREFIX, subject),\n        message,\n        settings.SERVER_EMAIL,\n        [a[1] for a in settings.MANAGERS],\n        connection=connection,\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n    mail.send(fail_silently=fail_silently)\n```\n\nMake sure to import `ImproperlyConfigured` at the top of the file if it's not already imported.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT by suggesting modifications to the `mail_managers` function to validate the `MANAGERS` setting. It includes a code snippet that checks the format of the `MANAGERS` setting and raises an exception if the format is incorrect, which directly addresses the issue of failing early when the setting is improperly set. The RESPONSE also provides guidance on where to find the relevant code in the Django repository, which is useful for implementing the suggested changes. The only reason it does not score a 10 is that it does not address the specific error message provided in the PROMPT, which could give additional context for the validation logic.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711728780.2624488,
        "result": "To resolve the `smtplib.SMTPRecipientsRefused` error caused by an incorrectly formatted `MANAGERS` setting, modify the `mail_managers` function in `django/core/mail/__init__.py` to validate the format of the `MANAGERS` setting before attempting to send emails:\n\n- Ensure that `MANAGERS` is a list of 2-tuples, where each tuple contains a name and an email address.\n- Raise an `ImproperlyConfigured` exception if the format is incorrect.\n\nHere is the updated `mail_managers` function:\n\n```python\nfrom django.core.exceptions import ImproperlyConfigured\n\ndef mail_managers(subject, message, fail_silently=False, connection=None, html_message=None):\n    \"\"\"Send a message to the managers, as defined by the MANAGERS setting.\"\"\"\n    if not settings.MANAGERS:\n        return\n    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.MANAGERS):\n        raise ImproperlyConfigured(\"The MANAGERS setting must be a list of 2-tuples.\")\n    mail = EmailMultiAlternatives(\n        \"%s%s\" % (settings.EMAIL_SUBJECT_PREFIX, subject),\n        message,\n        settings.SERVER_EMAIL,\n        [a[1] for a in settings.MANAGERS],\n        connection=connection,\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n    mail.send(fail_silently=fail_silently)\n```\n\nMake sure to import `ImproperlyConfigured` at the top of the file if it's not already imported.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.0/tree//django/core) \u2192 [mail](https://github.com/testbed/django__django__3.0/tree//django/core/mail)- [Lines 90 - 154](https://github.com/testbed/django__django__3.0/blob//django/core/mail/__init__.py#L90-L154)\n\n This snippet contains the mail_managers function which is directly related to the issue, as it is responsible for sending emails to managers. The issue describes a problem with the MANAGERS setting format, which is validated in this function.\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.0/tree//django/core) \u2192 [mail](https://github.com/testbed/django__django__3.0/tree//django/core/mail)- [Lines 1 - 75](https://github.com/testbed/django__django__3.0/blob//django/core/mail/message.py#L1-L75)\n\n This snippet includes the email message handling and header sanitization logic, which may be relevant to the issue since the problem could be related to how email addresses are processed and validated before sending."
    }
}