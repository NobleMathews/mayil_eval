{
    "id": "astropy__astropy-14295",
    "repo_name": "testbed/astropy__astropy__5.1",
    "task_id": 2895233797960582737,
    "title": "Presence of SIP keywords leads to ignored PV keywords.",
    "body": "<!-- This comments are hidden when you submit the issue,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/main/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/main/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- Please have a search on our GitHub repository to see if a similar\r\nissue has already been posted.\r\nIf a similar issue is closed, have a quick look to see if you are satisfied\r\nby the resolution.\r\nIf not please go ahead and open an issue! -->\r\n\r\n<!-- Please check that the development version still produces the same bug.\r\nYou can install development version with\r\npip install git+https://github.com/astropy/astropy\r\ncommand. -->\r\n\r\n### Description\r\nI am working on updating the fits header for one of our telescopes. We wanted to represent the distortions in SIP convention and the projection to be 'CAR'.\r\nWhile working on this, I noticed if SIP coefficients are present in the header and/or '-SIP' is added to CTYPEia keywords,\r\nastropy treats the PV keywords (PV1_0, PV1_1 and PV1_2) as \"redundant SCAMP distortions\".\r\n\r\nEarlier I could not figure out why the projection weren't going as I expected, and I suspected a bug in astropy wcs. After talking to Mark Calabretta about the difficulties I'm facing, that suspicion only grew stronger. The header was working as expected with WCSLIB but was giving unexpected behavior in astropy wcs.\r\n\r\nThe following would be one example header - \r\n```\r\nheader_dict = {\r\n'SIMPLE'  : True, \r\n'BITPIX'  : -32, \r\n'NAXIS'   :  2,\r\n'NAXIS1'  : 1024,\r\n'NAXIS2'  : 1024,\r\n'CRPIX1'  : 512.0,\r\n'CRPIX2'  : 512.0,\r\n'CDELT1'  : 0.01,\r\n'CDELT2'  : 0.01,\r\n'CRVAL1'  : 120.0,\r\n'CRVAL2'  : 29.0,\r\n'CTYPE1'  : 'RA---CAR-SIP',\r\n'CTYPE2'  : 'DEC--CAR-SIP',\r\n'PV1_1'   :120.0,\r\n'PV1_2'   :29.0,\r\n'PV1_0'   :1.0,\r\n'A_ORDER' :2,\r\n'A_2_0'   :5.0e-4,\r\n'B_ORDER' :2,\r\n'B_2_0'   :5.0e-4\r\n}\r\nfrom astropy.io import fits\r\nheader = fits.Header(header_dict)\r\n```\r\n\r\n### Expected behavior\r\nWhen you parse the wcs information from this header, the image should be centered at ra=120 and dec=29 with lines of constant ra and dec looking like the following image generated using wcslib - \r\n![wcsgrid_with_PV](https://user-images.githubusercontent.com/97835976/210666592-62860f54-f97a-4114-81bb-b50712194337.png)\r\n\r\n### Actual behavior\r\nIf I parse the wcs information using astropy wcs, it throws the following warning -\r\n`WARNING: FITSFixedWarning: Removed redundant SCAMP distortion parameters because SIP parameters are also present [astropy.wcs.wcs]`\r\nAnd the resulting grid is different.\r\nCode - \r\n```\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom astropy.wcs import WCS\r\nw = WCS(header)\r\nra = np.linspace(116, 126, 25)\r\ndec = np.linspace(25, 34, 25)\r\n\r\nfor r in ra:\r\n    x, y = w.all_world2pix(np.full_like(dec, r), dec, 0)\r\n    plt.plot(x, y, 'C0')\r\nfor d in dec:\r\n    x, y = w.all_world2pix(ra, np.full_like(ra, d), 0)\r\n    plt.plot(x, y, 'C0')\r\n\r\nplt.title('Lines of constant equatorial coordinates in pixel space')\r\nplt.xlabel('x')\r\nplt.ylabel('y')\r\n```\r\nGrid - \r\n![image](https://user-images.githubusercontent.com/97835976/210667514-4d2a033b-3571-4df5-9646-42e4cbb51026.png)\r\n\r\nThe astropy wcs grid/solution does not change whethere we keep or remove the PV keywords.\r\nFurthermore, the astropy grid can be recreated in wcslib, by removing the PV keywords.\r\n![wcsgrid_without_PV](https://user-images.githubusercontent.com/97835976/210667756-10336d93-1266-4ae6-ace1-27947746531c.png)\r\n\r\n\r\n### Steps to Reproduce\r\n<!-- Ideally a code example could be provided so we can run it ourselves. -->\r\n<!-- If you are pasting code, use triple backticks (```) around\r\nyour code snippet. -->\r\n<!-- If necessary, sanitize your screen output to be pasted so you do not\r\nreveal secrets like tokens and passwords. -->\r\n\r\n1. Initialize the header\r\n2. Parse the header using astropy.wcs.WCS\r\n3. Plot the graticule\r\n4. Remove the PV keywords and run again\r\n5. You will find the same graticule indicating that PV keywords are completely ignored.\r\n6.  Additionally, the graticules can be compared with the wcsgrid utility of wcslib.\r\n\r\n\r\n### System Details\r\n<!-- Even if you do not think this is necessary, it is useful information for the maintainers.\r\nPlease run the following snippet and paste the output below:\r\nimport platform; print(platform.platform())\r\nimport sys; print(\"Python\", sys.version)\r\nimport numpy; print(\"Numpy\", numpy.__version__)\r\nimport erfa; print(\"pyerfa\", erfa.__version__)\r\nimport astropy; print(\"astropy\", astropy.__version__)\r\nimport scipy; print(\"Scipy\", scipy.__version__)\r\nimport matplotlib; print(\"Matplotlib\", matplotlib.__version__)\r\n-->\r\nLinux-6.0.11-200.fc36.x86_64-x86_64-with-glibc2.35\r\nPython 3.9.12 (main, Apr  5 2022, 06:56:58) \r\n[GCC 7.5.0]\r\nNumpy 1.21.5\r\npyerfa 2.0.0\r\nastropy 5.1\r\nScipy 1.7.3\r\nMatplotlib 3.5.1\nRemove heuristic code to handle PTF files which is causing a bug\n<!-- This comments are hidden when you submit the pull request,\r\nso you do not need to remove them! -->\r\n\r\n<!-- Please be sure to check out our contributing guidelines,\r\nhttps://github.com/astropy/astropy/blob/main/CONTRIBUTING.md .\r\nPlease be sure to check out our code of conduct,\r\nhttps://github.com/astropy/astropy/blob/main/CODE_OF_CONDUCT.md . -->\r\n\r\n<!-- If you are new or need to be re-acquainted with Astropy\r\ncontributing workflow, please see\r\nhttp://docs.astropy.org/en/latest/development/workflow/development_workflow.html .\r\nThere is even a practical example at\r\nhttps://docs.astropy.org/en/latest/development/workflow/git_edit_workflow_examples.html#astropy-fix-example . -->\r\n\r\n<!-- Astropy coding style guidelines can be found here:\r\nhttps://docs.astropy.org/en/latest/development/codeguide.html#coding-style-conventions\r\nOur testing infrastructure enforces to follow a subset of the PEP8 to be\r\nfollowed. You can check locally whether your changes have followed these by\r\nrunning the following command:\r\n\r\ntox -e codestyle\r\n\r\n-->\r\n\r\n<!-- Please just have a quick search on GitHub to see if a similar\r\npull request has already been posted.\r\nWe have old closed pull requests that might provide useful code or ideas\r\nthat directly tie in with your pull request. -->\r\n\r\n<!-- We have several automatic features that run when a pull request is open.\r\nThey can appear daunting but do not worry because maintainers will help\r\nyou navigate them, if necessary. -->\r\n\r\n### Description\r\n<!-- Provide a general description of what your pull request does.\r\nComplete the following sentence and add relevant details as you see fit. -->\r\n\r\n<!-- In addition please ensure that the pull request title is descriptive\r\nand allows maintainers to infer the applicable subpackage(s). -->\r\n\r\n<!-- READ THIS FOR MANUAL BACKPORT FROM A MAINTAINER:\r\nApply \"skip-basebranch-check\" label **before** you open the PR! -->\r\n\r\nCurrently the `_fix_scamp` function remove any PV keywords when SIP distortions are present and no radial terms are present which should not  be the case. This function was put in place for solving https://github.com/astropy/astropy/issues/299 but it causes the bug #14255.\r\n\r\nWe can either keep adding heuristic code to fix the edge cases as they come up with or remove `_fix_scamp` and let the user deal with non-standard files. I'm opening a pull request for the latter following the discusison in #14255.\r\n\r\n<!-- If the pull request closes any open issues you can add this.\r\nIf you replace <Issue Number> with a number, GitHub will automatically link it.\r\nIf this pull request is unrelated to any issues, please remove\r\nthe following line. -->\r\n\r\nFixes #14255\r\n\r\n### Checklist for package maintainer(s)\r\n<!-- This section is to be filled by package maintainer(s) who will\r\nreview this pull request. -->\r\n\r\nThis checklist is meant to remind the package maintainer(s) who will review this pull request of some common things to look for. This list is not exhaustive.\r\n\r\n- [ ] Do the proposed changes actually accomplish desired goals?\r\n- [ ] Do the proposed changes follow the [Astropy coding guidelines](https://docs.astropy.org/en/latest/development/codeguide.html)?\r\n- [ ] Are tests added/updated as required? If so, do they follow the [Astropy testing guidelines](https://docs.astropy.org/en/latest/development/testguide.html)?\r\n- [ ] Are docs added/updated as required? If so, do they follow the [Astropy documentation guidelines](https://docs.astropy.org/en/latest/development/docguide.html#astropy-documentation-rules-and-guidelines)?\r\n- [ ] Is rebase and/or squash necessary? If so, please provide the author with appropriate instructions. Also see [\"When to rebase and squash commits\"](https://docs.astropy.org/en/latest/development/when_to_rebase.html).\r\n- [ ] Did the CI pass? If no, are the failures related? If you need to run daily and weekly cron jobs as part of the PR, please apply the `Extra CI` label. Codestyle issues can be fixed by the [bot](https://docs.astropy.org/en/latest/development/workflow/development_workflow.html#pre-commit).\r\n- [ ] Is a change log needed? If yes, did the change log check pass? If no, add the `no-changelog-entry-needed` label. If this is a manual backport, use the `skip-changelog-checks` label unless special changelog handling is necessary.\r\n- [ ] Is this a big PR that makes a \"What's new?\" entry worthwhile and if so, is (1) a \"what's new\" entry included in this PR and (2) the \"whatsnew-needed\" label applied?\r\n- [ ] Is a milestone set? Milestone must be set but `astropy-bot` check might be missing; do not let the green checkmark fool you.\r\n- [ ] At the time of adding the milestone, if the milestone set requires a backport to release branch(es), apply the appropriate `backport-X.Y.x` label(s) *before* merge.\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__5.1.git",
    "requested_commit": "",
    "mayil_response": "- Remove the `_fix_scamp` function from `astropy/wcs/wcs.py`.\n- Ensure that the `WCS` class and any other relevant classes or functions do not call `_fix_scamp`.\n- Remove any unit tests that specifically test the behavior of `_fix_scamp`.\n- Search for any documentation that references `_fix_scamp` and update it to reflect the removal of the function.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.1/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__5.1/tree//astropy/wcs)- [Lines 706 - 3753](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/wcs/wcs.py#L706-L3753)\n\n This snippet contains the '_fix_scamp' function which is responsible for removing PV keywords when SIP distortions are present. The issue describes a problem with PV keywords being ignored due to the presence of SIP keywords, which is directly related to the logic in this function. \n\n\n   - [Lines 1192 - 1263](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/wcs/wcs.py#L1192-L1263)\n\n This snippet contains the '_fix_pre2012_scamp_tpv' function which also deals with the handling of SIP and PV keywords in the header. It is relevant because it shows how the code is currently handling the presence of both SIP and PV keywords, which is at the core of the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0004969999999999999,
        "snippet_processor": 0.060770000000000005,
        "issue_star_creation": 0.030649999999999997,
        "issue_star_solver": 0.0659,
        "bouncer": 0.0239
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711736155.939693,
        "relevant_snippets": [
            {
                "code": "def _fix_scamp(self):\n        \"\"\"\n        Remove SCAMP's PVi_m distortion parameters if SIP distortion parameters\n        are also present. Some projects (e.g., Palomar Transient Factory)\n        convert SCAMP's distortion parameters (which abuse the PVi_m cards) to\n        SIP. However, wcslib gets confused by the presence of both SCAMP and\n        SIP distortion parameters.\n\n        See https://github.com/astropy/astropy/issues/299.\n\n        SCAMP uses TAN projection exclusively. The case of CTYPE ending\n        in -TAN should have been handled by ``_fix_pre2012_scamp_tpv()`` before\n        calling this function.\n        \"\"\"\n        if self.wcs is None:\n            return\n\n        # Delete SIP if CTYPE explicitly has '-TPV' code:\n        ctype = [ct.strip().upper() for ct in self.wcs.ctype]\n        if sum(ct.endswith(\"-TPV\") for ct in ctype) == 2:\n            if self.sip is not None:\n                self.sip = None\n                warnings.warn(\n                    \"Removed redundant SIP distortion parameters \"\n                    \"because CTYPE explicitly specifies TPV distortions\",\n                    FITSFixedWarning,\n                )\n            return\n\n        # Nothing to be done if no PV parameters attached since SCAMP\n        # encodes distortion coefficients using PV keywords\n        pv = self.wcs.get_pv()\n        if not pv:\n            return\n\n        # Nothing to be done if axes don't use SIP distortion parameters\n        if self.sip is None:\n            return\n\n        # Loop over distinct values of `i' index\n        has_scamp = False\n        for i in {v[0] for v in pv}:\n            # Get all values of `j' index for this value of `i' index\n            js = tuple(v[1] for v in pv if v[0] == i)\n            if \"-TAN\" in self.wcs.ctype[i - 1].upper() and js and max(js) >= 5:\n                # TAN projection *may* use PVi_j with j up to 4 - see\n                # Sections 2.5, 2.6, and Table 13\n                # in https://doi.org/10.1051/0004-6361:20021327\n                has_scamp = True\n                break\n\n        if has_scamp and all(ct.endswith(\"-SIP\") for ct in ctype):\n            # Prefer SIP - see recommendations in Section 7 in\n            # http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf\n            self.wcs.set_pv([])\n            warnings.warn(\n                \"Removed redundant SCAMP distortion parameters \"\n                \"because SIP parameters are also present\",\n                FITSFixedWarning,\n            )\n            return",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 23982,
                "end_index": 26504,
                "start_line": 706,
                "end_line": 3753,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "def _fix_pre2012_scamp_tpv(self, header, wcskey=\"\"):\n        \"\"\"\n        Replace -TAN with TPV (for pre-2012 SCAMP headers that use -TAN\n        in CTYPE). Ignore SIP if present. This follows recommendations in\n        Section 7 in\n        http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf.\n\n        This is to deal with pre-2012 headers that may contain TPV with a\n        CTYPE that ends in '-TAN' (post-2012 they should end in '-TPV' when\n        SCAMP has adopted the new TPV convention).\n        \"\"\"\n        if isinstance(header, (str, bytes)):\n            return\n\n        wcskey = wcskey.strip().upper()\n        cntype = [\n            (nax, header.get(f\"CTYPE{nax}{wcskey}\", \"\").strip())\n            for nax in range(1, self.naxis + 1)\n        ]\n\n        tan_axes = [ct[0] for ct in cntype if ct[1].endswith(\"-TAN\")]\n\n        if len(tan_axes) == 2:\n            # check if PVi_j with j >= 5 is present and if so, do not load SIP\n            tan_to_tpv = False\n            for nax in tan_axes:\n                js = []\n                for p in header[f\"PV{nax}_*{wcskey}\"].keys():\n                    prefix = f\"PV{nax}_\"\n                    if p.startswith(prefix):\n                        p = p[len(prefix) :]\n                        p = p.rstrip(wcskey)\n                        try:\n                            p = int(p)\n                        except ValueError:\n                            continue\n                        js.append(p)\n\n                if js and max(js) >= 5:\n                    tan_to_tpv = True\n                    break\n\n            if tan_to_tpv:\n                warnings.warn(\n                    \"Removed redundant SIP distortion parameters \"\n                    \"because SCAMP' PV distortions are also present\",\n                    FITSFixedWarning,\n                )\n                self._remove_sip_kw(header, del_order=True)\n                for i in tan_axes:\n                    kwd = f\"CTYPE{i:d}{wcskey}\"\n                    if kwd in header:\n                        header[kwd] = (\n                            header[kwd].strip().upper().replace(\"-TAN\", \"-TPV\")\n                        )\n\n    @staticmethod\n    def _remove_sip_kw(header, del_order=False):\n        \"\"\"\n        Remove SIP information from a header.\n        \"\"\"\n        # Never pass SIP coefficients to wcslib\n        # CTYPE must be passed with -SIP to wcslib\n        for key in {\n            m.group() for m in map(SIP_KW.match, list(header)) if m is not None\n        }:\n            del header[key]\n\n        if del_order:\n            for kwd in [\"A_ORDER\", \"B_ORDER\", \"AP_ORDER\", \"BP_ORDER\"]:\n                if kwd in header:\n                    del header[kwd]",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 42446,
                "end_index": 45137,
                "start_line": 1192,
                "end_line": 1263,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "if wcsprm.naxis != 2 and (\n                det2im[0] or det2im[1] or cpdis[0] or cpdis[1] or sip\n            ):\n                raise ValueError(\n                    f\"\"\"\nFITS WCS distortion paper lookup tables and SIP distortions only work\nin 2 dimensions.  However, WCSLIB has detected {wcsprm.naxis} dimensions in the\ncore WCS keywords.  To use core WCS in conjunction with FITS WCS\ndistortion paper lookup tables or SIP distortion, you must select or\nreduce these to 2 dimensions using the naxis kwarg.\n\"\"\"\n                )\n\n            header_naxis = header.get(\"NAXIS\", None)\n            if header_naxis is not None and header_naxis < wcsprm.naxis:\n                warnings.warn(\n                    f\"The WCS transformation has more axes ({wcsprm.naxis:d}) than the \"\n                    f\"image it is associated with ({header_naxis:d})\",\n                    FITSFixedWarning,\n                )",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 19719,
                "end_index": 20621,
                "start_line": 577,
                "end_line": 3796,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "try:\n                tmp_header = fits.Header.fromstring(header_string)\n                self._remove_sip_kw(tmp_header)\n                tmp_header_bytes = tmp_header.tostring().rstrip()\n                if isinstance(tmp_header_bytes, str):\n                    tmp_header_bytes = tmp_header_bytes.encode(\"ascii\")\n                tmp_wcsprm = _wcs.Wcsprm(\n                    header=tmp_header_bytes,\n                    key=key,\n                    relax=relax,\n                    keysel=keysel_flags,\n                    colsel=colsel,\n                    warnings=False,\n                    hdulist=fobj,\n                )\n                if naxis is not None:\n                    try:\n                        tmp_wcsprm = tmp_wcsprm.sub(naxis)\n                    except ValueError:\n                        pass\n                    est_naxis = tmp_wcsprm.naxis if tmp_wcsprm.naxis else 2\n\n            except _wcs.NoWcsKeywordsFoundError:\n                pass\n\n            self.naxis = est_naxis\n\n            header = fits.Header.fromstring(header_string)\n\n            det2im = self._read_det2im_kw(header, fobj, err=minerr)\n            cpdis = self._read_distortion_kw(header, fobj, dist=\"CPDIS\", err=minerr)\n            self._fix_pre2012_scamp_tpv(header)\n\n            sip = self._read_sip_kw(header, wcskey=key)\n            self._remove_sip_kw(header)\n\n            header_string = header.tostring()\n            header_string = header_string.replace(\"END\" + \" \" * 77, \"\")\n\n            if isinstance(header_string, str):\n                header_bytes = header_string.encode(\"ascii\")\n            else:\n                header_bytes = header_string\n                header_string = header_string.decode(\"ascii\")\n\n            try:\n                wcsprm = _wcs.Wcsprm(\n                    header=header_bytes,\n                    key=key,\n                    relax=relax,\n                    keysel=keysel_flags,\n                    colsel=colsel,\n                    hdulist=fobj,\n                )\n            except _wcs.NoWcsKeywordsFoundError:\n                # The header may have SIP or distortions, but no core\n                # WCS.  That isn't an error -- we want a \"default\"\n                # (identity) core Wcs transformation in that case.\n                if colsel is None:\n                    wcsprm = _wcs.Wcsprm(\n                        header=None,\n                        key=key,\n                        relax=relax,\n                        keysel=keysel_flags,\n                        colsel=colsel,\n                        hdulist=fobj,\n                    )\n                else:\n                    raise\n\n            if naxis is not None:\n                wcsprm = wcsprm.sub(naxis)\n            self.naxis = wcsprm.naxis",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 16964,
                "end_index": 19705,
                "start_line": 455,
                "end_line": 575,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "#else\n\n#if defined(NO_IMPORT_ASTROPY_WCS_API)\nextern void** AstropyWcs_API;\n#else\nvoid** AstropyWcs_API;\n#endif /* defined(NO_IMPORT_ASTROPY_PYWCS_API) */\n\n/* Function macros that delegate to a function pointer in the AstropyWcs_API table */\n#define AstropyWcs_GetCVersion (*(int (*)(void)) AstropyWcs_API[0])\n#define wcsprm_python2c (*(void (*)(struct wcsprm*)) AstropyWcs_API[1])\n#define wcsprm_c2python (*(void (*)(struct wcsprm*)) AstropyWcs_API[2])\n#define distortion_lookup_t_init (*(int (*)(distortion_lookup_t* lookup)) AstropyWcs_API[3])\n#define distortion_lookup_t_free (*(void (*)(distortion_lookup_t* lookup)) AstropyWcs_API[4])\n#define get_distortion_offset (*(double (*)(const distortion_lookup_t*, const double* const)) AstropyWcs_API[5])\n#define p4_pix2foc (*(int (*)(const unsigned int, const distortion_lookup_t**, const unsigned int, const double *, double *)) AstropyWcs_API[6])\n#define p4_pix2deltas (*(int (*)(const unsigned int, const distortion_lookup_t**, const unsigned int, const double *, double *)) AstropyWcs_API[7])\n#define sip_clear (*(void (*)(sip_t*) AstropyWcs_API[8]))\n#define sip_init (*(int (*)(sip_t*, unsigned int, double*, unsigned int, double*, unsigned int, double*, unsigned int, double*, double*)) AstropyWcs_API[9])\n#define sip_free (*(void (*)(sip_t*) AstropyWcs_API[10]))\n#define sip_pix2foc (*(int (*)(sip_t*, unsigned int, unsigned int, double*, double*)) AstropyWcs_API[11])\n#define sip_pix2deltas (*(int (*)(sip_t*, unsigned int, unsigned int, double*, double*)) AstropyWcs_API[12])\n#define sip_foc2pix (*(int (*)(sip_t*, unsigned int, unsigned int, double*, double*)) AstropyWcs_API[13])\n#define sip_foc2deltas (*(int (*)(sip_t*, unsigned int, unsigned int, double*, double*)) AstropyWcs_API[14])\n#define pipeline_clear (*(void (*)(pipeline_t*)) AstropyWcs_API[15])\n#define pipeline_init (*(void (*)(pipeline_t*, sip_t*, distortion_lookup_t**, struct wcsprm*)) AstropyWcs_API[16])\n#define pipeline_free (*(void (*)(pipeline_t*)) AstropyWcs_API[17])\n#define pipeline_all_pixel2world (*(int (*)(pipeline_t*, unsigned int, unsigned int, double*, double*)) AstropyWcs_API[18])\n#define pipeline_pix2foc (*(int (*)(pipeline_t*, unsigned int, unsigned int, double*, double*)) AstropyWcs_API[19])\n#define wcsp2s (*(int (*)(struct wcsprm *, int, int, const double[], double[], double[], double[], double[], int[])) AstropyWcs_API[20])\n#define wcss2p (*(int (*)(struct wcsprm *, int, int, const double[], double[], double[], double[], double[], int[])) AstropyWcs_API[21])\n#define wcsprt (*(int (*)(struct wcsprm *)) AstropyWcs_API[22])\n#define wcslib_get_error_message (*(const char* (*)(int)) AstropyWcs_API[23])\n#define wcsprintf_buf (*(const char * (*)()) AstropyWcs_API[24])",
                "filename": "astropy/wcs/include/astropy_wcs/astropy_wcs_api.h",
                "start_index": 1042,
                "end_index": 3764,
                "start_line": 42,
                "end_line": 75,
                "max_line": 114,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Under the hood, there are 3 separate classes that perform different\n# parts of the transformation:\n#\n#    - `~astropy.wcs.Wcsprm`: Is a direct wrapper of the core WCS\n#      functionality in `wcslib`_.  (This includes TPV and TPD\n#      polynomial distortion, but not SIP distortion).\n#\n#    - `~astropy.wcs.Sip`: Handles polynomial distortion as defined in the\n#      `SIP`_ convention.\n#\n#    - `~astropy.wcs.DistortionLookupTable`: Handles `distortion paper`_\n#      lookup tables.\n#\n# Additionally, the class `WCS` aggregates all of these transformations\n# together in a pipeline:\n#\n#    - Detector to image plane correction (by a pair of\n#      `~astropy.wcs.DistortionLookupTable` objects).\n#\n#    - `SIP`_ distortion correction (by an underlying `~astropy.wcs.Sip`\n#      object)\n#\n#    - `distortion paper`_ table-lookup correction (by a pair of\n#      `~astropy.wcs.DistortionLookupTable` objects).\n#\n#    - `wcslib`_ WCS transformation (by a `~astropy.wcs.Wcsprm` object)\n\n# STDLIB\nimport builtins\nimport copy\nimport io\nimport itertools\nimport os\nimport re\nimport textwrap\nimport uuid\nimport warnings\n\n# THIRD-PARTY\nimport numpy as np\nfrom packaging.version import Version\n\n# LOCAL\nfrom astropy import log\nfrom astropy import units as u\nfrom astropy.io import fits\nfrom astropy.utils.decorators import deprecated_renamed_argument\nfrom astropy.utils.exceptions import (\n    AstropyDeprecationWarning,\n    AstropyUserWarning,\n    AstropyWarning,\n)\n\nfrom . import _wcs, docstrings\n\n# Mix-in class that provides the APE 14 API\nfrom .wcsapi.fitswcs import FITSWCSAPIMixin, SlicedFITSWCS\n\n__all__ = [\n    \"FITSFixedWarning\",\n    \"WCS\",\n    \"find_all_wcs\",\n    \"DistortionLookupTable\",\n    \"Sip\",\n    \"Tabprm\",\n    \"Wcsprm\",\n    \"Auxprm\",\n    \"Celprm\",\n    \"Prjprm\",\n    \"Wtbarr\",\n    \"WCSBase\",\n    \"validate\",\n    \"WcsError\",\n    \"SingularMatrixError\",\n    \"InconsistentAxisTypesError\",\n    \"InvalidTransformError\",\n    \"InvalidCoordinateError\",\n    \"InvalidPrjParametersError\",\n    \"NoSolutionError\",\n    \"InvalidSubimageSpecificationError\",\n    \"NoConvergence\",\n    \"NonseparableSubimageCoordinateSystemError\",\n    \"NoWcsKeywordsFoundError\",\n    \"InvalidTabularParametersError\",\n]\n\n\n__doctest_skip__ = [\"WCS.all_world2pix\"]",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 0,
                "end_index": 2297,
                "start_line": 1,
                "end_line": 90,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "if (strncmp(wcsprj->code, \"TPU\", 3) == 0 ||\n        strncmp(wcsprj->code, \"TPV\", 3) == 0) {\n      // Translate the PV parameters.\n      struct disprm *dis;\n      if ((dis = calloc(1, sizeof(struct disprm))) == 0x0) {\n        return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));\n      }\n\n      int ndpmax = 6 + wcs->npv;\n\n      // Attach it to linprm.  Also inits it.\n      char dpq[16];\n      struct linprm *wcslin = &(wcs->lin);\n      dis->flag = -1;\n      if (strncmp(wcsprj->code, \"TPU\", 3) == 0) {\n        // Prior distortion.\n        lindist(1, wcslin, dis, ndpmax);\n        strcpy(dpq, \"DP\");\n      } else {\n        // Sequent distortion.\n        lindist(2, wcslin, dis, ndpmax);\n        strcpy(dpq, \"DQ\");\n      }\n\n      // Yes, the distortion type is \"TPV\" even for TPU.\n      strcpy(dis->dtype[wcs->lng], \"TPV\");\n      strcpy(dis->dtype[wcs->lat], \"TPV\");\n\n      // Keep the keywords in axis-order to aid debugging.\n      struct dpkey *keyp = dis->dp;\n      dis->ndp = 0;\n\n      sprintf(dpq+2, \"%d\", wcs->lng+1);\n      dpfill(keyp++, dpq, \"NAXES\",  0, 0, 2, 0.0);\n      dpfill(keyp++, dpq, \"AXIS.1\", 0, 0, 1, 0.0);\n      dpfill(keyp++, dpq, \"AXIS.2\", 0, 0, 2, 0.0);\n      dis->ndp += 3;\n\n      // Copy distortion parameters for the longitude axis.\n      for (int k = 0; k < wcs->npv; k++) {\n        if (wcs->pv[k].i != wcs->lng+1) continue;\n        sprintf(keyp->field, \"%s.TPV.%d\", dpq, wcs->pv[k].m);\n        dpfill(keyp++, 0x0, 0x0, 0, 1, 0, wcs->pv[k].value);\n        dis->ndp++;\n      }\n\n      // Now the latitude axis.\n      sprintf(dpq+2, \"%d\", wcs->lat+1);\n      dpfill(keyp++, dpq, \"NAXES\",  0, 0, 2, 0.0);\n      dpfill(keyp++, dpq, \"AXIS.1\", 0, 0, 2, 0.0);\n      dpfill(keyp++, dpq, \"AXIS.2\", 0, 0, 1, 0.0);\n      dis->ndp += 3;\n\n      for (int k = 0; k < wcs->npv; k++) {\n        if (wcs->pv[k].i != wcs->lat+1) continue;\n        sprintf(keyp->field, \"%s.TPV.%d\", dpq, wcs->pv[k].m);\n        dpfill(keyp++, 0x0, 0x0, 0, 1, 0, wcs->pv[k].value);\n        dis->ndp++;\n      }\n\n      // Erase PVi_ma associated with the celestial axes.\n      int n = 0;\n      for (int k = 0; k < wcs->npv; k++) {\n        int i = wcs->pv[k].i - 1;\n        if (i == wcs->lng || i == wcs->lat) continue;\n\n        wcs->pv[n].i = wcs->pv[k].i;\n        wcs->pv[n].m = wcs->pv[k].m;\n        wcs->pv[n].value = wcs->pv[k].value;\n\n        n++;\n      }\n\n      wcs->npv = n;\n      strcpy(wcsprj->code, \"TAN\");\n\n      // As the PVi_ma have now been erased, ctype must be reset to prevent\n      // this translation from re-occurring if wcsset() is called again.\n      strcpy(wcs->ctype[wcs->lng]+5, \"TAN\");\n      strcpy(wcs->ctype[wcs->lat]+5, \"TAN\");\n\n    } else",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 69749,
                "end_index": 72391,
                "start_line": 2532,
                "end_line": 4598,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "for (k = 0; k < wcs->npv; k++) {\n    wcsutil_double2str(keyvalue, format, (wcs->pv[k]).value);\n    if ((wcs->pv[k]).i == (wcs->lng + 1)) {\n      switch ((wcs->pv[k]).m) {\n      case 1:\n        strcpy(comment, \"[deg] Native longitude of the reference point\");\n        break;\n      case 2:\n        strcpy(comment, \"[deg] Native latitude  of the reference point\");\n        break;\n      case 3:\n        if (primage) {\n          sprintf(keyword, \"LONPOLE%c\", alt);\n        } else if (bintab) {\n          sprintf(keyword, \"LONP%d%c\", colnum, alt);\n        } else {\n          sprintf(keyword, \"LONP%d%c\", colax[(wcs->pv[k]).i - 1], alt);\n        }\n        sprintf(comment, \"[deg] alias for %s (has precedence)\", keyword);\n        break;\n      case 4:\n        if (primage) {\n          sprintf(keyword, \"LATPOLE%c\", alt);\n        } else if (bintab) {\n          sprintf(keyword, \"LATP%d%c\", colnum, alt);\n        } else {\n          sprintf(keyword, \"LATP%d%c\", colax[(wcs->pv[k]).i - 1], alt);\n        }\n        sprintf(comment, \"[deg] alias for %s (has precedence)\", keyword);\n        break;\n      }\n    } else if ((wcs->pv[k]).i == (wcs->lat + 1)) {\n      sprintf(comment, \"%s projection parameter\", wcs->cel.prj.code);\n    } else {\n      strcpy(comment, \"Coordinate transformation parameter\");\n    }\n\n    wcshdo_util(ctrl, \"PV\", \"V\", WCSHDO_PVn_ma, \"PV\", wcs->pv[k].i, -1,\n      wcs->pv[k].m, alt, colnum, colax, keyvalue, comment,\n      nkeyrec, header, &status);\n  }\n\n  for (k = 0; k < wcs->nps; k++) {\n    sprintf(keyvalue, \"'%s'\", (wcs->ps[k]).value);\n    wcshdo_util(ctrl, \"PS\", \"S\", WCSHDO_PVn_ma, \"PS\", wcs->ps[k].i, -1,\n      wcs->ps[k].m, alt, colnum, colax, keyvalue,\n      \"Coordinate transformation parameter\",\n      nkeyrec, header, &status);\n  }\n\n  // Celestial and spectral transformation parameters.\n  if (!undefined(wcs->lonpole)) {\n    wcsutil_double2str(keyvalue, format, wcs->lonpole);\n    wcshdo_util(ctrl, \"LONPOLE\", \"LONP\", 0, 0x0, 0, 0, 0, alt,\n      colnum, colax, keyvalue, \"[deg] Native longitude of celestial pole\",\n      nkeyrec, header, &status);\n  }\n\n  if (!undefined(wcs->latpole)) {\n    wcsutil_double2str(keyvalue, format, wcs->latpole);\n    wcshdo_util(ctrl, \"LATPOLE\", \"LATP\", 0, 0x0, 0, 0, 0, alt,\n      colnum, colax, keyvalue, \"[deg] Native latitude of celestial pole\",\n      nkeyrec, header, &status);\n  }\n\n  if (wcs->restfrq != 0.0) {\n    wcsutil_double2str(keyvalue, format, wcs->restfrq);\n    wcshdo_util(ctrl, \"RESTFRQ\", \"RFRQ\", 0, 0x0, 0, 0, 0, alt,\n      colnum, colax, keyvalue, \"[Hz] Line rest frequency\",\n      nkeyrec, header, &status);\n  }\n\n  if (wcs->restwav != 0.0) {\n    wcsutil_double2str(keyvalue, format, wcs->restwav);\n    wcshdo_util(ctrl, \"RESTWAV\", \"RWAV\", 0, 0x0, 0, 0, 0, alt,\n      colnum, colax, keyvalue, \"[Hz] Line rest wavelength\",\n      nkeyrec, header, &status);\n  }\n\n  // - - - - - - - - - - - - - - - - -  Auxiliary coordinate axis information.\n  sprintf(timeunit, \"%.15s\", wcs->timeunit[0] ? wcs->timeunit : \"s\");",
                "filename": "cextern/wcslib/C/wcshdr.c",
                "start_index": 23675,
                "end_index": 26654,
                "start_line": 837,
                "end_line": 917,
                "max_line": 2250,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\nimport re\nimport warnings\nfrom collections import OrderedDict, defaultdict\n\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates import EarthLocation\nfrom astropy.table import Column, MaskedColumn\nfrom astropy.table.column import col_copy\nfrom astropy.time import Time, TimeDelta\nfrom astropy.time.core import BARYCENTRIC_SCALES\nfrom astropy.time.formats import FITS_DEPRECATED_SCALES\nfrom astropy.utils.exceptions import AstropyUserWarning\n\nfrom . import Card, Header\n\n# The following is based on the FITS WCS Paper IV, \"Representations of time\n# coordinates in FITS\".\n# https://ui.adsabs.harvard.edu/abs/2015A%26A...574A..36R\n\n\n# FITS WCS standard specified \"4-3\" form for non-linear coordinate types\nTCTYP_RE_TYPE = re.compile(r\"(?P<type>[A-Z]+)[-]+\")\nTCTYP_RE_ALGO = re.compile(r\"(?P<algo>[A-Z]+)\\s*\")\n\n\n# FITS Time standard specified time units\nFITS_TIME_UNIT = [\"s\", \"d\", \"a\", \"cy\", \"min\", \"h\", \"yr\", \"ta\", \"Ba\"]\n\n\n# Global time reference coordinate keywords\nOBSGEO_XYZ = (\"OBSGEO-X\", \"OBSGEO-Y\", \"OBSGEO-Z\")\nOBSGEO_LBH = (\"OBSGEO-L\", \"OBSGEO-B\", \"OBSGEO-H\")\nTIME_KEYWORDS = (\n    (\n        \"DATE\",\n        \"DATE-AVG\",\n        \"DATE-BEG\",\n        \"DATE-END\",\n        \"DATE-OBS\",\n        \"DATEREF\",\n        \"JDREF\",\n        \"MJD-AVG\",\n        \"MJD-BEG\",\n        \"MJD-END\",\n        \"MJD-OBS\",\n        \"MJDREF\",\n        \"TIMEOFFS\",\n        \"TIMESYS\",\n        \"TIMEUNIT\",\n        \"TREFDIR\",\n        \"TREFPOS\",\n    )\n    + OBSGEO_LBH\n    + OBSGEO_XYZ\n)\n\n\n# Column-specific time override keywords\nCOLUMN_TIME_KEYWORDS = (\"TCTYP\", \"TCUNI\", \"TRPOS\")\n\n\n# Column-specific keywords regex\nCOLUMN_TIME_KEYWORD_REGEXP = f\"({'|'.join(COLUMN_TIME_KEYWORDS)})[0-9]+\"\n\n\ndef is_time_column_keyword(keyword):\n    \"\"\"\n    Check if the FITS header keyword is a time column-specific keyword.\n\n    Parameters\n    ----------\n    keyword : str\n        FITS keyword.\n    \"\"\"\n    return re.match(COLUMN_TIME_KEYWORD_REGEXP, keyword) is not None\n\n\n# Set astropy time global information\nGLOBAL_TIME_INFO = {\n    \"TIMESYS\": (\"UTC\", \"Default time scale\"),\n    \"JDREF\": (0.0, \"Time columns are jd = jd1 + jd2\"),\n    \"TREFPOS\": (\"TOPOCENTER\", \"Time reference position\"),\n}",
                "filename": "astropy/io/fits/fitstime.py",
                "start_index": 0,
                "end_index": 2232,
                "start_line": 1,
                "end_line": 649,
                "max_line": 655,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            },
            {
                "code": "if (strcmp(wcs->ctype[wcs->lat]+5, \"GLS\") == 0) {\n      strcpy(wcs->ctype[wcs->lng]+5, \"SFL\");\n      strcpy(wcs->ctype[wcs->lat]+5, \"SFL\");\n\n      if (wcs->crval[wcs->lng] != 0.0 || wcs->crval[wcs->lat] != 0.0) {\n        // In the AIPS convention, setting the reference longitude and\n        // latitude for GLS does not create an oblique graticule.  A non-zero\n        // reference longitude introduces an offset in longitude in the normal\n        // way, whereas a non-zero reference latitude simply translates the\n        // reference point (i.e. the map as a whole) to that latitude.  This\n        // might be effected by adjusting CRPIXja but that is complicated by\n        // the linear transformation and instead is accomplished here by\n        // setting theta_0.\n        if (wcs->npvmax < wcs->npv + 3) {\n          // Allocate space for three more PVi_ma keyvalues.\n          if (wcs->m_flag == WCSSET && wcs->pv == wcs->m_pv) {\n            if (!(wcs->pv = calloc(wcs->npv+3, sizeof(struct pvcard)))) {\n              wcs->pv = wcs->m_pv;\n              return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));\n            }\n\n            wcs->npvmax = wcs->npv + 3;\n            wcs->m_flag = WCSSET;\n\n            for (int k = 0; k < wcs->npv; k++) {\n              wcs->pv[k] = wcs->m_pv[k];\n            }\n\n            if (wcs->m_pv) free(wcs->m_pv);\n            wcs->m_pv = wcs->pv;\n\n          } else {\n            return wcserr_set(WCSFIX_ERRMSG(FIXERR_MEMORY));\n          }\n        }\n\n        wcs->pv[wcs->npv].i = wcs->lng + 1;\n        wcs->pv[wcs->npv].m = 0;\n        wcs->pv[wcs->npv].value = 1.0;\n        (wcs->npv)++;\n\n        // Note that the reference longitude is still zero.\n        wcs->pv[wcs->npv].i = wcs->lng + 1;\n        wcs->pv[wcs->npv].m = 1;\n        wcs->pv[wcs->npv].value = 0.0;\n        (wcs->npv)++;\n\n        wcs->pv[wcs->npv].i = wcs->lng + 1;\n        wcs->pv[wcs->npv].m = 2;\n        wcs->pv[wcs->npv].value = wcs->crval[wcs->lat];\n        (wcs->npv)++;\n      }\n\n      return FIXERR_SUCCESS;\n    }",
                "filename": "cextern/wcslib/C/wcsfix.c",
                "start_index": 26897,
                "end_index": 28919,
                "start_line": 973,
                "end_line": 1475,
                "max_line": 1481,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "astropy/wcs/wcs.py": [
                {
                    "chunk": {
                        "code": "def _fix_scamp(self):\n        \"\"\"\n        Remove SCAMP's PVi_m distortion parameters if SIP distortion parameters\n        are also present. Some projects (e.g., Palomar Transient Factory)\n        convert SCAMP's distortion parameters (which abuse the PVi_m cards) to\n        SIP. However, wcslib gets confused by the presence of both SCAMP and\n        SIP distortion parameters.\n\n        See https://github.com/astropy/astropy/issues/299.\n\n        SCAMP uses TAN projection exclusively. The case of CTYPE ending\n        in -TAN should have been handled by ``_fix_pre2012_scamp_tpv()`` before\n        calling this function.\n        \"\"\"\n        if self.wcs is None:\n            return\n\n        # Delete SIP if CTYPE explicitly has '-TPV' code:\n        ctype = [ct.strip().upper() for ct in self.wcs.ctype]\n        if sum(ct.endswith(\"-TPV\") for ct in ctype) == 2:\n            if self.sip is not None:\n                self.sip = None\n                warnings.warn(\n                    \"Removed redundant SIP distortion parameters \"\n                    \"because CTYPE explicitly specifies TPV distortions\",\n                    FITSFixedWarning,\n                )\n            return\n\n        # Nothing to be done if no PV parameters attached since SCAMP\n        # encodes distortion coefficients using PV keywords\n        pv = self.wcs.get_pv()\n        if not pv:\n            return\n\n        # Nothing to be done if axes don't use SIP distortion parameters\n        if self.sip is None:\n            return\n\n        # Loop over distinct values of `i' index\n        has_scamp = False\n        for i in {v[0] for v in pv}:\n            # Get all values of `j' index for this value of `i' index\n            js = tuple(v[1] for v in pv if v[0] == i)\n            if \"-TAN\" in self.wcs.ctype[i - 1].upper() and js and max(js) >= 5:\n                # TAN projection *may* use PVi_j with j up to 4 - see\n                # Sections 2.5, 2.6, and Table 13\n                # in https://doi.org/10.1051/0004-6361:20021327\n                has_scamp = True\n                break\n\n        if has_scamp and all(ct.endswith(\"-SIP\") for ct in ctype):\n            # Prefer SIP - see recommendations in Section 7 in\n            # http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf\n            self.wcs.set_pv([])\n            warnings.warn(\n                \"Removed redundant SCAMP distortion parameters \"\n                \"because SIP parameters are also present\",\n                FITSFixedWarning,\n            )\n            return",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 23982,
                        "end_index": 26504,
                        "start_line": 706,
                        "end_line": 3753,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the '_fix_scamp' function which is responsible for removing PV keywords when SIP distortions are present. The issue describes a problem with PV keywords being ignored due to the presence of SIP keywords, which is directly related to the logic in this function."
                },
                {
                    "chunk": {
                        "code": "def _fix_pre2012_scamp_tpv(self, header, wcskey=\"\"):\n        \"\"\"\n        Replace -TAN with TPV (for pre-2012 SCAMP headers that use -TAN\n        in CTYPE). Ignore SIP if present. This follows recommendations in\n        Section 7 in\n        http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf.\n\n        This is to deal with pre-2012 headers that may contain TPV with a\n        CTYPE that ends in '-TAN' (post-2012 they should end in '-TPV' when\n        SCAMP has adopted the new TPV convention).\n        \"\"\"\n        if isinstance(header, (str, bytes)):\n            return\n\n        wcskey = wcskey.strip().upper()\n        cntype = [\n            (nax, header.get(f\"CTYPE{nax}{wcskey}\", \"\").strip())\n            for nax in range(1, self.naxis + 1)\n        ]\n\n        tan_axes = [ct[0] for ct in cntype if ct[1].endswith(\"-TAN\")]\n\n        if len(tan_axes) == 2:\n            # check if PVi_j with j >= 5 is present and if so, do not load SIP\n            tan_to_tpv = False\n            for nax in tan_axes:\n                js = []\n                for p in header[f\"PV{nax}_*{wcskey}\"].keys():\n                    prefix = f\"PV{nax}_\"\n                    if p.startswith(prefix):\n                        p = p[len(prefix) :]\n                        p = p.rstrip(wcskey)\n                        try:\n                            p = int(p)\n                        except ValueError:\n                            continue\n                        js.append(p)\n\n                if js and max(js) >= 5:\n                    tan_to_tpv = True\n                    break\n\n            if tan_to_tpv:\n                warnings.warn(\n                    \"Removed redundant SIP distortion parameters \"\n                    \"because SCAMP' PV distortions are also present\",\n                    FITSFixedWarning,\n                )\n                self._remove_sip_kw(header, del_order=True)\n                for i in tan_axes:\n                    kwd = f\"CTYPE{i:d}{wcskey}\"\n                    if kwd in header:\n                        header[kwd] = (\n                            header[kwd].strip().upper().replace(\"-TAN\", \"-TPV\")\n                        )\n\n    @staticmethod\n    def _remove_sip_kw(header, del_order=False):\n        \"\"\"\n        Remove SIP information from a header.\n        \"\"\"\n        # Never pass SIP coefficients to wcslib\n        # CTYPE must be passed with -SIP to wcslib\n        for key in {\n            m.group() for m in map(SIP_KW.match, list(header)) if m is not None\n        }:\n            del header[key]\n\n        if del_order:\n            for kwd in [\"A_ORDER\", \"B_ORDER\", \"AP_ORDER\", \"BP_ORDER\"]:\n                if kwd in header:\n                    del header[kwd]",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 42446,
                        "end_index": 45137,
                        "start_line": 1192,
                        "end_line": 1263,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the '_fix_pre2012_scamp_tpv' function which also deals with the handling of SIP and PV keywords in the header. It is relevant because it shows how the code is currently handling the presence of both SIP and PV keywords, which is at the core of the issue."
                }
            ]
        },
        "solution_task": "- Remove the `_fix_scamp` function from `astropy/wcs/wcs.py`.\n- Ensure that the `WCS` class and any other relevant classes or functions do not call `_fix_scamp`.\n- Remove any unit tests that specifically test the behavior of `_fix_scamp`.\n- Search for any documentation that references `_fix_scamp` and update it to reflect the removal of the function.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT by suggesting the removal of the '_fix_scamp' function from the codebase. This function is identified as the cause of the bug where PV keywords are ignored when SIP keywords are present. The RESPONSE also includes additional steps to ensure that the removal of the function is comprehensive, including updating documentation and removing unit tests related to the function. Furthermore, the RESPONSE provides specific code snippets and lines within the astropy repository that are relevant to the issue, which can guide the developers directly to the problematic sections of the code. This level of detail and relevance is highly valuable for addressing the software bug.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711736296.395694,
        "result": "- Remove the `_fix_scamp` function from `astropy/wcs/wcs.py`.\n- Ensure that the `WCS` class and any other relevant classes or functions do not call `_fix_scamp`.\n- Remove any unit tests that specifically test the behavior of `_fix_scamp`.\n- Search for any documentation that references `_fix_scamp` and update it to reflect the removal of the function.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.1/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__5.1/tree//astropy/wcs)- [Lines 706 - 3753](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/wcs/wcs.py#L706-L3753)\n\n This snippet contains the '_fix_scamp' function which is responsible for removing PV keywords when SIP distortions are present. The issue describes a problem with PV keywords being ignored due to the presence of SIP keywords, which is directly related to the logic in this function. \n\n\n   - [Lines 1192 - 1263](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/wcs/wcs.py#L1192-L1263)\n\n This snippet contains the '_fix_pre2012_scamp_tpv' function which also deals with the handling of SIP and PV keywords in the header. It is relevant because it shows how the code is currently handling the presence of both SIP and PV keywords, which is at the core of the issue."
    }
}