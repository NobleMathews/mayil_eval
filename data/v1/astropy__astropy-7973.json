{
    "id": "astropy__astropy-7973",
    "repo_name": "testbed/astropy__astropy__3.0",
    "task_id": 4361088940201448171,
    "title": "Record data size in the WCS object",
    "body": "It is clear that there are practical reasons to have a record of the original data size in the WCS object. This in the past has been recorded in public attributes `naxis1` and `naxis2` and subsequently in the private `_naxis1` and `_naxis2`.  There's  along thread on why this should  or should not be done in #4662.\r\nMore recently #5411 expanded this attribute to more than 2 axes. It also broke the ability to set the private attributes which was subsequently fixed in #5454 as a stop gap measure.\r\n\r\nWe need to fix this permanently starting with v 1.3. There are two proposed ways to do it.\r\n\r\n1. Add public `naxisj` attributes, populated by the FITS header `NAXISj` keywords.\r\n2. Introduce a subclass of `WCS` which adds those and leave the original WCS to represent strictly the FITS WCS standard and nothing more.\r\n\r\nEither way a deprecation process will accompany the change.\r\n\r\nThe purpose of this issue is to collect votes. I don't want to start a new long discussion. Keep in mind that #4662 is available for reference and only share new arguments.\r\n\r\nSince 1.3 is approaching we need to make a fast decision. So please share your preference here and volunteer for the work if possible.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__3.0.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature of recording the original data size in the WCS object, you can choose between the two proposed methods. Here's a high-level overview of how to implement each option:\n\nOption 1: Add public `naxisj` attributes, populated by the FITS header `NAXISj` keywords.\n- Modify the `WCS` class to include public attributes for `naxisj` where `j` is the axis number.\n- In the `WCS` class constructor, read the `NAXISj` values from the FITS header and assign them to the corresponding `naxisj` attributes.\n- Ensure that these attributes are updated if the WCS object is modified to represent a different view of the data (e.g., after slicing).\n\nOption 2: Introduce a subclass of `WCS` which adds those attributes and leave the original WCS to represent strictly the FITS WCS standard and nothing more.\n- Create a new subclass of the `WCS` class, e.g., `ExtendedWCS`.\n- In the `ExtendedWCS` constructor, call the superclass constructor and then add additional logic to handle the `naxisj` attributes.\n- Ensure that the `naxisj` attributes are properly managed in any methods that might alter the WCS state.\n\nFor both options, you will need to:\n- Implement a deprecation process for the old way of accessing the data size through private attributes `_naxis1` and `_naxis2`.\n- Update the documentation to reflect the changes and guide users on how to use the new attributes.\n- Write unit tests to ensure that the new attributes behave as expected, including after any WCS transformations.\n\nHere is a pseudo-code example for Option 1:\n\n```python\nclass WCS:\n    def __init__(self, header=None, key=' ', relax=True, naxis=None):\n        # existing initialization code...\n        self.naxis = [None] * MAX_NAXIS  # MAX_NAXIS is the maximum number of axes supported\n        if header is not None:\n            for j in range(MAX_NAXIS):\n                naxis_key = f'NAXIS{j+1}'\n                if naxis_key in header:\n                    self.naxis[j] = header[naxis_key]\n        # more initialization code...\n\n    # other methods of WCS class...\n```\n\nFor Option 2:\n\n```python\nclass ExtendedWCS(WCS):\n    def __init__(self, header=None, key=' ', relax=True, naxis=None):\n        super().__init__(header, key, relax, naxis)\n        self.naxisj = [None] * MAX_NAXIS  # MAX_NAXIS is the maximum number of axes supported\n        if header is not None:\n            for j in range(MAX_NAXIS):\n                naxis_key = f'NAXIS{j+1}'\n                if naxis_key in header:\n                    self.naxisj[j] = header[naxis_key]\n        # additional initialization for ExtendedWCS...\n\n    # additional methods for ExtendedWCS...\n```\n\nRemember to replace `MAX_NAXIS` with the actual maximum number of axes supported by the WCS standard or the specific implementation.\n\nNote: The provided code snippets from the codebase are not directly relevant to the implementation of the new feature, but they provide context on how WCS objects are currently handled and how FITS headers are parsed. The actual implementation will depend on the existing structure of the WCS class and how it interacts with FITS headers.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__3.0/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/wcs)- [Lines 442 - 450](https://github.com/testbed/astropy__astropy__3.0/blob//astropy/wcs/wcs.py#L442-L450)\n\n This snippet initializes the WCS object and sets the default number of axes, which is relevant to the issue of recording the original data size in the WCS object.\n-  \u2192 [cextern](https://github.com/testbed/astropy__astropy__3.0/tree//cextern) \u2192 [wcslib](https://github.com/testbed/astropy__astropy__3.0/tree//cextern/wcslib) \u2192 [C](https://github.com/testbed/astropy__astropy__3.0/tree//cextern/wcslib/C)- [Lines 478 - 2166](https://github.com/testbed/astropy__astropy__3.0/blob//cextern/wcslib/C/wcs.h#L478-L2166)\n\n This snippet defines the structure of the WCS object, including the number of axes, which is directly related to the issue of recording the original data size.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__3.0/tree//astropy) \u2192 [io](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/io) \u2192 [fits](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/io/fits) \u2192 [hdu](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/io/fits/hdu)- [Lines 404 - 467](https://github.com/testbed/astropy__astropy__3.0/blob//astropy/io/fits/hdu/groups.py#L404-L467)\n\n This snippet deals with updating the FITS header, including the NAXIS values, which are related to the issue of recording the original data size in the WCS object.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000421,
        "snippet_processor": 0.07401,
        "issue_star_creation": 0.030689999999999995,
        "issue_star_solver": 0.08077000000000001,
        "bouncer": 0.02683
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711737601.494764,
        "relevant_snippets": [
            {
                "code": "if (abs(axis) > 0x1000) {\n      // Subimage extraction by type.\n      int k = abs(axis) & 0xFF;\n\n      int longitude = k & WCSSUB_LONGITUDE;\n      int latitude  = k & WCSSUB_LATITUDE;\n      int cubeface  = k & WCSSUB_CUBEFACE;\n      int spectral  = k & WCSSUB_SPECTRAL;\n      int stokes    = k & WCSSUB_STOKES;\n      int time      = k & WCSSUB_TIME;\n\n      int other;\n      if ((other = (axis < 0))) {\n        longitude = !longitude;\n        latitude  = !latitude;\n        cubeface  = !cubeface;\n        spectral  = !spectral;\n        stokes    = !stokes;\n        time      = !time;\n      }\n\n      for (int i = 0; i < naxis; i++) {\n        char ctypei[16];\n        strncpy (ctypei, (char *)(wcssrc->ctype + i), 8);\n        ctypei[8] = '\\0';\n\n        // Find the last non-blank character.\n        char *c = ctypei + 8;\n        while (c-- > ctypei) {\n          if (*c == ' ') *c = '\\0';\n          if (*c != '\\0') break;\n        }\n\n        if (\n          strcmp(ctypei,   \"RA\")  == 0 ||\n          strcmp(ctypei+1, \"LON\") == 0 ||\n          strcmp(ctypei+2, \"LN\")  == 0 ||\n          strncmp(ctypei,   \"RA---\", 5) == 0 ||\n          strncmp(ctypei+1, \"LON-\", 4) == 0 ||\n          strncmp(ctypei+2, \"LN-\", 3) == 0) {\n          if (!longitude) {\n            continue;\n          }\n\n        } else if (\n          strcmp(ctypei,   \"DEC\") == 0 ||\n          strcmp(ctypei+1, \"LAT\") == 0 ||\n          strcmp(ctypei+2, \"LT\")  == 0 ||\n          strncmp(ctypei,   \"DEC--\", 5) == 0 ||\n          strncmp(ctypei+1, \"LAT-\", 4) == 0 ||\n          strncmp(ctypei+2, \"LT-\", 3) == 0) {\n          if (!latitude) {\n            continue;\n          }\n\n        } else if ((\n          strncmp(ctypei, \"FREQ\", 4) == 0 ||\n          strncmp(ctypei, \"ENER\", 4) == 0 ||\n          strncmp(ctypei, \"WAVN\", 4) == 0 ||\n          strncmp(ctypei, \"VRAD\", 4) == 0 ||\n          strncmp(ctypei, \"WAVE\", 4) == 0 ||\n          strncmp(ctypei, \"VOPT\", 4) == 0 ||\n          strncmp(ctypei, \"ZOPT\", 4) == 0 ||\n          strncmp(ctypei, \"AWAV\", 4) == 0 ||\n          strncmp(ctypei, \"VELO\", 4) == 0 ||\n          strncmp(ctypei, \"BETA\", 4) == 0) &&\n          (ctypei[4] == '\\0' || ctypei[4] == '-')) {\n          if (!spectral) {\n            continue;\n          }\n\n        } else if (time_type(ctypei)) {\n          if (!time) {\n            continue;\n          }\n\n        } else if (strcmp(ctypei, \"STOKES\") == 0) {\n          if (!stokes) {\n            continue;\n          }\n\n        } else if (strcmp(ctypei, \"CUBEFACE\") == 0) {\n          if (!cubeface) {\n            continue;\n          }\n\n        } else if (!other) {\n          continue;\n        }\n\n        // This axis is wanted, but has it already been added?\n        int k;\n        for (k = 0; k < msub; k++) {\n          if (itmp[k] == i+1) {\n            break;\n          }\n        }\n        if (k == msub) itmp[msub++] = i+1;\n      }\n\n    } else",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 20308,
                "end_index": 23152,
                "start_line": 795,
                "end_line": 4598,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "if (0 < axis && axis <= naxis) {\n      // Check that the requested axis has not already been added.\n      int k;\n      for (k = 0; k < msub; k++) {\n        if (itmp[k] == axis) {\n          break;\n        }\n      }\n      if (k == msub) itmp[msub++] = axis;\n\n    } else if (axis == 0) {\n      // Graft on a new axis.\n      itmp[msub++] = 0;\n\n    } else {\n      status = wcserr_set(WCS_ERRMSG(WCSERR_BAD_SUBIMAGE));\n      goto cleanup;\n    }",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 23153,
                "end_index": 23591,
                "start_line": 895,
                "end_line": 4712,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "axis_type = wcs.world_axis_physical_types[idx]\n        axis_unit = u.Unit(wcs.world_axis_units[idx])\n        coord_wrap = None\n        format_unit = axis_unit\n\n        coord_type = \"scalar\"\n\n        if axis_type is not None:\n            axis_type_split = axis_type.split(\".\")\n\n            if \"pos.helioprojective.lon\" in axis_type:\n                coord_wrap = 180.0 * u.deg\n                format_unit = u.arcsec\n                coord_type = \"longitude\"\n            elif \"pos.helioprojective.lat\" in axis_type:\n                format_unit = u.arcsec\n                coord_type = \"latitude\"\n            elif \"pos.heliographic.stonyhurst.lon\" in axis_type:\n                coord_wrap = 180.0 * u.deg\n                format_unit = u.deg\n                coord_type = \"longitude\"\n            elif \"pos.heliographic.stonyhurst.lat\" in axis_type:\n                format_unit = u.deg\n                coord_type = \"latitude\"\n            elif \"pos.heliographic.carrington.lon\" in axis_type:\n                coord_wrap = 360.0 * u.deg\n                format_unit = u.deg\n                coord_type = \"longitude\"\n            elif \"pos.heliographic.carrington.lat\" in axis_type:\n                format_unit = u.deg\n                coord_type = \"latitude\"\n            elif \"pos\" in axis_type_split:\n                if \"lon\" in axis_type_split:\n                    coord_type = \"longitude\"\n                elif \"lat\" in axis_type_split:\n                    coord_type = \"latitude\"\n                elif \"ra\" in axis_type_split:\n                    coord_type = \"longitude\"\n                    format_unit = u.hourangle\n                elif \"dec\" in axis_type_split:\n                    coord_type = \"latitude\"\n                elif \"alt\" in axis_type_split:\n                    coord_type = \"longitude\"\n                elif \"az\" in axis_type_split:\n                    coord_type = \"latitude\"\n                elif \"long\" in axis_type_split:\n                    coord_type = \"longitude\"\n\n        coord_meta[\"type\"].append(coord_type)\n        coord_meta[\"wrap\"].append(coord_wrap)\n        coord_meta[\"format_unit\"].append(format_unit)\n        coord_meta[\"unit\"].append(axis_unit)\n\n        # For FITS-WCS, for backward-compatibility, we need to make sure that we\n        # provide aliases based on CTYPE for the name.",
                "filename": "astropy/visualization/wcsaxes/wcsapi.py",
                "start_index": 1605,
                "end_index": 3903,
                "start_line": 55,
                "end_line": 109,
                "max_line": 402,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "if header is None:\n            if naxis is None:\n                naxis = 2\n            wcsprm = _wcs.Wcsprm(header=None, key=key, relax=relax, naxis=naxis)\n            self.naxis = wcsprm.naxis\n            # Set some reasonable defaults.\n            det2im = (None, None)\n            cpdis = (None, None)\n            sip = None",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 14518,
                "end_index": 14845,
                "start_line": 442,
                "end_line": 450,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "{\n\n    // Was sufficient allocated previously?\n    if (wcs->m_flag == WCSSET &&\n       (wcs->m_naxis < naxis  ||\n        wcs->npvmax  < npvmax ||\n        wcs->npsmax  < npsmax)) {\n      // No, free it.\n      wcsfree(wcs);\n    }\n\n    if (alloc || wcs->crpix == 0x0) {\n      if (wcs->m_crpix) {\n        // In case the caller fiddled with it.\n        wcs->crpix = wcs->m_crpix;\n\n      } else {\n        if ((wcs->crpix = calloc(naxis, sizeof(double))) == 0x0) {\n          return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));\n        }\n\n        wcs->m_flag  = WCSSET;\n        wcs->m_naxis = naxis;\n        wcs->m_crpix = wcs->crpix;\n      }\n    }\n\n    if (alloc || wcs->pc == 0x0) {\n      if (wcs->m_pc) {\n        // In case the caller fiddled with it.\n        wcs->pc = wcs->m_pc;\n\n      } else {\n        if ((wcs->pc = calloc(naxis*naxis, sizeof(double))) == 0x0) {\n          wcsfree(wcs);\n          return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));\n        }\n\n        wcs->m_flag  = WCSSET;\n        wcs->m_naxis = naxis;\n        wcs->m_pc    = wcs->pc;\n      }\n    }\n\n    if (alloc || wcs->cdelt == 0x0) {\n      if (wcs->m_cdelt) {\n        // In case the caller fiddled with it.\n        wcs->cdelt = wcs->m_cdelt;\n\n      } else {\n        if ((wcs->cdelt = calloc(naxis, sizeof(double))) == 0x0) {\n          wcsfree(wcs);\n          return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));\n        }\n\n        wcs->m_flag  = WCSSET;\n        wcs->m_naxis = naxis;\n        wcs->m_cdelt = wcs->cdelt;\n      }\n    }\n\n    if (alloc || wcs->crval == 0x0) {\n      if (wcs->m_crval) {\n        // In case the caller fiddled with it.\n        wcs->crval = wcs->m_crval;\n\n      } else {\n        if ((wcs->crval = calloc(naxis, sizeof(double))) == 0x0) {\n          wcsfree(wcs);\n          return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));\n        }\n\n        wcs->m_flag  = WCSSET;\n        wcs->m_naxis = naxis;\n        wcs->m_crval = wcs->crval;\n      }\n    }\n\n    if (alloc || wcs->cunit == 0x0) {\n      if (wcs->m_cunit) {\n        // In case the caller fiddled with it.\n        wcs->cunit = wcs->m_cunit;\n\n      } else {\n        if ((wcs->cunit = calloc(naxis, sizeof(char [72]))) == 0x0) {\n          wcsfree(wcs);\n          return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));\n        }\n\n        wcs->m_flag  = WCSSET;\n        wcs->m_naxis = naxis;\n        wcs->m_cunit = wcs->cunit;\n      }\n    }\n\n    if (alloc || wcs->ctype == 0x0) {\n      if (wcs->m_ctype) {\n        // In case the caller fiddled with it.\n        wcs->ctype = wcs->m_ctype;\n\n      } else {\n        if ((wcs->ctype = calloc(naxis, sizeof(char [72]))) == 0x0) {\n          wcsfree(wcs);\n          return wcserr_set(WCS_ERRMSG(WCSERR_MEMORY));\n        }\n\n        wcs->m_flag  = WCSSET;\n        wcs->m_naxis = naxis;\n        wcs->m_ctype = wcs->ctype;\n      }\n    }",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 6997,
                "end_index": 9780,
                "start_line": 54,
                "end_line": 4712,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "{\n  // Initialization flag (see the prologue above).\n  //--------------------------------------------------------------------------\n  int    flag;\t\t\t// Set to zero to force initialization.\n\n  // FITS header keyvalues to be provided (see the prologue above).\n  //--------------------------------------------------------------------------\n  int    naxis;\t\t\t// Number of axes (pixel and coordinate).\n  double *crpix;\t\t// CRPIXja keyvalues for each pixel axis.\n  double *pc;\t\t\t// PCi_ja  linear transformation matrix.\n  double *cdelt;\t\t// CDELTia keyvalues for each coord axis.\n  double *crval;\t\t// CRVALia keyvalues for each coord axis.\n\n  char   (*cunit)[72];\t\t// CUNITia keyvalues for each coord axis.\n  char   (*ctype)[72];\t\t// CTYPEia keyvalues for each coord axis.\n\n  double lonpole;\t\t// LONPOLEa keyvalue.\n  double latpole;\t\t// LATPOLEa keyvalue.\n\n  double restfrq;\t\t// RESTFRQa keyvalue.\n  double restwav;\t\t// RESTWAVa keyvalue.\n\n  int    npv;\t\t\t// Number of PVi_ma keywords, and the\n  int    npvmax;\t\t// number for which space was allocated.\n  struct pvcard *pv;\t\t// PVi_ma keywords for each i and m.\n\n  int    nps;\t\t\t// Number of PSi_ma keywords, and the\n  int    npsmax;\t\t// number for which space was allocated.\n  struct pscard *ps;\t\t// PSi_ma keywords for each i and m.\n\n  // Alternative header keyvalues (see the prologue above).\n  //--------------------------------------------------------------------------\n  double *cd;\t\t\t// CDi_ja linear transformation matrix.\n  double *crota;\t\t// CROTAi keyvalues for each coord axis.\n  int    altlin;\t\t// Alternative representations\n\t\t\t\t//   Bit 0: PCi_ja is present,\n\t\t\t\t//   Bit 1: CDi_ja is present,\n\t\t\t\t//   Bit 2: CROTAi is present.\n  int    velref;\t\t// AIPS velocity code, VELREF.\n\n  // Auxiliary coordinate system information of a general nature.  Not\n  // used by WCSLIB.  Refer to the prologue comments above for a brief\n  // explanation of these values.\n  char   alt[4];\n  int    colnum;\n  int    *colax;\n\t\t\t\t// Auxiliary coordinate axis information.\n  char   (*cname)[72];\n  double *crder;\n  double *csyer;\n  double *czphs;\n  double *cperi;\n\n  char   wcsname[72];\n\t\t\t\t// Time reference system and measurement.\n  char   timesys[72], trefpos[72], trefdir[72], plephem[72];\n  char   timeunit[72];\n  char   dateref[72];\n  double mjdref[2];\n  double timeoffs;\n\t\t\t\t// Data timestamps and durations.\n  char   dateobs[72], datebeg[72], dateavg[72], dateend[72];\n  double mjdobs, mjdbeg, mjdavg, mjdend;\n  double jepoch, bepoch;\n  double tstart, tstop;\n  double xposure, telapse;\n\t\t\t\t// Timing accuracy.\n  double timsyer, timrder;\n  double timedel, timepixr;\n\t\t\t\t// Spatial & celestial reference frame.\n  double obsgeo[6];\n  char   obsorbit[72];\n  char   radesys[72];\n  double equinox;\n  char   specsys[72];\n  char   ssysobs[72];\n  double velosys;\n  double zsource;\n  char   ssyssrc[72];\n  double velangl;\n\n  // Additional auxiliary coordinate system information of a specialist",
                "filename": "cextern/wcslib/C/wcs.h",
                "start_index": 88659,
                "end_index": 91589,
                "start_line": 478,
                "end_line": 2166,
                "max_line": 2292,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "if (nwcs == 0) {\n      wcsvfree(&nwcs, &wcs);\n      PyErr_SetString(\n          WcsExc_NoWcsKeywordsFound,\n          \"No WCS keywords found in the given header\");\n      return -1;\n    }\n\n    /* Find the desired WCS */\n    for (i = 0; i < nwcs; ++i) {\n      if (wcs[i].alt[0] == key[0]) {\n        break;\n      }\n    }\n\n    if (i >= nwcs) {\n      wcsvfree(&nwcs, &wcs);\n      PyErr_Format(\n          PyExc_KeyError,\n          \"No WCS with key '%s' was found in the given header\",\n          key);\n      return -1;\n    }\n\n    if (wcscopy(1, wcs + i, &self->x) != 0) {\n      wcsvfree(&nwcs, &wcs);\n      PyErr_SetString(\n          PyExc_MemoryError,\n          self->x.err->msg);\n      return -1;\n    }\n\n    if (self->x.ntab) {\n      wcstab(&self->x);\n      for (j = 0; j < self->x.nwtb; j++) {\n        if (!_update_wtbarr_from_hdulist(hdulist, &(self->x.wtb[j]))) {\n          wcsfree(&self->x);\n          return -1;\n        }\n      }\n    }\n\n    note_change(self);\n    wcsprm_c2python(&self->x);\n    wcsvfree(&nwcs, &wcs);\n    return 0;\n  }",
                "filename": "astropy/wcs/src/wcslib_wrap.c",
                "start_index": 13282,
                "end_index": 14315,
                "start_line": 547,
                "end_line": 4215,
                "max_line": 4296,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "{\n  int status = 0;\n\n  // Find the number of coordinate descriptions.\n  *nwcs = 0;\n  for (int ialt = 0; ialt < 27; ialt++) {\n    if (alts[ialt]) (*nwcs)++;\n  }\n\n  int defaults;\n  if ((defaults = !(*nwcs) && naxis)) {\n    // NAXIS is non-zero but there were no WCS keywords with an alternate\n    // version code; create a default WCS with blank alternate version.\n    wcspih_pass1(naxis, 0, 0, ' ', 0, alts, dpq, 0x0);\n    *nwcs = 1;\n  }",
                "filename": "cextern/wcslib/C/flexed/wcspih.c",
                "start_index": 1140347,
                "end_index": 1140783,
                "start_line": 396,
                "end_line": 26678,
                "max_line": 26682,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "{\n  int status = 0;\n\n  if (alts->arridx == 0x0) {\n    *nwcs = 0;\n    return 0;\n  }\n\n  // Determine the number of axes in each pixel list representation.\n  int ialt, mask, ncol = alts->ncol;\n  for (ialt = 0, mask = 1; ialt < 27; ialt++, mask <<= 1) {\n    alts->pixidx[ialt] = 0;\n\n    if (alts->pixlist[0] | mask) {\n      for (int icol = 1; icol <= ncol; icol++) {\n        if (alts->pixlist[icol] & mask) {\n          alts->pixidx[ialt]++;\n        }\n      }\n    }\n  }\n\n  // Find the total number of coordinate representations.\n  *nwcs = 0;\n  alts->imgherit = 0;\n  int inherit[27];\n  for (int ialt = 0; ialt < 27; ialt++) {\n    inherit[ialt] = 0;\n\n    for (int icol = 1; icol <= ncol; icol++) {\n      if (alts->arridx[icol][ialt] < 0) {\n        // No BIMGARR keytype but there's at least one BINTAB.\n        if (alts->arridx[0][ialt] > 0) {\n          // There is an IMGAXIS keytype that we will inherit, so count this\n          // representation.\n          alts->arridx[icol][ialt] = alts->arridx[0][ialt];\n        } else {\n          alts->arridx[icol][ialt] = 0;\n        }\n      }\n\n      if (alts->arridx[icol][ialt]) {\n        if (alts->arridx[0][ialt]) {\n          // All IMGHEAD keywords are inherited for this ialt.\n          inherit[ialt] = 1;\n\n          if (alts->arridx[icol][ialt] < alts->arridx[0][ialt]) {\n            // The extra axes are also inherited.\n            alts->arridx[icol][ialt] = alts->arridx[0][ialt];\n          }\n        }\n\n        (*nwcs)++;\n      }\n    }\n\n    // Count every \"a\" found in any IMGHEAD keyword...\n    if (alts->arridx[0][ialt]) {\n      if (inherit[ialt]) {\n        // ...but not if the IMGHEAD keywords will be inherited.\n        alts->arridx[0][ialt] = 0;\n        alts->imgherit = 1;\n      } else if (alts->arridx[0][ialt] > 0) {\n        (*nwcs)++;\n      }\n    }\n\n    // We need a struct for every \"a\" found in a PIXLIST keyword.\n    if (alts->pixidx[ialt]) {\n      (*nwcs)++;\n    }\n  }",
                "filename": "cextern/wcslib/C/flexed/wcsbth.c",
                "start_index": 1390744,
                "end_index": 1392671,
                "start_line": 396,
                "end_line": 32199,
                "max_line": 32203,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            },
            {
                "code": "def update_header(self):\n        old_naxis = self._header.get(\"NAXIS\", 0)\n\n        if self._data_loaded:\n            if isinstance(self.data, GroupData):\n                self._axes = list(self.data.data.shape)[1:]\n                self._axes.reverse()\n                self._axes = [0] + self._axes\n                field0 = self.data.dtype.names[0]\n                field0_code = self.data.dtype.fields[field0][0].name\n            elif self.data is None:\n                self._axes = [0]\n                field0_code = \"uint8\"  # For lack of a better default\n            else:\n                raise ValueError(\"incorrect array type\")\n\n            self._header[\"BITPIX\"] = DTYPE2BITPIX[field0_code]\n\n        self._header[\"NAXIS\"] = len(self._axes)\n\n        # add NAXISi if it does not exist\n        for idx, axis in enumerate(self._axes):\n            if idx == 0:\n                after = \"NAXIS\"\n            else:\n                after = \"NAXIS\" + str(idx)\n\n            self._header.set(\"NAXIS\" + str(idx + 1), axis, after=after)\n\n        # delete extra NAXISi's\n        for idx in range(len(self._axes) + 1, old_naxis + 1):\n            try:\n                del self._header[\"NAXIS\" + str(idx)]\n            except KeyError:\n                pass\n\n        if self._has_data and isinstance(self.data, GroupData):\n            self._header.set(\"GROUPS\", True, after=\"NAXIS\" + str(len(self._axes)))\n            self._header.set(\"PCOUNT\", len(self.data.parnames), after=\"GROUPS\")\n            self._header.set(\"GCOUNT\", len(self.data), after=\"PCOUNT\")\n\n            column = self.data._coldefs[self._data_field]\n            scale, zero = self.data._get_scale_factors(column)[3:5]\n            if scale:\n                self._header.set(\"BSCALE\", column.bscale)\n            if zero:\n                self._header.set(\"BZERO\", column.bzero)\n\n            for idx, name in enumerate(self.data.parnames):\n                self._header.set(\"PTYPE\" + str(idx + 1), name)\n                column = self.data._coldefs[idx]\n                scale, zero = self.data._get_scale_factors(column)[3:5]\n                if scale:\n                    self._header.set(\"PSCAL\" + str(idx + 1), column.bscale)\n                if zero:\n                    self._header.set(\"PZERO\" + str(idx + 1), column.bzero)\n\n        # Update the position of the EXTEND keyword if it already exists\n        if \"EXTEND\" in self._header:\n            if len(self._axes):\n                after = \"NAXIS\" + str(len(self._axes))\n            else:\n                after = \"NAXIS\"\n            self._header.set(\"EXTEND\", after=after)",
                "filename": "astropy/io/fits/hdu/groups.py",
                "start_index": 12864,
                "end_index": 15433,
                "start_line": 404,
                "end_line": 467,
                "max_line": 633,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__3.0",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "astropy/wcs/wcs.py": [
                {
                    "chunk": {
                        "code": "if header is None:\n            if naxis is None:\n                naxis = 2\n            wcsprm = _wcs.Wcsprm(header=None, key=key, relax=relax, naxis=naxis)\n            self.naxis = wcsprm.naxis\n            # Set some reasonable defaults.\n            det2im = (None, None)\n            cpdis = (None, None)\n            sip = None",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 14518,
                        "end_index": 14845,
                        "start_line": 442,
                        "end_line": 450,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet initializes the WCS object and sets the default number of axes, which is relevant to the issue of recording the original data size in the WCS object."
                }
            ],
            "cextern/wcslib/C/wcs.h": [
                {
                    "chunk": {
                        "code": "{\n  // Initialization flag (see the prologue above).\n  //--------------------------------------------------------------------------\n  int    flag;\t\t\t// Set to zero to force initialization.\n\n  // FITS header keyvalues to be provided (see the prologue above).\n  //--------------------------------------------------------------------------\n  int    naxis;\t\t\t// Number of axes (pixel and coordinate).\n  double *crpix;\t\t// CRPIXja keyvalues for each pixel axis.\n  double *pc;\t\t\t// PCi_ja  linear transformation matrix.\n  double *cdelt;\t\t// CDELTia keyvalues for each coord axis.\n  double *crval;\t\t// CRVALia keyvalues for each coord axis.\n\n  char   (*cunit)[72];\t\t// CUNITia keyvalues for each coord axis.\n  char   (*ctype)[72];\t\t// CTYPEia keyvalues for each coord axis.\n\n  double lonpole;\t\t// LONPOLEa keyvalue.\n  double latpole;\t\t// LATPOLEa keyvalue.\n\n  double restfrq;\t\t// RESTFRQa keyvalue.\n  double restwav;\t\t// RESTWAVa keyvalue.\n\n  int    npv;\t\t\t// Number of PVi_ma keywords, and the\n  int    npvmax;\t\t// number for which space was allocated.\n  struct pvcard *pv;\t\t// PVi_ma keywords for each i and m.\n\n  int    nps;\t\t\t// Number of PSi_ma keywords, and the\n  int    npsmax;\t\t// number for which space was allocated.\n  struct pscard *ps;\t\t// PSi_ma keywords for each i and m.\n\n  // Alternative header keyvalues (see the prologue above).\n  //--------------------------------------------------------------------------\n  double *cd;\t\t\t// CDi_ja linear transformation matrix.\n  double *crota;\t\t// CROTAi keyvalues for each coord axis.\n  int    altlin;\t\t// Alternative representations\n\t\t\t\t//   Bit 0: PCi_ja is present,\n\t\t\t\t//   Bit 1: CDi_ja is present,\n\t\t\t\t//   Bit 2: CROTAi is present.\n  int    velref;\t\t// AIPS velocity code, VELREF.\n\n  // Auxiliary coordinate system information of a general nature.  Not\n  // used by WCSLIB.  Refer to the prologue comments above for a brief\n  // explanation of these values.\n  char   alt[4];\n  int    colnum;\n  int    *colax;\n\t\t\t\t// Auxiliary coordinate axis information.\n  char   (*cname)[72];\n  double *crder;\n  double *csyer;\n  double *czphs;\n  double *cperi;\n\n  char   wcsname[72];\n\t\t\t\t// Time reference system and measurement.\n  char   timesys[72], trefpos[72], trefdir[72], plephem[72];\n  char   timeunit[72];\n  char   dateref[72];\n  double mjdref[2];\n  double timeoffs;\n\t\t\t\t// Data timestamps and durations.\n  char   dateobs[72], datebeg[72], dateavg[72], dateend[72];\n  double mjdobs, mjdbeg, mjdavg, mjdend;\n  double jepoch, bepoch;\n  double tstart, tstop;\n  double xposure, telapse;\n\t\t\t\t// Timing accuracy.\n  double timsyer, timrder;\n  double timedel, timepixr;\n\t\t\t\t// Spatial & celestial reference frame.\n  double obsgeo[6];\n  char   obsorbit[72];\n  char   radesys[72];\n  double equinox;\n  char   specsys[72];\n  char   ssysobs[72];\n  double velosys;\n  double zsource;\n  char   ssyssrc[72];\n  double velangl;\n\n  // Additional auxiliary coordinate system information of a specialist",
                        "filename": "cextern/wcslib/C/wcs.h",
                        "start_index": 88659,
                        "end_index": 91589,
                        "start_line": 478,
                        "end_line": 2166,
                        "max_line": 2292,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the structure of the WCS object, including the number of axes, which is directly related to the issue of recording the original data size."
                }
            ],
            "astropy/io/fits/hdu/groups.py": [
                {
                    "chunk": {
                        "code": "def update_header(self):\n        old_naxis = self._header.get(\"NAXIS\", 0)\n\n        if self._data_loaded:\n            if isinstance(self.data, GroupData):\n                self._axes = list(self.data.data.shape)[1:]\n                self._axes.reverse()\n                self._axes = [0] + self._axes\n                field0 = self.data.dtype.names[0]\n                field0_code = self.data.dtype.fields[field0][0].name\n            elif self.data is None:\n                self._axes = [0]\n                field0_code = \"uint8\"  # For lack of a better default\n            else:\n                raise ValueError(\"incorrect array type\")\n\n            self._header[\"BITPIX\"] = DTYPE2BITPIX[field0_code]\n\n        self._header[\"NAXIS\"] = len(self._axes)\n\n        # add NAXISi if it does not exist\n        for idx, axis in enumerate(self._axes):\n            if idx == 0:\n                after = \"NAXIS\"\n            else:\n                after = \"NAXIS\" + str(idx)\n\n            self._header.set(\"NAXIS\" + str(idx + 1), axis, after=after)\n\n        # delete extra NAXISi's\n        for idx in range(len(self._axes) + 1, old_naxis + 1):\n            try:\n                del self._header[\"NAXIS\" + str(idx)]\n            except KeyError:\n                pass\n\n        if self._has_data and isinstance(self.data, GroupData):\n            self._header.set(\"GROUPS\", True, after=\"NAXIS\" + str(len(self._axes)))\n            self._header.set(\"PCOUNT\", len(self.data.parnames), after=\"GROUPS\")\n            self._header.set(\"GCOUNT\", len(self.data), after=\"PCOUNT\")\n\n            column = self.data._coldefs[self._data_field]\n            scale, zero = self.data._get_scale_factors(column)[3:5]\n            if scale:\n                self._header.set(\"BSCALE\", column.bscale)\n            if zero:\n                self._header.set(\"BZERO\", column.bzero)\n\n            for idx, name in enumerate(self.data.parnames):\n                self._header.set(\"PTYPE\" + str(idx + 1), name)\n                column = self.data._coldefs[idx]\n                scale, zero = self.data._get_scale_factors(column)[3:5]\n                if scale:\n                    self._header.set(\"PSCAL\" + str(idx + 1), column.bscale)\n                if zero:\n                    self._header.set(\"PZERO\" + str(idx + 1), column.bzero)\n\n        # Update the position of the EXTEND keyword if it already exists\n        if \"EXTEND\" in self._header:\n            if len(self._axes):\n                after = \"NAXIS\" + str(len(self._axes))\n            else:\n                after = \"NAXIS\"\n            self._header.set(\"EXTEND\", after=after)",
                        "filename": "astropy/io/fits/hdu/groups.py",
                        "start_index": 12864,
                        "end_index": 15433,
                        "start_line": 404,
                        "end_line": 467,
                        "max_line": 633,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet deals with updating the FITS header, including the NAXIS values, which are related to the issue of recording the original data size in the WCS object."
                }
            ]
        },
        "solution_task": "To implement the feature of recording the original data size in the WCS object, you can choose between the two proposed methods. Here's a high-level overview of how to implement each option:\n\nOption 1: Add public `naxisj` attributes, populated by the FITS header `NAXISj` keywords.\n- Modify the `WCS` class to include public attributes for `naxisj` where `j` is the axis number.\n- In the `WCS` class constructor, read the `NAXISj` values from the FITS header and assign them to the corresponding `naxisj` attributes.\n- Ensure that these attributes are updated if the WCS object is modified to represent a different view of the data (e.g., after slicing).\n\nOption 2: Introduce a subclass of `WCS` which adds those attributes and leave the original WCS to represent strictly the FITS WCS standard and nothing more.\n- Create a new subclass of the `WCS` class, e.g., `ExtendedWCS`.\n- In the `ExtendedWCS` constructor, call the superclass constructor and then add additional logic to handle the `naxisj` attributes.\n- Ensure that the `naxisj` attributes are properly managed in any methods that might alter the WCS state.\n\nFor both options, you will need to:\n- Implement a deprecation process for the old way of accessing the data size through private attributes `_naxis1` and `_naxis2`.\n- Update the documentation to reflect the changes and guide users on how to use the new attributes.\n- Write unit tests to ensure that the new attributes behave as expected, including after any WCS transformations.\n\nHere is a pseudo-code example for Option 1:\n\n```python\nclass WCS:\n    def __init__(self, header=None, key=' ', relax=True, naxis=None):\n        # existing initialization code...\n        self.naxis = [None] * MAX_NAXIS  # MAX_NAXIS is the maximum number of axes supported\n        if header is not None:\n            for j in range(MAX_NAXIS):\n                naxis_key = f'NAXIS{j+1}'\n                if naxis_key in header:\n                    self.naxis[j] = header[naxis_key]\n        # more initialization code...\n\n    # other methods of WCS class...\n```\n\nFor Option 2:\n\n```python\nclass ExtendedWCS(WCS):\n    def __init__(self, header=None, key=' ', relax=True, naxis=None):\n        super().__init__(header, key, relax, naxis)\n        self.naxisj = [None] * MAX_NAXIS  # MAX_NAXIS is the maximum number of axes supported\n        if header is not None:\n            for j in range(MAX_NAXIS):\n                naxis_key = f'NAXIS{j+1}'\n                if naxis_key in header:\n                    self.naxisj[j] = header[naxis_key]\n        # additional initialization for ExtendedWCS...\n\n    # additional methods for ExtendedWCS...\n```\n\nRemember to replace `MAX_NAXIS` with the actual maximum number of axes supported by the WCS standard or the specific implementation.\n\nNote: The provided code snippets from the codebase are not directly relevant to the implementation of the new feature, but they provide context on how WCS objects are currently handled and how FITS headers are parsed. The actual implementation will depend on the existing structure of the WCS class and how it interacts with FITS headers.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed explanation of how to implement both proposed options for recording the original data size in the WCS object. It includes high-level steps, pseudo-code examples, and considerations for updating documentation and writing unit tests. The RESPONSE also addresses the need for a deprecation process for the old attributes. However, it does not directly address the prompt's request for votes or volunteering for the work, which is a significant aspect of the prompt's purpose. The RESPONSE also includes unnecessary details about code snippets from the codebase, which are not directly relevant to the implementation of the new feature but provide context. This information is not directly actionable but does not detract from the overall utility of the RESPONSE.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711737659.787644,
        "result": "To implement the feature of recording the original data size in the WCS object, you can choose between the two proposed methods. Here's a high-level overview of how to implement each option:\n\nOption 1: Add public `naxisj` attributes, populated by the FITS header `NAXISj` keywords.\n- Modify the `WCS` class to include public attributes for `naxisj` where `j` is the axis number.\n- In the `WCS` class constructor, read the `NAXISj` values from the FITS header and assign them to the corresponding `naxisj` attributes.\n- Ensure that these attributes are updated if the WCS object is modified to represent a different view of the data (e.g., after slicing).\n\nOption 2: Introduce a subclass of `WCS` which adds those attributes and leave the original WCS to represent strictly the FITS WCS standard and nothing more.\n- Create a new subclass of the `WCS` class, e.g., `ExtendedWCS`.\n- In the `ExtendedWCS` constructor, call the superclass constructor and then add additional logic to handle the `naxisj` attributes.\n- Ensure that the `naxisj` attributes are properly managed in any methods that might alter the WCS state.\n\nFor both options, you will need to:\n- Implement a deprecation process for the old way of accessing the data size through private attributes `_naxis1` and `_naxis2`.\n- Update the documentation to reflect the changes and guide users on how to use the new attributes.\n- Write unit tests to ensure that the new attributes behave as expected, including after any WCS transformations.\n\nHere is a pseudo-code example for Option 1:\n\n```python\nclass WCS:\n    def __init__(self, header=None, key=' ', relax=True, naxis=None):\n        # existing initialization code...\n        self.naxis = [None] * MAX_NAXIS  # MAX_NAXIS is the maximum number of axes supported\n        if header is not None:\n            for j in range(MAX_NAXIS):\n                naxis_key = f'NAXIS{j+1}'\n                if naxis_key in header:\n                    self.naxis[j] = header[naxis_key]\n        # more initialization code...\n\n    # other methods of WCS class...\n```\n\nFor Option 2:\n\n```python\nclass ExtendedWCS(WCS):\n    def __init__(self, header=None, key=' ', relax=True, naxis=None):\n        super().__init__(header, key, relax, naxis)\n        self.naxisj = [None] * MAX_NAXIS  # MAX_NAXIS is the maximum number of axes supported\n        if header is not None:\n            for j in range(MAX_NAXIS):\n                naxis_key = f'NAXIS{j+1}'\n                if naxis_key in header:\n                    self.naxisj[j] = header[naxis_key]\n        # additional initialization for ExtendedWCS...\n\n    # additional methods for ExtendedWCS...\n```\n\nRemember to replace `MAX_NAXIS` with the actual maximum number of axes supported by the WCS standard or the specific implementation.\n\nNote: The provided code snippets from the codebase are not directly relevant to the implementation of the new feature, but they provide context on how WCS objects are currently handled and how FITS headers are parsed. The actual implementation will depend on the existing structure of the WCS class and how it interacts with FITS headers.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__3.0/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/wcs)- [Lines 442 - 450](https://github.com/testbed/astropy__astropy__3.0/blob//astropy/wcs/wcs.py#L442-L450)\n\n This snippet initializes the WCS object and sets the default number of axes, which is relevant to the issue of recording the original data size in the WCS object.\n-  \u2192 [cextern](https://github.com/testbed/astropy__astropy__3.0/tree//cextern) \u2192 [wcslib](https://github.com/testbed/astropy__astropy__3.0/tree//cextern/wcslib) \u2192 [C](https://github.com/testbed/astropy__astropy__3.0/tree//cextern/wcslib/C)- [Lines 478 - 2166](https://github.com/testbed/astropy__astropy__3.0/blob//cextern/wcslib/C/wcs.h#L478-L2166)\n\n This snippet defines the structure of the WCS object, including the number of axes, which is directly related to the issue of recording the original data size.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__3.0/tree//astropy) \u2192 [io](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/io) \u2192 [fits](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/io/fits) \u2192 [hdu](https://github.com/testbed/astropy__astropy__3.0/tree//astropy/io/fits/hdu)- [Lines 404 - 467](https://github.com/testbed/astropy__astropy__3.0/blob//astropy/io/fits/hdu/groups.py#L404-L467)\n\n This snippet deals with updating the FITS header, including the NAXIS values, which are related to the issue of recording the original data size in the WCS object."
    }
}