{
    "id": "pytest-dev__pytest-11047",
    "repo_name": "testbed/pytest-dev__pytest__7.4",
    "task_id": 8269707181450340324,
    "title": "support sub-second granularity/precision in `--log-date-format` (strftime `%f`)",
    "body": "***tl;dr*** pytest processing strftime `%f` specifier from `--log-*-date-format` arguments would allow me to accurately merge log messages from disparate sub-systems\r\n\r\n### What's the problem?\r\n\r\nTests I run have pytest log messages that print at the second granularity for the datetimestamp, e.g. `2023-05-11T13:45:34`. At the same time, other log file messages not generated by pytest print sub-second datetimestamps, e.g. `2023-05-11T13:45:34.123`.\r\n\r\nWhen reviewing the various logs, there are many message from other system components that are printing many log messages per second. Because pytest log messages are lacking sub-second precision, I am unable to align pytest log messages within other system log messages.\r\n\r\n#### contrived example\r\n\r\nFor example, the system-under-test generates a log file like:\r\n```text\r\n2023-05-11T13:45:34.001 starting the frobulator\r\n2023-05-11T13:45:34.100 wiggling the waggulator\r\n2023-05-11T13:45:34.200 stopping the frobulator\r\n2023-05-11T13:45:34.301 starting the frobulator\r\n2023-05-11T13:45:34.400 poking the prokulator\r\n2023-05-11T13:45:34.450 prokulator response ERROR_NOT_ONLINE\r\n2023-05-11T13:45:34.500 stopping the frobulator\r\n2023-05-11T13:45:34.600 starting the frobulator\r\n2023-05-11T13:45:34.700 juggling some bowling pins\r\n2023-05-11T13:45:34.750 DROPPED A PIN!\r\n2023-05-11T13:45:34.800 stopping the frobulator\r\n2023-05-11T13:45:34.839 ERROR 0x0F009001 STOPPING THE frobulator\r\n```\r\nand the driver of tests, pytest, generates a log file like:\r\n```text\r\n2023-05-11T13:45:34 checking device\r\n2023-05-11T13:45:34 ping device\r\n2023-05-11T13:45:34 device error!\r\n```\r\n\r\nThe pytest log messages cannot be precisely ordered among the other log messages that occurred during the datetime second `2023-05-11T13:45:34`, there were many things that occurred in the other system components within that second.\r\n\r\n#### current confusion\r\n\r\nGiven the following pytest code\r\n\r\n```Python\r\nimport logging\r\nimport pytest\r\n\r\nlogging.basicConfig()\r\nlogger = logging.getLogger(__name__)\r\n\r\ndef test_logger():\r\n    logger.error(\"test_logger()ERROR\")\r\n    logger.warning(\"test_logger()WARNING\")\r\n```\r\n\r\nTo add sub-second granularity, it seems sensible to add `%f` within the `--log-cli-date-format`\r\n\r\n```text\r\n$ python -m pytest \\\r\n         -v -v \\\r\n         --log-cli-date-format=\"%Y%m%dT%H%M%S.%f\" \\\r\n         --capture=tee-sys \\\r\n         -k \"test_logger\"\r\n```\r\n\r\nbut then I see the confusing output of\r\n\r\n```text\r\n20230511T181007.%f: ERROR : [test_main.py:27 - test_logger()] : test_logger()ERROR\r\n20230511T181007.%f: WARNING : [test_main.py:28 - test_logger()] : test_logger()WARNING\r\n```\r\n\r\npytest logging is ignoring the strftime `%f` specifier!\r\n\r\n---\r\n\r\n### pytest feature request\r\n\r\nI want pytest log messages to print sub-second granularity, e.g. process strftime `%f` within `--log-date-format=\"...%f...\"` settings.\r\n\r\n#### Describe the solution you'd like\r\n<!-- A clear and concise description of what you want to happen. -->\r\n\r\nSupport strftime `%f` specifier in the various settings for _date-format_, e.g. `--log-date-format`, `--log-cli-date-format`, `--log-file-date-format`.\r\n\r\n<!-- Provide examples of real-world use cases that this would enable and how it solves the problem described above. -->\r\n\r\nIn my complex testing system, this means _all_ log messages would be printed to millisecond precision. This allows engineers investigating issues to more accurately merge disparate testing system logs by their natural ordering mechanism of a datetimestamp.\r\n\r\n---\r\n\r\n### Alternative Solutions\r\n\r\n<!-- Have you tried to workaround the problem using a pytest plugin or other tools? Or a different approach to solving this issue? Please elaborate here. -->\r\n\r\nI can set the `logging` format to include `%(msecs)03d`.\r\nHowever, it's a little confusing to have to manipulate log datetimestamps by two different mechanisms, `--log-cli-format` and `--log-cli-date-format`.\r\n\r\n#### example workaround\r\n\r\nOn the command-line run:\r\n```text\r\n$ python -m pytest \\\r\n         -v -v \\\r\n         --log-cli-date-format=\"%Y%m%dT%H%M%S.\" \\\r\n         --log-cli-format=\"%(asctime)s%(msecs)03d: %(levelname)s : [%(filename)s:%(lineno)s - %(funcName)s()] : %(message)s\" \\\r\n         --capture=tee-sys \\\r\n         -k \"test_logger\"\r\n```\r\nThis prints datetimestamps with millisecond precision\r\n```text\r\n20230511T180748.192: ERROR : [test_main.py:27 - test_logger()] : test_logger()ERROR\r\n20230511T180748.195: WARNING : [test_main.py:28 - test_logger()] : test_logger()WARNING\r\n```\r\n\r\n<br />\r\n\r\n### Summary\r\n\r\nIt is more intuitive for pytest to process the Python strftime `%f` specifier within all `--*-date-format` options.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pytest-dev__pytest__7.4.git",
    "requested_commit": "",
    "mayil_response": "To implement sub-second granularity in pytest's `--log-date-format`, you will need to modify the logging configuration to include the `%f` specifier, which represents microseconds in the datetime string. Here's a high-level overview of the steps to implement this feature:\n\n- Identify where the logging configuration is set up in the pytest codebase.\n- Modify the logging date format to include the `%f` specifier.\n- Ensure that the logging formatter used by pytest can handle the `%f` specifier correctly.\n- Add tests to verify that the log messages now include sub-second precision.\n- Update the documentation to reflect the new feature.\n\nHere's a pseudo-code example of how you might modify the logging configuration:\n\n```python\nimport logging\n\n# This function sets up the logging configuration.\n# You will need to locate a similar function in the pytest codebase.\ndef setup_logging():\n    # The format string should include `%f` to capture microseconds.\n    log_format = \"%(asctime)s.%(msecs)03d: %(levelname)s: %(message)s\"\n    date_format = \"%Y-%m-%dT%H:%M:%S\"  # Add `%f` here for microseconds\n\n    # Configure the root logger.\n    logging.basicConfig(level=logging.INFO, format=log_format, datefmt=date_format)\n\n    # Get the logger for pytest and configure it.\n    pytest_logger = logging.getLogger('pytest')\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(log_format, datefmt=date_format)\n    handler.setFormatter(formatter)\n    pytest_logger.addHandler(handler)\n    pytest_logger.propagate = False\n\n# Call the setup_logging function somewhere appropriate in the pytest initialization code.\nsetup_logging()\n```\n\nIn the actual implementation, you will need to locate where pytest configures its loggers and modify the date format there. You may also need to handle the parsing of the `--log-date-format` argument to include the `%f` specifier.\n\nRemember to add unit tests to ensure that the log messages are formatted with sub-second precision when the `%f` specifier is included in the `--log-date-format` argument.\n\nFor further research, you can look into Python's `logging` module documentation to understand how custom formatters and handlers work: https://docs.python.org/3/library/logging.html\n\nNote: The provided code snippets from the codebase do not seem to be directly relevant to the logging configuration of pytest, so you will need to find the appropriate place in the pytest codebase to make these changes.",
    "ai_cost": {
        "search_embedding": 2.6e-07,
        "issue_classifier": 0.005165,
        "snippet_processor": 0.039850000000000003,
        "issue_star_creation": 0.04342,
        "issue_star_solver": 0.04872,
        "bouncer": 0.11951000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711733587.0410502,
        "relevant_snippets": [
            {
                "code": "blank_issues_enabled: false\ncontact_links:\n  - name: \u2753 Support Question\n    url: https://github.com/pytest-dev/pytest/discussions\n    about: Use GitHub's new Discussions feature for questions",
                "filename": ".github/ISSUE_TEMPLATE/config.yml",
                "start_index": 0,
                "end_index": 191,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "rtd:\n  project: pytest",
                "filename": ".github/config.yml",
                "start_index": 0,
                "end_index": 22,
                "start_line": 1,
                "end_line": 2,
                "max_line": 2,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "import pytest\n\n\n@pytest.fixture(scope=\"module\", params=range(966))\ndef foo(request):\n    return request.param\n\n\ndef test_it(foo):\n    pass\n\n\ndef test_it2(foo):\n    pass",
                "filename": "bench/manyparam.py",
                "start_index": 0,
                "end_index": 168,
                "start_line": 1,
                "end_line": 14,
                "max_line": 14,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "import datetime\nimport pathlib\nimport re\nfrom textwrap import dedent\nfrom textwrap import indent\n\nimport packaging.version\nimport platformdirs\nimport tabulate\nimport wcwidth\nfrom requests_cache import CachedResponse\nfrom requests_cache import CachedSession\nfrom requests_cache import OriginalResponse\nfrom requests_cache import SQLiteCache\nfrom tqdm import tqdm\n\n\nFILE_HEAD = r\"\"\"\n.. Note this file is autogenerated by scripts/update-plugin-list.py - usually weekly via github action\n\n.. _plugin-list:\n\nPlugin List\n===========\n\nPyPI projects that match \"pytest-\\*\" are considered plugins and are listed\nautomatically together with a manually-maintained list in `the source\ncode <https://github.com/pytest-dev/pytest/blob/main/scripts/update-plugin-list.py>`_.\nPackages classified as inactive are excluded.\n\n.. The following conditional uses a different format for this list when\n   creating a PDF, because otherwise the table gets far too wide for the\n   page.\n\n\"\"\"\nDEVELOPMENT_STATUS_CLASSIFIERS = (\n    \"Development Status :: 1 - Planning\",\n    \"Development Status :: 2 - Pre-Alpha\",\n    \"Development Status :: 3 - Alpha\",\n    \"Development Status :: 4 - Beta\",\n    \"Development Status :: 5 - Production/Stable\",\n    \"Development Status :: 6 - Mature\",\n    \"Development Status :: 7 - Inactive\",\n)\nADDITIONAL_PROJECTS = {  # set of additional projects to consider as plugins\n    \"logassert\",\n    \"nuts\",\n}\n\n\ndef escape_rst(text: str) -> str:\n    \"\"\"Rudimentary attempt to escape special RST characters to appear as\n    plain text.\"\"\"\n    text = (\n        text.replace(\"*\", \"\\\\*\")\n        .replace(\"<\", \"\\\\<\")\n        .replace(\">\", \"\\\\>\")\n        .replace(\"`\", \"\\\\`\")\n    )\n    text = re.sub(r\"_\\b\", \"\", text)\n    return text\n\n\ndef project_response_with_refresh(\n    session: CachedSession, name: str, last_serial: int\n) -> OriginalResponse | CachedResponse:\n    \"\"\"Get a http cached pypi project\n\n    force refresh in case of last serial mismatch\n    \"\"\"\n\n    response = session.get(f\"https://pypi.org/pypi/{name}/json\")\n    if int(response.headers.get(\"X-PyPI-Last-Serial\", -1)) != last_serial:\n        response = session.get(f\"https://pypi.org/pypi/{name}/json\", refresh=True)\n    return response\n\n\ndef get_session() -> CachedSession:\n    \"\"\"Configures the requests-cache session\"\"\"\n    cache_path = platformdirs.user_cache_path(\"pytest-plugin-list\")\n    cache_path.mkdir(exist_ok=True, parents=True)\n    cache_file = cache_path.joinpath(\"http_cache.sqlite3\")\n    return CachedSession(backend=SQLiteCache(cache_file))\n\n\ndef pytest_plugin_projects_from_pypi(session: CachedSession) -> dict[str, int]:\n    response = session.get(\n        \"https://pypi.org/simple\",\n        headers={\"Accept\": \"application/vnd.pypi.simple.v1+json\"},\n        refresh=True,\n    )\n    return {\n        name: p[\"_last-serial\"]\n        for p in response.json()[\"projects\"]\n        if (name := p[\"name\"]).startswith(\"pytest-\") or name in ADDITIONAL_PROJECTS\n    }",
                "filename": "scripts/update-plugin-list.py",
                "start_index": 0,
                "end_index": 2939,
                "start_line": 1,
                "end_line": 155,
                "max_line": 195,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "# 10000 iterations, just for relative comparison\n#                      2.7.5     3.3.2\n# FilesCompleter       75.1109   69.2116\n# FastFilesCompleter    0.7383    1.0760\nimport timeit\n\nimports = [\n    \"from argcomplete.completers import FilesCompleter as completer\",\n    \"from _pytest._argcomplete import FastFilesCompleter as completer\",\n]\n\ncount = 1000  # only a few seconds\nsetup = \"%s\\nfc = completer()\"\nrun = 'fc(\"/d\")'\n\n\nif __name__ == \"__main__\":\n    print(timeit.timeit(run, setup=setup % imports[0], number=count))\n    print(timeit.timeit(run, setup=setup % imports[1], number=count))",
                "filename": "bench/bench_argcomplete.py",
                "start_index": 0,
                "end_index": 593,
                "start_line": 1,
                "end_line": 19,
                "max_line": 19,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "\"\"\"\nThis script is part of the pytest release process which is triggered manually in the Actions\ntab of the repository.\n\nThe user will need to enter the base branch to start the release from (for example\n``6.1.x`` or ``main``) and if it should be a major release.\n\nThe appropriate version will be obtained based on the given branch automatically.\n\nAfter that, it will create a release using the `release` tox environment, and push a new PR.\n\n**Token**: currently the token from the GitHub Actions is used, pushed with\n`pytest bot <pytestbot@gmail.com>` commit author.\n\"\"\"\nimport argparse\nimport re\nfrom pathlib import Path\nfrom subprocess import check_call\nfrom subprocess import check_output\nfrom subprocess import run\n\nfrom colorama import Fore\nfrom colorama import init\nfrom github3.repos import Repository\n\n\nclass InvalidFeatureRelease(Exception):\n    pass\n\n\nSLUG = \"pytest-dev/pytest\"\n\nPR_BODY = \"\"\"\\\nCreated automatically from manual trigger.\n\nOnce all builds pass and it has been **approved** by one or more maintainers, the build\ncan be released by pushing a tag `{version}` to this repository.\n\"\"\"\n\n\ndef login(token: str) -> Repository:\n    import github3\n\n    github = github3.login(token=token)\n    owner, repo = SLUG.split(\"/\")\n    return github.repository(owner, repo)",
                "filename": "scripts/prepare-release-pr.py",
                "start_index": 0,
                "end_index": 1281,
                "start_line": 1,
                "end_line": 46,
                "max_line": 174,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "import sys\n\nif __name__ == \"__main__\":\n    import cProfile\n    import pytest  # NOQA\n    import pstats\n\n    script = sys.argv[1:] if len(sys.argv) > 1 else [\"empty.py\"]\n    cProfile.run(\"pytest.cmdline.main(%r)\" % script, \"prof\")\n    p = pstats.Stats(\"prof\")\n    p.strip_dirs()\n    p.sort_stats(\"cumulative\")\n    print(p.print_stats(500))",
                "filename": "bench/bench.py",
                "start_index": 0,
                "end_index": 338,
                "start_line": 1,
                "end_line": 13,
                "max_line": 13,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "# info:\n# * https://help.github.com/en/articles/displaying-a-sponsor-button-in-your-repository\n# * https://tidelift.com/subscription/how-to-connect-tidelift-with-github\ntidelift: pypi/pytest\nopen_collective: pytest",
                "filename": ".github/FUNDING.yml",
                "start_index": 0,
                "end_index": 214,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "import pytest\n\nSKIP = True\n\n\n@pytest.mark.parametrize(\"x\", range(5000))\ndef test_foo(x):\n    if SKIP:\n        pytest.skip(\"heh\")",
                "filename": "bench/skip.py",
                "start_index": 0,
                "end_index": 128,
                "start_line": 1,
                "end_line": 9,
                "max_line": 9,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            },
            {
                "code": "import json\nfrom pathlib import Path\n\nimport requests\n\nissues_url = \"https://api.github.com/repos/pytest-dev/pytest/issues\"\n\n\ndef get_issues():\n    issues = []\n    url = issues_url\n    while 1:\n        get_data = {\"state\": \"all\"}\n        r = requests.get(url, params=get_data)\n        data = r.json()\n        if r.status_code == 403:\n            # API request limit exceeded\n            print(data[\"message\"])\n            exit(1)\n        issues.extend(data)\n\n        # Look for next page\n        links = requests.utils.parse_header_links(r.headers[\"Link\"])\n        another_page = False\n        for link in links:\n            if link[\"rel\"] == \"next\":\n                url = link[\"url\"]\n                another_page = True\n        if not another_page:\n            return issues\n\n\ndef main(args):\n    cachefile = Path(args.cache)\n    if not cachefile.exists() or args.refresh:\n        issues = get_issues()\n        cachefile.write_text(json.dumps(issues), \"utf-8\")\n    else:\n        issues = json.loads(cachefile.read_text(\"utf-8\"))\n\n    open_issues = [x for x in issues if x[\"state\"] == \"open\"]\n\n    open_issues.sort(key=lambda x: x[\"number\"])\n    report(open_issues)\n\n\ndef _get_kind(issue):\n    labels = [label[\"name\"] for label in issue[\"labels\"]]\n    for key in (\"bug\", \"enhancement\", \"proposal\"):\n        if key in labels:\n            return key\n    return \"issue\"\n\n\ndef report(issues):\n    for issue in issues:\n        title = issue[\"title\"]\n        # body = issue[\"body\"]\n        kind = _get_kind(issue)\n        status = issue[\"state\"]\n        number = issue[\"number\"]\n        link = \"https://github.com/pytest-dev/pytest/issues/%s/\" % number\n        print(\"----\")\n        print(status, kind, link)\n        print(title)\n        # print()\n        # lines = body.split(\"\\n\")\n        # print(\"\\n\".join(lines[:3]))\n        # if len(lines) > 3 or len(body) > 240:\n        #    print(\"...\")\n    print(\"\\n\\nFound %s open issues\" % len(issues))\n\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(\"process bitbucket issues\")\n    parser.add_argument(\n        \"--refresh\", action=\"store_true\", help=\"invalidate cache, refresh issues\"\n    )\n    parser.add_argument(\n        \"--cache\", action=\"store\", default=\"issues.json\", help=\"cache file\"\n    )\n    args = parser.parse_args()\n    main(args)",
                "filename": "extra/get_issues.py",
                "start_index": 0,
                "end_index": 2321,
                "start_line": 1,
                "end_line": 85,
                "max_line": 85,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.4",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {},
        "solution_task": "To implement sub-second granularity in pytest's `--log-date-format`, you will need to modify the logging configuration to include the `%f` specifier, which represents microseconds in the datetime string. Here's a high-level overview of the steps to implement this feature:\n\n- Identify where the logging configuration is set up in the pytest codebase.\n- Modify the logging date format to include the `%f` specifier.\n- Ensure that the logging formatter used by pytest can handle the `%f` specifier correctly.\n- Add tests to verify that the log messages now include sub-second precision.\n- Update the documentation to reflect the new feature.\n\nHere's a pseudo-code example of how you might modify the logging configuration:\n\n```python\nimport logging\n\n# This function sets up the logging configuration.\n# You will need to locate a similar function in the pytest codebase.\ndef setup_logging():\n    # The format string should include `%f` to capture microseconds.\n    log_format = \"%(asctime)s.%(msecs)03d: %(levelname)s: %(message)s\"\n    date_format = \"%Y-%m-%dT%H:%M:%S\"  # Add `%f` here for microseconds\n\n    # Configure the root logger.\n    logging.basicConfig(level=logging.INFO, format=log_format, datefmt=date_format)\n\n    # Get the logger for pytest and configure it.\n    pytest_logger = logging.getLogger('pytest')\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(log_format, datefmt=date_format)\n    handler.setFormatter(formatter)\n    pytest_logger.addHandler(handler)\n    pytest_logger.propagate = False\n\n# Call the setup_logging function somewhere appropriate in the pytest initialization code.\nsetup_logging()\n```\n\nIn the actual implementation, you will need to locate where pytest configures its loggers and modify the date format there. You may also need to handle the parsing of the `--log-date-format` argument to include the `%f` specifier.\n\nRemember to add unit tests to ensure that the log messages are formatted with sub-second precision when the `%f` specifier is included in the `--log-date-format` argument.\n\nFor further research, you can look into Python's `logging` module documentation to understand how custom formatters and handlers work: https://docs.python.org/3/library/logging.html\n\nNote: The provided code snippets from the codebase do not seem to be directly relevant to the logging configuration of pytest, so you will need to find the appropriate place in the pytest codebase to make these changes.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable step-by-step guide on how to implement sub-second granularity in pytest's `--log-date-format`. It correctly identifies the need to modify the logging configuration to include the `%f` specifier and suggests ensuring that the formatter can handle it. The RESPONSE also includes a pseudo-code example, which is helpful, and it advises on adding tests and updating documentation, which are important steps in the feature implementation process. However, the RESPONSE could have been more specific by addressing the unique context of pytest's codebase and the existing command-line arguments that the user is trying to modify. It does not directly address the `--log-date-format` argument parsing, which is a key part of the feature request. Additionally, the RESPONSE could have provided more detailed guidance on integrating the `%f` specifier within the existing pytest framework, rather than a general Python logging example.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711733636.666413,
        "result": "To implement sub-second granularity in pytest's `--log-date-format`, you will need to modify the logging configuration to include the `%f` specifier, which represents microseconds in the datetime string. Here's a high-level overview of the steps to implement this feature:\n\n- Identify where the logging configuration is set up in the pytest codebase.\n- Modify the logging date format to include the `%f` specifier.\n- Ensure that the logging formatter used by pytest can handle the `%f` specifier correctly.\n- Add tests to verify that the log messages now include sub-second precision.\n- Update the documentation to reflect the new feature.\n\nHere's a pseudo-code example of how you might modify the logging configuration:\n\n```python\nimport logging\n\n# This function sets up the logging configuration.\n# You will need to locate a similar function in the pytest codebase.\ndef setup_logging():\n    # The format string should include `%f` to capture microseconds.\n    log_format = \"%(asctime)s.%(msecs)03d: %(levelname)s: %(message)s\"\n    date_format = \"%Y-%m-%dT%H:%M:%S\"  # Add `%f` here for microseconds\n\n    # Configure the root logger.\n    logging.basicConfig(level=logging.INFO, format=log_format, datefmt=date_format)\n\n    # Get the logger for pytest and configure it.\n    pytest_logger = logging.getLogger('pytest')\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(log_format, datefmt=date_format)\n    handler.setFormatter(formatter)\n    pytest_logger.addHandler(handler)\n    pytest_logger.propagate = False\n\n# Call the setup_logging function somewhere appropriate in the pytest initialization code.\nsetup_logging()\n```\n\nIn the actual implementation, you will need to locate where pytest configures its loggers and modify the date format there. You may also need to handle the parsing of the `--log-date-format` argument to include the `%f` specifier.\n\nRemember to add unit tests to ensure that the log messages are formatted with sub-second precision when the `%f` specifier is included in the `--log-date-format` argument.\n\nFor further research, you can look into Python's `logging` module documentation to understand how custom formatters and handlers work: https://docs.python.org/3/library/logging.html\n\nNote: The provided code snippets from the codebase do not seem to be directly relevant to the logging configuration of pytest, so you will need to find the appropriate place in the pytest codebase to make these changes."
    }
}