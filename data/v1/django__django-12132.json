{
    "id": "django__django-12132",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 8524780734014031708,
    "title": "Add subdomains of localhost to ALLOWED_HOSTS in DEBUG mode",
    "body": "Description\n\t \n\t\t(last modified by thenewguy)\n\t \nIt would minimize configuration for new projects if ALLOWED_HOSTS += .localhost? when DEBUG=True\nChrome resolves *.localhost to localhost without modifying any host files or DNS\nReferencing the project this way makes it easy to test subdomains -> static.localhost, uploads.localhost, www.localhost, etc\n---\nUpdated\n---\nConversation on developer mailing list resulted in decision to reopen and accept ticket. The conversation turned up that this behavior is spec compliant per \u200bhttps://tools.ietf.org/html/rfc6761#section-6.3\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature of adding subdomains of localhost to `ALLOWED_HOSTS` when `DEBUG=True`, you can modify the `django/conf/global_settings.py` file to include a conditional check for the `DEBUG` setting and append `.localhost` to the `ALLOWED_HOSTS` list if `DEBUG` is `True`.\n\nHere's a high-level overview of the steps to implement this feature:\n\n- Locate the `ALLOWED_HOSTS` setting in the `django/conf/global_settings.py` file.\n- Check if the `DEBUG` setting is `True`.\n- If `DEBUG` is `True`, append `.localhost` to the `ALLOWED_HOSTS` list to allow all subdomains of localhost.\n\nHere's a code snippet that demonstrates how to implement this feature:\n\n```python\n# django/conf/global_settings.py\n\n# ... (other settings)\n\n# ALLOWED_HOSTS configuration\nALLOWED_HOSTS = []\n\n# Check if DEBUG is True and add subdomains of localhost to ALLOWED_HOSTS\nif DEBUG:\n    ALLOWED_HOSTS += ['.localhost', '127.0.0.1', '[::1]']\n\n# ... (other settings)\n```\n\nMake sure to place this code snippet in the appropriate location within the `global_settings.py` file, where the `ALLOWED_HOSTS` setting is defined or can be modified.\n\nRemember that this change will affect the global default settings for Django projects. If you want to make this change only for a specific project, you should instead modify the `ALLOWED_HOSTS` setting in the project's `settings.py` file, not in the global Django settings.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 243 - 311](https://github.com/testbed/django__django__3.1/blob//django/utils/http.py#L243-L311)\n\n This snippet contains the function 'url_has_allowed_host_and_scheme' which is likely where the logic for checking allowed hosts is implemented. Modifying this function to include subdomains of localhost when DEBUG=True would address the issue.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [conf](https://github.com/testbed/django__django__3.1/tree//django/conf)- [Lines 482 - 580](https://github.com/testbed/django__django__3.1/blob//django/conf/global_settings.py#L482-L580)\n\n This snippet contains the 'ALLOWED_HOSTS' setting in the global settings file. The issue specifically mentions modifying 'ALLOWED_HOSTS' to include subdomains of localhost in DEBUG mode, so this is a relevant location for the change.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00020449999999999998,
        "snippet_processor": 0.04630000000000001,
        "issue_star_creation": 0.022739999999999996,
        "issue_star_solver": 0.07763,
        "bouncer": 0.04344
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711731919.3316941,
        "relevant_snippets": [
            {
                "code": "# Languages using BiDi (right-to-left) layout\nLANGUAGES_BIDI = [\"he\", \"ar\", \"ar-dz\", \"ckb\", \"fa\", \"ur\"]\n\n# If you set this to False, Django will make some optimizations so as not\n# to load the internationalization machinery.\nUSE_I18N = True\nLOCALE_PATHS = []\n\n# Settings for language cookie\nLANGUAGE_COOKIE_NAME = \"django_language\"\nLANGUAGE_COOKIE_AGE = None\nLANGUAGE_COOKIE_DOMAIN = None\nLANGUAGE_COOKIE_PATH = \"/\"\nLANGUAGE_COOKIE_SECURE = False\nLANGUAGE_COOKIE_HTTPONLY = False\nLANGUAGE_COOKIE_SAMESITE = None\n\n# Not-necessarily-technical managers of the site. They get broken link\n# notifications and other various emails.\nMANAGERS = ADMINS\n\n# Default charset to use for all HttpResponse objects, if a MIME type isn't\n# manually specified. It's used to construct the Content-Type header.\nDEFAULT_CHARSET = \"utf-8\"\n\n# Email address that error messages come from.\nSERVER_EMAIL = \"root@localhost\"\n\n# Database connection info. If left empty, will default to the dummy backend.\nDATABASES = {}\n\n# Classes used to implement DB routing behavior.\nDATABASE_ROUTERS = []\n\n# The email backend to use. For possible shortcuts see django.core.mail.\n# The default is to use the SMTP backend.\n# Third-party backends can be specified by providing a Python path\n# to a module that defines an EmailBackend class.\nEMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n\n# Host for sending email.\nEMAIL_HOST = \"localhost\"\n\n# Port for sending email.\nEMAIL_PORT = 25\n\n# Whether to send SMTP 'Date' header in the local time zone or in UTC.\nEMAIL_USE_LOCALTIME = False\n\n# Optional SMTP authentication information for EMAIL_HOST.\nEMAIL_HOST_USER = \"\"\nEMAIL_HOST_PASSWORD = \"\"\nEMAIL_USE_TLS = False\nEMAIL_USE_SSL = False\nEMAIL_SSL_CERTFILE = None\nEMAIL_SSL_KEYFILE = None\nEMAIL_TIMEOUT = None\n\n# List of strings representing installed apps.\nINSTALLED_APPS = []\n\nTEMPLATES = []\n\n# Default form rendering class.\nFORM_RENDERER = \"django.forms.renderers.DjangoTemplates\"\n\n# Default email address to use for various automated correspondence from\n# the site managers.\nDEFAULT_FROM_EMAIL = \"webmaster@localhost\"\n\n# Subject-line prefix for email messages send with django.core.mail.mail_admins\n# or ...mail_managers.  Make sure to include the trailing space.\nEMAIL_SUBJECT_PREFIX = \"[Django] \"\n\n# Whether to append trailing slashes to URLs.\nAPPEND_SLASH = True\n\n# Whether to prepend the \"www.\" subdomain to URLs that don't have it.\nPREPEND_WWW = False\n\n# Override the server-derived value of SCRIPT_NAME\nFORCE_SCRIPT_NAME = None\n\n# List of compiled regular expression objects representing User-Agent strings\n# that are not allowed to visit any page, systemwide. Use this for bad\n# robots/crawlers. Here are a few examples:\n#     import re\n#     DISALLOWED_USER_AGENTS = [\n#         re.compile(r'^NaverBot.*'),\n#         re.compile(r'^EmailSiphon.*'),\n#         re.compile(r'^SiteSucker.*'),\n#         re.compile(r'^sohu-search'),\n#     ]\nDISALLOWED_USER_AGENTS = []\n\nABSOLUTE_URL_OVERRIDES = {}",
                "filename": "django/conf/global_settings.py",
                "start_index": 5498,
                "end_index": 8466,
                "start_line": 152,
                "end_line": 247,
                "max_line": 667,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "def url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=False):\n    \"\"\"\n    Return ``True`` if the url uses an allowed host and a safe scheme.\n\n    Always return ``False`` on an empty url.\n\n    If ``require_https`` is ``True``, only 'https' will be considered a valid\n    scheme, as opposed to 'http' and 'https' with the default, ``False``.\n\n    Note: \"True\" doesn't entail that a URL is \"safe\". It may still be e.g.\n    quoted incorrectly. Ensure to also use django.utils.encoding.iri_to_uri()\n    on the path component of untrusted URLs.\n    \"\"\"\n    if url is not None:\n        url = url.strip()\n    if not url:\n        return False\n    if allowed_hosts is None:\n        allowed_hosts = set()\n    elif isinstance(allowed_hosts, str):\n        allowed_hosts = {allowed_hosts}\n    # Chrome treats \\ completely as / in paths but it could be part of some\n    # basic auth credentials so we need to check both URLs.\n    return _url_has_allowed_host_and_scheme(\n        url, allowed_hosts, require_https=require_https\n    ) and _url_has_allowed_host_and_scheme(\n        url.replace(\"\\\\\", \"/\"), allowed_hosts, require_https=require_https\n    )\n\n\ndef _url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=False):\n    # Chrome considers any URL with more than two slashes to be absolute, but\n    # urlparse is not so flexible. Treat any url with three slashes as unsafe.\n    if url.startswith(\"///\"):\n        return False\n    try:\n        url_info = urlparse(url)\n    except ValueError:  # e.g. invalid IPv6 addresses\n        return False\n    # Forbid URLs like http:///example.com - with a scheme, but without a hostname.\n    # In that URL, example.com is not the hostname but, a path component. However,\n    # Chrome will still consider example.com to be the hostname, so we must not\n    # allow this syntax.\n    if not url_info.netloc and url_info.scheme:\n        return False\n    # Forbid URLs that start with control characters. Some browsers (like\n    # Chrome) ignore quite a few control characters at the start of a\n    # URL and might consider the URL as scheme relative.\n    if unicodedata.category(url[0])[0] == \"C\":\n        return False\n    scheme = url_info.scheme\n    # Consider URLs without a scheme (e.g. //example.com/p) to be http.\n    if not url_info.scheme and url_info.netloc:\n        scheme = \"http\"\n    valid_schemes = [\"https\"] if require_https else [\"http\", \"https\"]\n    return (not url_info.netloc or url_info.netloc in allowed_hosts) and (\n        not scheme or scheme in valid_schemes\n    )\n\n\ndef escape_leading_slashes(url):\n    \"\"\"\n    If redirecting to an absolute path (two leading slashes), a slash must be\n    escaped to prevent browsers from handling the path as schemaless and\n    redirecting to another host.\n    \"\"\"\n    if url.startswith(\"//\"):\n        url = \"/%2F{}\".format(url.removeprefix(\"//\"))\n    return url",
                "filename": "django/utils/http.py",
                "start_index": 7834,
                "end_index": 10705,
                "start_line": 243,
                "end_line": 311,
                "max_line": 375,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "import string\n\nfrom django.core.exceptions import ImproperlyConfigured, ValidationError\nfrom django.db import models\nfrom django.db.models.signals import pre_delete, pre_save\nfrom django.http.request import split_domain_port\nfrom django.utils.translation import gettext_lazy as _\n\nSITE_CACHE = {}\n\n\ndef _simple_domain_name_validator(value):\n    \"\"\"\n    Validate that the given value contains no whitespaces to prevent common\n    typos.\n    \"\"\"\n    checks = ((s in value) for s in string.whitespace)\n    if any(checks):\n        raise ValidationError(\n            _(\"The domain name cannot contain any spaces or tabs.\"),\n            code=\"invalid\",\n        )\n\n\nclass SiteManager(models.Manager):\n    use_in_migrations = True\n\n    def _get_site_by_id(self, site_id):\n        if site_id not in SITE_CACHE:\n            site = self.get(pk=site_id)\n            SITE_CACHE[site_id] = site\n        return SITE_CACHE[site_id]\n\n    def _get_site_by_request(self, request):\n        host = request.get_host()\n        try:\n            # First attempt to look up the site by host with or without port.\n            if host not in SITE_CACHE:\n                SITE_CACHE[host] = self.get(domain__iexact=host)\n            return SITE_CACHE[host]\n        except Site.DoesNotExist:\n            # Fallback to looking up site after stripping port from the host.\n            domain, port = split_domain_port(host)\n            if domain not in SITE_CACHE:\n                SITE_CACHE[domain] = self.get(domain__iexact=domain)\n            return SITE_CACHE[domain]\n\n    def get_current(self, request=None):\n        \"\"\"\n        Return the current Site based on the SITE_ID in the project's settings.\n        If SITE_ID isn't defined, return the site with domain matching\n        request.get_host(). The ``Site`` object is cached the first time it's\n        retrieved from the database.\n        \"\"\"\n        from django.conf import settings\n\n        if getattr(settings, \"SITE_ID\", \"\"):\n            site_id = settings.SITE_ID\n            return self._get_site_by_id(site_id)\n        elif request:\n            return self._get_site_by_request(request)\n\n        raise ImproperlyConfigured(\n            'You\\'re using the Django \"sites framework\" without having '\n            \"set the SITE_ID setting. Create a site in your database and \"\n            \"set the SITE_ID setting or pass a request to \"\n            \"Site.objects.get_current() to fix this error.\"\n        )\n\n    def clear_cache(self):\n        \"\"\"Clear the ``Site`` object cache.\"\"\"\n        global SITE_CACHE\n        SITE_CACHE = {}\n\n    def get_by_natural_key(self, domain):\n        return self.get(domain=domain)",
                "filename": "django/contrib/sites/models.py",
                "start_index": 0,
                "end_index": 2642,
                "start_line": 1,
                "end_line": 76,
                "max_line": 120,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "custom: https://www.djangoproject.com/fundraising/\ngithub: [django]",
                "filename": ".github/FUNDING.yml",
                "start_index": 0,
                "end_index": 67,
                "start_line": 1,
                "end_line": 2,
                "max_line": 2,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "# List of compiled regular expression objects representing URLs that need not\n# be reported by BrokenLinkEmailsMiddleware. Here are a few examples:\n#    import re\n#    IGNORABLE_404_URLS = [\n#        re.compile(r'^/apple-touch-icon.*\\.png$'),\n#        re.compile(r'^/favicon.ico$'),\n#        re.compile(r'^/robots.txt$'),\n#        re.compile(r'^/phpmyadmin/'),\n#        re.compile(r'\\.(cgi|php|pl)$'),\n#    ]\nIGNORABLE_404_URLS = []\n\n# A secret key for this particular Django installation. Used in secret-key\n# hashing algorithms. Set this in your settings, or Django will complain\n# loudly.\nSECRET_KEY = \"\"\n\n# List of secret keys used to verify the validity of signatures. This allows\n# secret key rotation.\nSECRET_KEY_FALLBACKS = []\n\n# Default file storage mechanism that holds media.\nDEFAULT_FILE_STORAGE = \"django.core.files.storage.FileSystemStorage\"\n\nSTORAGES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.files.storage.FileSystemStorage\",\n    },\n    \"staticfiles\": {\n        \"BACKEND\": \"django.contrib.staticfiles.storage.StaticFilesStorage\",\n    },\n}\n\n# Absolute filesystem path to the directory that will hold user-uploaded files.\n# Example: \"/var/www/example.com/media/\"\nMEDIA_ROOT = \"\"\n\n# URL that handles the media served from MEDIA_ROOT.\n# Examples: \"http://example.com/media/\", \"http://media.example.com/\"\nMEDIA_URL = \"\"\n\n# Absolute path to the directory static files should be collected to.\n# Example: \"/var/www/example.com/static/\"\nSTATIC_ROOT = None\n\n# URL that handles the static files served from STATIC_ROOT.\n# Example: \"http://example.com/static/\", \"http://static.example.com/\"\nSTATIC_URL = None\n\n# List of upload handler classes to be applied in order.\nFILE_UPLOAD_HANDLERS = [\n    \"django.core.files.uploadhandler.MemoryFileUploadHandler\",\n    \"django.core.files.uploadhandler.TemporaryFileUploadHandler\",\n]\n\n# Maximum size, in bytes, of a request before it will be streamed to the\n# file system instead of into memory.\nFILE_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB\n\n# Maximum size in bytes of request data (excluding file uploads) that will be\n# read before a SuspiciousOperation (RequestDataTooBig) is raised.\nDATA_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB\n\n# Maximum number of GET/POST parameters that will be read before a\n# SuspiciousOperation (TooManyFieldsSent) is raised.\nDATA_UPLOAD_MAX_NUMBER_FIELDS = 1000\n\n# Maximum number of files encoded in a multipart upload that will be read\n# before a SuspiciousOperation (TooManyFilesSent) is raised.\nDATA_UPLOAD_MAX_NUMBER_FILES = 100\n\n# Directory in which upload streamed files will be temporarily saved. A value of\n# `None` will make Django use the operating system's default temporary directory\n# (i.e. \"/tmp\" on *nix systems).\nFILE_UPLOAD_TEMP_DIR = None\n\n# The numeric mode to set newly-uploaded files to. The value should be a mode\n# you'd pass directly to os.chmod; see\n# https://docs.python.org/library/os.html#files-and-directories.\nFILE_UPLOAD_PERMISSIONS = 0o644",
                "filename": "django/conf/global_settings.py",
                "start_index": 8468,
                "end_index": 11437,
                "start_line": 249,
                "end_line": 328,
                "max_line": 667,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "import errno\nimport os\nimport re\nimport socket\nimport sys\nfrom datetime import datetime\n\nfrom django.conf import settings\nfrom django.core.management.base import BaseCommand, CommandError\nfrom django.core.servers.basehttp import WSGIServer, get_internal_wsgi_application, run\nfrom django.utils import autoreload\nfrom django.utils.regex_helper import _lazy_re_compile\n\nnaiveip_re = _lazy_re_compile(\n    r\"\"\"^(?:\n(?P<addr>\n    (?P<ipv4>\\d{1,3}(?:\\.\\d{1,3}){3}) |         # IPv4 address\n    (?P<ipv6>\\[[a-fA-F0-9:]+\\]) |               # IPv6 address\n    (?P<fqdn>[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*) # FQDN\n):)?(?P<port>\\d+)$\"\"\",\n    re.X,\n)",
                "filename": "django/core/management/commands/runserver.py",
                "start_index": 0,
                "end_index": 637,
                "start_line": 1,
                "end_line": 186,
                "max_line": 186,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "def _origin_verified(self, request):\n        request_origin = request.META[\"HTTP_ORIGIN\"]\n        try:\n            good_host = request.get_host()\n        except DisallowedHost:\n            pass\n        else:\n            good_origin = \"%s://%s\" % (\n                \"https\" if request.is_secure() else \"http\",\n                good_host,\n            )\n            if request_origin == good_origin:\n                return True\n        if request_origin in self.allowed_origins_exact:\n            return True\n        try:\n            parsed_origin = urlparse(request_origin)\n        except ValueError:\n            return False\n        request_scheme = parsed_origin.scheme\n        request_netloc = parsed_origin.netloc\n        return any(\n            is_same_domain(request_netloc, host)\n            for host in self.allowed_origin_subdomains.get(request_scheme, ())\n        )\n\n    def _check_referer(self, request):\n        referer = request.META.get(\"HTTP_REFERER\")\n        if referer is None:\n            raise RejectRequest(REASON_NO_REFERER)\n\n        try:\n            referer = urlparse(referer)\n        except ValueError:\n            raise RejectRequest(REASON_MALFORMED_REFERER)\n\n        # Make sure we have a valid URL for Referer.\n        if \"\" in (referer.scheme, referer.netloc):\n            raise RejectRequest(REASON_MALFORMED_REFERER)\n\n        # Ensure that our Referer is also secure.\n        if referer.scheme != \"https\":\n            raise RejectRequest(REASON_INSECURE_REFERER)\n\n        if any(\n            is_same_domain(referer.netloc, host)\n            for host in self.csrf_trusted_origins_hosts\n        ):\n            return\n        # Allow matching the configured cookie domain.\n        good_referer = (\n            settings.SESSION_COOKIE_DOMAIN\n            if settings.CSRF_USE_SESSIONS\n            else settings.CSRF_COOKIE_DOMAIN\n        )\n        if good_referer is None:\n            # If no cookie domain is configured, allow matching the current\n            # host:port exactly if it's permitted by ALLOWED_HOSTS.\n            try:\n                # request.get_host() includes the port.\n                good_referer = request.get_host()\n            except DisallowedHost:\n                raise RejectRequest(REASON_BAD_REFERER % referer.geturl())\n        else:\n            server_port = request.get_port()\n            if server_port not in (\"443\", \"80\"):\n                good_referer = \"%s:%s\" % (good_referer, server_port)\n\n        if not is_same_domain(referer.netloc, good_referer):\n            raise RejectRequest(REASON_BAD_REFERER % referer.geturl())\n\n    def _bad_token_message(self, reason, token_source):\n        if token_source != \"POST\":\n            # Assume it is a settings.CSRF_HEADER_NAME value.\n            header_name = HttpHeaders.parse_header_name(token_source)\n            token_source = f\"the {header_name!r} HTTP header\"\n        return f\"CSRF token from {token_source} {reason}.\"",
                "filename": "django/middleware/csrf.py",
                "start_index": 10130,
                "end_index": 13056,
                "start_line": 270,
                "end_line": 346,
                "max_line": 482,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from inspect import getattr_static, unwrap\n\nfrom django.contrib.sites.shortcuts import get_current_site\nfrom django.core.exceptions import ImproperlyConfigured, ObjectDoesNotExist\nfrom django.http import Http404, HttpResponse\nfrom django.template import TemplateDoesNotExist, loader\nfrom django.utils import feedgenerator\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.html import escape\nfrom django.utils.http import http_date\nfrom django.utils.timezone import get_default_timezone, is_naive, make_aware\nfrom django.utils.translation import get_language\n\n\ndef add_domain(domain, url, secure=False):\n    protocol = \"https\" if secure else \"http\"\n    if url.startswith(\"//\"):\n        # Support network-path reference (see #16753) - RSS requires a protocol\n        url = \"%s:%s\" % (protocol, url)\n    elif not url.startswith((\"http://\", \"https://\", \"mailto:\")):\n        url = iri_to_uri(\"%s://%s%s\" % (protocol, domain, url))\n    return url\n\n\nclass FeedDoesNotExist(ObjectDoesNotExist):\n    pass",
                "filename": "django/contrib/syndication/views.py",
                "start_index": 0,
                "end_index": 1008,
                "start_line": 1,
                "end_line": 178,
                "max_line": 234,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "from urllib.parse import parse_qsl, unquote, urlparse, urlunparse\n\nfrom django import template\nfrom django.contrib.admin.utils import quote\nfrom django.urls import Resolver404, get_script_prefix, resolve\nfrom django.utils.http import urlencode\n\nregister = template.Library()\n\n\n@register.filter\ndef admin_urlname(value, arg):\n    return \"admin:%s_%s_%s\" % (value.app_label, value.model_name, arg)\n\n\n@register.filter\ndef admin_urlquote(value):\n    return quote(value)\n\n\n@register.simple_tag(takes_context=True)\ndef add_preserved_filters(context, url, popup=False, to_field=None):\n    opts = context.get(\"opts\")\n    preserved_filters = context.get(\"preserved_filters\")\n\n    parsed_url = list(urlparse(url))\n    parsed_qs = dict(parse_qsl(parsed_url[4]))\n    merged_qs = {}\n\n    if opts and preserved_filters:\n        preserved_filters = dict(parse_qsl(preserved_filters))\n\n        match_url = \"/%s\" % unquote(url).partition(get_script_prefix())[2]\n        try:\n            match = resolve(match_url)\n        except Resolver404:\n            pass\n        else:\n            current_url = \"%s:%s\" % (match.app_name, match.url_name)\n            changelist_url = \"admin:%s_%s_changelist\" % (\n                opts.app_label,\n                opts.model_name,\n            )\n            if (\n                changelist_url == current_url\n                and \"_changelist_filters\" in preserved_filters\n            ):\n                preserved_filters = dict(\n                    parse_qsl(preserved_filters[\"_changelist_filters\"])\n                )\n\n        merged_qs.update(preserved_filters)\n\n    if popup:\n        from django.contrib.admin.options import IS_POPUP_VAR\n\n        merged_qs[IS_POPUP_VAR] = 1\n    if to_field:\n        from django.contrib.admin.options import TO_FIELD_VAR\n\n        merged_qs[TO_FIELD_VAR] = to_field\n\n    merged_qs.update(parsed_qs)\n\n    parsed_url[4] = urlencode(merged_qs)\n    return urlunparse(parsed_url)",
                "filename": "django/contrib/admin/templatetags/admin_urls.py",
                "start_index": 0,
                "end_index": 1925,
                "start_line": 1,
                "end_line": 66,
                "max_line": 66,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            },
            {
                "code": "# A string like \"example.com\", or None for standard domain cookie.\nSESSION_COOKIE_DOMAIN = None\n# Whether the session cookie should be secure (https:// only).\nSESSION_COOKIE_SECURE = False\n# The path of the session cookie.\nSESSION_COOKIE_PATH = \"/\"\n# Whether to use the HttpOnly flag.\nSESSION_COOKIE_HTTPONLY = True\n# Whether to set the flag restricting cookie leaks on cross-site requests.\n# This can be 'Lax', 'Strict', 'None', or False to disable the flag.\nSESSION_COOKIE_SAMESITE = \"Lax\"\n# Whether to save the session data on every request.\nSESSION_SAVE_EVERY_REQUEST = False\n# Whether a user's session cookie expires when the web browser is closed.\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False\n# The module to store session data\nSESSION_ENGINE = \"django.contrib.sessions.backends.db\"\n# Directory to store session files if using the file session module. If None,\n# the backend will use a sensible default.\nSESSION_FILE_PATH = None\n# class to serialize session data\nSESSION_SERIALIZER = \"django.contrib.sessions.serializers.JSONSerializer\"\n\n#########\n# CACHE #\n#########\n\n# The cache backends to use.\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.cache.backends.locmem.LocMemCache\",\n    }\n}\nCACHE_MIDDLEWARE_KEY_PREFIX = \"\"\nCACHE_MIDDLEWARE_SECONDS = 600\nCACHE_MIDDLEWARE_ALIAS = \"default\"\n\n##################\n# AUTHENTICATION #\n##################\n\nAUTH_USER_MODEL = \"auth.User\"\n\nAUTHENTICATION_BACKENDS = [\"django.contrib.auth.backends.ModelBackend\"]\n\nLOGIN_URL = \"/accounts/login/\"\n\nLOGIN_REDIRECT_URL = \"/accounts/profile/\"\n\nLOGOUT_REDIRECT_URL = None\n\n# The number of seconds a password reset link is valid for (default: 3 days).\nPASSWORD_RESET_TIMEOUT = 60 * 60 * 24 * 3\n\n# the first hasher in this list is the preferred algorithm.  any\n# password using different algorithms will be converted automatically\n# upon login\nPASSWORD_HASHERS = [\n    \"django.contrib.auth.hashers.PBKDF2PasswordHasher\",\n    \"django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher\",\n    \"django.contrib.auth.hashers.Argon2PasswordHasher\",\n    \"django.contrib.auth.hashers.BCryptSHA256PasswordHasher\",\n    \"django.contrib.auth.hashers.ScryptPasswordHasher\",\n]\n\nAUTH_PASSWORD_VALIDATORS = []\n\n###########\n# SIGNING #\n###########\n\nSIGNING_BACKEND = \"django.core.signing.TimestampSigner\"\n\n########\n# CSRF #\n########\n\n# Dotted path to callable to be used as view when a request is\n# rejected by the CSRF middleware.\nCSRF_FAILURE_VIEW = \"django.views.csrf.csrf_failure\"\n\n# Settings for CSRF cookie.\nCSRF_COOKIE_NAME = \"csrftoken\"\nCSRF_COOKIE_AGE = 60 * 60 * 24 * 7 * 52\nCSRF_COOKIE_DOMAIN = None\nCSRF_COOKIE_PATH = \"/\"\nCSRF_COOKIE_SECURE = False\nCSRF_COOKIE_HTTPONLY = False\nCSRF_COOKIE_SAMESITE = \"Lax\"\nCSRF_HEADER_NAME = \"HTTP_X_CSRFTOKEN\"\nCSRF_TRUSTED_ORIGINS = []\nCSRF_USE_SESSIONS = False\n\n############\n# MESSAGES #\n############\n\n# Class to use as messages backend\nMESSAGE_STORAGE = \"django.contrib.messages.storage.fallback.FallbackStorage\"",
                "filename": "django/conf/global_settings.py",
                "start_index": 17386,
                "end_index": 20317,
                "start_line": 482,
                "end_line": 580,
                "max_line": 667,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/utils/http.py": [
                {
                    "chunk": {
                        "code": "def url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=False):\n    \"\"\"\n    Return ``True`` if the url uses an allowed host and a safe scheme.\n\n    Always return ``False`` on an empty url.\n\n    If ``require_https`` is ``True``, only 'https' will be considered a valid\n    scheme, as opposed to 'http' and 'https' with the default, ``False``.\n\n    Note: \"True\" doesn't entail that a URL is \"safe\". It may still be e.g.\n    quoted incorrectly. Ensure to also use django.utils.encoding.iri_to_uri()\n    on the path component of untrusted URLs.\n    \"\"\"\n    if url is not None:\n        url = url.strip()\n    if not url:\n        return False\n    if allowed_hosts is None:\n        allowed_hosts = set()\n    elif isinstance(allowed_hosts, str):\n        allowed_hosts = {allowed_hosts}\n    # Chrome treats \\ completely as / in paths but it could be part of some\n    # basic auth credentials so we need to check both URLs.\n    return _url_has_allowed_host_and_scheme(\n        url, allowed_hosts, require_https=require_https\n    ) and _url_has_allowed_host_and_scheme(\n        url.replace(\"\\\\\", \"/\"), allowed_hosts, require_https=require_https\n    )\n\n\ndef _url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=False):\n    # Chrome considers any URL with more than two slashes to be absolute, but\n    # urlparse is not so flexible. Treat any url with three slashes as unsafe.\n    if url.startswith(\"///\"):\n        return False\n    try:\n        url_info = urlparse(url)\n    except ValueError:  # e.g. invalid IPv6 addresses\n        return False\n    # Forbid URLs like http:///example.com - with a scheme, but without a hostname.\n    # In that URL, example.com is not the hostname but, a path component. However,\n    # Chrome will still consider example.com to be the hostname, so we must not\n    # allow this syntax.\n    if not url_info.netloc and url_info.scheme:\n        return False\n    # Forbid URLs that start with control characters. Some browsers (like\n    # Chrome) ignore quite a few control characters at the start of a\n    # URL and might consider the URL as scheme relative.\n    if unicodedata.category(url[0])[0] == \"C\":\n        return False\n    scheme = url_info.scheme\n    # Consider URLs without a scheme (e.g. //example.com/p) to be http.\n    if not url_info.scheme and url_info.netloc:\n        scheme = \"http\"\n    valid_schemes = [\"https\"] if require_https else [\"http\", \"https\"]\n    return (not url_info.netloc or url_info.netloc in allowed_hosts) and (\n        not scheme or scheme in valid_schemes\n    )\n\n\ndef escape_leading_slashes(url):\n    \"\"\"\n    If redirecting to an absolute path (two leading slashes), a slash must be\n    escaped to prevent browsers from handling the path as schemaless and\n    redirecting to another host.\n    \"\"\"\n    if url.startswith(\"//\"):\n        url = \"/%2F{}\".format(url.removeprefix(\"//\"))\n    return url",
                        "filename": "django/utils/http.py",
                        "start_index": 7834,
                        "end_index": 10705,
                        "start_line": 243,
                        "end_line": 311,
                        "max_line": 375,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the function 'url_has_allowed_host_and_scheme' which is likely where the logic for checking allowed hosts is implemented. Modifying this function to include subdomains of localhost when DEBUG=True would address the issue."
                }
            ],
            "django/conf/global_settings.py": [
                {
                    "chunk": {
                        "code": "# A string like \"example.com\", or None for standard domain cookie.\nSESSION_COOKIE_DOMAIN = None\n# Whether the session cookie should be secure (https:// only).\nSESSION_COOKIE_SECURE = False\n# The path of the session cookie.\nSESSION_COOKIE_PATH = \"/\"\n# Whether to use the HttpOnly flag.\nSESSION_COOKIE_HTTPONLY = True\n# Whether to set the flag restricting cookie leaks on cross-site requests.\n# This can be 'Lax', 'Strict', 'None', or False to disable the flag.\nSESSION_COOKIE_SAMESITE = \"Lax\"\n# Whether to save the session data on every request.\nSESSION_SAVE_EVERY_REQUEST = False\n# Whether a user's session cookie expires when the web browser is closed.\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False\n# The module to store session data\nSESSION_ENGINE = \"django.contrib.sessions.backends.db\"\n# Directory to store session files if using the file session module. If None,\n# the backend will use a sensible default.\nSESSION_FILE_PATH = None\n# class to serialize session data\nSESSION_SERIALIZER = \"django.contrib.sessions.serializers.JSONSerializer\"\n\n#########\n# CACHE #\n#########\n\n# The cache backends to use.\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.cache.backends.locmem.LocMemCache\",\n    }\n}\nCACHE_MIDDLEWARE_KEY_PREFIX = \"\"\nCACHE_MIDDLEWARE_SECONDS = 600\nCACHE_MIDDLEWARE_ALIAS = \"default\"\n\n##################\n# AUTHENTICATION #\n##################\n\nAUTH_USER_MODEL = \"auth.User\"\n\nAUTHENTICATION_BACKENDS = [\"django.contrib.auth.backends.ModelBackend\"]\n\nLOGIN_URL = \"/accounts/login/\"\n\nLOGIN_REDIRECT_URL = \"/accounts/profile/\"\n\nLOGOUT_REDIRECT_URL = None\n\n# The number of seconds a password reset link is valid for (default: 3 days).\nPASSWORD_RESET_TIMEOUT = 60 * 60 * 24 * 3\n\n# the first hasher in this list is the preferred algorithm.  any\n# password using different algorithms will be converted automatically\n# upon login\nPASSWORD_HASHERS = [\n    \"django.contrib.auth.hashers.PBKDF2PasswordHasher\",\n    \"django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher\",\n    \"django.contrib.auth.hashers.Argon2PasswordHasher\",\n    \"django.contrib.auth.hashers.BCryptSHA256PasswordHasher\",\n    \"django.contrib.auth.hashers.ScryptPasswordHasher\",\n]\n\nAUTH_PASSWORD_VALIDATORS = []\n\n###########\n# SIGNING #\n###########\n\nSIGNING_BACKEND = \"django.core.signing.TimestampSigner\"\n\n########\n# CSRF #\n########\n\n# Dotted path to callable to be used as view when a request is\n# rejected by the CSRF middleware.\nCSRF_FAILURE_VIEW = \"django.views.csrf.csrf_failure\"\n\n# Settings for CSRF cookie.\nCSRF_COOKIE_NAME = \"csrftoken\"\nCSRF_COOKIE_AGE = 60 * 60 * 24 * 7 * 52\nCSRF_COOKIE_DOMAIN = None\nCSRF_COOKIE_PATH = \"/\"\nCSRF_COOKIE_SECURE = False\nCSRF_COOKIE_HTTPONLY = False\nCSRF_COOKIE_SAMESITE = \"Lax\"\nCSRF_HEADER_NAME = \"HTTP_X_CSRFTOKEN\"\nCSRF_TRUSTED_ORIGINS = []\nCSRF_USE_SESSIONS = False\n\n############\n# MESSAGES #\n############\n\n# Class to use as messages backend\nMESSAGE_STORAGE = \"django.contrib.messages.storage.fallback.FallbackStorage\"",
                        "filename": "django/conf/global_settings.py",
                        "start_index": 17386,
                        "end_index": 20317,
                        "start_line": 482,
                        "end_line": 580,
                        "max_line": 667,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'ALLOWED_HOSTS' setting in the global settings file. The issue specifically mentions modifying 'ALLOWED_HOSTS' to include subdomains of localhost in DEBUG mode, so this is a relevant location for the change."
                }
            ]
        },
        "solution_task": "To implement the feature of adding subdomains of localhost to `ALLOWED_HOSTS` when `DEBUG=True`, you can modify the `django/conf/global_settings.py` file to include a conditional check for the `DEBUG` setting and append `.localhost` to the `ALLOWED_HOSTS` list if `DEBUG` is `True`.\n\nHere's a high-level overview of the steps to implement this feature:\n\n- Locate the `ALLOWED_HOSTS` setting in the `django/conf/global_settings.py` file.\n- Check if the `DEBUG` setting is `True`.\n- If `DEBUG` is `True`, append `.localhost` to the `ALLOWED_HOSTS` list to allow all subdomains of localhost.\n\nHere's a code snippet that demonstrates how to implement this feature:\n\n```python\n# django/conf/global_settings.py\n\n# ... (other settings)\n\n# ALLOWED_HOSTS configuration\nALLOWED_HOSTS = []\n\n# Check if DEBUG is True and add subdomains of localhost to ALLOWED_HOSTS\nif DEBUG:\n    ALLOWED_HOSTS += ['.localhost', '127.0.0.1', '[::1]']\n\n# ... (other settings)\n```\n\nMake sure to place this code snippet in the appropriate location within the `global_settings.py` file, where the `ALLOWED_HOSTS` setting is defined or can be modified.\n\nRemember that this change will affect the global default settings for Django projects. If you want to make this change only for a specific project, you should instead modify the `ALLOWED_HOSTS` setting in the project's `settings.py` file, not in the global Django settings.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the feature request of adding subdomains of localhost to `ALLOWED_HOSTS` when `DEBUG=True`. It offers a step-by-step guide on how to implement the feature by modifying the `django/conf/global_settings.py` file and includes a code snippet demonstrating the necessary changes. Additionally, the RESPONSE provides links to relevant code snippets in the Django repository that could be useful for further understanding and implementing the feature. However, the RESPONSE could have been more comprehensive by discussing potential implications of this change on existing projects or providing alternative solutions if modifying the global settings is not desirable. It also does not address the RFC compliance mentioned in the PROMPT, which could be relevant for justifying the change.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711731994.113176,
        "result": "To implement the feature of adding subdomains of localhost to `ALLOWED_HOSTS` when `DEBUG=True`, you can modify the `django/conf/global_settings.py` file to include a conditional check for the `DEBUG` setting and append `.localhost` to the `ALLOWED_HOSTS` list if `DEBUG` is `True`.\n\nHere's a high-level overview of the steps to implement this feature:\n\n- Locate the `ALLOWED_HOSTS` setting in the `django/conf/global_settings.py` file.\n- Check if the `DEBUG` setting is `True`.\n- If `DEBUG` is `True`, append `.localhost` to the `ALLOWED_HOSTS` list to allow all subdomains of localhost.\n\nHere's a code snippet that demonstrates how to implement this feature:\n\n```python\n# django/conf/global_settings.py\n\n# ... (other settings)\n\n# ALLOWED_HOSTS configuration\nALLOWED_HOSTS = []\n\n# Check if DEBUG is True and add subdomains of localhost to ALLOWED_HOSTS\nif DEBUG:\n    ALLOWED_HOSTS += ['.localhost', '127.0.0.1', '[::1]']\n\n# ... (other settings)\n```\n\nMake sure to place this code snippet in the appropriate location within the `global_settings.py` file, where the `ALLOWED_HOSTS` setting is defined or can be modified.\n\nRemember that this change will affect the global default settings for Django projects. If you want to make this change only for a specific project, you should instead modify the `ALLOWED_HOSTS` setting in the project's `settings.py` file, not in the global Django settings.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 243 - 311](https://github.com/testbed/django__django__3.1/blob//django/utils/http.py#L243-L311)\n\n This snippet contains the function 'url_has_allowed_host_and_scheme' which is likely where the logic for checking allowed hosts is implemented. Modifying this function to include subdomains of localhost when DEBUG=True would address the issue.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [conf](https://github.com/testbed/django__django__3.1/tree//django/conf)- [Lines 482 - 580](https://github.com/testbed/django__django__3.1/blob//django/conf/global_settings.py#L482-L580)\n\n This snippet contains the 'ALLOWED_HOSTS' setting in the global settings file. The issue specifically mentions modifying 'ALLOWED_HOSTS' to include subdomains of localhost in DEBUG mode, so this is a relevant location for the change."
    }
}