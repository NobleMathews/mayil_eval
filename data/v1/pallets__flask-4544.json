{
    "id": "pallets__flask-4544",
    "repo_name": "testbed/pallets__flask__2.1",
    "task_id": 2275507685526374262,
    "title": "`flask run` rejects `--key foo.pem --cert foo.cert`",
    "body": "When trying the development server, I find that `flask run --cert foo.cert --key foo.pem` works fine, but `flask run --key foo.pem --cert foo.cert` fails with:\r\n\r\n```\r\nError: Invalid value for '--key': \"--cert\" must also be specified.\r\n```\r\n\r\nIsn't this somewhat counterintuitive?\r\n\r\nIn flask/cli.py, [`_validate_key()`](https://github.com/pallets/flask/blob/3897a518014931a82c77a353e1e9c2248529b856/src/flask/cli.py#L711) function insists the certificate file should have been specified, and it feels too restrictive. But I'm not familiar with Click to contribute a pretty PR...\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9.10\r\n- Flask version: 2.0.3\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pallets__flask__2.1.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `_validate_key` function in `flask/cli.py` to ensure that the `cert` parameter is correctly retrieved from the Click context regardless of the order in which `--key` and `--cert` arguments are provided on the command line.\n- Update the `run_command` function in `flask/cli.py` to ensure that the `cert` parameter is correctly passed to the `run_simple` function call.\n\n```python\n# flask/cli.py\n\ndef _validate_key(ctx, param, value):\n    cert = ctx.params.get(\"cert\")\n    if value is not None:\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n        ctx.params[\"cert\"] = (cert, value)\n    return value\n\n@click.command(\"run\", short_help=\"Run a development server.\")\n@click.option(\"--host\", \"-h\", default=\"127.0.0.1\", help=\"The interface to bind to.\")\n@click.option(\"--port\", \"-p\", default=5000, help=\"The port to bind to.\")\n@click.option(\n    \"--cert\",\n    type=CertParamType(),\n    help=\"Specify a certificate file to use HTTPS.\",\n    is_eager=True,\n)\n@click.option(\n    \"--key\",\n    type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n    callback=_validate_key,\n    expose_value=False,\n    help=\"The key file to use when specifying a certificate.\",\n)\n# ... other options ...\n\n@pass_script_info\ndef run_command(\n    info,\n    host,\n    port,\n    reload,\n    debugger,\n    with_threads,\n    cert,\n    extra_files,\n    exclude_patterns,\n):\n    # ... existing code ...\n\n    # Ensure that cert is a tuple if key is provided\n    if isinstance(cert, tuple):\n        ssl_context = cert\n    else:\n        ssl_context = cert if cert else None\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=ssl_context,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )\n```\n\n- Ensure that the `cert` parameter is correctly handled as a tuple `(cert, key)` when both `--cert` and `--key` are provided, and as a single value when only `--cert` is provided.\n- The `run_simple` function call within `run_command` should use the `ssl_context` variable, which is set based on the type of `cert` (either a tuple or a single value).\n\n### Code snippets to check\n\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.1/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.1/tree//src/flask)- [Lines 730 - 822](https://github.com/testbed/pallets__flask__2.1/blob//src/flask/cli.py#L730-L822)\n\n This snippet contains the _validate_key function which is responsible for the validation logic that is causing the issue. Modifying this function could resolve the issue. \n\n\n   - [Lines 825 - 937](https://github.com/testbed/pallets__flask__2.1/blob//src/flask/cli.py#L825-L937)\n\n This snippet defines the CLI options for the 'flask run' command, including the --cert and --key options. Understanding how these options are defined and how the callbacks are used is necessary to solve the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00025049999999999996,
        "snippet_processor": 0.06058,
        "issue_star_creation": 0.020859999999999997,
        "issue_star_solver": 0.07324,
        "bouncer": 0.024110000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711742894.5910342,
        "relevant_snippets": [
            {
                "code": "class CertParamType(click.ParamType):\n    \"\"\"Click option type for the ``--cert`` option. Allows either an\n    existing file, the string ``'adhoc'``, or an import for a\n    :class:`~ssl.SSLContext` object.\n    \"\"\"\n\n    name = \"path\"\n\n    def __init__(self):\n        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)\n\n    def convert(self, value, param, ctx):\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise\n\n\ndef _validate_key(ctx, param, value):\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n\n    try:\n        import ssl\n    except ImportError:\n        is_context = False\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key is not used.', ctx, param\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value\n\n\nclass SeparatedPathType(click.Path):\n    \"\"\"Click option type that accepts a list of values separated by the\n    OS's path separator (``:``, ``;`` on Windows). Each value is\n    validated as a :class:`click.Path` type.\n    \"\"\"\n\n    def convert(self, value, param, ctx):\n        items = self.split_envvar_value(value)\n        super_convert = super().convert\n        return [super_convert(item, param, ctx) for item in items]",
                "filename": "src/flask/cli.py",
                "start_index": 24149,
                "end_index": 26977,
                "start_line": 730,
                "end_line": 822,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "@click.command(\"run\", short_help=\"Run a development server.\")\n@click.option(\"--host\", \"-h\", default=\"127.0.0.1\", help=\"The interface to bind to.\")\n@click.option(\"--port\", \"-p\", default=5000, help=\"The port to bind to.\")\n@click.option(\n    \"--cert\",\n    type=CertParamType(),\n    help=\"Specify a certificate file to use HTTPS.\",\n    is_eager=True,\n)\n@click.option(\n    \"--key\",\n    type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n    callback=_validate_key,\n    expose_value=False,\n    help=\"The key file to use when specifying a certificate.\",\n)\n@click.option(\n    \"--reload/--no-reload\",\n    default=None,\n    help=\"Enable or disable the reloader. By default the reloader \"\n    \"is active if debug is enabled.\",\n)\n@click.option(\n    \"--debugger/--no-debugger\",\n    default=None,\n    help=\"Enable or disable the debugger. By default the debugger \"\n    \"is active if debug is enabled.\",\n)\n@click.option(\n    \"--with-threads/--without-threads\",\n    default=True,\n    help=\"Enable or disable multithreading.\",\n)\n@click.option(\n    \"--extra-files\",\n    default=None,\n    type=SeparatedPathType(),\n    help=(\n        \"Extra files that trigger a reload on change. Multiple paths\"\n        f\" are separated by {os.path.pathsep!r}.\"\n    ),\n)\n@click.option(\n    \"--exclude-patterns\",\n    default=None,\n    type=SeparatedPathType(),\n    help=(\n        \"Files matching these fnmatch patterns will not trigger a reload\"\n        \" on change. Multiple patterns are separated by\"\n        f\" {os.path.pathsep!r}.\"\n    ),\n)\n@pass_script_info\ndef run_command(\n    info,\n    host,\n    port,\n    reload,\n    debugger,\n    with_threads,\n    cert,\n    extra_files,\n    exclude_patterns,\n):\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default with the '--debug'\n    option.\n    \"\"\"\n    try:\n        app = info.load_app()\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading, print out the error immediately, but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(environ, start_response):\n                raise err from None\n\n        else:\n            # When not reloading, raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug, info.app_import_path)\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )\n\n\nrun_command.params.insert(0, _debug_option)",
                "filename": "src/flask/cli.py",
                "start_index": 26980,
                "end_index": 29944,
                "start_line": 825,
                "end_line": 937,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:\n    # If the flag isn't provided, it will default to False. Don't use\n    # that, let debug be set by env in that case.\n    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]\n\n    if source is not None and source in (\n        ParameterSource.DEFAULT,\n        ParameterSource.DEFAULT_MAP,\n    ):\n        return None\n\n    # Set with env var instead of ScriptInfo.load so that it can be\n    # accessed early during a factory function.\n    os.environ[\"FLASK_DEBUG\"] = \"1\" if value else \"0\"\n    return value\n\n\n_debug_option = click.Option(\n    [\"--debug/--no-debug\"],\n    help=\"Set debug mode.\",\n    expose_value=False,\n    callback=_set_debug,\n)\n\n\ndef _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    if value is None:\n        return None\n\n    import importlib\n\n    try:\n        importlib.import_module(\"dotenv\")\n    except ImportError:\n        raise click.BadParameter(\n            \"python-dotenv must be installed to load an env file.\",\n            ctx=ctx,\n            param=param,\n        ) from None\n\n    # Don't check FLASK_SKIP_DOTENV, that only disables automatically\n    # loading .env and .flaskenv files.\n    load_dotenv(value)\n    return value\n\n\n# This option is eager so env vars are loaded as early as possible to be\n# used by other options.\n_env_file_option = click.Option(\n    [\"-e\", \"--env-file\"],\n    type=click.Path(exists=True, dir_okay=False),\n    help=\"Load environment variables from this file. python-dotenv must be installed.\",\n    is_eager=True,\n    expose_value=False,\n    callback=_env_file_callback,\n)",
                "filename": "src/flask/cli.py",
                "start_index": 13423,
                "end_index": 15110,
                "start_line": 422,
                "end_line": 1068,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            if not is_running_from_reloader():\n                click.secho(\n                    \" * Ignoring a call to 'app.run()' that would block\"\n                    \" the current 'flask' CLI command.\\n\"\n                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n                    ' \"__main__\"\\' guard.',\n                    fg=\"red\",\n                )\n\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, env var overrides existing value\n            if \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(t.cast(str, host), port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False",
                "filename": "src/flask/app.py",
                "start_index": 22987,
                "end_index": 24852,
                "start_line": 561,
                "end_line": 617,
                "max_line": 1477,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "blank_issues_enabled: false\ncontact_links:\n  - name: Security issue\n    url: security@palletsprojects.com\n    about: Do not report security issues publicly. Email our security contact.\n  - name: Questions\n    url: https://stackoverflow.com/questions/tagged/flask?tab=Frequent\n    about: Search for and ask questions about your code on Stack Overflow.\n  - name: Questions and discussions\n    url: https://discord.gg/pallets\n    about: Discuss questions about your code on our Discord chat.",
                "filename": ".github/ISSUE_TEMPLATE/config.yml",
                "start_index": 0,
                "end_index": 488,
                "start_line": 1,
                "end_line": 11,
                "max_line": 11,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: click.Context | None = None,\n        **extra: t.Any,\n    ) -> click.Context:\n        # Set a flag to tell app.run to become a no-op. If app.run was\n        # not in a __name__ == __main__ guard, it would start the server\n        # when importing, blocking whatever command is being called.\n        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n\n        # Attempt to load .env and .flask env files. The --env-file\n        # option can cause another file to be loaded.\n        if get_load_dotenv(self.load_dotenv):\n            load_dotenv()\n\n        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n            extra[\"obj\"] = ScriptInfo(\n                create_app=self.create_app, set_debug_flag=self.set_debug_flag\n            )\n\n        return super().make_context(info_name, args, parent=parent, **extra)\n\n    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:\n        if not args and self.no_args_is_help:\n            # Attempt to load --env-file and --app early in case they\n            # were given as env vars. Otherwise no_args_is_help will not\n            # see commands from app.cli.\n            _env_file_option.handle_parse_result(ctx, {}, [])\n            _app_option.handle_parse_result(ctx, {}, [])\n\n        return super().parse_args(ctx, args)",
                "filename": "src/flask/cli.py",
                "start_index": 20251,
                "end_index": 21642,
                "start_line": 613,
                "end_line": 645,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\", \"match\")),\n    default=\"endpoint\",\n    help=(\n        \"Method to sort routes by. 'match' is the order that Flask will match routes\"\n        \" when dispatching a request.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n    host_matching = current_app.url_map.host_matching\n    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\n    rows = []\n\n    for rule in rules:\n        row = [\n            rule.endpoint,\n            \", \".join(sorted((rule.methods or set()) - ignored_methods)),\n        ]\n\n        if has_domain:\n            row.append((rule.host if host_matching else rule.subdomain) or \"\")\n\n        row.append(rule.rule)\n        rows.append(row)\n\n    headers = [\"Endpoint\", \"Methods\"]\n    sorts = [\"endpoint\", \"methods\"]\n\n    if has_domain:\n        headers.append(\"Host\" if host_matching else \"Subdomain\")\n        sorts.append(\"domain\")\n\n    headers.append(\"Rule\")\n    sorts.append(\"rule\")\n\n    try:\n        rows.sort(key=itemgetter(sorts.index(sort)))\n    except ValueError:\n        pass\n\n    rows.insert(0, headers)\n    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]\n    rows.insert(1, [\"-\" * w for w in widths])\n    template = \"  \".join(f\"{{{i}:<{w}}}\" for i, w in enumerate(widths))\n\n    for row in rows:\n        click.echo(template.format(*row))\n\n\ncli = FlaskGroup(\n    name=\"flask\",\n    help=\"\"\"\\\nA general utility script for Flask applications.\n\nAn application to load must be given with the '--app' option,\n'FLASK_APP' environment variable, or with a 'wsgi.py' or 'app.py' file\nin the current directory.\n\"\"\",\n)\n\n\ndef main() -> None:\n    cli.main()\n\n\nif __name__ == \"__main__\":\n    main()",
                "filename": "src/flask/cli.py",
                "start_index": 31602,
                "end_index": 33820,
                "start_line": 989,
                "end_line": 1068,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "def with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.\n\n    Custom commands (and their options) registered under ``app.cli`` or\n    ``blueprint.cli`` will always have an app context available, this\n    decorator is not required in that case.\n\n    .. versionchanged:: 2.2\n        The app context is active for subcommands as well as the\n        decorated callback. The app context is always available to\n        ``app.cli`` command and parameter callbacks.\n    \"\"\"\n\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        if not current_app:\n            app = __ctx.ensure_object(ScriptInfo).load_app()\n            __ctx.with_resource(app.app_context())\n\n        return __ctx.invoke(f, *args, **kwargs)\n\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop(\"with_appcontext\", True)\n\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault(\"cls\", AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\ndef _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n    if value is None:\n        return None\n\n    info = ctx.ensure_object(ScriptInfo)\n    info.app_import_path = value\n    return value\n\n\n# This option is eager so the app will be available if --help is given.\n# --help is also eager, so --app must be before it in the param list.\n# no_args_is_help bypasses eager processing, so this option must be\n# processed manually in that case to ensure FLASK_APP gets picked up.\n_app_option = click.Option(\n    [\"-A\", \"--app\"],\n    metavar=\"IMPORT\",\n    help=(\n        \"The Flask application or factory function to load, in the form 'module:name'.\"\n        \" Module can be a dotted import or file path. Name is not required if it is\"\n        \" 'app', 'application', 'create_app', or 'make_app', and can be 'name(args)' to\"\n        \" pass arguments.\"\n    ),\n    is_eager=True,\n    expose_value=False,\n    callback=_set_app,\n)",
                "filename": "src/flask/cli.py",
                "start_index": 10497,
                "end_index": 13420,
                "start_line": 338,
                "end_line": 1068,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\n\nimport typing as t\n\nfrom .blueprints import Blueprint\nfrom .globals import request_ctx\nfrom .sansio.app import App\n\n\nclass UnexpectedUnicodeError(AssertionError, UnicodeError):\n    \"\"\"Raised in places where we want some better error reporting for\n    unexpected unicode or binary data.\n    \"\"\"\n\n\nclass DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError/BadRequest.\n    \"\"\"\n\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = [\n            f\"You tried to access the file {key!r} in the request.files\"\n            \" dictionary but it does not exist. The mimetype for the\"\n            f\" request is {request.mimetype!r} instead of\"\n            \" 'multipart/form-data' which means that no file contents\"\n            \" were transmitted. To fix this error you should provide\"\n            ' enctype=\"multipart/form-data\" in your form.'\n        ]\n        if form_matches:\n            names = \", \".join(repr(x) for x in form_matches)\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                f\"This was submitted: {names}\"\n            )\n        self.msg = \"\".join(buf)\n\n    def __str__(self):\n        return self.msg\n\n\nclass FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised in debug mode if a routing redirect\n    would cause the browser to drop the method or body. This happens\n    when method is not GET, HEAD or OPTIONS and the status code is not\n    307 or 308.\n    \"\"\"\n\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = [\n            f\"A request was sent to '{request.url}', but routing issued\"\n            f\" a redirect to the canonical URL '{exc.new_url}'.\"\n        ]\n\n        if f\"{request.base_url}/\" == exc.new_url.partition(\"?\")[0]:\n            buf.append(\n                \" The URL was defined with a trailing slash. Flask\"\n                \" will redirect to the URL with a trailing slash if it\"\n                \" was accessed without one.\"\n            )\n\n        buf.append(\n            \" Send requests to the canonical URL, or use 307 or 308 for\"\n            \" routing redirects. Otherwise, browsers will drop form\"\n            \" data.\\n\\n\"\n            \"This exception is only raised in debug mode.\"\n        )\n        super().__init__(\"\".join(buf))",
                "filename": "src/flask/debughelpers.py",
                "start_index": 0,
                "end_index": 2489,
                "start_line": 1,
                "end_line": 70,
                "max_line": 160,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\n\nimport os\nimport sys\nimport typing as t\nimport weakref\nfrom collections.abc import Iterator as _abc_Iterator\nfrom datetime import timedelta\nfrom inspect import iscoroutinefunction\nfrom itertools import chain\nfrom types import TracebackType\nfrom urllib.parse import quote as _url_quote\n\nimport click\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.datastructures import ImmutableDict\nfrom werkzeug.exceptions import BadRequestKeyError\nfrom werkzeug.exceptions import HTTPException\nfrom werkzeug.exceptions import InternalServerError\nfrom werkzeug.routing import BuildError\nfrom werkzeug.routing import MapAdapter\nfrom werkzeug.routing import RequestRedirect\nfrom werkzeug.routing import RoutingException\nfrom werkzeug.routing import Rule\nfrom werkzeug.serving import is_running_from_reloader\nfrom werkzeug.wrappers import Response as BaseResponse\n\nfrom . import cli\nfrom . import typing as ft\nfrom .ctx import AppContext\nfrom .ctx import RequestContext\nfrom .globals import _cv_app\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import g\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .helpers import get_debug_flag\nfrom .helpers import get_flashed_messages\nfrom .helpers import get_load_dotenv\nfrom .helpers import send_from_directory\nfrom .sansio.app import App\nfrom .sansio.scaffold import _sentinel\nfrom .sessions import SecureCookieSessionInterface\nfrom .sessions import SessionInterface\nfrom .signals import appcontext_tearing_down\nfrom .signals import got_request_exception\nfrom .signals import request_finished\nfrom .signals import request_started\nfrom .signals import request_tearing_down\nfrom .templating import Environment\nfrom .wrappers import Request\nfrom .wrappers import Response\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .testing import FlaskClient\n    from .testing import FlaskCliRunner\n\nT_shell_context_processor = t.TypeVar(\n    \"T_shell_context_processor\", bound=ft.ShellContextProcessorCallable\n)\nT_teardown = t.TypeVar(\"T_teardown\", bound=ft.TeardownCallable)\nT_template_filter = t.TypeVar(\"T_template_filter\", bound=ft.TemplateFilterCallable)\nT_template_global = t.TypeVar(\"T_template_global\", bound=ft.TemplateGlobalCallable)\nT_template_test = t.TypeVar(\"T_template_test\", bound=ft.TemplateTestCallable)\n\n\ndef _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)",
                "filename": "src/flask/app.py",
                "start_index": 0,
                "end_index": 2549,
                "start_line": 1,
                "end_line": 73,
                "max_line": 1477,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.1",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "src/flask/cli.py": [
                {
                    "chunk": {
                        "code": "class CertParamType(click.ParamType):\n    \"\"\"Click option type for the ``--cert`` option. Allows either an\n    existing file, the string ``'adhoc'``, or an import for a\n    :class:`~ssl.SSLContext` object.\n    \"\"\"\n\n    name = \"path\"\n\n    def __init__(self):\n        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)\n\n    def convert(self, value, param, ctx):\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise\n\n\ndef _validate_key(ctx, param, value):\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n\n    try:\n        import ssl\n    except ImportError:\n        is_context = False\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key is not used.', ctx, param\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value\n\n\nclass SeparatedPathType(click.Path):\n    \"\"\"Click option type that accepts a list of values separated by the\n    OS's path separator (``:``, ``;`` on Windows). Each value is\n    validated as a :class:`click.Path` type.\n    \"\"\"\n\n    def convert(self, value, param, ctx):\n        items = self.split_envvar_value(value)\n        super_convert = super().convert\n        return [super_convert(item, param, ctx) for item in items]",
                        "filename": "src/flask/cli.py",
                        "start_index": 24149,
                        "end_index": 26977,
                        "start_line": 730,
                        "end_line": 822,
                        "max_line": 1068,
                        "git_instance": "github",
                        "repo_name": "testbed/pallets__flask__2.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the _validate_key function which is responsible for the validation logic that is causing the issue. Modifying this function could resolve the issue."
                },
                {
                    "chunk": {
                        "code": "@click.command(\"run\", short_help=\"Run a development server.\")\n@click.option(\"--host\", \"-h\", default=\"127.0.0.1\", help=\"The interface to bind to.\")\n@click.option(\"--port\", \"-p\", default=5000, help=\"The port to bind to.\")\n@click.option(\n    \"--cert\",\n    type=CertParamType(),\n    help=\"Specify a certificate file to use HTTPS.\",\n    is_eager=True,\n)\n@click.option(\n    \"--key\",\n    type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n    callback=_validate_key,\n    expose_value=False,\n    help=\"The key file to use when specifying a certificate.\",\n)\n@click.option(\n    \"--reload/--no-reload\",\n    default=None,\n    help=\"Enable or disable the reloader. By default the reloader \"\n    \"is active if debug is enabled.\",\n)\n@click.option(\n    \"--debugger/--no-debugger\",\n    default=None,\n    help=\"Enable or disable the debugger. By default the debugger \"\n    \"is active if debug is enabled.\",\n)\n@click.option(\n    \"--with-threads/--without-threads\",\n    default=True,\n    help=\"Enable or disable multithreading.\",\n)\n@click.option(\n    \"--extra-files\",\n    default=None,\n    type=SeparatedPathType(),\n    help=(\n        \"Extra files that trigger a reload on change. Multiple paths\"\n        f\" are separated by {os.path.pathsep!r}.\"\n    ),\n)\n@click.option(\n    \"--exclude-patterns\",\n    default=None,\n    type=SeparatedPathType(),\n    help=(\n        \"Files matching these fnmatch patterns will not trigger a reload\"\n        \" on change. Multiple patterns are separated by\"\n        f\" {os.path.pathsep!r}.\"\n    ),\n)\n@pass_script_info\ndef run_command(\n    info,\n    host,\n    port,\n    reload,\n    debugger,\n    with_threads,\n    cert,\n    extra_files,\n    exclude_patterns,\n):\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default with the '--debug'\n    option.\n    \"\"\"\n    try:\n        app = info.load_app()\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading, print out the error immediately, but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(environ, start_response):\n                raise err from None\n\n        else:\n            # When not reloading, raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug, info.app_import_path)\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )\n\n\nrun_command.params.insert(0, _debug_option)",
                        "filename": "src/flask/cli.py",
                        "start_index": 26980,
                        "end_index": 29944,
                        "start_line": 825,
                        "end_line": 937,
                        "max_line": 1068,
                        "git_instance": "github",
                        "repo_name": "testbed/pallets__flask__2.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the CLI options for the 'flask run' command, including the --cert and --key options. Understanding how these options are defined and how the callbacks are used is necessary to solve the issue."
                }
            ]
        },
        "solution_task": "- Modify the `_validate_key` function in `flask/cli.py` to ensure that the `cert` parameter is correctly retrieved from the Click context regardless of the order in which `--key` and `--cert` arguments are provided on the command line.\n- Update the `run_command` function in `flask/cli.py` to ensure that the `cert` parameter is correctly passed to the `run_simple` function call.\n\n```python\n# flask/cli.py\n\ndef _validate_key(ctx, param, value):\n    cert = ctx.params.get(\"cert\")\n    if value is not None:\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n        ctx.params[\"cert\"] = (cert, value)\n    return value\n\n@click.command(\"run\", short_help=\"Run a development server.\")\n@click.option(\"--host\", \"-h\", default=\"127.0.0.1\", help=\"The interface to bind to.\")\n@click.option(\"--port\", \"-p\", default=5000, help=\"The port to bind to.\")\n@click.option(\n    \"--cert\",\n    type=CertParamType(),\n    help=\"Specify a certificate file to use HTTPS.\",\n    is_eager=True,\n)\n@click.option(\n    \"--key\",\n    type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n    callback=_validate_key,\n    expose_value=False,\n    help=\"The key file to use when specifying a certificate.\",\n)\n# ... other options ...\n\n@pass_script_info\ndef run_command(\n    info,\n    host,\n    port,\n    reload,\n    debugger,\n    with_threads,\n    cert,\n    extra_files,\n    exclude_patterns,\n):\n    # ... existing code ...\n\n    # Ensure that cert is a tuple if key is provided\n    if isinstance(cert, tuple):\n        ssl_context = cert\n    else:\n        ssl_context = cert if cert else None\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=ssl_context,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )\n```\n\n- Ensure that the `cert` parameter is correctly handled as a tuple `(cert, key)` when both `--cert` and `--key` are provided, and as a single value when only `--cert` is provided.\n- The `run_simple` function call within `run_command` should use the `ssl_context` variable, which is set based on the type of `cert` (either a tuple or a single value).",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the problem described in the PROMPT. It suggests modifying the `_validate_key` function to ensure that the `cert` parameter is retrieved correctly, regardless of the order of the `--key` and `--cert` arguments. It also recommends updating the `run_command` function to pass the `cert` parameter correctly. The code snippet provided is relevant and directly addresses the issue with the `_validate_key` function. The RESPONSE also includes a reminder to handle the `cert` parameter as a tuple when both `--cert` and `--key` are provided, which is a crucial detail for the correct functioning of the SSL context in Flask. The links to the code snippets are helpful for locating the relevant sections of the codebase to be modified.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711742964.454529,
        "result": "- Modify the `_validate_key` function in `flask/cli.py` to ensure that the `cert` parameter is correctly retrieved from the Click context regardless of the order in which `--key` and `--cert` arguments are provided on the command line.\n- Update the `run_command` function in `flask/cli.py` to ensure that the `cert` parameter is correctly passed to the `run_simple` function call.\n\n```python\n# flask/cli.py\n\ndef _validate_key(ctx, param, value):\n    cert = ctx.params.get(\"cert\")\n    if value is not None:\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n        ctx.params[\"cert\"] = (cert, value)\n    return value\n\n@click.command(\"run\", short_help=\"Run a development server.\")\n@click.option(\"--host\", \"-h\", default=\"127.0.0.1\", help=\"The interface to bind to.\")\n@click.option(\"--port\", \"-p\", default=5000, help=\"The port to bind to.\")\n@click.option(\n    \"--cert\",\n    type=CertParamType(),\n    help=\"Specify a certificate file to use HTTPS.\",\n    is_eager=True,\n)\n@click.option(\n    \"--key\",\n    type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n    callback=_validate_key,\n    expose_value=False,\n    help=\"The key file to use when specifying a certificate.\",\n)\n# ... other options ...\n\n@pass_script_info\ndef run_command(\n    info,\n    host,\n    port,\n    reload,\n    debugger,\n    with_threads,\n    cert,\n    extra_files,\n    exclude_patterns,\n):\n    # ... existing code ...\n\n    # Ensure that cert is a tuple if key is provided\n    if isinstance(cert, tuple):\n        ssl_context = cert\n    else:\n        ssl_context = cert if cert else None\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=ssl_context,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )\n```\n\n- Ensure that the `cert` parameter is correctly handled as a tuple `(cert, key)` when both `--cert` and `--key` are provided, and as a single value when only `--cert` is provided.\n- The `run_simple` function call within `run_command` should use the `ssl_context` variable, which is set based on the type of `cert` (either a tuple or a single value).\n\n### Code snippets to check\n\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.1/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.1/tree//src/flask)- [Lines 730 - 822](https://github.com/testbed/pallets__flask__2.1/blob//src/flask/cli.py#L730-L822)\n\n This snippet contains the _validate_key function which is responsible for the validation logic that is causing the issue. Modifying this function could resolve the issue. \n\n\n   - [Lines 825 - 937](https://github.com/testbed/pallets__flask__2.1/blob//src/flask/cli.py#L825-L937)\n\n This snippet defines the CLI options for the 'flask run' command, including the --cert and --key options. Understanding how these options are defined and how the callbacks are used is necessary to solve the issue."
    }
}