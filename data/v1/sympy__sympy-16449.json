{
    "id": "sympy__sympy-16449",
    "repo_name": "testbed/sympy__sympy__1.5",
    "task_id": 5064748851542968921,
    "title": "Add CDF to maxwell distribution",
    "body": "Add function to find CDF of Maxwell distribution using reference: [wiki](https://en.wikipedia.org/wiki/Maxwell%E2%80%93Boltzmann_distribution)\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sympy__sympy__1.5.git",
    "requested_commit": "",
    "mayil_response": "To implement the Cumulative Distribution Function (CDF) for the Maxwell distribution in the `sympy/stats/crv_types.py` file, you can follow these steps:\n\n- Add a `_cdf` method to the `MaxwellDistribution` class.\n- Use the formula for the CDF of the Maxwell distribution, which can be derived from the PDF by integrating it from 0 to x.\n- The CDF of the Maxwell distribution is not elementary, but it can be expressed in terms of the error function `erf` and the square root function `sqrt`.\n- The CDF formula for the Maxwell distribution is given by:\n\n  \\[ F(x) = \\text{erf}\\left(\\frac{x}{\\sqrt{2}a}\\right) - \\sqrt{\\frac{2}{\\pi}} \\frac{x e^{-\\frac{x^2}{2a^2}}}{a} \\]\n\n- Import the `erf` function from `sympy.functions.special.error_functions`.\n- Use the `integrate` function from `sympy` to perform the integration if necessary.\n\nHere is the pseudo code for the `_cdf` method:\n\n```python\nfrom sympy import erf, sqrt, exp, pi\n\nclass MaxwellDistribution(SingleContinuousDistribution):\n    # ... existing code ...\n\n    def _cdf(self, x):\n        a = self.a\n        cdf = erf(x / (sqrt(2) * a)) - sqrt(2/pi) * (x * exp(-x**2 / (2 * a**2)) / a)\n        return cdf\n```\n\nAnd you would add this method to the `MaxwellDistribution` class in the `sympy/stats/crv_types.py` file. The `a` parameter is the scale parameter of the Maxwell distribution, which is already defined in the class.\n\nRemember to add the `_cdf` method within the `MaxwellDistribution` class and ensure that it uses the correct symbols and parameters as defined in the class. The `erf` function is already imported in the provided codebase, so you can use it directly.\n\nAfter implementing the `_cdf` method, you can test it by creating a Maxwell distribution object and calling the `cdf` method on it, which should now use the newly implemented `_cdf` method internally.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 2517 - 2597](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L2517-L2597)\n\n This snippet defines the Maxwell distribution and will need to be modified to include the CDF function. \n\n\n   - [Lines 1758 - 1851](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L1758-L1851)\n\n This snippet shows an example of how the CDF is implemented for another distribution (inverse Gamma distribution), which could serve as a reference for implementing the CDF for the Maxwell distribution.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 903 - 1263](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/rv.py#L903-L1263)\n\n This snippet contains the general implementation of the CDF function for random expressions and may need to be referenced for implementing the CDF of the Maxwell distribution.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [functions](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/functions) \u2192 [special](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/functions/special)- [Lines 239 - 239](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/functions/special/error_functions.py#L239-L239)\n\n The erfc function is related to the error function, which is often used in the computation of CDFs for various distributions, and may be needed for the Maxwell distribution CDF.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0004125,
        "snippet_processor": 0.06274,
        "issue_star_creation": 0.023829999999999997,
        "issue_star_solver": 0.062450000000000006,
        "bouncer": 0.02564
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711748251.195746,
        "relevant_snippets": [
            {
                "code": "def Maxwell(name, a):\n    r\"\"\"\n    Create a continuous random variable with a Maxwell distribution.\n\n    The density of the Maxwell distribution is given by\n\n    .. math::\n        f(x) := \\sqrt{\\frac{2}{\\pi}} \\frac{x^2 e^{-x^2/(2a^2)}}{a^3}\n\n    with :math:`x \\geq 0`.\n\n    .. TODO - what does the parameter mean?\n\n    Parameters\n    ==========\n\n    a : Real number, `a > 0`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Maxwell, density, E, variance\n    >>> from sympy import Symbol, simplify\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Maxwell(\"x\", a)\n\n    >>> density(X)(z)\n    sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)\n\n    >>> E(X)\n    2*sqrt(2)*a/sqrt(pi)\n\n    >>> simplify(variance(X))\n    a**2*(-8 + 3*pi)/pi\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution\n    .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html\n\n    \"\"\"\n\n    return rv(name, MaxwellDistribution, (a, ))\n\n#-------------------------------------------------------------------------------\n# Moyal Distribution -----------------------------------------------------------\nclass MoyalDistribution(SingleContinuousDistribution):\n    _argnames = ('mu', 'sigma')\n\n    @staticmethod\n    def check(mu, sigma):\n        _value_check(mu.is_real, \"Location parameter must be real.\")\n        _value_check(sigma.is_real and sigma > 0, \"Scale parameter must be real\\\n        and positive.\")\n\n    def pdf(self, x):\n        mu, sigma = self.mu, self.sigma\n        num = exp(-(exp(-(x - mu)/sigma) + (x - mu)/(sigma))/2)\n        den = (sqrt(2*pi) * sigma)\n        return num/den\n\n    def _characteristic_function(self, t):\n        mu, sigma = self.mu, self.sigma\n        term1 = exp(I*t*mu)\n        term2 = (2**(-I*sigma*t) * gamma(Rational(1, 2) - I*t*sigma))\n        return (term1 * term2)/sqrt(pi)\n\n    def _moment_generating_function(self, t):\n        mu, sigma = self.mu, self.sigma\n        term1 = exp(t*mu)\n        term2 = (2**(-1*sigma*t) * gamma(Rational(1, 2) - t*sigma))\n        return (term1 * term2)/sqrt(pi)",
                "filename": "sympy/stats/crv_types.py",
                "start_index": 65981,
                "end_index": 68108,
                "start_line": 2517,
                "end_line": 2597,
                "max_line": 4247,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "class erfc(Function):",
                "filename": "sympy/functions/special/error_functions.py",
                "start_index": 6793,
                "end_index": 6814,
                "start_line": 239,
                "end_line": 239,
                "max_line": 2529,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "def cdf(expr, condition=None, evaluate=True, **kwargs):\n    \"\"\"\n    Cumulative Distribution Function of a random expression.\n\n    optionally given a second condition\n\n    This density will take on different forms for different types of\n    probability spaces.\n    Discrete variables produce Dicts.\n    Continuous variables produce Lambdas.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, Die, Normal, cdf\n\n    >>> D = Die('D', 6)\n    >>> X = Normal('X', 0, 1)\n\n    >>> density(D).dict\n    {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}\n    >>> cdf(D)\n    {1: 1/6, 2: 1/3, 3: 1/2, 4: 2/3, 5: 5/6, 6: 1}\n    >>> cdf(3*D, D > 2)\n    {9: 1/4, 12: 1/2, 15: 3/4, 18: 1}\n\n    >>> cdf(X)\n    Lambda(_z, erf(sqrt(2)*_z/2)/2 + 1/2)\n    \"\"\"\n    if condition is not None:  # If there is a condition\n        # Recompute on new conditional expr\n        return cdf(given(expr, condition, **kwargs), **kwargs)\n\n    # Otherwise pass work off to the ProbabilitySpace\n    result = pspace(expr).compute_cdf(expr, **kwargs)\n\n    if evaluate and hasattr(result, 'doit'):\n        return result.doit()\n    else:\n        return result\n\n\ndef characteristic_function(expr, condition=None, evaluate=True, **kwargs):\n    \"\"\"\n    Characteristic function of a random expression, optionally given a second condition\n\n    Returns a Lambda\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Normal, DiscreteUniform, Poisson, characteristic_function\n\n    >>> X = Normal('X', 0, 1)\n    >>> characteristic_function(X)\n    Lambda(_t, exp(-_t**2/2))\n\n    >>> Y = DiscreteUniform('Y', [1, 2, 7])\n    >>> characteristic_function(Y)\n    Lambda(_t, exp(7*_t*I)/3 + exp(2*_t*I)/3 + exp(_t*I)/3)\n\n    >>> Z = Poisson('Z', 2)\n    >>> characteristic_function(Z)\n    Lambda(_t, exp(2*exp(_t*I) - 2))\n    \"\"\"\n    if condition is not None:\n        return characteristic_function(given(expr, condition, **kwargs), **kwargs)\n\n    result = pspace(expr).compute_characteristic_function(expr, **kwargs)\n\n    if evaluate and hasattr(result, 'doit'):\n        return result.doit()\n    else:\n        return result\n\ndef moment_generating_function(expr, condition=None, evaluate=True, **kwargs):\n    if condition is not None:\n        return moment_generating_function(given(expr, condition, **kwargs), **kwargs)\n\n    result = pspace(expr).compute_moment_generating_function(expr, **kwargs)\n\n    if evaluate and hasattr(result, 'doit'):\n        return result.doit()\n    else:\n        return result",
                "filename": "sympy/stats/rv.py",
                "start_index": 28667,
                "end_index": 31134,
                "start_line": 903,
                "end_line": 1263,
                "max_line": 1499,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "###############################################################################\n################## LOWER and UPPER INCOMPLETE GAMMA FUNCTIONS #################\n###############################################################################",
                "filename": "sympy/functions/special/gamma_functions.py",
                "start_index": 7212,
                "end_index": 7451,
                "start_line": 24,
                "end_line": 1228,
                "max_line": 1321,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "# conceal the implicit import from the code quality tester\nfrom sympy import (exp, gamma, integrate, oo, pi, sqrt, Symbol, symbols,\n        besseli, laplace_transform, fourier_transform, mellin_transform,\n        inverse_fourier_transform, inverse_laplace_transform,\n        inverse_mellin_transform)\n\nLT = laplace_transform\nFT = fourier_transform\nMT = mellin_transform\nIFT = inverse_fourier_transform\nILT = inverse_laplace_transform\nIMT = inverse_mellin_transform\n\nfrom sympy.abc import x, y\nnu, beta, rho = symbols('nu beta rho')\n\napos, bpos, cpos, dpos, posk, p = symbols('a b c d k p', positive=True)\nk = Symbol('k', real=True)\nnegk = Symbol('k', negative=True)\n\nmu1, mu2 = symbols('mu1 mu2', real=True, nonzero=True, finite=True)\nsigma1, sigma2 = symbols('sigma1 sigma2', real=True, nonzero=True,\n                         finite=True, positive=True)\nrate = Symbol('lambda', real=True, positive=True, finite=True)\n\n\ndef normal(x, mu, sigma):\n    return 1/sqrt(2*pi*sigma**2)*exp(-(x - mu)**2/2/sigma**2)\n\n\ndef exponential(x, rate):\n    return rate*exp(-rate*x)\nalpha, beta = symbols('alpha beta', positive=True)\nbetadist = x**(alpha - 1)*(1 + x)**(-alpha - beta)*gamma(alpha + beta) \\\n    /gamma(alpha)/gamma(beta)\nkint = Symbol('k', integer=True, positive=True)\nchi = 2**(1 - kint/2)*x**(kint - 1)*exp(-x**2/2)/gamma(kint/2)\nchisquared = 2**(-k/2)/gamma(k/2)*x**(k/2 - 1)*exp(-x/2)\ndagum = apos*p/x*(x/bpos)**(apos*p)/(1 + x**apos/bpos**apos)**(p + 1)\nd1, d2 = symbols('d1 d2', positive=True)\nf = sqrt(((d1*x)**d1 * d2**d2)/(d1*x + d2)**(d1 + d2))/x \\\n    /gamma(d1/2)/gamma(d2/2)*gamma((d1 + d2)/2)\nnupos, sigmapos = symbols('nu sigma', positive=True)\nrice = x/sigmapos**2*exp(-(x**2 + nupos**2)/2/sigmapos**2)*besseli(0, x*\n                         nupos/sigmapos**2)\nmu = Symbol('mu', real=True)\nlaplace = exp(-abs(x - mu)/bpos)/2/bpos\n\nu = Symbol('u', polar=True)\ntpos = Symbol('t', positive=True)\n\n\ndef E(expr):\n    integrate(expr*exponential(x, rate)*normal(y, mu1, sigma1),\n                     (x, 0, oo), (y, -oo, oo), meijerg=True)\n    integrate(expr*exponential(x, rate)*normal(y, mu1, sigma1),\n                     (y, -oo, oo), (x, 0, oo), meijerg=True)",
                "filename": "sympy/benchmarks/bench_meijerint.py",
                "start_index": 0,
                "end_index": 2171,
                "start_line": 1,
                "end_line": 57,
                "max_line": 255,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "addb([1, 1], [2, 2, Rational(3, 2)],\n         Matrix([Chi(2*sqrt(z)) - log(2*sqrt(z)),\n                 cosh(2*sqrt(z)), sqrt(z)*sinh(2*sqrt(z)), 1, EulerGamma]),\n         Matrix([[1/z, 0, 0, 0, -1/z]]),\n         Matrix([[0, S.Half, 0, Rational(-1, 2), 0],\n                 [0, 0, 1, 0, 0],\n                 [0, z, S.Half, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0]]))\n\n    # 3F3\n    # This is rule: http://functions.wolfram.com/07.31.03.0134.01\n    # Initial reason to add it was a nice solution for\n    # integrate(erf(a*z)/z**2, z) and same for erfc and erfi.\n    # Basic rule\n    # add([1, 1, a], [2, 2, a+1], (a/(z*(a-1)**2)) *\n    #     (1 - (-z)**(1-a) * (gamma(a) - uppergamma(a,-z))\n    #      - (a-1) * (EulerGamma + uppergamma(0,-z) + log(-z))\n    #      - exp(z)))\n    # Manually tuned rule\n    addb([1, 1, a], [2, 2, a+1],\n         Matrix([a*(log(-z) + expint(1, -z) + EulerGamma)/(z*(a**2 - 2*a + 1)),\n                 a*(-z)**(-a)*(gamma(a) - uppergamma(a, -z))/(a - 1)**2,\n                 a*exp(z)/(a**2 - 2*a + 1),\n                 a/(z*(a**2 - 2*a + 1))]),\n         Matrix([[1-a, 1, -1/z, 1]]),\n         Matrix([[-1,0,-1/z,1],\n                 [0,-a,1,0],\n                 [0,0,z,0],\n                 [0,0,0,-1]]))",
                "filename": "sympy/simplify/hyperexpand.py",
                "start_index": 15542,
                "end_index": 16806,
                "start_line": 358,
                "end_line": 387,
                "max_line": 2491,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "def GammaInverse(name, a, b):\n    r\"\"\"\n    Create a continuous random variable with an inverse Gamma distribution.\n\n    The density of the inverse Gamma distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{-\\alpha - 1}\n                \\exp\\left(\\frac{-\\beta}{x}\\right)\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    a : Real number, `a > 0` a shape\n    b : Real number, `b > 0` a scale\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import GammaInverse, density, cdf, E, variance\n    >>> from sympy import Symbol, pprint\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> b = Symbol(\"b\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = GammaInverse(\"x\", a, b)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                -b\n                ---\n     a  -a - 1   z\n    b *z      *e\n    ---------------\n       Gamma(a)\n\n    >>> cdf(X)(z)\n    Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution\n\n    \"\"\"\n\n    return rv(name, GammaInverseDistribution, (a, b))\n\n\n#-------------------------------------------------------------------------------\n# Gumbel distribution (Maximum and Minimum) --------------------------------------------------------\n\n\nclass GumbelDistribution(SingleContinuousDistribution):\n    _argnames = ('beta', 'mu', 'minimum')\n\n    set = Interval(-oo, oo)\n\n    @staticmethod\n    def check(beta, mu, minimum):\n        _value_check(beta > 0, \"Scale parameter beta must be positive.\")\n\n    def pdf(self, x):\n        beta, mu = self.beta, self.mu\n        z = (x - mu)/beta\n        f_max = (1/beta)*exp(-z - exp(-z))\n        f_min = (1/beta)*exp(z - exp(z))\n        return Piecewise((f_min, self.minimum), (f_max, not self.minimum))\n\n    def _cdf(self, x):\n        beta, mu = self.beta, self.mu\n        z = (x - mu)/beta\n        F_max = exp(-exp(-z))\n        F_min = 1 - exp(-exp(z))\n        return Piecewise((F_min, self.minimum), (F_max, not self.minimum))\n\n    def _characteristic_function(self, t):\n        cf_max = gamma(1 - I*self.beta*t) * exp(I*self.mu*t)\n        cf_min = gamma(1 + I*self.beta*t) * exp(I*self.mu*t)\n        return Piecewise((cf_min, self.minimum), (cf_max, not self.minimum))\n\n    def _moment_generating_function(self, t):\n        mgf_max = gamma(1 - self.beta*t) * exp(self.mu*t)\n        mgf_min = gamma(1 + self.beta*t) * exp(self.mu*t)\n        return Piecewise((mgf_min, self.minimum), (mgf_max, not self.minimum))",
                "filename": "sympy/stats/crv_types.py",
                "start_index": 46121,
                "end_index": 48704,
                "start_line": 1758,
                "end_line": 1851,
                "max_line": 4247,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "class loggamma(Function):",
                "filename": "sympy/functions/special/gamma_functions.py",
                "start_index": 28190,
                "end_index": 28215,
                "start_line": 836,
                "end_line": 836,
                "max_line": 1321,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "@cacheit\n    def compute_moment_generating_function(self, **kwargs):\n        \"\"\" Compute the moment generating function from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, t = symbols('x, t', real=True, cls=Dummy)\n        pdf = self.pdf(x)\n        mgf = integrate(exp(t * x) * pdf, (x, -oo, oo))\n        return Lambda(t, mgf)\n\n    def _moment_generating_function(self, t):\n        return None\n\n    def moment_generating_function(self, t, **kwargs):\n        \"\"\" Moment generating function \"\"\"\n        if not kwargs:\n                mgf = self._moment_generating_function(t)\n                if mgf is not None:\n                    return mgf\n        return self.compute_moment_generating_function(**kwargs)(t)\n\n    def expectation(self, expr, var, evaluate=True, **kwargs):\n        \"\"\" Expectation of expression over distribution \"\"\"\n        if evaluate:\n            try:\n                p = poly(expr, var)\n                t = Dummy('t', real=True)\n                mgf = self._moment_generating_function(t)\n                if mgf is None:\n                    return integrate(expr * self.pdf(var), (var, self.set), **kwargs)\n                deg = p.degree()\n                taylor = poly(series(mgf, t, 0, deg + 1).removeO(), t)\n                result = 0\n                for k in range(deg+1):\n                    result += p.coeff_monomial(var ** k) * taylor.coeff_monomial(t ** k) * factorial(k)\n                return result\n            except PolynomialError:\n                return integrate(expr * self.pdf(var), (var, self.set), **kwargs)\n        else:\n            return Integral(expr * self.pdf(var), (var, self.set), **kwargs)\n\n    @cacheit\n    def compute_quantile(self, **kwargs):\n        \"\"\" Compute the Quantile from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, p = symbols('x, p', real=True, cls=Dummy)\n        left_bound = self.set.start\n\n        pdf = self.pdf(x)\n        cdf = integrate(pdf, (x, left_bound, x), **kwargs)\n        quantile = solveset(cdf - p, x, self.set)\n        return Lambda(p, Piecewise((quantile, (p >= 0) & (p <= 1) ), (nan, True)))\n\n    def _quantile(self, x):\n        return None\n\n    def quantile(self, x, **kwargs):\n        \"\"\" Cumulative density function \"\"\"\n        if len(kwargs) == 0:\n            quantile = self._quantile(x)\n            if quantile is not None:\n                return quantile\n        return self.compute_quantile(**kwargs)(x)",
                "filename": "sympy/stats/crv.py",
                "start_index": 8431,
                "end_index": 10845,
                "start_line": 182,
                "end_line": 317,
                "max_line": 585,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            },
            {
                "code": "class ExGaussianDistribution(SingleContinuousDistribution):\n    _argnames = ('mean', 'std', 'rate')\n\n    set = Interval(-oo, oo)\n\n    @staticmethod\n    def check(mean, std, rate):\n        _value_check(\n            std > 0, \"Standard deviation of ExGaussian must be positive.\")\n        _value_check(rate > 0, \"Rate of ExGaussian must be positive.\")\n\n    def pdf(self, x):\n        mean, std, rate = self.mean, self.std, self.rate\n        term1 = rate/2\n        term2 = exp(rate * (2 * mean + rate * std**2 - 2*x)/2)\n        term3 = erfc((mean + rate*std**2 - x)/(sqrt(2)*std))\n        return term1*term2*term3\n\n    def _cdf(self, x):\n        from sympy.stats import cdf\n        mean, std, rate = self.mean, self.std, self.rate\n        u = rate*(x - mean)\n        v = rate*std\n        GaussianCDF1 = cdf(Normal('x', 0, v))(u)\n        GaussianCDF2 = cdf(Normal('x', v**2, v))(u)\n\n        return GaussianCDF1 - exp(-u + (v**2/2) + log(GaussianCDF2))\n\n    def _characteristic_function(self, t):\n        mean, std, rate = self.mean, self.std, self.rate\n        term1 = (1 - I*t/rate)**(-1)\n        term2 = exp(I*mean*t - std**2*t**2/2)\n        return term1 * term2\n\n    def _moment_generating_function(self, t):\n        mean, std, rate = self.mean, self.std, self.rate\n        term1 = (1 - t/rate)**(-1)\n        term2 = exp(mean*t + std**2*t**2/2)\n        return term1*term2",
                "filename": "sympy/stats/crv_types.py",
                "start_index": 26894,
                "end_index": 28261,
                "start_line": 1068,
                "end_line": 1106,
                "max_line": 4247,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "sympy/stats/crv_types.py": [
                {
                    "chunk": {
                        "code": "def Maxwell(name, a):\n    r\"\"\"\n    Create a continuous random variable with a Maxwell distribution.\n\n    The density of the Maxwell distribution is given by\n\n    .. math::\n        f(x) := \\sqrt{\\frac{2}{\\pi}} \\frac{x^2 e^{-x^2/(2a^2)}}{a^3}\n\n    with :math:`x \\geq 0`.\n\n    .. TODO - what does the parameter mean?\n\n    Parameters\n    ==========\n\n    a : Real number, `a > 0`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Maxwell, density, E, variance\n    >>> from sympy import Symbol, simplify\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Maxwell(\"x\", a)\n\n    >>> density(X)(z)\n    sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)\n\n    >>> E(X)\n    2*sqrt(2)*a/sqrt(pi)\n\n    >>> simplify(variance(X))\n    a**2*(-8 + 3*pi)/pi\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution\n    .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html\n\n    \"\"\"\n\n    return rv(name, MaxwellDistribution, (a, ))\n\n#-------------------------------------------------------------------------------\n# Moyal Distribution -----------------------------------------------------------\nclass MoyalDistribution(SingleContinuousDistribution):\n    _argnames = ('mu', 'sigma')\n\n    @staticmethod\n    def check(mu, sigma):\n        _value_check(mu.is_real, \"Location parameter must be real.\")\n        _value_check(sigma.is_real and sigma > 0, \"Scale parameter must be real\\\n        and positive.\")\n\n    def pdf(self, x):\n        mu, sigma = self.mu, self.sigma\n        num = exp(-(exp(-(x - mu)/sigma) + (x - mu)/(sigma))/2)\n        den = (sqrt(2*pi) * sigma)\n        return num/den\n\n    def _characteristic_function(self, t):\n        mu, sigma = self.mu, self.sigma\n        term1 = exp(I*t*mu)\n        term2 = (2**(-I*sigma*t) * gamma(Rational(1, 2) - I*t*sigma))\n        return (term1 * term2)/sqrt(pi)\n\n    def _moment_generating_function(self, t):\n        mu, sigma = self.mu, self.sigma\n        term1 = exp(t*mu)\n        term2 = (2**(-1*sigma*t) * gamma(Rational(1, 2) - t*sigma))\n        return (term1 * term2)/sqrt(pi)",
                        "filename": "sympy/stats/crv_types.py",
                        "start_index": 65981,
                        "end_index": 68108,
                        "start_line": 2517,
                        "end_line": 2597,
                        "max_line": 4247,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the Maxwell distribution and will need to be modified to include the CDF function."
                },
                {
                    "chunk": {
                        "code": "def GammaInverse(name, a, b):\n    r\"\"\"\n    Create a continuous random variable with an inverse Gamma distribution.\n\n    The density of the inverse Gamma distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{-\\alpha - 1}\n                \\exp\\left(\\frac{-\\beta}{x}\\right)\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    a : Real number, `a > 0` a shape\n    b : Real number, `b > 0` a scale\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import GammaInverse, density, cdf, E, variance\n    >>> from sympy import Symbol, pprint\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> b = Symbol(\"b\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = GammaInverse(\"x\", a, b)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                -b\n                ---\n     a  -a - 1   z\n    b *z      *e\n    ---------------\n       Gamma(a)\n\n    >>> cdf(X)(z)\n    Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution\n\n    \"\"\"\n\n    return rv(name, GammaInverseDistribution, (a, b))\n\n\n#-------------------------------------------------------------------------------\n# Gumbel distribution (Maximum and Minimum) --------------------------------------------------------\n\n\nclass GumbelDistribution(SingleContinuousDistribution):\n    _argnames = ('beta', 'mu', 'minimum')\n\n    set = Interval(-oo, oo)\n\n    @staticmethod\n    def check(beta, mu, minimum):\n        _value_check(beta > 0, \"Scale parameter beta must be positive.\")\n\n    def pdf(self, x):\n        beta, mu = self.beta, self.mu\n        z = (x - mu)/beta\n        f_max = (1/beta)*exp(-z - exp(-z))\n        f_min = (1/beta)*exp(z - exp(z))\n        return Piecewise((f_min, self.minimum), (f_max, not self.minimum))\n\n    def _cdf(self, x):\n        beta, mu = self.beta, self.mu\n        z = (x - mu)/beta\n        F_max = exp(-exp(-z))\n        F_min = 1 - exp(-exp(z))\n        return Piecewise((F_min, self.minimum), (F_max, not self.minimum))\n\n    def _characteristic_function(self, t):\n        cf_max = gamma(1 - I*self.beta*t) * exp(I*self.mu*t)\n        cf_min = gamma(1 + I*self.beta*t) * exp(I*self.mu*t)\n        return Piecewise((cf_min, self.minimum), (cf_max, not self.minimum))\n\n    def _moment_generating_function(self, t):\n        mgf_max = gamma(1 - self.beta*t) * exp(self.mu*t)\n        mgf_min = gamma(1 + self.beta*t) * exp(self.mu*t)\n        return Piecewise((mgf_min, self.minimum), (mgf_max, not self.minimum))",
                        "filename": "sympy/stats/crv_types.py",
                        "start_index": 46121,
                        "end_index": 48704,
                        "start_line": 1758,
                        "end_line": 1851,
                        "max_line": 4247,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows an example of how the CDF is implemented for another distribution (inverse Gamma distribution), which could serve as a reference for implementing the CDF for the Maxwell distribution."
                }
            ],
            "sympy/stats/rv.py": [
                {
                    "chunk": {
                        "code": "def cdf(expr, condition=None, evaluate=True, **kwargs):\n    \"\"\"\n    Cumulative Distribution Function of a random expression.\n\n    optionally given a second condition\n\n    This density will take on different forms for different types of\n    probability spaces.\n    Discrete variables produce Dicts.\n    Continuous variables produce Lambdas.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, Die, Normal, cdf\n\n    >>> D = Die('D', 6)\n    >>> X = Normal('X', 0, 1)\n\n    >>> density(D).dict\n    {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}\n    >>> cdf(D)\n    {1: 1/6, 2: 1/3, 3: 1/2, 4: 2/3, 5: 5/6, 6: 1}\n    >>> cdf(3*D, D > 2)\n    {9: 1/4, 12: 1/2, 15: 3/4, 18: 1}\n\n    >>> cdf(X)\n    Lambda(_z, erf(sqrt(2)*_z/2)/2 + 1/2)\n    \"\"\"\n    if condition is not None:  # If there is a condition\n        # Recompute on new conditional expr\n        return cdf(given(expr, condition, **kwargs), **kwargs)\n\n    # Otherwise pass work off to the ProbabilitySpace\n    result = pspace(expr).compute_cdf(expr, **kwargs)\n\n    if evaluate and hasattr(result, 'doit'):\n        return result.doit()\n    else:\n        return result\n\n\ndef characteristic_function(expr, condition=None, evaluate=True, **kwargs):\n    \"\"\"\n    Characteristic function of a random expression, optionally given a second condition\n\n    Returns a Lambda\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Normal, DiscreteUniform, Poisson, characteristic_function\n\n    >>> X = Normal('X', 0, 1)\n    >>> characteristic_function(X)\n    Lambda(_t, exp(-_t**2/2))\n\n    >>> Y = DiscreteUniform('Y', [1, 2, 7])\n    >>> characteristic_function(Y)\n    Lambda(_t, exp(7*_t*I)/3 + exp(2*_t*I)/3 + exp(_t*I)/3)\n\n    >>> Z = Poisson('Z', 2)\n    >>> characteristic_function(Z)\n    Lambda(_t, exp(2*exp(_t*I) - 2))\n    \"\"\"\n    if condition is not None:\n        return characteristic_function(given(expr, condition, **kwargs), **kwargs)\n\n    result = pspace(expr).compute_characteristic_function(expr, **kwargs)\n\n    if evaluate and hasattr(result, 'doit'):\n        return result.doit()\n    else:\n        return result\n\ndef moment_generating_function(expr, condition=None, evaluate=True, **kwargs):\n    if condition is not None:\n        return moment_generating_function(given(expr, condition, **kwargs), **kwargs)\n\n    result = pspace(expr).compute_moment_generating_function(expr, **kwargs)\n\n    if evaluate and hasattr(result, 'doit'):\n        return result.doit()\n    else:\n        return result",
                        "filename": "sympy/stats/rv.py",
                        "start_index": 28667,
                        "end_index": 31134,
                        "start_line": 903,
                        "end_line": 1263,
                        "max_line": 1499,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the general implementation of the CDF function for random expressions and may need to be referenced for implementing the CDF of the Maxwell distribution."
                }
            ],
            "sympy/functions/special/error_functions.py": [
                {
                    "chunk": {
                        "code": "class erfc(Function):",
                        "filename": "sympy/functions/special/error_functions.py",
                        "start_index": 6793,
                        "end_index": 6814,
                        "start_line": 239,
                        "end_line": 239,
                        "max_line": 2529,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "The erfc function is related to the error function, which is often used in the computation of CDFs for various distributions, and may be needed for the Maxwell distribution CDF."
                }
            ]
        },
        "solution_task": "To implement the Cumulative Distribution Function (CDF) for the Maxwell distribution in the `sympy/stats/crv_types.py` file, you can follow these steps:\n\n- Add a `_cdf` method to the `MaxwellDistribution` class.\n- Use the formula for the CDF of the Maxwell distribution, which can be derived from the PDF by integrating it from 0 to x.\n- The CDF of the Maxwell distribution is not elementary, but it can be expressed in terms of the error function `erf` and the square root function `sqrt`.\n- The CDF formula for the Maxwell distribution is given by:\n\n  \\[ F(x) = \\text{erf}\\left(\\frac{x}{\\sqrt{2}a}\\right) - \\sqrt{\\frac{2}{\\pi}} \\frac{x e^{-\\frac{x^2}{2a^2}}}{a} \\]\n\n- Import the `erf` function from `sympy.functions.special.error_functions`.\n- Use the `integrate` function from `sympy` to perform the integration if necessary.\n\nHere is the pseudo code for the `_cdf` method:\n\n```python\nfrom sympy import erf, sqrt, exp, pi\n\nclass MaxwellDistribution(SingleContinuousDistribution):\n    # ... existing code ...\n\n    def _cdf(self, x):\n        a = self.a\n        cdf = erf(x / (sqrt(2) * a)) - sqrt(2/pi) * (x * exp(-x**2 / (2 * a**2)) / a)\n        return cdf\n```\n\nAnd you would add this method to the `MaxwellDistribution` class in the `sympy/stats/crv_types.py` file. The `a` parameter is the scale parameter of the Maxwell distribution, which is already defined in the class.\n\nRemember to add the `_cdf` method within the `MaxwellDistribution` class and ensure that it uses the correct symbols and parameters as defined in the class. The `erf` function is already imported in the provided codebase, so you can use it directly.\n\nAfter implementing the `_cdf` method, you can test it by creating a Maxwell distribution object and calling the `cdf` method on it, which should now use the newly implemented `_cdf` method internally.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant suggestions that can directly lead to the successful implementation or improvement of the requested feature.",
            "supporting_evidence": "The RESPONSE provides a clear and detailed set of instructions for implementing the CDF of the Maxwell distribution in the `sympy/stats/crv_types.py` file. It includes the necessary formula, references to the error function, and a pseudo code example that can be directly used in the implementation. The RESPONSE also guides the user to the relevant sections of the existing codebase where modifications are needed and suggests testing the implementation by creating a Maxwell distribution object and calling the `cdf` method. The RESPONSE is comprehensive and addresses all aspects of the feature request, providing actionable guidance for the successful addition of the CDF to the Maxwell distribution.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711748307.533781,
        "result": "To implement the Cumulative Distribution Function (CDF) for the Maxwell distribution in the `sympy/stats/crv_types.py` file, you can follow these steps:\n\n- Add a `_cdf` method to the `MaxwellDistribution` class.\n- Use the formula for the CDF of the Maxwell distribution, which can be derived from the PDF by integrating it from 0 to x.\n- The CDF of the Maxwell distribution is not elementary, but it can be expressed in terms of the error function `erf` and the square root function `sqrt`.\n- The CDF formula for the Maxwell distribution is given by:\n\n  \\[ F(x) = \\text{erf}\\left(\\frac{x}{\\sqrt{2}a}\\right) - \\sqrt{\\frac{2}{\\pi}} \\frac{x e^{-\\frac{x^2}{2a^2}}}{a} \\]\n\n- Import the `erf` function from `sympy.functions.special.error_functions`.\n- Use the `integrate` function from `sympy` to perform the integration if necessary.\n\nHere is the pseudo code for the `_cdf` method:\n\n```python\nfrom sympy import erf, sqrt, exp, pi\n\nclass MaxwellDistribution(SingleContinuousDistribution):\n    # ... existing code ...\n\n    def _cdf(self, x):\n        a = self.a\n        cdf = erf(x / (sqrt(2) * a)) - sqrt(2/pi) * (x * exp(-x**2 / (2 * a**2)) / a)\n        return cdf\n```\n\nAnd you would add this method to the `MaxwellDistribution` class in the `sympy/stats/crv_types.py` file. The `a` parameter is the scale parameter of the Maxwell distribution, which is already defined in the class.\n\nRemember to add the `_cdf` method within the `MaxwellDistribution` class and ensure that it uses the correct symbols and parameters as defined in the class. The `erf` function is already imported in the provided codebase, so you can use it directly.\n\nAfter implementing the `_cdf` method, you can test it by creating a Maxwell distribution object and calling the `cdf` method on it, which should now use the newly implemented `_cdf` method internally.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 2517 - 2597](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L2517-L2597)\n\n This snippet defines the Maxwell distribution and will need to be modified to include the CDF function. \n\n\n   - [Lines 1758 - 1851](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L1758-L1851)\n\n This snippet shows an example of how the CDF is implemented for another distribution (inverse Gamma distribution), which could serve as a reference for implementing the CDF for the Maxwell distribution.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 903 - 1263](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/rv.py#L903-L1263)\n\n This snippet contains the general implementation of the CDF function for random expressions and may need to be referenced for implementing the CDF of the Maxwell distribution.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [functions](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/functions) \u2192 [special](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/functions/special)- [Lines 239 - 239](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/functions/special/error_functions.py#L239-L239)\n\n The erfc function is related to the error function, which is often used in the computation of CDFs for various distributions, and may be needed for the Maxwell distribution CDF."
    }
}