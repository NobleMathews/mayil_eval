{
    "id": "sympy__sympy-21931",
    "repo_name": "testbed/sympy__sympy__1.9",
    "task_id": 203957853647311202,
    "title": "nicer printing of Permutation (and others)",
    "body": "Perhaps Partition's args print with FiniteSet because the args were made to be SymPy types. But the printing need not be so verbose. \r\n\r\n```python\r\n>>> Partition([1,2])\r\nPartition(FiniteSet(1, 2))\r\n>>> Partition({1,2})\r\nPartition(FiniteSet(1, 2))\r\n```\r\nPrinting of its (and other combinatoric funcs as pertinent) args can be done with lists, tuples or sets as community preferences dictate, e.g. `Partition([1,2])` or `Partition({1,2})`, the latter more suggestive that the parts of the Partition are subsets of the set from which they were taken.\nnicer printing of Permutation (and others)\nPerhaps Partition's args print with FiniteSet because the args were made to be SymPy types. But the printing need not be so verbose. \r\n\r\n```python\r\n>>> Partition([1,2])\r\nPartition(FiniteSet(1, 2))\r\n>>> Partition({1,2})\r\nPartition(FiniteSet(1, 2))\r\n```\r\nPrinting of its (and other combinatoric funcs as pertinent) args can be done with lists, tuples or sets as community preferences dictate, e.g. `Partition([1,2])` or `Partition({1,2})`, the latter more suggestive that the parts of the Partition are subsets of the set from which they were taken.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sympy__sympy__1.9.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `__repr__` method of the `Partition` class to print the internal `FiniteSet` representation as a list, tuple, or set, according to community preferences.\n- Ensure that the `__repr__` method checks the type of the input iterable and formats the output accordingly.\n- If the input is a list or tuple, use the same type for printing. If the input is a set, print as a set.\n\n```python\nclass Partition(FiniteSet):\n    def __init__(self, iterable):\n        super().__init__(*iterable)\n        self.input_type = type(iterable)\n\n    def __repr__(self):\n        elements = list(self.args)\n        if self.input_type in (list, tuple):\n            return f\"{self.input_type.__name__}({elements})\"\n        elif self.input_type is set:\n            return f\"set({elements})\"\n        else:\n            return super().__repr__()\n```\n\n- Ensure that the `Partition` class correctly stores the type of the input iterable during initialization.\n- Adjust the `__repr__` method to check the stored input type and format the output as desired.\n- If the input type is not a list, tuple, or set, default to the parent class's `__repr__` method.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [combinatorics](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/combinatorics)- [Lines 12 - 12](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/combinatorics/partitions.py#L12-L12)\n\n This snippet defines the Partition class inheriting from FiniteSet, which is directly related to the issue of verbose printing of Partition instances.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [printing](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/printing) \u2192 [pretty](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/printing/pretty)- [Lines 372 - 422](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/printing/pretty/pretty.py#L372-L422)\n\n This snippet contains the pretty printing methods for combinatoric functions like Permutation, which may need to be modified to address the printing issue for Partition and similar functions.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [functions](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/functions) \u2192 [combinatorial](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/functions/combinatorial)- [Lines 45 - 1408](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/functions/combinatorial/numbers.py#L45-L1408)\n\n This snippet defines the partition function and may contain relevant information on how Partition objects are constructed and printed.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00029299999999999997,
        "snippet_processor": 0.08825000000000001,
        "issue_star_creation": 0.02848,
        "issue_star_solver": 0.0763,
        "bouncer": 0.032920000000000005
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711744099.405438,
        "relevant_snippets": [
            {
                "code": "class Partition(FiniteSet):",
                "filename": "sympy/combinatorics/partitions.py",
                "start_index": 371,
                "end_index": 398,
                "start_line": 12,
                "end_line": 12,
                "max_line": 730,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "from sympy.combinatorics import Permutation as Perm\nfrom sympy.combinatorics.perm_groups import PermutationGroup\nfrom sympy.core import Basic, Tuple\nfrom sympy.core.compatibility import as_int\nfrom sympy.sets import FiniteSet\nfrom sympy.utilities.iterables import (minlex, unflatten, flatten)\n\nrmul = Perm.rmul",
                "filename": "sympy/combinatorics/polyhedron.py",
                "start_index": 0,
                "end_index": 310,
                "start_line": 1,
                "end_line": 8,
                "max_line": 1010,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "def _print_Cycle(self, dc):\n        from sympy.combinatorics.permutations import Permutation, Cycle\n        # for Empty Cycle\n        if dc == Cycle():\n            cyc = stringPict('')\n            return prettyForm(*cyc.parens())\n\n        dc_list = Permutation(dc.list()).cyclic_form\n        # for Identity Cycle\n        if dc_list == []:\n            cyc = self._print(dc.size - 1)\n            return prettyForm(*cyc.parens())\n\n        cyc = stringPict('')\n        for i in dc_list:\n            l = self._print(str(tuple(i)).replace(',', ''))\n            cyc = prettyForm(*cyc.right(l))\n        return cyc\n\n    def _print_Permutation(self, expr):\n        from sympy.combinatorics.permutations import Permutation, Cycle\n\n        perm_cyclic = Permutation.print_cyclic\n        if perm_cyclic is not None:\n            SymPyDeprecationWarning(\n                feature=\"Permutation.print_cyclic = {}\".format(perm_cyclic),\n                useinstead=\"init_printing(perm_cyclic={})\"\n                .format(perm_cyclic),\n                issue=15201,\n                deprecated_since_version=\"1.6\").warn()\n        else:\n            perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n\n        if perm_cyclic:\n            return self._print_Cycle(Cycle(expr))\n\n        lower = expr.array_form\n        upper = list(range(len(lower)))\n\n        result = stringPict('')\n        first = True\n        for u, l in zip(upper, lower):\n            s1 = self._print(u)\n            s2 = self._print(l)\n            col = prettyForm(*s1.below(s2))\n            if first:\n                first = False\n            else:\n                col = prettyForm(*col.left(\" \"))\n            result = prettyForm(*result.right(col))\n        return prettyForm(*result.parens())",
                "filename": "sympy/printing/pretty/pretty.py",
                "start_index": 12535,
                "end_index": 14276,
                "start_line": 372,
                "end_line": 422,
                "max_line": 2718,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    A permutation, alternatively known as an 'arrangement number' or 'ordering'\n    is an arrangement of the elements of an ordered list into a one-to-one\n    mapping with itself. The permutation of a given arrangement is given by\n    indicating the positions of the elements after re-arrangement [2]_. For\n    example, if one started with elements [x, y, a, b] (in that order) and\n    they were reordered as [x, y, b, a] then the permutation would be\n    [0, 1, 3, 2]. Notice that (in SymPy) the first element is always referred\n    to as 0 and the permutation uses the indices of the elements in the\n    original ordering, not the elements (a, b, etc...) themselves.\n\n    >>> from sympy.combinatorics import Permutation\n    >>> from sympy.interactive import init_printing\n    >>> init_printing(perm_cyclic=False, pretty_print=False)\n\n    Permutations Notation\n    =====================\n\n    Permutations are commonly represented in disjoint cycle or array forms.\n\n    Array Notation and 2-line Form\n    ------------------------------------\n\n    In the 2-line form, the elements and their final positions are shown\n    as a matrix with 2 rows:\n\n    [0    1    2     ... n-1]\n    [p(0) p(1) p(2)  ... p(n-1)]\n\n    Since the first line is always range(n), where n is the size of p,\n    it is sufficient to represent the permutation by the second line,\n    referred to as the \"array form\" of the permutation. This is entered\n    in brackets as the argument to the Permutation class:\n\n    >>> p = Permutation([0, 2, 1]); p\n    Permutation([0, 2, 1])\n\n    Given i in range(p.size), the permutation maps i to i^p\n\n    >>> [i^p for i in range(p.size)]\n    [0, 2, 1]\n\n    The composite of two permutations p*q means first apply p, then q, so\n    i^(p*q) = (i^p)^q which is i^p^q according to Python precedence rules:\n\n    >>> q = Permutation([2, 1, 0])\n    >>> [i^p^q for i in range(3)]\n    [2, 0, 1]\n    >>> [i^(p*q) for i in range(3)]\n    [2, 0, 1]\n\n    One can use also the notation p(i) = i^p, but then the composition\n    rule is (p*q)(i) = q(p(i)), not p(q(i)):\n\n    >>> [(p*q)(i) for i in range(p.size)]\n    [2, 0, 1]\n    >>> [q(p(i)) for i in range(p.size)]\n    [2, 0, 1]\n    >>> [p(q(i)) for i in range(p.size)]\n    [1, 2, 0]\n\n    Disjoint Cycle Notation\n    -----------------------\n\n    In disjoint cycle notation, only the elements that have shifted are\n    indicated. In the above case, the 2 and 1 switched places. This can\n    be entered in two ways:\n\n    >>> Permutation(1, 2) == Permutation([[1, 2]]) == p\n    True\n\n    Only the relative ordering of elements in a cycle matter:\n\n    >>> Permutation(1,2,3) == Permutation(2,3,1) == Permutation(3,1,2)\n    True\n\n    The disjoint cycle notation is convenient when representing\n    permutations that have several cycles in them:\n\n    >>> Permutation(1, 2)(3, 5) == Permutation([[1, 2], [3, 5]])\n    True\n\n    It also provides some economy in entry when computing products of\n    permutations that are written in disjoint cycle notation:\n\n    >>> Permutation(1, 2)(1, 3)(2, 3)\n    Permutation([0, 3, 2, 1])\n    >>> _ == Permutation([[1, 2]])*Permutation([[1, 3]])*Permutation([[2, 3]])\n    True\n\n        Caution: when the cycles have common elements\n        between them then the order in which the\n        permutations are applied matters. The\n        convention is that the permutations are\n        applied from *right to left*. In the following, the\n        transposition of elements 2 and 3 is followed\n        by the transposition of elements 1 and 2:\n\n        >>> Permutation(1, 2)(2, 3) == Permutation([(1, 2), (2, 3)])\n        True\n        >>> Permutation(1, 2)(2, 3).list()\n        [0, 3, 1, 2]\n\n        If the first and second elements had been\n        swapped first, followed by the swapping of the second\n        and third, the result would have been [0, 2, 3, 1].\n        If, for some reason, you want to apply the cycles\n        in the order they are entered, you can simply reverse\n        the order of cycles:\n\n        >>> Permutation([(1, 2), (2, 3)][::-1]).list()\n        [0, 2, 3, 1]\n\n    Entering a singleton in a permutation is a way to indicate the size of the\n    permutation. The ``size`` keyword can also be used.\n\n    Array-form entry:\n\n    >>> Permutation([[1, 2], [9]])\n    Permutation([0, 2, 1], size=10)\n    >>> Permutation([[1, 2]], size=10)\n    Permutation([0, 2, 1], size=10)\n\n    Cyclic-form entry:\n\n    >>> Permutation(1, 2, size=10)\n    Permutation([0, 2, 1], size=10)\n    >>> Permutation(9)(1, 2)\n    Permutation([0, 2, 1], size=10)\n\n    Caution: no singleton containing an element larger than the largest\n    in any previous cycle can be entered. This is an important difference\n    in how Permutation and Cycle handle the __call__ syntax. A singleton\n    argument at the start of a Permutation performs instantiation of the\n    Permutation and is permitted:\n\n    >>> Permutation(5)\n    Permutation([], size=6)\n\n    A singleton entered after instantiation is a call to the permutation\n    -- a function call -- and if the argument is out of range it will\n    trigger an error. For this reason, it is better to start the cycle\n    with the singleton:\n\n    The following fails because there is no element 3:\n\n    >>> Permutation(1, 2)(3)\n    Traceback (most recent call last):\n    ...\n    IndexError: list index out of range\n\n    This is ok: only the call to an out of range singleton is prohibited;\n    otherwise the permutation autosizes:\n\n    >>> Permutation(3)(1, 2)\n    Permutation([0, 2, 1, 3])\n    >>> Permutation(1, 2)(3, 4) == Permutation(3, 4)(1, 2)\n    True\n\n\n    Equality testing\n    ----------------\n\n    The array forms must be the same in order for permutations to be equal:\n\n    >>> Permutation([1, 0, 2, 3]) == Permutation([1, 0])\n    False\n\n\n    Identity Permutation\n    --------------------\n\n    The identity permutation is a permutation in which no element is out of\n    place. It can be entered in a variety of ways. All the following create\n    an identity permutation of size 4:\n\n    >>> I = Permutation([0, 1, 2, 3])\n    >>> all(p == I for p in [\n    ... Permutation(3),\n    ... Permutation(range(4)),\n    ... Permutation([], size=4),\n    ... Permutation(size=4)])\n    True\n\n    Watch out for entering the range *inside* a set of brackets (which is\n    cycle notation):\n\n    >>> I == Permutation([range(4)])\n    False\n\n\n    Permutation Printing\n    ====================\n\n    There are a few things to note about how Permutations are printed.\n\n    1) If you prefer one form (array or cycle) over another, you can set\n    ``init_printing`` with the ``perm_cyclic`` flag.\n\n    >>> from sympy import init_printing\n    >>> p = Permutation(1, 2)(4, 5)(3, 4)\n    >>> p\n    Permutation([0, 2, 1, 4, 5, 3])\n\n    >>> init_printing(perm_cyclic=True, pretty_print=False)\n    >>> p\n    (1 2)(3 4 5)\n\n    2) Regardless of the setting, a list of elements in the array for cyclic\n    form can be obtained and either of those can be copied and supplied as\n    the argument to Permutation:\n\n    >>> p.array_form\n    [0, 2, 1, 4, 5, 3]\n    >>> p.cyclic_form\n    [[1, 2], [3, 4, 5]]\n    >>> Permutation(_) == p\n    True\n\n    3) Printing is economical in that as little as possible is printed while\n    retaining all information about the size of the permutation:\n\n    >>> init_printing(perm_cyclic=False, pretty_print=False)\n    >>> Permutation([1, 0, 2, 3])\n    Permutation([1, 0, 2, 3])\n    >>> Permutation([1, 0, 2, 3], size=20)\n    Permutation([1, 0], size=20)\n    >>> Permutation([1, 0, 2, 4, 3, 5, 6], size=20)\n    Permutation([1, 0, 2, 4, 3], size=20)\n\n    >>> p = Permutation([1, 0, 2, 3])\n    >>> init_printing(perm_cyclic=True, pretty_print=False)\n    >>> p\n    (3)(0 1)\n    >>> init_printing(perm_cyclic=False, pretty_print=False)\n\n    The 2 was not printed but it is still there as can be seen with the\n    array_form and size methods:\n\n    >>> p.array_form\n    [1, 0, 2, 3]\n    >>> p.size\n    4\n\n    Short introduction to other methods\n    ===================================\n\n    The permutation can act as a bijective function, telling what element is\n    located at a given position\n\n    >>> q = Permutation([5, 2, 3, 4, 1, 0])\n    >>> q.array_form[1] # the hard way\n    2\n    >>> q(1) # the easy way\n    2\n    >>> {i: q(i) for i in range(q.size)} # showing the bijection\n    {0: 5, 1: 2, 2: 3, 3: 4, 4: 1, 5: 0}\n\n    The full cyclic form (including singletons) can be obtained:\n\n    >>> p.full_cyclic_form\n    [[0, 1], [2], [3]]\n\n    Any permutation can be factored into transpositions of pairs of elements:\n\n    >>> Permutation([[1, 2], [3, 4, 5]]).transpositions()\n    [(1, 2), (3, 5), (3, 4)]\n    >>> Permutation.rmul(*[Permutation([ti], size=6) for ti in _]).cyclic_form\n    [[1, 2], [3, 4, 5]]\n\n    The number of permutations on a set of n elements is given by n! and is\n    called the cardinality.\n\n    >>> p.size\n    4\n    >>> p.cardinality\n    24\n\n    A given permutation has a rank among all the possible permutations of the\n    same elements, but what that rank is depends on how the permutations are\n    enumerated. (There are a number of different methods of doing so.) The\n    lexicographic rank is given by the rank method and this rank is used to\n    increment a permutation with addition/subtraction:\n\n    >>> p.rank()\n    6\n    >>> p + 1\n    Permutation([1, 0, 3, 2])\n    >>> p.next_lex()\n    Permutation([1, 0, 3, 2])\n    >>> _.rank()\n    7\n    >>> p.unrank_lex(p.size, rank=7)\n    Permutation([1, 0, 3, 2])\n\n    The product of two permutations p and q is defined as their composition as\n    functions, (p*q)(i) = q(p(i)) [6]_.\n\n    >>> p = Permutation([1, 0, 2, 3])\n    >>> q = Permutation([2, 3, 1, 0])\n    >>> list(q*p)\n    [2, 3, 0, 1]\n    >>> list(p*q)\n    [3, 2, 1, 0]\n    >>> [q(p(i)) for i in range(p.size)]\n    [3, 2, 1, 0]\n\n    The permutation can be 'applied' to any list-like object, not only\n    Permutations:\n\n    >>> p(['zero', 'one', 'four', 'two'])\n    ['one', 'zero', 'four', 'two']\n    >>> p('zo42')\n    ['o', 'z', '4', '2']\n\n    If you have a list of arbitrary elements, the corresponding permutation\n    can be found with the from_sequence method:\n\n    >>> Permutation.from_sequence('SymPy')\n    Permutation([1, 3, 2, 0, 4])\n\n    See Also\n    ========\n\n    Cycle\n\n    References\n    ==========\n\n    .. [1] Skiena, S. 'Permutations.' 1.1 in Implementing Discrete Mathematics\n           Combinatorics and Graph Theory with Mathematica.  Reading, MA:\n           Addison-Wesley, pp. 3-16, 1990.\n\n    .. [2] Knuth, D. E. The Art of Computer Programming, Vol. 4: Combinatorial\n           Algorithms, 1st ed. Reading, MA: Addison-Wesley, 2011.\n\n    .. [3] Wendy Myrvold and Frank Ruskey. 2001. Ranking and unranking\n           permutations in linear time. Inf. Process. Lett. 79, 6 (September 2001),\n           281-284. DOI=10.1016/S0020-0190(01)00141-7\n\n    .. [4] D. L. Kreher, D. R. Stinson 'Combinatorial Algorithms'\n           CRC Press, 1999\n\n    .. [5] Graham, R. L.; Knuth, D. E.; and Patashnik, O.\n           Concrete Mathematics: A Foundation for Computer Science, 2nd ed.\n           Reading, MA: Addison-Wesley, 1994.\n\n    .. [6] https://en.wikipedia.org/wiki/Permutation#Product_and_inverse\n\n    .. [7] https://en.wikipedia.org/wiki/Lehmer_code\n\n    \"\"\"",
                "filename": "sympy/combinatorics/permutations.py",
                "start_index": 12014,
                "end_index": 23226,
                "start_line": 20,
                "end_line": 3007,
                "max_line": 3024,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "#                                                                            #\n#                           Partition numbers                                #\n#                                                                            #\n#----------------------------------------------------------------------------#\n\n_npartition = [1, 1]\nclass partition(Function):\n    r\"\"\"\n    Partition numbers\n\n    The Partition numbers are a sequence of integers `p_n` that represent the\n    number of distinct ways of representing `n` as a sum of natural numbers\n    (with order irrelevant). The generating function for `p_n` is given by:\n\n    .. math:: \\sum_{n=0}^\\infty p_n x^n = \\prod_{k=1}^\\infty (1 - x^k)^{-1}\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol\n    >>> from sympy.functions import partition\n    >>> [partition(n) for n in range(9)]\n    [1, 1, 2, 3, 5, 7, 11, 15, 22]\n    >>> n = Symbol('n', integer=True, negative=True)\n    >>> partition(n)\n    0\n\n    See Also\n    ========\n\n    bell, bernoulli, catalan, euler, fibonacci, harmonic, lucas, genocchi, tribonacci\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Partition_(number_theory%29\n    .. [2] https://en.wikipedia.org/wiki/Pentagonal_number_theorem\n\n    \"\"\"\n\n    @staticmethod\n    def _partition(n):\n        L = len(_npartition)\n        if n < L:\n            return _npartition[n]\n        # lengthen cache\n        for _n in range(L, n + 1):\n            v, p, i = 0, 0, 0\n            while 1:\n                s = 0\n                p += 3*i + 1  # p = pentagonal number: 1, 5, 12, ...\n                if _n >= p:\n                    s += _npartition[_n - p]\n                i += 1\n                gp = p + i  # gp = generalized pentagonal: 2, 7, 15, ...\n                if _n >= gp:\n                    s += _npartition[_n - gp]\n                if s == 0:\n                    break\n                else:\n                    v += s if i%2 == 1 else -s\n            _npartition.append(v)\n        return v\n\n    @classmethod\n    def eval(cls, n):\n        is_int = n.is_integer\n        if is_int == False:\n            raise ValueError(\"Partition numbers are defined only for \"\n                             \"integers\")\n        elif is_int:\n            if n.is_negative:\n                return S.Zero\n\n            if n.is_zero or (n - 1).is_zero:\n                return S.One\n\n            if n.is_Integer:\n                return Integer(cls._partition(n))\n\n\n    def _eval_is_integer(self):\n        if self.args[0].is_integer:\n            return True\n\n    def _eval_is_negative(self):\n        if self.args[0].is_integer:\n            return False\n\n    def _eval_is_positive(self):\n        n = self.args[0]\n        if n.is_nonnegative and n.is_integer:\n            return True\n\n\n#######################################################################\n###\n### Functions for enumerating partitions, permutations and combinations\n###\n#######################################################################",
                "filename": "sympy/functions/combinatorial/numbers.py",
                "start_index": 42637,
                "end_index": 45626,
                "start_line": 45,
                "end_line": 1408,
                "max_line": 2046,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "from __future__ import print_function, division\n\nimport itertools\n\nfrom sympy.core import S\nfrom sympy.core.containers import Tuple\nfrom sympy.core.function import _coeff_isneg\nfrom sympy.core.mul import Mul\nfrom sympy.core.numbers import Rational\nfrom sympy.core.power import Pow\nfrom sympy.core.symbol import Symbol\nfrom sympy.core.sympify import SympifyError\nfrom sympy.printing.conventions import requires_partial\nfrom sympy.printing.precedence import PRECEDENCE, precedence, precedence_traditional\nfrom sympy.printing.printer import Printer\nfrom sympy.printing.str import sstr\nfrom sympy.utilities import default_sort_key\nfrom sympy.utilities.iterables import has_variety\nfrom sympy.utilities.exceptions import SymPyDeprecationWarning\n\nfrom sympy.printing.pretty.stringpict import prettyForm, stringPict\nfrom sympy.printing.pretty.pretty_symbology import xstr, hobj, vobj, xobj, \\\n    xsym, pretty_symbol, pretty_atom, pretty_use_unicode, greek_unicode, U, \\\n    pretty_try_use_unicode,  annotated\n\n# rename for usage from outside\npprint_use_unicode = pretty_use_unicode\npprint_try_use_unicode = pretty_try_use_unicode",
                "filename": "sympy/printing/pretty/pretty.py",
                "start_index": 0,
                "end_index": 1123,
                "start_line": 1,
                "end_line": 28,
                "max_line": 2718,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "def _print_AccumulationBounds(self, i):\n        left = '<'\n        right = '>'\n\n        return self._print_seq(i.args[:2], left, right)\n\n    def _print_Intersection(self, u):\n\n        delimiter = ' %s ' % pretty_atom('Intersection', 'n')\n\n        return self._print_seq(u.args, None, None, delimiter,\n                               parenthesize=lambda set: set.is_ProductSet or\n                               set.is_Union or set.is_Complement)\n\n    def _print_Union(self, u):\n\n        union_delimiter = ' %s ' % pretty_atom('Union', 'U')\n\n        return self._print_seq(u.args, None, None, union_delimiter,\n                               parenthesize=lambda set: set.is_ProductSet or\n                               set.is_Intersection or set.is_Complement)\n\n    def _print_SymmetricDifference(self, u):\n        if not self._use_unicode:\n            raise NotImplementedError(\"ASCII pretty printing of SymmetricDifference is not implemented\")\n\n        sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')\n\n        return self._print_seq(u.args, None, None, sym_delimeter)\n\n    def _print_Complement(self, u):\n\n        delimiter = r' \\ '\n\n        return self._print_seq(u.args, None, None, delimiter,\n             parenthesize=lambda set: set.is_ProductSet or set.is_Intersection\n                               or set.is_Union)\n\n    def _print_ImageSet(self, ts):\n        if self._use_unicode:\n            inn = u\"\\N{SMALL ELEMENT OF}\"\n        else:\n            inn = 'in'\n        fun = ts.lamda\n        sets = ts.base_sets\n        signature = fun.signature\n        expr = self._print(fun.expr)\n        bar = self._print(\"|\")\n        if len(signature) == 1:\n            return self._print_seq((expr, bar, signature[0], inn, sets[0]), \"{\", \"}\", ' ')\n        else:\n            pargs = tuple(j for var, setv in zip(signature, sets) for j in (var, inn, setv, \",\"))\n            return self._print_seq((expr, bar) + pargs[:-1], \"{\", \"}\", ' ')\n\n    def _print_ConditionSet(self, ts):\n        if self._use_unicode:\n            inn = u\"\\N{SMALL ELEMENT OF}\"\n            # using _and because and is a keyword and it is bad practice to\n            # overwrite them\n            _and = u\"\\N{LOGICAL AND}\"\n        else:\n            inn = 'in'\n            _and = 'and'\n\n        variables = self._print_seq(Tuple(ts.sym))\n        as_expr = getattr(ts.condition, 'as_expr', None)\n        if as_expr is not None:\n            cond = self._print(ts.condition.as_expr())\n        else:\n            cond = self._print(ts.condition)\n            if self._use_unicode:\n                cond = self._print(cond)\n                cond = prettyForm(*cond.parens())\n\n        bar = self._print(\"|\")\n\n        if ts.base_set is S.UniversalSet:\n            return self._print_seq((variables, bar, cond), \"{\", \"}\", ' ')\n\n        base = self._print(ts.base_set)\n        return self._print_seq((variables, bar, variables, inn,\n                                base, _and, cond), \"{\", \"}\", ' ')",
                "filename": "sympy/printing/pretty/pretty.py",
                "start_index": 70377,
                "end_index": 73335,
                "start_line": 1990,
                "end_line": 2071,
                "max_line": 2718,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "\"\"\"\nAlgorithms and classes to support enumerative combinatorics.\n\nCurrently just multiset partitions, but more could be added.\n\nTerminology (following Knuth, algorithm 7.1.2.5M TAOCP)\n*multiset* aaabbcccc has a *partition* aaabc | bccc\n\nThe submultisets, aaabc and bccc of the partition are called\n*parts*, or sometimes *vectors*.  (Knuth notes that multiset\npartitions can be thought of as partitions of vectors of integers,\nwhere the ith element of the vector gives the multiplicity of\nelement i.)\n\nThe values a, b and c are *components* of the multiset.  These\ncorrespond to elements of a set, but in a multiset can be present\nwith a multiplicity greater than 1.\n\nThe algorithm deserves some explanation.\n\nThink of the part aaabc from the multiset above.  If we impose an\nordering on the components of the multiset, we can represent a part\nwith a vector, in which the value of the first element of the vector\ncorresponds to the multiplicity of the first component in that\npart. Thus, aaabc can be represented by the vector [3, 1, 1].  We\ncan also define an ordering on parts, based on the lexicographic\nordering of the vector (leftmost vector element, i.e., the element\nwith the smallest component number, is the most significant), so\nthat [3, 1, 1] > [3, 1, 0] and [3, 1, 1] > [2, 1, 4].  The ordering\non parts can be extended to an ordering on partitions: First, sort\nthe parts in each partition, left-to-right in decreasing order. Then\npartition A is greater than partition B if A's leftmost/greatest\npart is greater than B's leftmost part.  If the leftmost parts are\nequal, compare the second parts, and so on.\n\nIn this ordering, the greatest partition of a given multiset has only\none part.  The least partition is the one in which the components\nare spread out, one per part.\n\nThe enumeration algorithms in this file yield the partitions of the\nargument multiset in decreasing order.  The main data structure is a\nstack of parts, corresponding to the current partition.  An\nimportant invariant is that the parts on the stack are themselves in\ndecreasing order.  This data structure is decremented to find the\nnext smaller partition.  Most often, decrementing the partition will\nonly involve adjustments to the smallest parts at the top of the\nstack, much as adjacent integers *usually* differ only in their last\nfew digits.\n\nKnuth's algorithm uses two main operations on parts:\n\nDecrement - change the part so that it is smaller in the\n  (vector) lexicographic order, but reduced by the smallest amount possible.\n  For example, if the multiset has vector [5,\n  3, 1], and the bottom/greatest part is [4, 2, 1], this part would\n  decrement to [4, 2, 0], while [4, 0, 0] would decrement to [3, 3,\n  1].  A singleton part is never decremented -- [1, 0, 0] is not\n  decremented to [0, 3, 1].  Instead, the decrement operator needs\n  to fail for this case.  In Knuth's pseudocode, the decrement\n  operator is step m5.\n\nSpread unallocated multiplicity - Once a part has been decremented,\n  it cannot be the rightmost part in the partition.  There is some\n  multiplicity that has not been allocated, and new parts must be\n  created above it in the stack to use up this multiplicity.  To\n  maintain the invariant that the parts on the stack are in\n  decreasing order, these new parts must be less than or equal to\n  the decremented part.\n  For example, if the multiset is [5, 3, 1], and its most\n  significant part has just been decremented to [5, 3, 0], the\n  spread operation will add a new part so that the stack becomes\n  [[5, 3, 0], [0, 0, 1]].  If the most significant part (for the\n  same multiset) has been decremented to [2, 0, 0] the stack becomes\n  [[2, 0, 0], [2, 0, 0], [1, 3, 1]].  In the pseudocode, the spread\n  operation for one part is step m2.  The complete spread operation\n  is a loop of steps m2 and m3.\n\nIn order to facilitate the spread operation, Knuth stores, for each\ncomponent of each part, not just the multiplicity of that component\nin the part, but also the total multiplicity available for this\ncomponent in this part or any lesser part above it on the stack.\n\nOne added twist is that Knuth does not represent the part vectors as\narrays. Instead, he uses a sparse representation, in which a\ncomponent of a part is represented as a component number (c), plus\nthe multiplicity of the component in that part (v) as well as the\ntotal multiplicity available for that component (u).  This saves\ntime that would be spent skipping over zeros.\n\n\"\"\"",
                "filename": "sympy/utilities/enumerative.py",
                "start_index": 49,
                "end_index": 4521,
                "start_line": 3,
                "end_line": 1148,
                "max_line": 1155,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "def _print_Cycle(self, expr):\n        from sympy.combinatorics.permutations import Permutation\n        if expr.size == 0:\n            return r\"\\left( \\right)\"\n        expr = Permutation(expr)\n        expr_perm = expr.cyclic_form\n        siz = expr.size\n        if expr.array_form[-1] == siz - 1:\n            expr_perm = expr_perm + [[siz - 1]]\n        term_tex = ''\n        for i in expr_perm:\n            term_tex += str(i).replace(',', r\"\\;\")\n        term_tex = term_tex.replace('[', r\"\\left( \")\n        term_tex = term_tex.replace(']', r\"\\right)\")\n        return term_tex\n\n    def _print_Permutation(self, expr):\n        from sympy.combinatorics.permutations import Permutation\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n\n        perm_cyclic = Permutation.print_cyclic\n        if perm_cyclic is not None:\n            SymPyDeprecationWarning(\n                feature=\"Permutation.print_cyclic = {}\".format(perm_cyclic),\n                useinstead=\"init_printing(perm_cyclic={})\"\n                .format(perm_cyclic),\n                issue=15201,\n                deprecated_since_version=\"1.6\").warn()\n        else:\n            perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n\n        if perm_cyclic:\n            return self._print_Cycle(expr)\n\n        if expr.size == 0:\n            return r\"\\left( \\right)\"\n\n        lower = [self._print(arg) for arg in expr.array_form]\n        upper = [self._print(arg) for arg in range(len(lower))]\n\n        row1 = \" & \".join(upper)\n        row2 = \" & \".join(lower)\n        mat = r\" \\\\ \".join((row1, row2))\n        return r\"\\begin{pmatrix} %s \\end{pmatrix}\" % mat\n\n\n    def _print_AppliedPermutation(self, expr):\n        perm, var = expr.args\n        return r\"\\sigma_{%s}(%s)\" % (self._print(perm), self._print(var))\n\n    def _print_Float(self, expr):\n        # Based off of that in StrPrinter\n        dps = prec_to_dps(expr._prec)\n        strip = False if self._settings['full_prec'] else True\n        low = self._settings[\"min\"] if \"min\" in self._settings else None\n        high = self._settings[\"max\"] if \"max\" in self._settings else None\n        str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)\n\n        # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n        # thus we use the number separator\n        separator = self._settings['mul_symbol_latex_numbers']\n\n        if 'e' in str_real:\n            (mant, exp) = str_real.split('e')\n\n            if exp[0] == '+':\n                exp = exp[1:]\n            if self._settings['decimal_separator'] == 'comma':\n                mant = mant.replace('.','{,}')\n\n            return r\"%s%s10^{%s}\" % (mant, separator, exp)\n        elif str_real == \"+inf\":\n            return r\"\\infty\"\n        elif str_real == \"-inf\":\n            return r\"- \\infty\"\n        else:\n            if self._settings['decimal_separator'] == 'comma':\n                str_real = str_real.replace('.','{,}')\n            return str_real",
                "filename": "sympy/printing/latex.py",
                "start_index": 12209,
                "end_index": 15191,
                "start_line": 370,
                "end_line": 448,
                "max_line": 2941,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            },
            {
                "code": "def _print_frozenset(self, s):\n        if not s:\n            return prettyForm('frozenset()')\n        items = sorted(s, key=default_sort_key)\n        pretty = self._print_seq(items)\n        pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))\n        pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))\n        pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))\n        return pretty\n\n    def _print_UniversalSet(self, s):\n        if self._use_unicode:\n            return prettyForm(u\"\\N{MATHEMATICAL DOUBLE-STRUCK CAPITAL U}\")\n        else:\n            return prettyForm('UniversalSet')\n\n    def _print_PolyRing(self, ring):\n        return prettyForm(sstr(ring))\n\n    def _print_FracField(self, field):\n        return prettyForm(sstr(field))\n\n    def _print_FreeGroupElement(self, elm):\n        return prettyForm(str(elm))\n\n    def _print_PolyElement(self, poly):\n        return prettyForm(sstr(poly))\n\n    def _print_FracElement(self, frac):\n        return prettyForm(sstr(frac))\n\n    def _print_AlgebraicNumber(self, expr):\n        if expr.is_aliased:\n            return self._print(expr.as_poly().as_expr())\n        else:\n            return self._print(expr.as_expr())\n\n    def _print_ComplexRootOf(self, expr):\n        args = [self._print_Add(expr.expr, order='lex'), expr.index]\n        pform = prettyForm(*self._print_seq(args).parens())\n        pform = prettyForm(*pform.left('CRootOf'))\n        return pform\n\n    def _print_RootSum(self, expr):\n        args = [self._print_Add(expr.expr, order='lex')]\n\n        if expr.fun is not S.IdentityFunction:\n            args.append(self._print(expr.fun))\n\n        pform = prettyForm(*self._print_seq(args).parens())\n        pform = prettyForm(*pform.left('RootSum'))\n\n        return pform\n\n    def _print_FiniteField(self, expr):\n        if self._use_unicode:\n            form = u'\\N{DOUBLE-STRUCK CAPITAL Z}_%d'\n        else:\n            form = 'GF(%d)'\n\n        return prettyForm(pretty_symbol(form % expr.mod))\n\n    def _print_IntegerRing(self, expr):\n        if self._use_unicode:\n            return prettyForm(u'\\N{DOUBLE-STRUCK CAPITAL Z}')\n        else:\n            return prettyForm('ZZ')\n\n    def _print_RationalField(self, expr):\n        if self._use_unicode:\n            return prettyForm(u'\\N{DOUBLE-STRUCK CAPITAL Q}')\n        else:\n            return prettyForm('QQ')\n\n    def _print_RealField(self, domain):\n        if self._use_unicode:\n            prefix = u'\\N{DOUBLE-STRUCK CAPITAL R}'\n        else:\n            prefix = 'RR'\n\n        if domain.has_default_precision:\n            return prettyForm(prefix)\n        else:\n            return self._print(pretty_symbol(prefix + \"_\" + str(domain.precision)))",
                "filename": "sympy/printing/pretty/pretty.py",
                "start_index": 78403,
                "end_index": 81118,
                "start_line": 2228,
                "end_line": 2322,
                "max_line": 2718,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.9",
                "sha": ""
            }
        ],
        "classification": "other",
        "snippet_processor_task": {
            "sympy/combinatorics/partitions.py": [
                {
                    "chunk": {
                        "code": "class Partition(FiniteSet):",
                        "filename": "sympy/combinatorics/partitions.py",
                        "start_index": 371,
                        "end_index": 398,
                        "start_line": 12,
                        "end_line": 12,
                        "max_line": 730,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.9",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the Partition class inheriting from FiniteSet, which is directly related to the issue of verbose printing of Partition instances."
                }
            ],
            "sympy/printing/pretty/pretty.py": [
                {
                    "chunk": {
                        "code": "def _print_Cycle(self, dc):\n        from sympy.combinatorics.permutations import Permutation, Cycle\n        # for Empty Cycle\n        if dc == Cycle():\n            cyc = stringPict('')\n            return prettyForm(*cyc.parens())\n\n        dc_list = Permutation(dc.list()).cyclic_form\n        # for Identity Cycle\n        if dc_list == []:\n            cyc = self._print(dc.size - 1)\n            return prettyForm(*cyc.parens())\n\n        cyc = stringPict('')\n        for i in dc_list:\n            l = self._print(str(tuple(i)).replace(',', ''))\n            cyc = prettyForm(*cyc.right(l))\n        return cyc\n\n    def _print_Permutation(self, expr):\n        from sympy.combinatorics.permutations import Permutation, Cycle\n\n        perm_cyclic = Permutation.print_cyclic\n        if perm_cyclic is not None:\n            SymPyDeprecationWarning(\n                feature=\"Permutation.print_cyclic = {}\".format(perm_cyclic),\n                useinstead=\"init_printing(perm_cyclic={})\"\n                .format(perm_cyclic),\n                issue=15201,\n                deprecated_since_version=\"1.6\").warn()\n        else:\n            perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n\n        if perm_cyclic:\n            return self._print_Cycle(Cycle(expr))\n\n        lower = expr.array_form\n        upper = list(range(len(lower)))\n\n        result = stringPict('')\n        first = True\n        for u, l in zip(upper, lower):\n            s1 = self._print(u)\n            s2 = self._print(l)\n            col = prettyForm(*s1.below(s2))\n            if first:\n                first = False\n            else:\n                col = prettyForm(*col.left(\" \"))\n            result = prettyForm(*result.right(col))\n        return prettyForm(*result.parens())",
                        "filename": "sympy/printing/pretty/pretty.py",
                        "start_index": 12535,
                        "end_index": 14276,
                        "start_line": 372,
                        "end_line": 422,
                        "max_line": 2718,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.9",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the pretty printing methods for combinatoric functions like Permutation, which may need to be modified to address the printing issue for Partition and similar functions."
                }
            ],
            "sympy/functions/combinatorial/numbers.py": [
                {
                    "chunk": {
                        "code": "#                                                                            #\n#                           Partition numbers                                #\n#                                                                            #\n#----------------------------------------------------------------------------#\n\n_npartition = [1, 1]\nclass partition(Function):\n    r\"\"\"\n    Partition numbers\n\n    The Partition numbers are a sequence of integers `p_n` that represent the\n    number of distinct ways of representing `n` as a sum of natural numbers\n    (with order irrelevant). The generating function for `p_n` is given by:\n\n    .. math:: \\sum_{n=0}^\\infty p_n x^n = \\prod_{k=1}^\\infty (1 - x^k)^{-1}\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol\n    >>> from sympy.functions import partition\n    >>> [partition(n) for n in range(9)]\n    [1, 1, 2, 3, 5, 7, 11, 15, 22]\n    >>> n = Symbol('n', integer=True, negative=True)\n    >>> partition(n)\n    0\n\n    See Also\n    ========\n\n    bell, bernoulli, catalan, euler, fibonacci, harmonic, lucas, genocchi, tribonacci\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Partition_(number_theory%29\n    .. [2] https://en.wikipedia.org/wiki/Pentagonal_number_theorem\n\n    \"\"\"\n\n    @staticmethod\n    def _partition(n):\n        L = len(_npartition)\n        if n < L:\n            return _npartition[n]\n        # lengthen cache\n        for _n in range(L, n + 1):\n            v, p, i = 0, 0, 0\n            while 1:\n                s = 0\n                p += 3*i + 1  # p = pentagonal number: 1, 5, 12, ...\n                if _n >= p:\n                    s += _npartition[_n - p]\n                i += 1\n                gp = p + i  # gp = generalized pentagonal: 2, 7, 15, ...\n                if _n >= gp:\n                    s += _npartition[_n - gp]\n                if s == 0:\n                    break\n                else:\n                    v += s if i%2 == 1 else -s\n            _npartition.append(v)\n        return v\n\n    @classmethod\n    def eval(cls, n):\n        is_int = n.is_integer\n        if is_int == False:\n            raise ValueError(\"Partition numbers are defined only for \"\n                             \"integers\")\n        elif is_int:\n            if n.is_negative:\n                return S.Zero\n\n            if n.is_zero or (n - 1).is_zero:\n                return S.One\n\n            if n.is_Integer:\n                return Integer(cls._partition(n))\n\n\n    def _eval_is_integer(self):\n        if self.args[0].is_integer:\n            return True\n\n    def _eval_is_negative(self):\n        if self.args[0].is_integer:\n            return False\n\n    def _eval_is_positive(self):\n        n = self.args[0]\n        if n.is_nonnegative and n.is_integer:\n            return True\n\n\n#######################################################################\n###\n### Functions for enumerating partitions, permutations and combinations\n###\n#######################################################################",
                        "filename": "sympy/functions/combinatorial/numbers.py",
                        "start_index": 42637,
                        "end_index": 45626,
                        "start_line": 45,
                        "end_line": 1408,
                        "max_line": 2046,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.9",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the partition function and may contain relevant information on how Partition objects are constructed and printed."
                }
            ]
        },
        "solution_task": "- Modify the `__repr__` method of the `Partition` class to print the internal `FiniteSet` representation as a list, tuple, or set, according to community preferences.\n- Ensure that the `__repr__` method checks the type of the input iterable and formats the output accordingly.\n- If the input is a list or tuple, use the same type for printing. If the input is a set, print as a set.\n\n```python\nclass Partition(FiniteSet):\n    def __init__(self, iterable):\n        super().__init__(*iterable)\n        self.input_type = type(iterable)\n\n    def __repr__(self):\n        elements = list(self.args)\n        if self.input_type in (list, tuple):\n            return f\"{self.input_type.__name__}({elements})\"\n        elif self.input_type is set:\n            return f\"set({elements})\"\n        else:\n            return super().__repr__()\n```\n\n- Ensure that the `Partition` class correctly stores the type of the input iterable during initialization.\n- Adjust the `__repr__` method to check the stored input type and format the output as desired.\n- If the input type is not a list, tuple, or set, default to the parent class's `__repr__` method.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem of verbose printing in the Partition class. It suggests modifying the '__repr__' method to print the internal 'FiniteSet' representation as a list, tuple, or set, which directly addresses the issue raised in the PROMPT. The RESPONSE also includes a code snippet that demonstrates how to implement the changes, which is highly relevant and useful for resolving the bug. The RESPONSE further advises ensuring that the 'Partition' class stores the type of the input iterable during initialization and adjusts the '__repr__' method accordingly, which is a comprehensive approach to the problem. The RESPONSE also provides links to the relevant code snippets in the SymPy repository, which could be useful for developers looking to implement the suggested changes. However, the RESPONSE does not address the 'other combinatoric funcs as pertinent' mentioned in the PROMPT, which leaves the solution slightly incomplete for the broader scope of the issue.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711744304.4918149,
        "result": "- Modify the `__repr__` method of the `Partition` class to print the internal `FiniteSet` representation as a list, tuple, or set, according to community preferences.\n- Ensure that the `__repr__` method checks the type of the input iterable and formats the output accordingly.\n- If the input is a list or tuple, use the same type for printing. If the input is a set, print as a set.\n\n```python\nclass Partition(FiniteSet):\n    def __init__(self, iterable):\n        super().__init__(*iterable)\n        self.input_type = type(iterable)\n\n    def __repr__(self):\n        elements = list(self.args)\n        if self.input_type in (list, tuple):\n            return f\"{self.input_type.__name__}({elements})\"\n        elif self.input_type is set:\n            return f\"set({elements})\"\n        else:\n            return super().__repr__()\n```\n\n- Ensure that the `Partition` class correctly stores the type of the input iterable during initialization.\n- Adjust the `__repr__` method to check the stored input type and format the output as desired.\n- If the input type is not a list, tuple, or set, default to the parent class's `__repr__` method.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [combinatorics](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/combinatorics)- [Lines 12 - 12](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/combinatorics/partitions.py#L12-L12)\n\n This snippet defines the Partition class inheriting from FiniteSet, which is directly related to the issue of verbose printing of Partition instances.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [printing](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/printing) \u2192 [pretty](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/printing/pretty)- [Lines 372 - 422](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/printing/pretty/pretty.py#L372-L422)\n\n This snippet contains the pretty printing methods for combinatoric functions like Permutation, which may need to be modified to address the printing issue for Partition and similar functions.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.9/tree//sympy) \u2192 [functions](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/functions) \u2192 [combinatorial](https://github.com/testbed/sympy__sympy__1.9/tree//sympy/functions/combinatorial)- [Lines 45 - 1408](https://github.com/testbed/sympy__sympy__1.9/blob//sympy/functions/combinatorial/numbers.py#L45-L1408)\n\n This snippet defines the partition function and may contain relevant information on how Partition objects are constructed and printed."
    }
}