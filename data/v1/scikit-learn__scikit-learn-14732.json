{
    "id": "scikit-learn__scikit-learn-14732",
    "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
    "task_id": 6374109451753425268,
    "title": "median_absolute_error multioutput",
    "body": "Multioutput is not currently supported in `median_absolute_error`. Is this a design choice or has it just not been implemented yet? In case of the latter, I am happy to submit a PR. \r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__0.22.git",
    "requested_commit": "",
    "mayil_response": "",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0009725,
        "snippet_processor": 0.08512000000000002,
        "issue_star_creation": 0.049199999999999994,
        "issue_star_solver": 0.054560000000000004,
        "bouncer": 0.02766
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711739000.947265,
        "relevant_snippets": [
            {
                "code": "@validate_params(\n    {\n        \"y_true\": [\"array-like\"],\n        \"y_pred\": [\"array-like\"],\n        \"multioutput\": [StrOptions({\"raw_values\", \"uniform_average\"}), \"array-like\"],\n        \"sample_weight\": [\"array-like\", None],\n    },\n    prefer_skip_nested_validation=True,\n)\ndef median_absolute_error(\n    y_true, y_pred, *, multioutput=\"uniform_average\", sample_weight=None\n):\n    \"\"\"Median absolute error regression loss.\n\n    Median absolute error output is non-negative floating point. The best value\n    is 0.0. Read more in the :ref:`User Guide <median_absolute_error>`.\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_samples,) or (n_samples, n_outputs)\n        Ground truth (correct) target values.\n\n    y_pred : array-like of shape (n_samples,) or (n_samples, n_outputs)\n        Estimated target values.\n\n    multioutput : {'raw_values', 'uniform_average'} or array-like of shape \\\n            (n_outputs,), default='uniform_average'\n        Defines aggregating of multiple output values. Array-like value defines\n        weights used to average errors.\n\n        'raw_values' :\n            Returns a full set of errors in case of multioutput input.\n\n        'uniform_average' :\n            Errors of all outputs are averaged with uniform weight.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights.\n\n        .. versionadded:: 0.24\n\n    Returns\n    -------\n    loss : float or ndarray of floats\n        If multioutput is 'raw_values', then mean absolute error is returned\n        for each output separately.\n        If multioutput is 'uniform_average' or an ndarray of weights, then the\n        weighted average of all output errors is returned.\n\n    Examples\n    --------\n    >>> from sklearn.metrics import median_absolute_error\n    >>> y_true = [3, -0.5, 2, 7]\n    >>> y_pred = [2.5, 0.0, 2, 8]\n    >>> median_absolute_error(y_true, y_pred)\n    0.5\n    >>> y_true = [[0.5, 1], [-1, 1], [7, -6]]\n    >>> y_pred = [[0, 2], [-1, 2], [8, -5]]\n    >>> median_absolute_error(y_true, y_pred)\n    0.75\n    >>> median_absolute_error(y_true, y_pred, multioutput='raw_values')\n    array([0.5, 1. ])\n    >>> median_absolute_error(y_true, y_pred, multioutput=[0.3, 0.7])\n    0.85\n    \"\"\"\n    y_type, y_true, y_pred, multioutput = _check_reg_targets(\n        y_true, y_pred, multioutput\n    )\n    if sample_weight is None:\n        output_errors = np.median(np.abs(y_pred - y_true), axis=0)\n    else:\n        sample_weight = _check_sample_weight(sample_weight, y_pred)\n        output_errors = _weighted_percentile(\n            np.abs(y_pred - y_true), sample_weight=sample_weight\n        )\n    if isinstance(multioutput, str):\n        if multioutput == \"raw_values\":\n            return output_errors\n        elif multioutput == \"uniform_average\":\n            # pass None as weights to np.average: uniform mean\n            multioutput = None\n\n    return np.average(output_errors, weights=multioutput)",
                "filename": "sklearn/metrics/_regression.py",
                "start_index": 20207,
                "end_index": 23159,
                "start_line": 140,
                "end_line": 663,
                "max_line": 1632,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "class _MultiOutputEstimator(MetaEstimatorMixin, BaseEstimator, metaclass=ABCMeta):",
                "filename": "sklearn/multioutput.py",
                "start_index": 2618,
                "end_index": 2700,
                "start_line": 96,
                "end_line": 96,
                "max_line": 1168,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "@ignore_warnings(category=FutureWarning)\ndef check_classifier_multioutput(name, estimator):\n    n_samples, n_labels, n_classes = 42, 5, 3\n    tags = _safe_tags(estimator)\n    estimator = clone(estimator)\n    X, y = make_multilabel_classification(\n        random_state=42, n_samples=n_samples, n_labels=n_labels, n_classes=n_classes\n    )\n    estimator.fit(X, y)\n    y_pred = estimator.predict(X)\n\n    assert y_pred.shape == (n_samples, n_classes), (\n        \"The shape of the prediction for multioutput data is \"\n        \"incorrect. Expected {}, got {}.\".format((n_samples, n_labels), y_pred.shape)\n    )\n    assert y_pred.dtype.kind == \"i\"\n\n    if hasattr(estimator, \"decision_function\"):\n        decision = estimator.decision_function(X)\n        assert isinstance(decision, np.ndarray)\n        assert decision.shape == (n_samples, n_classes), (\n            \"The shape of the decision function output for \"\n            \"multioutput data is incorrect. Expected {}, got {}.\".format(\n                (n_samples, n_classes), decision.shape\n            )\n        )\n\n        dec_pred = (decision > 0).astype(int)\n        dec_exp = estimator.classes_[dec_pred]\n        assert_array_equal(dec_exp, y_pred)\n\n    if hasattr(estimator, \"predict_proba\"):\n        y_prob = estimator.predict_proba(X)\n\n        if isinstance(y_prob, list) and not tags[\"poor_score\"]:\n            for i in range(n_classes):\n                assert y_prob[i].shape == (n_samples, 2), (\n                    \"The shape of the probability for multioutput data is\"\n                    \" incorrect. Expected {}, got {}.\".format(\n                        (n_samples, 2), y_prob[i].shape\n                    )\n                )\n                assert_array_equal(\n                    np.argmax(y_prob[i], axis=1).astype(int), y_pred[:, i]\n                )\n        elif not tags[\"poor_score\"]:\n            assert y_prob.shape == (n_samples, n_classes), (\n                \"The shape of the probability for multioutput data is\"\n                \" incorrect. Expected {}, got {}.\".format(\n                    (n_samples, n_classes), y_prob.shape\n                )\n            )\n            assert_array_equal(y_prob.round().astype(int), y_pred)\n\n    if hasattr(estimator, \"decision_function\") and hasattr(estimator, \"predict_proba\"):\n        for i in range(n_classes):\n            y_proba = estimator.predict_proba(X)[:, i]\n            y_decision = estimator.decision_function(X)\n            assert_array_equal(rankdata(y_proba), rankdata(y_decision[:, i]))",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 73288,
                "end_index": 75799,
                "start_line": 181,
                "end_line": 2203,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "\"\"\"\nThis module implements multioutput regression and classification.\n\nThe estimators provided in this module are meta-estimators: they require\na base estimator to be provided in their constructor. The meta-estimator\nextends single output estimators to multioutput estimators.\n\"\"\"\n\n# Author: Tim Head <betatim@gmail.com>\n# Author: Hugo Bowne-Anderson <hugobowne@gmail.com>\n# Author: Chris Rivera <chris.richard.rivera@gmail.com>\n# Author: Michael Williamson\n# Author: James Ashton Nichols <james.ashton.nichols@gmail.com>\n#\n# License: BSD 3 clause\n\n\nfrom abc import ABCMeta, abstractmethod\nfrom numbers import Integral\n\nimport numpy as np\nimport scipy.sparse as sp\n\nfrom .base import (\n    BaseEstimator,\n    ClassifierMixin,\n    MetaEstimatorMixin,\n    RegressorMixin,\n    _fit_context,\n    clone,\n    is_classifier,\n)\nfrom .model_selection import cross_val_predict\nfrom .utils import Bunch, _print_elapsed_time, check_random_state\nfrom .utils._param_validation import HasMethods, StrOptions\nfrom .utils.metadata_routing import (\n    MetadataRouter,\n    MethodMapping,\n    _routing_enabled,\n    process_routing,\n)\nfrom .utils.metaestimators import available_if\nfrom .utils.multiclass import check_classification_targets\nfrom .utils.parallel import Parallel, delayed\nfrom .utils.validation import _check_method_params, check_is_fitted, has_fit_parameter\n\n__all__ = [\n    \"MultiOutputRegressor\",\n    \"MultiOutputClassifier\",\n    \"ClassifierChain\",\n    \"RegressorChain\",\n]\n\n\ndef _fit_estimator(estimator, X, y, sample_weight=None, **fit_params):\n    estimator = clone(estimator)\n    if sample_weight is not None:\n        estimator.fit(X, y, sample_weight=sample_weight, **fit_params)\n    else:\n        estimator.fit(X, y, **fit_params)\n    return estimator\n\n\ndef _partial_fit_estimator(\n    estimator, X, y, classes=None, partial_fit_params=None, first_time=True\n):\n    partial_fit_params = {} if partial_fit_params is None else partial_fit_params\n    if first_time:\n        estimator = clone(estimator)\n\n    if classes is not None:\n        estimator.partial_fit(X, y, classes=classes, **partial_fit_params)\n    else:\n        estimator.partial_fit(X, y, **partial_fit_params)\n    return estimator\n\n\ndef _available_if_estimator_has(attr):\n    \"\"\"Return a function to check if the sub-estimator(s) has(have) `attr`.\n\n    Helper for Chain implementations.\n    \"\"\"\n\n    def _check(self):\n        if hasattr(self, \"estimators_\"):\n            return all(hasattr(est, attr) for est in self.estimators_)\n\n        if hasattr(self.estimator, attr):\n            return True\n\n        return False\n\n    return available_if(_check)",
                "filename": "sklearn/multioutput.py",
                "start_index": 0,
                "end_index": 2615,
                "start_line": 1,
                "end_line": 628,
                "max_line": 1168,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "output_errors = np.average(mape, weights=sample_weight, axis=0)\n    if isinstance(multioutput, str):\n        if multioutput == \"raw_values\":\n            return output_errors\n        elif multioutput == \"uniform_average\":\n            # pass None as weights to np.average: uniform mean\n            multioutput = None\n\n    return np.average(output_errors, weights=multioutput)",
                "filename": "sklearn/metrics/_regression.py",
                "start_index": 13918,
                "end_index": 14291,
                "start_line": 393,
                "end_line": 663,
                "max_line": 1632,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "def mean_absolute_percentage_error(\n    y_true, y_pred, *, sample_weight=None, multioutput=\"uniform_average\"\n):",
                "filename": "sklearn/metrics/_regression.py",
                "start_index": 10852,
                "end_index": 10963,
                "start_line": 318,
                "end_line": 1549,
                "max_line": 1632,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "@_available_if_estimator_has(\"partial_fit\")\n    @_fit_context(\n        # MultiOutput*.estimator is not validated yet\n        prefer_skip_nested_validation=False\n    )",
                "filename": "sklearn/multioutput.py",
                "start_index": 2976,
                "end_index": 3142,
                "start_line": 107,
                "end_line": 1164,
                "max_line": 1168,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "@ignore_warnings(category=FutureWarning)\ndef check_regressor_multioutput(name, estimator):\n    estimator = clone(estimator)\n    n_samples = n_features = 10\n\n    if not _is_pairwise_metric(estimator):\n        n_samples = n_samples + 1\n\n    X, y = make_regression(\n        random_state=42, n_targets=5, n_samples=n_samples, n_features=n_features\n    )\n    X = _enforce_estimator_tags_X(estimator, X)\n\n    estimator.fit(X, y)\n    y_pred = estimator.predict(X)\n\n    assert y_pred.dtype == np.dtype(\"float64\"), (\n        \"Multioutput predictions by a regressor are expected to be\"\n        \" floating-point precision. Got {} instead\".format(y_pred.dtype)\n    )\n    assert y_pred.shape == y.shape, (\n        \"The shape of the prediction for multioutput data is incorrect.\"\n        \" Expected {}, got {}.\"\n    )",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 75802,
                "end_index": 76605,
                "start_line": 181,
                "end_line": 4639,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "class MultiOutputClassifier(ClassifierMixin, _MultiOutputEstimator):",
                "filename": "sklearn/multioutput.py",
                "start_index": 14886,
                "end_index": 14954,
                "start_line": 440,
                "end_line": 440,
                "max_line": 1168,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "class MultiOutputRegressor(RegressorMixin, _MultiOutputEstimator):",
                "filename": "sklearn/multioutput.py",
                "start_index": 11285,
                "end_index": 11351,
                "start_line": 337,
                "end_line": 337,
                "max_line": 1168,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            }
        ],
        "classification": "question",
        "question_answerer_task": "The `median_absolute_error` function in `sklearn.metrics._regression.py` does support multioutput as indicated by the parameter `multioutput` which can take the values `'raw_values'`, `'uniform_average'`, or an array-like of shape `(n_outputs,)`. The function's documentation and implementation handle multioutput cases, as seen in the provided code snippet.\n\n- If `multioutput='raw_values'`, the function returns the median absolute error for each output separately.\n- If `multioutput='uniform_average'`, the function returns the average of all output errors with uniform weight.\n- If `multioutput` is an array-like of weights, the function returns the weighted average of all output errors.\n\nTherefore, multioutput is supported in `median_absolute_error`, and it is not just a design choice or an unimplemented feature. There is no need to submit a PR for this functionality as it already exists.",
        "bouncer_response": {
            "score": 0,
            "criteria": "The RESPONSE must provide accurate information regarding the support of multioutput in the `median_absolute_error` function.",
            "supporting_evidence": "The RESPONSE incorrectly states that the `median_absolute_error` function in `sklearn.metrics._regression.py` supports multioutput, which is not true as of the knowledge cutoff date in April 2023. The `median_absolute_error` function does not have a `multioutput` parameter, and the sklearn library does not support multioutput for this function. Therefore, the RESPONSE provides confidently incorrect information and does not address the question in the PROMPT about whether the lack of multioutput support is a design choice or an oversight.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711739054.220875,
        "result": ""
    }
}