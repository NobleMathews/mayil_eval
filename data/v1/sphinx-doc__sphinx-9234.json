{
    "id": "sphinx-doc__sphinx-9234",
    "repo_name": "testbed/sphinx-doc__sphinx__4.1",
    "task_id": 1648359853874031737,
    "title": "Link checker should be able to prohibit unknown redirects",
    "body": "**Is your feature request related to a problem? Please describe.**\r\nA lot of links become stale or move. Good websites will provide redirects to the correct new location or return an HTTP error code. Bad websites will redirect to an unrelated page or the root of the website.\r\n\r\nPreventing all redirects does not allow links to URLs like https://www.sphinx-doc.org/ which redirects to https://www.sphinx-doc.org/en/master/. It needs to be possible to allow these redirects but disallow others.\r\n\r\n**Describe the solution you'd like**\r\nIt should be possible to prohibit unknown redirects by listing all of the allowed redirects as pairs of URLs.\r\n\r\n**Describe alternatives you've considered**\r\nPost-process `linkcheck/output.txt` by removing filenames and line numbers then sorting it and comparing it with known good output.\r\n\r\n**Additional context**\r\nA link to https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10/ (which used to work) now redirects to https://blogs.windows.com/windowsdeveloper/. Linkcheck allows this but the original link is not valid and needs to be updated to the article's new URL of https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/.\r\n\r\nLinkcheck should be able to report an error for this redirect.\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__4.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature that prohibits unknown redirects while allowing specified ones, you can follow these steps:\n\n- Modify the `linkcheck_allowed_redirects` configuration to accept pairs of URLs (source and target) for allowed redirects.\n- Update the `allowed_redirect` function to check if a redirect is within the allowed pairs.\n- Modify the `check` function to handle the new logic for allowed and prohibited redirects.\n- Update the `process_result` function to report an error for prohibited redirects.\n- Ensure that the configuration is compiled correctly in the `compile_linkcheck_allowed_redirects` function.\n\nHere's a high-level overview of the changes:\n\n1. Update the configuration to accept pairs of URLs:\n```python\n# In setup function\napp.add_config_value('linkcheck_allowed_redirects_pairs', [], False)\n```\n\n2. Modify the `compile_linkcheck_allowed_redirects` function to compile the pairs:\n```python\ndef compile_linkcheck_allowed_redirects_pairs(app: Sphinx, config: Config) -> None:\n    compiled_pairs = []\n    for from_url, to_url in app.config.linkcheck_allowed_redirects_pairs:\n        try:\n            compiled_pairs.append((re.compile(from_url), re.compile(to_url)))\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects_pairs: %r %s'),\n                           exc.pattern, exc.msg)\n    app.config.linkcheck_allowed_redirects_pairs = compiled_pairs\n```\n\n3. Update the `allowed_redirect` function to use the compiled pairs:\n```python\ndef allowed_redirect(url: str, new_url: str) -> bool:\n    return any(\n        from_url.match(url) and to_url.match(new_url)\n        for from_url, to_url in self.config.linkcheck_allowed_redirects_pairs\n    )\n```\n\n4. Modify the `check` function to handle the new logic:\n```python\n# Inside the check function, after the check_uri() call\nif status == 'redirected' and not allowed_redirect(uri, new_url):\n    return 'prohibited-redirect', new_url, code\n```\n\n5. Update the `process_result` function to report an error for prohibited redirects:\n```python\n# Inside the process_result function\nelif result.status == 'prohibited-redirect':\n    logger.warning(__('prohibited redirect: %s (redirected to %s)'), result.uri, result.message,\n                   location=(result.docname, result.lineno))\n    self.write_entry('prohibited-redirect', result.docname, filename, result.lineno,\n                     result.uri + ': redirected to ' + result.message)\n    self.broken_hyperlinks += 1\n```\n\n6. Connect the new compile function in the `setup` function:\n```python\napp.connect('config-inited', compile_linkcheck_allowed_redirects_pairs, priority=800)\n```\n\n7. Update the documentation to describe the new configuration option and how to use it.\n\nRemember to test the changes thoroughly to ensure that the link checker behaves as expected, allowing specified redirects and prohibiting others.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx) \u2192 [builders](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx/builders)- [Lines 382 - 452](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L382-L452)\n\n This snippet contains the 'allowed_redirect' function which is central to the feature request of handling allowed redirects. \n\n\n   - [Lines 366 - 380](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L366-L380)\n\n This snippet includes the logic that determines if a redirect is allowed or not, which is directly related to the issue. \n\n\n   - [Lines 493 - 559](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L493-L559)\n\n This snippet contains the 'compile_linkcheck_allowed_redirects' function which compiles the allowed redirects into regex objects, a necessary part of the feature. \n\n\n   - [Lines 122 - 176](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L122-L176)\n\n This snippet processes the result of link checks and would need to be updated to handle the new 'unknown redirect' error status. \n\n\n   - [Lines 562 - 592](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L562-L592)\n\n This snippet sets up configuration values for link checking, including 'linkcheck_allowed_redirects', which will be used for the new feature.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002935,
        "snippet_processor": 0.06212,
        "issue_star_creation": 0.026479999999999997,
        "issue_star_solver": 0.06126000000000001,
        "bouncer": 0.02851
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711702567.8685708,
        "relevant_snippets": [
            {
                "code": "def allowed_redirect(url: str, new_url: str) -> bool:\n            return any(\n                from_url.match(url) and to_url.match(new_url)\n                for from_url, to_url\n                in self.config.linkcheck_allowed_redirects.items()\n            )\n\n        def check(docname: str) -> tuple[str, str, int]:\n            # check for various conditions without bothering the network\n\n            for doc_matcher in self.documents_exclude:\n                if doc_matcher.match(docname):\n                    info = (\n                        f'{docname} matched {doc_matcher.pattern} from '\n                        'linkcheck_exclude_documents'\n                    )\n                    return 'ignored', info, 0\n\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                if uri_re.match(uri):\n                    # non supported URI schemes (ex. ftp)\n                    return 'unchecked', '', 0\n                else:\n                    srcdir = path.dirname(self.env.doc2path(docname))\n                    if path.exists(path.join(srcdir, uri)):\n                        return 'working', '', 0\n                    else:\n                        return 'broken', '', 0\n\n            # need to actually check the URI\n            for _ in range(self.config.linkcheck_retries):\n                status, info, code = check_uri()\n                if status != \"broken\":\n                    break\n\n            return (status, info, code)\n\n        while True:\n            check_request = self.wqueue.get()\n            next_check, hyperlink = check_request\n            if hyperlink is None:\n                break\n\n            uri, docname, lineno = hyperlink\n\n            if uri is None:\n                break\n            netloc = urlparse(uri).netloc\n            try:\n                # Refresh rate limit.\n                # When there are many links in the queue, workers are all stuck waiting\n                # for responses, but the builder keeps queuing. Links in the queue may\n                # have been queued before rate limits were discovered.\n                next_check = self.rate_limits[netloc].next_check\n            except KeyError:\n                pass\n            if next_check > time.time():\n                # Sleep before putting message back in the queue to avoid\n                # waking up other threads.\n                time.sleep(QUEUE_POLL_SECS)\n                self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                self.wqueue.task_done()\n                continue\n            status, info, code = check(docname)\n            if status == 'rate-limited':\n                logger.info(darkgray('-rate limited-   ') + uri + darkgray(' | sleeping...'))\n            else:\n                self.rqueue.put(CheckResult(uri, docname, lineno, status, info, code))\n            self.wqueue.task_done()",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 14844,
                "end_index": 17804,
                "start_line": 382,
                "end_line": 452,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "class HyperlinkCollector(SphinxPostTransform):\n    builders = ('linkcheck',)\n    default_priority = 800\n\n    def run(self, **kwargs: Any) -> None:\n        builder = cast(CheckExternalLinksBuilder, self.app.builder)\n        hyperlinks = builder.hyperlinks\n\n        def add_uri(uri: str, node: nodes.Element) -> None:\n            newuri = self.app.emit_firstresult('linkcheck-process-uri', uri)\n            if newuri:\n                uri = newuri\n\n            try:\n                lineno = get_node_line(node)\n            except ValueError:\n                lineno = None\n            uri_info = Hyperlink(uri, self.env.docname, lineno)\n            if uri not in hyperlinks:\n                hyperlinks[uri] = uri_info\n\n        # reference nodes\n        for refnode in self.document.findall(nodes.reference):\n            if 'refuri' not in refnode:\n                continue\n            uri = refnode['refuri']\n            add_uri(uri, refnode)\n\n        # image nodes\n        for imgnode in self.document.findall(nodes.image):\n            uri = imgnode['candidates'].get('?')\n            if uri and '://' in uri:\n                add_uri(uri, imgnode)\n\n        # raw nodes\n        for rawnode in self.document.findall(nodes.raw):\n            uri = rawnode.get('source')\n            if uri and '://' in uri:\n                add_uri(uri, rawnode)\n\n\ndef rewrite_github_anchor(app: Sphinx, uri: str) -> str | None:\n    \"\"\"Rewrite anchor name of the hyperlink to github.com\n\n    The hyperlink anchors in github.com are dynamically generated.  This rewrites\n    them before checking and makes them comparable.\n    \"\"\"\n    parsed = urlparse(uri)\n    if parsed.hostname == \"github.com\" and parsed.fragment:\n        prefixed = parsed.fragment.startswith('user-content-')\n        if not prefixed:\n            fragment = f'user-content-{parsed.fragment}'\n            return urlunparse(parsed._replace(fragment=fragment))\n    return None\n\n\ndef compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -> None:\n    \"\"\"Compile patterns in linkcheck_allowed_redirects to the regexp objects.\"\"\"\n    for url, pattern in list(app.config.linkcheck_allowed_redirects.items()):\n        try:\n            app.config.linkcheck_allowed_redirects[re.compile(url)] = re.compile(pattern)\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects: %r %s'),\n                           exc.pattern, exc.msg)\n        finally:\n            # Remove the original regexp-string\n            app.config.linkcheck_allowed_redirects.pop(url)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 19389,
                "end_index": 21951,
                "start_line": 493,
                "end_line": 559,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "try:\n                if anchor and self.config.linkcheck_anchors:\n                    # Read the whole document and see if #anchor exists\n                    with requests.get(req_url, stream=True, config=self.config, auth=auth_info,\n                                      **kwargs) as response:\n                        response.raise_for_status()\n                        found = check_anchor(response, unquote(anchor))\n\n                    if not found:\n                        raise Exception(__(\"Anchor '%s' not found\") % anchor)\n                else:\n                    try:\n                        # try a HEAD request first, which should be easier on\n                        # the server and the network\n                        with requests.head(req_url, allow_redirects=True, config=self.config,\n                                           auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n                    # Servers drop the connection on HEAD requests, causing\n                    # ConnectionError.\n                    except (ConnectionError, HTTPError, TooManyRedirects) as err:\n                        if isinstance(err, HTTPError) and err.response.status_code == 429:\n                            raise\n                        # retry with GET request if that fails, some servers\n                        # don't like HEAD requests.\n                        with requests.get(req_url, stream=True, config=self.config,\n                                          auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n            except HTTPError as err:\n                if err.response.status_code == 401:\n                    # We'll take \"Unauthorized\" as working.\n                    return 'working', ' - unauthorized', 0\n                elif err.response.status_code == 429:\n                    next_check = self.limit_rate(err.response)\n                    if next_check is not None:\n                        self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                        return 'rate-limited', '', 0\n                    return 'broken', str(err), 0\n                elif err.response.status_code == 503:\n                    # We'll take \"Service Unavailable\" as ignored.\n                    return 'ignored', str(err), 0\n                else:\n                    return 'broken', str(err), 0\n            except Exception as err:\n                return 'broken', str(err), 0\n            else:\n                netloc = urlparse(req_url).netloc\n                try:\n                    del self.rate_limits[netloc]\n                except KeyError:\n                    pass",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 11520,
                "end_index": 14211,
                "start_line": 156,
                "end_line": 468,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Checks for broken external links.\n    \"\"\"\n    name = 'linkcheck'\n    epilog = __('Look for any errors in the above output or in '\n                '%(outdir)s/output.txt')\n\n    def init(self) -> None:\n        self.broken_hyperlinks = 0\n        self.hyperlinks: dict[str, Hyperlink] = {}\n        # set a timeout for non-responding servers\n        socket.setdefaulttimeout(5.0)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 3091,
                "end_index": 3473,
                "start_line": 1,
                "end_line": 120,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "class CheckExternalLinksBuilder(DummyBuilder):",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 3040,
                "end_index": 3086,
                "start_line": 108,
                "end_line": 108,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "if response.url.rstrip('/') == req_url.rstrip('/'):\n                return 'working', '', 0\n            else:\n                new_url = response.url\n                if anchor:\n                    new_url += '#' + anchor\n\n                if allowed_redirect(req_url, new_url):\n                    return 'working', '', 0\n                elif response.history:\n                    # history contains any redirects, get last\n                    code = response.history[-1].status_code\n                    return 'redirected', new_url, code\n                else:\n                    return 'redirected', new_url, 0",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 14224,
                "end_index": 14834,
                "start_line": 366,
                "end_line": 380,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "def process_result(self, result: CheckResult) -> None:\n        filename = self.env.doc2path(result.docname, False)\n\n        linkstat = {\"filename\": filename, \"lineno\": result.lineno,\n                    \"status\": result.status, \"code\": result.code, \"uri\": result.uri,\n                    \"info\": result.message}\n        self.write_linkstat(linkstat)\n\n        if result.status == 'unchecked':\n            return\n        if result.status == 'working' and result.message == 'old':\n            return\n        if result.lineno:\n            logger.info('(%16s: line %4d) ', result.docname, result.lineno, nonl=True)\n        if result.status == 'ignored':\n            if result.message:\n                logger.info(darkgray('-ignored- ') + result.uri + ': ' + result.message)\n            else:\n                logger.info(darkgray('-ignored- ') + result.uri)\n        elif result.status == 'local':\n            logger.info(darkgray('-local-   ') + result.uri)\n            self.write_entry('local', result.docname, filename, result.lineno, result.uri)\n        elif result.status == 'working':\n            logger.info(darkgreen('ok        ') + result.uri + result.message)\n        elif result.status == 'broken':\n            if self.app.quiet or self.app.warningiserror:\n                logger.warning(__('broken link: %s (%s)'), result.uri, result.message,\n                               location=(result.docname, result.lineno))\n            else:\n                logger.info(red('broken    ') + result.uri + red(' - ' + result.message))\n            self.write_entry('broken', result.docname, filename, result.lineno,\n                             result.uri + ': ' + result.message)\n            self.broken_hyperlinks += 1\n        elif result.status == 'redirected':\n            try:\n                text, color = {\n                    301: ('permanently', purple),\n                    302: ('with Found', purple),\n                    303: ('with See Other', purple),\n                    307: ('temporarily', turquoise),\n                    308: ('permanently', purple),\n                }[result.code]\n            except KeyError:\n                text, color = ('with unknown code', purple)\n            linkstat['text'] = text\n            if self.config.linkcheck_allowed_redirects:\n                logger.warning('redirect  ' + result.uri + ' - ' + text + ' to ' +\n                               result.message, location=(result.docname, result.lineno))\n            else:\n                logger.info(color('redirect  ') + result.uri +\n                            color(' - ' + text + ' to ' + result.message))\n            self.write_entry('redirected ' + text, result.docname, filename,\n                             result.lineno, result.uri + ' to ' + result.message)\n        else:\n            raise ValueError(\"Unknown status %s.\" % result.status)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 3479,
                "end_index": 6320,
                "start_line": 122,
                "end_line": 176,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    app.add_builder(CheckExternalLinksBuilder)\n    app.add_post_transform(HyperlinkCollector)\n\n    app.add_config_value('linkcheck_ignore', [], False)\n    app.add_config_value('linkcheck_exclude_documents', [], False)\n    app.add_config_value('linkcheck_allowed_redirects', {}, False)\n    app.add_config_value('linkcheck_auth', [], False)\n    app.add_config_value('linkcheck_request_headers', {}, False)\n    app.add_config_value('linkcheck_retries', 1, False)\n    app.add_config_value('linkcheck_timeout', None, False, [int, float])\n    app.add_config_value('linkcheck_workers', 5, False)\n    app.add_config_value('linkcheck_anchors', True, False)\n    # Anchors starting with ! are ignored since they are\n    # commonly used for dynamic pages\n    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], False)\n    app.add_config_value('linkcheck_rate_limit_timeout', 300.0, False)\n\n    app.add_event('linkcheck-process-uri')\n\n    app.connect('config-inited', compile_linkcheck_allowed_redirects, priority=800)\n\n    # FIXME: Disable URL rewrite handler for github.com temporarily.\n    # ref: https://github.com/sphinx-doc/sphinx/issues/9435\n    # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 21954,
                "end_index": 23325,
                "start_line": 562,
                "end_line": 592,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "\"\"\"Extension to save typing and prevent hard-coding of base URLs in reST files.\n\nThis adds a new config value called ``extlinks`` that is created like this::\n\n   extlinks = {'exmpl': ('https://example.invalid/%s.html', caption), ...}\n\nNow you can use e.g. :exmpl:`foo` in your documents.  This will create a\nlink to ``https://example.invalid/foo.html``.  The link caption depends on\nthe *caption* value given:\n\n- If it is ``None``, the caption will be the full URL.\n- If it is a string, it must contain ``%s`` exactly once.  In this case the\n  caption will be *caption* with the role content substituted for ``%s``.\n\nYou can also give an explicit caption, e.g. :exmpl:`Foo <foo>`.\n\nBoth, the url string and the caption string must escape ``%`` as ``%%``.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any\n\nfrom docutils import nodes, utils\nfrom docutils.nodes import Node, system_message\nfrom docutils.parsers.rst.states import Inliner\n\nimport sphinx\nfrom sphinx.application import Sphinx\nfrom sphinx.locale import __\nfrom sphinx.transforms.post_transforms import SphinxPostTransform\nfrom sphinx.util import logging, rst\nfrom sphinx.util.nodes import split_explicit_title\nfrom sphinx.util.typing import RoleFunction\n\nlogger = logging.getLogger(__name__)\n\n\nclass ExternalLinksChecker(SphinxPostTransform):\n    \"\"\"\n    For each external link, check if it can be replaced by an extlink.\n\n    We treat each ``reference`` node without ``internal`` attribute as an external link.\n    \"\"\"\n\n    default_priority = 500\n\n    def run(self, **kwargs: Any) -> None:\n        if not self.config.extlinks_detect_hardcoded_links:\n            return\n\n        for refnode in self.document.findall(nodes.reference):\n            self.check_uri(refnode)\n\n    def check_uri(self, refnode: nodes.reference) -> None:\n        \"\"\"\n        If the URI in ``refnode`` has a replacement in ``extlinks``,\n        emit a warning with a replacement suggestion.\n        \"\"\"\n        if 'internal' in refnode or 'refuri' not in refnode:\n            return\n\n        uri = refnode['refuri']\n        title = refnode.astext()\n\n        for alias, (base_uri, _caption) in self.app.config.extlinks.items():\n            uri_pattern = re.compile(re.escape(base_uri).replace('%s', '(?P<value>.+)'))\n\n            match = uri_pattern.match(uri)\n            if (\n                match and\n                match.groupdict().get('value') and\n                '/' not in match.groupdict()['value']\n            ):\n                # build a replacement suggestion\n                msg = __('hardcoded link %r could be replaced by an extlink '\n                         '(try using %r instead)')\n                value = match.groupdict().get('value')\n                if uri != title:\n                    replacement = f\":{alias}:`{rst.escape(title)} <{value}>`\"\n                else:\n                    replacement = f\":{alias}:`{value}`\"\n                logger.warning(msg, uri, replacement, location=refnode)",
                "filename": "sphinx/ext/extlinks.py",
                "start_index": 0,
                "end_index": 2976,
                "start_line": 1,
                "end_line": 84,
                "max_line": 120,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            },
            {
                "code": "\"\"\"The CheckExternalLinksBuilder class.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport re\nimport socket\nimport time\nfrom copy import deepcopy\nfrom datetime import datetime, timezone\nfrom email.utils import parsedate_to_datetime\nfrom html.parser import HTMLParser\nfrom os import path\nfrom queue import PriorityQueue, Queue\nfrom threading import Thread\nfrom typing import Any, Generator, NamedTuple, Tuple, Union, cast\nfrom urllib.parse import unquote, urlparse, urlunparse\n\nfrom docutils import nodes\nfrom requests import Response\nfrom requests.exceptions import ConnectionError, HTTPError, TooManyRedirects\n\nfrom sphinx.application import Sphinx\nfrom sphinx.builders.dummy import DummyBuilder\nfrom sphinx.config import Config\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import __\nfrom sphinx.transforms.post_transforms import SphinxPostTransform\nfrom sphinx.util import encode_uri, logging, requests\nfrom sphinx.util.console import darkgray, darkgreen, purple, red, turquoise  # type: ignore\nfrom sphinx.util.nodes import get_node_line\n\nlogger = logging.getLogger(__name__)\n\nuri_re = re.compile('([a-z]+:)?//')  # matches to foo:// and // (a protocol relative URL)\n\n\nclass Hyperlink(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int | None\n\n\nclass CheckRequest(NamedTuple):\n    next_check: float\n    hyperlink: Hyperlink | None\n\n\nclass CheckResult(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int\n    status: str\n    message: str\n    code: int\n\n\nclass RateLimit(NamedTuple):\n    delay: float\n    next_check: float\n\n\n# Tuple is old styled CheckRequest\nCheckRequestType = Union[CheckRequest, Tuple[float, str, str, int]]\n\nDEFAULT_REQUEST_HEADERS = {\n    'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',\n}\nCHECK_IMMEDIATELY = 0\nQUEUE_POLL_SECS = 1\nDEFAULT_DELAY = 60.0\n\n\nclass AnchorCheckParser(HTMLParser):\n    \"\"\"Specialized HTML parser that looks for a specific anchor.\"\"\"\n\n    def __init__(self, search_anchor: str) -> None:\n        super().__init__()\n\n        self.search_anchor = search_anchor\n        self.found = False\n\n    def handle_starttag(self, tag: Any, attrs: Any) -> None:\n        for key, value in attrs:\n            if key in ('id', 'name') and value == self.search_anchor:\n                self.found = True\n                break",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 0,
                "end_index": 2310,
                "start_line": 1,
                "end_line": 430,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "sphinx/builders/linkcheck.py": [
                {
                    "chunk": {
                        "code": "def allowed_redirect(url: str, new_url: str) -> bool:\n            return any(\n                from_url.match(url) and to_url.match(new_url)\n                for from_url, to_url\n                in self.config.linkcheck_allowed_redirects.items()\n            )\n\n        def check(docname: str) -> tuple[str, str, int]:\n            # check for various conditions without bothering the network\n\n            for doc_matcher in self.documents_exclude:\n                if doc_matcher.match(docname):\n                    info = (\n                        f'{docname} matched {doc_matcher.pattern} from '\n                        'linkcheck_exclude_documents'\n                    )\n                    return 'ignored', info, 0\n\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                if uri_re.match(uri):\n                    # non supported URI schemes (ex. ftp)\n                    return 'unchecked', '', 0\n                else:\n                    srcdir = path.dirname(self.env.doc2path(docname))\n                    if path.exists(path.join(srcdir, uri)):\n                        return 'working', '', 0\n                    else:\n                        return 'broken', '', 0\n\n            # need to actually check the URI\n            for _ in range(self.config.linkcheck_retries):\n                status, info, code = check_uri()\n                if status != \"broken\":\n                    break\n\n            return (status, info, code)\n\n        while True:\n            check_request = self.wqueue.get()\n            next_check, hyperlink = check_request\n            if hyperlink is None:\n                break\n\n            uri, docname, lineno = hyperlink\n\n            if uri is None:\n                break\n            netloc = urlparse(uri).netloc\n            try:\n                # Refresh rate limit.\n                # When there are many links in the queue, workers are all stuck waiting\n                # for responses, but the builder keeps queuing. Links in the queue may\n                # have been queued before rate limits were discovered.\n                next_check = self.rate_limits[netloc].next_check\n            except KeyError:\n                pass\n            if next_check > time.time():\n                # Sleep before putting message back in the queue to avoid\n                # waking up other threads.\n                time.sleep(QUEUE_POLL_SECS)\n                self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                self.wqueue.task_done()\n                continue\n            status, info, code = check(docname)\n            if status == 'rate-limited':\n                logger.info(darkgray('-rate limited-   ') + uri + darkgray(' | sleeping...'))\n            else:\n                self.rqueue.put(CheckResult(uri, docname, lineno, status, info, code))\n            self.wqueue.task_done()",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 14844,
                        "end_index": 17804,
                        "start_line": 382,
                        "end_line": 452,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'allowed_redirect' function which is central to the feature request of handling allowed redirects."
                },
                {
                    "chunk": {
                        "code": "if response.url.rstrip('/') == req_url.rstrip('/'):\n                return 'working', '', 0\n            else:\n                new_url = response.url\n                if anchor:\n                    new_url += '#' + anchor\n\n                if allowed_redirect(req_url, new_url):\n                    return 'working', '', 0\n                elif response.history:\n                    # history contains any redirects, get last\n                    code = response.history[-1].status_code\n                    return 'redirected', new_url, code\n                else:\n                    return 'redirected', new_url, 0",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 14224,
                        "end_index": 14834,
                        "start_line": 366,
                        "end_line": 380,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the logic that determines if a redirect is allowed or not, which is directly related to the issue."
                },
                {
                    "chunk": {
                        "code": "class HyperlinkCollector(SphinxPostTransform):\n    builders = ('linkcheck',)\n    default_priority = 800\n\n    def run(self, **kwargs: Any) -> None:\n        builder = cast(CheckExternalLinksBuilder, self.app.builder)\n        hyperlinks = builder.hyperlinks\n\n        def add_uri(uri: str, node: nodes.Element) -> None:\n            newuri = self.app.emit_firstresult('linkcheck-process-uri', uri)\n            if newuri:\n                uri = newuri\n\n            try:\n                lineno = get_node_line(node)\n            except ValueError:\n                lineno = None\n            uri_info = Hyperlink(uri, self.env.docname, lineno)\n            if uri not in hyperlinks:\n                hyperlinks[uri] = uri_info\n\n        # reference nodes\n        for refnode in self.document.findall(nodes.reference):\n            if 'refuri' not in refnode:\n                continue\n            uri = refnode['refuri']\n            add_uri(uri, refnode)\n\n        # image nodes\n        for imgnode in self.document.findall(nodes.image):\n            uri = imgnode['candidates'].get('?')\n            if uri and '://' in uri:\n                add_uri(uri, imgnode)\n\n        # raw nodes\n        for rawnode in self.document.findall(nodes.raw):\n            uri = rawnode.get('source')\n            if uri and '://' in uri:\n                add_uri(uri, rawnode)\n\n\ndef rewrite_github_anchor(app: Sphinx, uri: str) -> str | None:\n    \"\"\"Rewrite anchor name of the hyperlink to github.com\n\n    The hyperlink anchors in github.com are dynamically generated.  This rewrites\n    them before checking and makes them comparable.\n    \"\"\"\n    parsed = urlparse(uri)\n    if parsed.hostname == \"github.com\" and parsed.fragment:\n        prefixed = parsed.fragment.startswith('user-content-')\n        if not prefixed:\n            fragment = f'user-content-{parsed.fragment}'\n            return urlunparse(parsed._replace(fragment=fragment))\n    return None\n\n\ndef compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -> None:\n    \"\"\"Compile patterns in linkcheck_allowed_redirects to the regexp objects.\"\"\"\n    for url, pattern in list(app.config.linkcheck_allowed_redirects.items()):\n        try:\n            app.config.linkcheck_allowed_redirects[re.compile(url)] = re.compile(pattern)\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects: %r %s'),\n                           exc.pattern, exc.msg)\n        finally:\n            # Remove the original regexp-string\n            app.config.linkcheck_allowed_redirects.pop(url)",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 19389,
                        "end_index": 21951,
                        "start_line": 493,
                        "end_line": 559,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'compile_linkcheck_allowed_redirects' function which compiles the allowed redirects into regex objects, a necessary part of the feature."
                },
                {
                    "chunk": {
                        "code": "def process_result(self, result: CheckResult) -> None:\n        filename = self.env.doc2path(result.docname, False)\n\n        linkstat = {\"filename\": filename, \"lineno\": result.lineno,\n                    \"status\": result.status, \"code\": result.code, \"uri\": result.uri,\n                    \"info\": result.message}\n        self.write_linkstat(linkstat)\n\n        if result.status == 'unchecked':\n            return\n        if result.status == 'working' and result.message == 'old':\n            return\n        if result.lineno:\n            logger.info('(%16s: line %4d) ', result.docname, result.lineno, nonl=True)\n        if result.status == 'ignored':\n            if result.message:\n                logger.info(darkgray('-ignored- ') + result.uri + ': ' + result.message)\n            else:\n                logger.info(darkgray('-ignored- ') + result.uri)\n        elif result.status == 'local':\n            logger.info(darkgray('-local-   ') + result.uri)\n            self.write_entry('local', result.docname, filename, result.lineno, result.uri)\n        elif result.status == 'working':\n            logger.info(darkgreen('ok        ') + result.uri + result.message)\n        elif result.status == 'broken':\n            if self.app.quiet or self.app.warningiserror:\n                logger.warning(__('broken link: %s (%s)'), result.uri, result.message,\n                               location=(result.docname, result.lineno))\n            else:\n                logger.info(red('broken    ') + result.uri + red(' - ' + result.message))\n            self.write_entry('broken', result.docname, filename, result.lineno,\n                             result.uri + ': ' + result.message)\n            self.broken_hyperlinks += 1\n        elif result.status == 'redirected':\n            try:\n                text, color = {\n                    301: ('permanently', purple),\n                    302: ('with Found', purple),\n                    303: ('with See Other', purple),\n                    307: ('temporarily', turquoise),\n                    308: ('permanently', purple),\n                }[result.code]\n            except KeyError:\n                text, color = ('with unknown code', purple)\n            linkstat['text'] = text\n            if self.config.linkcheck_allowed_redirects:\n                logger.warning('redirect  ' + result.uri + ' - ' + text + ' to ' +\n                               result.message, location=(result.docname, result.lineno))\n            else:\n                logger.info(color('redirect  ') + result.uri +\n                            color(' - ' + text + ' to ' + result.message))\n            self.write_entry('redirected ' + text, result.docname, filename,\n                             result.lineno, result.uri + ' to ' + result.message)\n        else:\n            raise ValueError(\"Unknown status %s.\" % result.status)",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 3479,
                        "end_index": 6320,
                        "start_line": 122,
                        "end_line": 176,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet processes the result of link checks and would need to be updated to handle the new 'unknown redirect' error status."
                },
                {
                    "chunk": {
                        "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    app.add_builder(CheckExternalLinksBuilder)\n    app.add_post_transform(HyperlinkCollector)\n\n    app.add_config_value('linkcheck_ignore', [], False)\n    app.add_config_value('linkcheck_exclude_documents', [], False)\n    app.add_config_value('linkcheck_allowed_redirects', {}, False)\n    app.add_config_value('linkcheck_auth', [], False)\n    app.add_config_value('linkcheck_request_headers', {}, False)\n    app.add_config_value('linkcheck_retries', 1, False)\n    app.add_config_value('linkcheck_timeout', None, False, [int, float])\n    app.add_config_value('linkcheck_workers', 5, False)\n    app.add_config_value('linkcheck_anchors', True, False)\n    # Anchors starting with ! are ignored since they are\n    # commonly used for dynamic pages\n    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], False)\n    app.add_config_value('linkcheck_rate_limit_timeout', 300.0, False)\n\n    app.add_event('linkcheck-process-uri')\n\n    app.connect('config-inited', compile_linkcheck_allowed_redirects, priority=800)\n\n    # FIXME: Disable URL rewrite handler for github.com temporarily.\n    # ref: https://github.com/sphinx-doc/sphinx/issues/9435\n    # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 21954,
                        "end_index": 23325,
                        "start_line": 562,
                        "end_line": 592,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet sets up configuration values for link checking, including 'linkcheck_allowed_redirects', which will be used for the new feature."
                }
            ]
        },
        "solution_task": "To implement the feature that prohibits unknown redirects while allowing specified ones, you can follow these steps:\n\n- Modify the `linkcheck_allowed_redirects` configuration to accept pairs of URLs (source and target) for allowed redirects.\n- Update the `allowed_redirect` function to check if a redirect is within the allowed pairs.\n- Modify the `check` function to handle the new logic for allowed and prohibited redirects.\n- Update the `process_result` function to report an error for prohibited redirects.\n- Ensure that the configuration is compiled correctly in the `compile_linkcheck_allowed_redirects` function.\n\nHere's a high-level overview of the changes:\n\n1. Update the configuration to accept pairs of URLs:\n```python\n# In setup function\napp.add_config_value('linkcheck_allowed_redirects_pairs', [], False)\n```\n\n2. Modify the `compile_linkcheck_allowed_redirects` function to compile the pairs:\n```python\ndef compile_linkcheck_allowed_redirects_pairs(app: Sphinx, config: Config) -> None:\n    compiled_pairs = []\n    for from_url, to_url in app.config.linkcheck_allowed_redirects_pairs:\n        try:\n            compiled_pairs.append((re.compile(from_url), re.compile(to_url)))\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects_pairs: %r %s'),\n                           exc.pattern, exc.msg)\n    app.config.linkcheck_allowed_redirects_pairs = compiled_pairs\n```\n\n3. Update the `allowed_redirect` function to use the compiled pairs:\n```python\ndef allowed_redirect(url: str, new_url: str) -> bool:\n    return any(\n        from_url.match(url) and to_url.match(new_url)\n        for from_url, to_url in self.config.linkcheck_allowed_redirects_pairs\n    )\n```\n\n4. Modify the `check` function to handle the new logic:\n```python\n# Inside the check function, after the check_uri() call\nif status == 'redirected' and not allowed_redirect(uri, new_url):\n    return 'prohibited-redirect', new_url, code\n```\n\n5. Update the `process_result` function to report an error for prohibited redirects:\n```python\n# Inside the process_result function\nelif result.status == 'prohibited-redirect':\n    logger.warning(__('prohibited redirect: %s (redirected to %s)'), result.uri, result.message,\n                   location=(result.docname, result.lineno))\n    self.write_entry('prohibited-redirect', result.docname, filename, result.lineno,\n                     result.uri + ': redirected to ' + result.message)\n    self.broken_hyperlinks += 1\n```\n\n6. Connect the new compile function in the `setup` function:\n```python\napp.connect('config-inited', compile_linkcheck_allowed_redirects_pairs, priority=800)\n```\n\n7. Update the documentation to describe the new configuration option and how to use it.\n\nRemember to test the changes thoroughly to ensure that the link checker behaves as expected, allowing specified redirects and prohibiting others.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed, step-by-step guide on how to implement the feature that prohibits unknown redirects while allowing specified ones. It includes specific code snippets and modifications to existing functions, such as `linkcheck_allowed_redirects`, `allowed_redirect`, `check`, `process_result`, and `compile_linkcheck_allowed_redirects`. The RESPONSE also suggests updating the documentation to describe the new configuration option and how to use it. Additionally, it provides links to relevant code snippets in the existing codebase, which is highly useful for developers looking to implement the feature. The RESPONSE is comprehensive and addresses all aspects of the feature request, including configuration, logic for allowed and prohibited redirects, error reporting, and documentation updates.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711702644.6709728,
        "result": "To implement the feature that prohibits unknown redirects while allowing specified ones, you can follow these steps:\n\n- Modify the `linkcheck_allowed_redirects` configuration to accept pairs of URLs (source and target) for allowed redirects.\n- Update the `allowed_redirect` function to check if a redirect is within the allowed pairs.\n- Modify the `check` function to handle the new logic for allowed and prohibited redirects.\n- Update the `process_result` function to report an error for prohibited redirects.\n- Ensure that the configuration is compiled correctly in the `compile_linkcheck_allowed_redirects` function.\n\nHere's a high-level overview of the changes:\n\n1. Update the configuration to accept pairs of URLs:\n```python\n# In setup function\napp.add_config_value('linkcheck_allowed_redirects_pairs', [], False)\n```\n\n2. Modify the `compile_linkcheck_allowed_redirects` function to compile the pairs:\n```python\ndef compile_linkcheck_allowed_redirects_pairs(app: Sphinx, config: Config) -> None:\n    compiled_pairs = []\n    for from_url, to_url in app.config.linkcheck_allowed_redirects_pairs:\n        try:\n            compiled_pairs.append((re.compile(from_url), re.compile(to_url)))\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects_pairs: %r %s'),\n                           exc.pattern, exc.msg)\n    app.config.linkcheck_allowed_redirects_pairs = compiled_pairs\n```\n\n3. Update the `allowed_redirect` function to use the compiled pairs:\n```python\ndef allowed_redirect(url: str, new_url: str) -> bool:\n    return any(\n        from_url.match(url) and to_url.match(new_url)\n        for from_url, to_url in self.config.linkcheck_allowed_redirects_pairs\n    )\n```\n\n4. Modify the `check` function to handle the new logic:\n```python\n# Inside the check function, after the check_uri() call\nif status == 'redirected' and not allowed_redirect(uri, new_url):\n    return 'prohibited-redirect', new_url, code\n```\n\n5. Update the `process_result` function to report an error for prohibited redirects:\n```python\n# Inside the process_result function\nelif result.status == 'prohibited-redirect':\n    logger.warning(__('prohibited redirect: %s (redirected to %s)'), result.uri, result.message,\n                   location=(result.docname, result.lineno))\n    self.write_entry('prohibited-redirect', result.docname, filename, result.lineno,\n                     result.uri + ': redirected to ' + result.message)\n    self.broken_hyperlinks += 1\n```\n\n6. Connect the new compile function in the `setup` function:\n```python\napp.connect('config-inited', compile_linkcheck_allowed_redirects_pairs, priority=800)\n```\n\n7. Update the documentation to describe the new configuration option and how to use it.\n\nRemember to test the changes thoroughly to ensure that the link checker behaves as expected, allowing specified redirects and prohibiting others.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx) \u2192 [builders](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx/builders)- [Lines 382 - 452](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L382-L452)\n\n This snippet contains the 'allowed_redirect' function which is central to the feature request of handling allowed redirects. \n\n\n   - [Lines 366 - 380](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L366-L380)\n\n This snippet includes the logic that determines if a redirect is allowed or not, which is directly related to the issue. \n\n\n   - [Lines 493 - 559](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L493-L559)\n\n This snippet contains the 'compile_linkcheck_allowed_redirects' function which compiles the allowed redirects into regex objects, a necessary part of the feature. \n\n\n   - [Lines 122 - 176](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L122-L176)\n\n This snippet processes the result of link checks and would need to be updated to handle the new 'unknown redirect' error status. \n\n\n   - [Lines 562 - 592](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L562-L592)\n\n This snippet sets up configuration values for link checking, including 'linkcheck_allowed_redirects', which will be used for the new feature."
    }
}