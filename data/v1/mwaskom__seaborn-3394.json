{
    "id": "mwaskom__seaborn-3394",
    "repo_name": "testbed/mwaskom__seaborn__0.13",
    "task_id": 626708051286895232,
    "title": "pd.NA reverses axis ordering",
    "body": "## Issue\r\nWhen plotting with `pd.NA`, axis ordering get reversed into **descending**. \r\n\r\n## Workaround\r\n`np.nan` does not produce this issue\r\n\r\n## Expected Behavior\r\nNAs should be excluded without reversing axis order\r\n\r\n## Reproducible Example\r\n```python\r\nimport pandas as pd\r\nimport numpy as np\r\nimport seaborn as sns\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\nmock_data = pd.DataFrame({\r\n    'date': ['0', '1', '2', '3'],\r\n    'value': [1, 2, 1, 1.5]\r\n})\r\n\r\nmock_data_full = mock_data.copy()\r\nmock_data_full['type'] = 'no_NA'\r\n\r\nmock_data_pd_na = mock_data.copy()\r\nmock_data_pd_na['type'] = 'pd.NA'\r\nmock_data_pd_na.loc[2, 'value'] = pd.NA\r\n\r\nmock_data_np_nan = mock_data.copy()\r\nmock_data_np_nan['type'] = 'np.nan'\r\nmock_data_np_nan.loc[2, 'value'] = np.nan\r\n\r\ntest_data = pd.concat([mock_data_full, mock_data_pd_na, mock_data_np_nan])\r\n\r\ngrid = sns.FacetGrid(\r\n    data=test_data,\r\n    col='type',\r\n    sharey=False,\r\n    sharex=True,  # time-series consistency\r\n)\r\ngrid.map(sns.lineplot, 'date', 'value', alpha=0.5)\r\nplt.show()\r\n```\r\n#### Result\r\n![image](https://user-images.githubusercontent.com/22682408/138944257-f0ff1d0b-717b-48cf-895d-97683a9dd019.png)\r\n\r\n\r\n\r\n## System Info\r\n```python\r\nprint(f'''\r\n    python: {sys.version},\r\n    seaborn: {sns.__version__},\r\n    pandas: {pd.__version__}\r\n''')\r\n```\r\n```log\r\n    python: 3.9.7 (default, Sep  9 2021, 23:20:13)  [GCC 9.3.0],\r\n    seaborn: 0.11.2,\r\n    pandas: 1.3.4\r\n```\r\n\r\n\r\n\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/mwaskom__seaborn__0.13.git",
    "requested_commit": "",
    "mayil_response": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83e\udd14.                   But we've outlined some ideas that might help you get started:\n\n- Replace `pd.NA` with `np.nan` in the DataFrame before plotting.\n- If the DataFrame is being created or modified before the plot, ensure that any missing data is represented as `np.nan` and not `pd.NA`.\n- If the DataFrame is expected to have `pd.NA` values (e.g., from external sources or other parts of the code), add a preprocessing step to convert `pd.NA` to `np.nan` before plotting.\n  ```python\n  df.replace(pd.NA, np.nan, inplace=True)\n  ```\n- After this replacement, proceed with the plotting as usual using `sns.FacetGrid`, `sns.lineplot`, and `plt.show`.\n\n### Code snippets to check\n\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.13/tree//seaborn)- [Lines 1420 - 1470](https://github.com/testbed/mwaskom__seaborn__0.13/blob//seaborn/_base.py#L1420-L1470)\n\n This snippet from seaborn/_base.py shows how categorical data is handled and NA values are dropped, which is directly related to the issue of axis ordering when plotting with pd.NA.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00031,
        "snippet_processor": 0.061450000000000005,
        "issue_star_creation": 0.034129999999999994,
        "issue_star_solver": 0.04283,
        "bouncer": 0.027120000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711735664.8535838,
        "relevant_snippets": [
            {
                "code": "# Now get a reference to the categorical data vector and remove na values\n        cat_data = self.plot_data[axis].dropna()\n\n        # Get the initial categorical order, which we do before string\n        # conversion to respect the original types of the order list.\n        # Track whether the order is given explicitly so that we can know\n        # whether or not to use the order constructed here downstream\n        self._var_ordered[axis] = order is not None or cat_data.dtype.name == \"category\"\n        order = pd.Index(categorical_order(cat_data, order), name=axis)\n\n        # Then convert data to strings. This is because in matplotlib,\n        # \"categorical\" data really mean \"string\" data, so doing this artists\n        # will be drawn on the categorical axis with a fixed scale.\n        # TODO implement formatter here; check that it returns strings?\n        if formatter is not None:\n            cat_data = cat_data.map(formatter)\n            order = order.map(formatter)\n        else:\n            cat_data = cat_data.astype(str)\n            order = order.astype(str)\n\n        # Update the levels list with the type-converted order variable\n        self.var_levels[axis] = order\n\n        # Now ensure that seaborn will use categorical rules internally\n        self.var_types[axis] = \"categorical\"\n\n        # Put the string-typed categorical vector back into the plot_data structure\n        self.plot_data[axis] = cat_data\n\n        return self",
                "filename": "seaborn/_base.py",
                "start_index": 54736,
                "end_index": 56188,
                "start_line": 1420,
                "end_line": 1470,
                "max_line": 1776,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "\"\"\"\nOverlapping densities ('ridge plot')\n====================================\n\n\n\"\"\"\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set_theme(style=\"white\", rc={\"axes.facecolor\": (0, 0, 0, 0)})\n\n# Create the data\nrs = np.random.RandomState(1979)\nx = rs.randn(500)\ng = np.tile(list(\"ABCDEFGHIJ\"), 50)\ndf = pd.DataFrame(dict(x=x, g=g))\nm = df.g.map(ord)\ndf[\"x\"] += m\n\n# Initialize the FacetGrid object\npal = sns.cubehelix_palette(10, rot=-.25, light=.7)\ng = sns.FacetGrid(df, row=\"g\", hue=\"g\", aspect=15, height=.5, palette=pal)\n\n# Draw the densities in a few steps\ng.map(sns.kdeplot, \"x\",\n      bw_adjust=.5, clip_on=False,\n      fill=True, alpha=1, linewidth=1.5)\ng.map(sns.kdeplot, \"x\", clip_on=False, color=\"w\", lw=2, bw_adjust=.5)\n\n# passing color=None to refline() uses the hue mapping\ng.refline(y=0, linewidth=2, linestyle=\"-\", color=None, clip_on=False)\n\n\n# Define and use a simple function to label the plot in axes coordinates\ndef label(x, color, label):\n    ax = plt.gca()\n    ax.text(0, .2, label, fontweight=\"bold\", color=color,\n            ha=\"left\", va=\"center\", transform=ax.transAxes)\n\n\ng.map(label, \"x\")\n\n# Set the subplots to overlap\ng.figure.subplots_adjust(hspace=-.25)\n\n# Remove axes details that don't play well with overlap\ng.set_titles(\"\")\ng.set(yticks=[], ylabel=\"\")\ng.despine(bottom=True, left=True)",
                "filename": "examples/kde_ridgeplot.py",
                "start_index": 0,
                "end_index": 1373,
                "start_line": 1,
                "end_line": 50,
                "max_line": 50,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "\"\"\"\nPlotting on a large number of facets\n====================================\n\n_thumb: .4, .3\n\n\"\"\"\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nsns.set_theme(style=\"ticks\")\n\n# Create a dataset with many short random walks\nrs = np.random.RandomState(4)\npos = rs.randint(-1, 2, (20, 5)).cumsum(axis=1)\npos -= pos[:, 0, np.newaxis]\nstep = np.tile(range(5), 20)\nwalk = np.repeat(range(20), 5)\ndf = pd.DataFrame(np.c_[pos.flat, step, walk],\n                  columns=[\"position\", \"step\", \"walk\"])\n\n# Initialize a grid of plots with an Axes for each walk\ngrid = sns.FacetGrid(df, col=\"walk\", hue=\"walk\", palette=\"tab20c\",\n                     col_wrap=4, height=1.5)\n\n# Draw a horizontal line to show the starting point\ngrid.refline(y=0, linestyle=\":\")\n\n# Draw a line plot to show the trajectory of each random walk\ngrid.map(plt.plot, \"step\", \"position\", marker=\"o\")\n\n# Adjust the tick positions and labels\ngrid.set(xticks=np.arange(5), yticks=[-3, 3],\n         xlim=(-.5, 4.5), ylim=(-3.5, 3.5))\n\n# Adjust the arrangement of the plots\ngrid.fig.tight_layout(w_pad=1)",
                "filename": "examples/many_facets.py",
                "start_index": 0,
                "end_index": 1109,
                "start_line": 1,
                "end_line": 39,
                "max_line": 39,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "\"\"\"\nColor palette choices\n=====================\n\n\"\"\"\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set_theme(style=\"white\", context=\"talk\")\nrs = np.random.RandomState(8)\n\n# Set up the matplotlib figure\nf, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(7, 5), sharex=True)\n\n# Generate some sequential data\nx = np.array(list(\"ABCDEFGHIJ\"))\ny1 = np.arange(1, 11)\nsns.barplot(x=x, y=y1, palette=\"rocket\", ax=ax1)\nax1.axhline(0, color=\"k\", clip_on=False)\nax1.set_ylabel(\"Sequential\")\n\n# Center the data to make it diverging\ny2 = y1 - 5.5\nsns.barplot(x=x, y=y2, palette=\"vlag\", ax=ax2)\nax2.axhline(0, color=\"k\", clip_on=False)\nax2.set_ylabel(\"Diverging\")\n\n# Randomly reorder the data to make it qualitative\ny3 = rs.choice(y1, len(y1), replace=False)\nsns.barplot(x=x, y=y3, palette=\"deep\", ax=ax3)\nax3.axhline(0, color=\"k\", clip_on=False)\nax3.set_ylabel(\"Qualitative\")\n\n# Finalize the plot\nsns.despine(bottom=True)\nplt.setp(f.axes, yticks=[])\nplt.tight_layout(h_pad=2)",
                "filename": "examples/palette_choices.py",
                "start_index": 0,
                "end_index": 991,
                "start_line": 1,
                "end_line": 37,
                "max_line": 37,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\nimport re\nfrom copy import copy\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom functools import partial\nfrom typing import Any, Callable, Tuple, Optional, ClassVar\n\nimport numpy as np\nimport matplotlib as mpl\nfrom matplotlib.ticker import (\n    Locator,\n    Formatter,\n    AutoLocator,\n    AutoMinorLocator,\n    FixedLocator,\n    LinearLocator,\n    LogLocator,\n    SymmetricalLogLocator,\n    MaxNLocator,\n    MultipleLocator,\n    EngFormatter,\n    FuncFormatter,\n    LogFormatterSciNotation,\n    ScalarFormatter,\n    StrMethodFormatter,\n)\nfrom matplotlib.dates import (\n    AutoDateLocator,\n    AutoDateFormatter,\n    ConciseDateFormatter,\n)\nfrom matplotlib.axis import Axis\nfrom matplotlib.scale import ScaleBase\nfrom pandas import Series\n\nfrom seaborn._core.rules import categorical_order\nfrom seaborn._core.typing import Default, default\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from seaborn._core.plot import Plot\n    from seaborn._core.properties import Property\n    from numpy.typing import ArrayLike, NDArray\n\n    TransFuncs = Tuple[\n        Callable[[ArrayLike], ArrayLike], Callable[[ArrayLike], ArrayLike]\n    ]\n\n    # TODO Reverting typing to Any as it was proving too complicated to\n    # work out the right way to communicate the types to mypy. Revisit!\n    Pipeline = Sequence[Optional[Callable[[Any], Any]]]",
                "filename": "seaborn/_core/scales.py",
                "start_index": 0,
                "end_index": 1401,
                "start_line": 1,
                "end_line": 52,
                "max_line": 1092,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "def scale_datetime(self, axis, *args, **kwargs):\n\n        # Use pd.to_datetime to convert strings or numbers to datetime objects\n        # Note, use day-resolution for numeric->datetime to match matplotlib\n\n        raise NotImplementedError",
                "filename": "seaborn/_base.py",
                "start_index": 51450,
                "end_index": 51690,
                "start_line": 1352,
                "end_line": 1357,
                "max_line": 1776,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "\"\"\"\nConditional means with observations\n===================================\n\n\"\"\"\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nsns.set_theme(style=\"whitegrid\")\niris = sns.load_dataset(\"iris\")\n\n# \"Melt\" the dataset to \"long-form\" or \"tidy\" representation\niris = pd.melt(iris, \"species\", var_name=\"measurement\")\n\n# Initialize the figure\nf, ax = plt.subplots()\nsns.despine(bottom=True, left=True)\n\n# Show each observation with a scatterplot\nsns.stripplot(\n    data=iris, x=\"value\", y=\"measurement\", hue=\"species\",\n    dodge=True, alpha=.25, zorder=1, legend=False\n)\n\n# Show the conditional means, aligning each pointplot in the\n# center of the strips by adjusting the width allotted to each\n# category (.8 by default) by the number of hue levels\nsns.pointplot(\n    data=iris, x=\"value\", y=\"measurement\", hue=\"species\",\n    join=False, dodge=.8 - .8 / 3, palette=\"dark\",\n    markers=\"d\", scale=.75, errorbar=None\n)\n\n# Improve the legend\nsns.move_legend(\n    ax, loc=\"lower right\", ncol=3, frameon=True, columnspacing=1, handletextpad=0\n)",
                "filename": "examples/jitter_stripplot.py",
                "start_index": 0,
                "end_index": 1062,
                "start_line": 1,
                "end_line": 38,
                "max_line": 38,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "\"\"\"\nPlotting a diagonal correlation matrix\n======================================\n\n_thumb: .3, .6\n\"\"\"\nfrom string import ascii_letters\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nsns.set_theme(style=\"white\")\n\n# Generate a large random dataset\nrs = np.random.RandomState(33)\nd = pd.DataFrame(data=rs.normal(size=(100, 26)),\n                 columns=list(ascii_letters[26:]))\n\n# Compute the correlation matrix\ncorr = d.corr()\n\n# Generate a mask for the upper triangle\nmask = np.triu(np.ones_like(corr, dtype=bool))\n\n# Set up the matplotlib figure\nf, ax = plt.subplots(figsize=(11, 9))\n\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(230, 20, as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})",
                "filename": "examples/many_pairwise_correlations.py",
                "start_index": 0,
                "end_index": 907,
                "start_line": 1,
                "end_line": 34,
                "max_line": 34,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "\"\"\"\nLineplot from a wide-form dataset\n=================================\n\n_thumb: .52, .5\n\n\"\"\"\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nsns.set_theme(style=\"whitegrid\")\n\nrs = np.random.RandomState(365)\nvalues = rs.randn(365, 4).cumsum(axis=0)\ndates = pd.date_range(\"1 1 2016\", periods=365, freq=\"D\")\ndata = pd.DataFrame(values, dates, columns=[\"A\", \"B\", \"C\", \"D\"])\ndata = data.rolling(7).mean()\n\nsns.lineplot(data=data, palette=\"tab10\", linewidth=2.5)",
                "filename": "examples/wide_data_lineplot.py",
                "start_index": 0,
                "end_index": 470,
                "start_line": 1,
                "end_line": 19,
                "max_line": 19,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            },
            {
                "code": "\"\"\"\nAnscombe's quartet\n==================\n\n_thumb: .4, .4\n\"\"\"\nimport seaborn as sns\nsns.set_theme(style=\"ticks\")\n\n# Load the example dataset for Anscombe's quartet\ndf = sns.load_dataset(\"anscombe\")\n\n# Show the results of a linear regression within each dataset\nsns.lmplot(\n    data=df, x=\"x\", y=\"y\", col=\"dataset\", hue=\"dataset\",\n    col_wrap=2, palette=\"muted\", ci=None,\n    height=4, scatter_kws={\"s\": 50, \"alpha\": 1}\n)",
                "filename": "examples/anscombes_quartet.py",
                "start_index": 0,
                "end_index": 421,
                "start_line": 1,
                "end_line": 18,
                "max_line": 18,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.13",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "seaborn/_base.py": [
                {
                    "chunk": {
                        "code": "# Now get a reference to the categorical data vector and remove na values\n        cat_data = self.plot_data[axis].dropna()\n\n        # Get the initial categorical order, which we do before string\n        # conversion to respect the original types of the order list.\n        # Track whether the order is given explicitly so that we can know\n        # whether or not to use the order constructed here downstream\n        self._var_ordered[axis] = order is not None or cat_data.dtype.name == \"category\"\n        order = pd.Index(categorical_order(cat_data, order), name=axis)\n\n        # Then convert data to strings. This is because in matplotlib,\n        # \"categorical\" data really mean \"string\" data, so doing this artists\n        # will be drawn on the categorical axis with a fixed scale.\n        # TODO implement formatter here; check that it returns strings?\n        if formatter is not None:\n            cat_data = cat_data.map(formatter)\n            order = order.map(formatter)\n        else:\n            cat_data = cat_data.astype(str)\n            order = order.astype(str)\n\n        # Update the levels list with the type-converted order variable\n        self.var_levels[axis] = order\n\n        # Now ensure that seaborn will use categorical rules internally\n        self.var_types[axis] = \"categorical\"\n\n        # Put the string-typed categorical vector back into the plot_data structure\n        self.plot_data[axis] = cat_data\n\n        return self",
                        "filename": "seaborn/_base.py",
                        "start_index": 54736,
                        "end_index": 56188,
                        "start_line": 1420,
                        "end_line": 1470,
                        "max_line": 1776,
                        "git_instance": "github",
                        "repo_name": "testbed/mwaskom__seaborn__0.13",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from seaborn/_base.py shows how categorical data is handled and NA values are dropped, which is directly related to the issue of axis ordering when plotting with pd.NA."
                }
            ]
        },
        "solution_task": "- Replace `pd.NA` with `np.nan` in the DataFrame before plotting.\n- If the DataFrame is being created or modified before the plot, ensure that any missing data is represented as `np.nan` and not `pd.NA`.\n- If the DataFrame is expected to have `pd.NA` values (e.g., from external sources or other parts of the code), add a preprocessing step to convert `pd.NA` to `np.nan` before plotting.\n  ```python\n  df.replace(pd.NA, np.nan, inplace=True)\n  ```\n- After this replacement, proceed with the plotting as usual using `sns.FacetGrid`, `sns.lineplot`, and `plt.show`.",
        "bouncer_response": {
            "score": 5,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a workaround to the issue by suggesting the replacement of pd.NA with np.nan, which is actionable and relevant. It also includes a code snippet to perform this replacement, which adds to its utility. However, the RESPONSE does not address the underlying issue of why pd.NA reverses the axis ordering or provide a solution that would allow the use of pd.NA without this side effect. The link to the seaborn code snippet is potentially useful for someone looking to understand the internal handling of NA values, but it does not offer a direct solution to the problem.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711735740.471564,
        "result": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83e\udd14.                   But we've outlined some ideas that might help you get started:\n\n- Replace `pd.NA` with `np.nan` in the DataFrame before plotting.\n- If the DataFrame is being created or modified before the plot, ensure that any missing data is represented as `np.nan` and not `pd.NA`.\n- If the DataFrame is expected to have `pd.NA` values (e.g., from external sources or other parts of the code), add a preprocessing step to convert `pd.NA` to `np.nan` before plotting.\n  ```python\n  df.replace(pd.NA, np.nan, inplace=True)\n  ```\n- After this replacement, proceed with the plotting as usual using `sns.FacetGrid`, `sns.lineplot`, and `plt.show`.\n\n### Code snippets to check\n\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.13/tree//seaborn)- [Lines 1420 - 1470](https://github.com/testbed/mwaskom__seaborn__0.13/blob//seaborn/_base.py#L1420-L1470)\n\n This snippet from seaborn/_base.py shows how categorical data is handled and NA values are dropped, which is directly related to the issue of axis ordering when plotting with pd.NA."
    }
}