{
    "id": "scikit-learn__scikit-learn-13877",
    "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
    "task_id": 2349992463546653896,
    "title": "pairwise_distances returns zeros for metric cosine when executed in parallel",
    "body": "#### Description\r\n`pairwise_distances` returns a list of zeros when calculating `cosine` with `n_jobs` equal to -1 or greater than 2. Using `n_jobs=1` calculates the expected results.\r\n\r\nUsing the metric `euclidean` returns non-zero results, but the values seem to be integers instead of floats.\r\n\r\n#### Steps/Code to Reproduce\r\n```python\r\nimport numpy as np\r\nfrom sklearn.metrics import pairwise_distances\r\n\r\nX = np.array([\r\n    [1, 3],\r\n    [2, 1],\r\n    [3, 2]\r\n])\r\npairwise_distances(X, metric='cosine', n_jobs=-1)\r\n```\r\n\r\n#### Expected Results\r\n```\r\n[[0.         0.29289322 0.21064778]\r\n [0.29289322 0.         0.00772212]\r\n [0.21064778 0.00772212 0.        ]]\r\n```\r\n\r\n#### Actual Results\r\n```\r\n[[0 0 0]\r\n [0 0 0]\r\n [0 0 0]]\r\n```\r\n\r\n#### Details\r\nI executed `pairwise_distances` with different values for `metric` and `n_jobs`. The outputs were as follows:\r\n```\r\nX:\r\n[[1 3]\r\n [2 1]\r\n [3 2]]\r\n\r\n\r\nmetric=cosine, n_jobs=-1:\r\n[[0 0 0]\r\n [0 0 0]\r\n [0 0 0]]\r\n\r\nmetric=cosine, n_jobs=1:\r\n[[0.         0.29289322 0.21064778]\r\n [0.29289322 0.         0.00772212]\r\n [0.21064778 0.00772212 0.        ]]\r\n\r\nmetric=cosine, n_jobs=2:\r\n[[0 0 0]\r\n [0 0 0]\r\n [0 0 0]]\r\n\r\n\r\nmetric=euclidean, n_jobs=-1:\r\n[[0 2 2]\r\n [2 0 1]\r\n [2 1 0]]\r\n\r\nmetric=euclidean, n_jobs=1:\r\n[[0.         2.23606798 2.23606798]\r\n [2.23606798 0.         1.41421356]\r\n [2.23606798 1.41421356 0.        ]]\r\n\r\nmetric=euclidean, n_jobs=2:\r\n[[0 2 2]\r\n [2 0 1]\r\n [2 1 0]]\r\n```\r\n\r\n#### Versions\r\n```\r\nSystem:\r\n    python: 3.6.7 (default, Nov 21 2018, 09:28:58)  [GCC 8.2.1 20180831]\r\nexecutable: /home/lennart/tool-playground/jupyter/.venv-3.6/bin/python3.6\r\n   machine: Linux-5.0.9-2-MANJARO-x86_64-with-arch-Manjaro-Linux\r\n\r\nBLAS:\r\n    macros: NO_ATLAS_INFO=1\r\n  lib_dirs: /usr/lib64\r\ncblas_libs: cblas\r\n\r\nPython deps:\r\n       pip: 19.0.3\r\nsetuptools: 39.0.1\r\n   sklearn: 0.21.0\r\n     numpy: 1.16.2\r\n     scipy: 1.2.1\r\n    Cython: None\r\n    pandas: 0.24.1\r\n```\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__0.22.git",
    "requested_commit": "",
    "mayil_response": "- Investigate the implementation of `pairwise_distances` in `sklearn/metrics/pairwise.py` to ensure that it correctly handles the `n_jobs` parameter for parallel computation.\n- Ensure that the `dtype` of the output distance matrix is `float` and not inadvertently cast to `int` when using `metric='euclidean'`.\n- Check the `return` statement of the `_parallel_pairwise` function to confirm that the output matrix `ret` retains its `float` data type after parallel computation.\n- Verify that the `np.fill_diagonal(ret, 0)` call in `_parallel_pairwise` does not alter the data type of the matrix `ret`.\n- If the issue persists, consider adding an explicit cast to `float` for the output of the distance computation to ensure the correct data type is returned, for example:\n  ```python\n  return ret.astype(float)\n  ```\n- Review any recent changes to the `pairwise_distances` function or related utility functions that may have introduced the issue with `n_jobs` and data type handling.\n- If the issue is specific to certain versions of dependencies (NumPy, SciPy, scikit-learn), consider adding version checks and warnings to inform users about potential incompatibilities.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [metrics](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/metrics)- [Lines 233 - 1163](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L233-L1163)\n\n This snippet contains the implementation of cosine_distances, which is relevant because the issue is with the cosine metric returning zeros. \n\n\n   - [Lines 2035 - 2425](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L2035-L2425)\n\n This snippet contains the logic for handling different metrics and parallel execution in pairwise_distances, which is directly related to the issue. \n\n\n   - [Lines 1756 - 1817](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L1756-L1817)\n\n This snippet lists the valid metrics for pairwise_distances and could be relevant to ensure that the cosine and euclidean metrics are correctly mapped to their functions. \n\n\n   - [Lines 2034 - 2076](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L2034-L2076)\n\n This snippet includes the logic for chunking the data in pairwise_distances, which could be relevant since the issue occurs when n_jobs is not equal to 1.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005394999999999999,
        "snippet_processor": 0.08021,
        "issue_star_creation": 0.03338,
        "issue_star_solver": 0.08541,
        "bouncer": 0.023790000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711739736.898578,
        "relevant_snippets": [
            {
                "code": "# Author: Mathieu Blondel <mathieu@mblondel.org>\n# License: BSD 3 clause\nimport time\n\nimport matplotlib.pyplot as plt\n\nfrom sklearn.metrics.pairwise import pairwise_distances, pairwise_kernels\nfrom sklearn.utils import check_random_state\n\n\ndef plot(func):\n    random_state = check_random_state(0)\n    one_core = []\n    multi_core = []\n    sample_sizes = range(1000, 6000, 1000)\n\n    for n_samples in sample_sizes:\n        X = random_state.rand(n_samples, 300)\n\n        start = time.time()\n        func(X, n_jobs=1)\n        one_core.append(time.time() - start)\n\n        start = time.time()\n        func(X, n_jobs=-1)\n        multi_core.append(time.time() - start)\n\n    plt.figure(\"scikit-learn parallel %s benchmark results\" % func.__name__)\n    plt.plot(sample_sizes, one_core, label=\"one core\")\n    plt.plot(sample_sizes, multi_core, label=\"multi core\")\n    plt.xlabel(\"n_samples\")\n    plt.ylabel(\"Time (s)\")\n    plt.title(\"Parallel %s\" % func.__name__)\n    plt.legend()\n\n\ndef euclidean_distances(X, n_jobs):\n    return pairwise_distances(X, metric=\"euclidean\", n_jobs=n_jobs)\n\n\ndef rbf_kernels(X, n_jobs):\n    return pairwise_kernels(X, metric=\"rbf\", n_jobs=n_jobs, gamma=0.1)\n\n\nplot(euclidean_distances)\nplot(rbf_kernels)\nplt.show()",
                "filename": "benchmarks/bench_plot_parallel_pairwise.py",
                "start_index": 0,
                "end_index": 1235,
                "start_line": 1,
                "end_line": 47,
                "max_line": 47,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "from sklearn.metrics.pairwise import pairwise_distances\n\nfrom .common import Benchmark\nfrom .datasets import _random_dataset\n\n\nclass PairwiseDistancesBenchmark(Benchmark):\n    \"\"\"\n    Benchmarks for pairwise distances.\n    \"\"\"\n\n    param_names = [\"representation\", \"metric\", \"n_jobs\"]\n    params = (\n        [\"dense\", \"sparse\"],\n        [\"cosine\", \"euclidean\", \"manhattan\", \"correlation\"],\n        Benchmark.n_jobs_vals,\n    )\n\n    def setup(self, *params):\n        representation, metric, n_jobs = params\n\n        if representation == \"sparse\" and metric == \"correlation\":\n            raise NotImplementedError\n\n        if Benchmark.data_size == \"large\":\n            if metric in (\"manhattan\", \"correlation\"):\n                n_samples = 8000\n            else:\n                n_samples = 24000\n        else:\n            if metric in (\"manhattan\", \"correlation\"):\n                n_samples = 4000\n            else:\n                n_samples = 12000\n\n        data = _random_dataset(n_samples=n_samples, representation=representation)\n        self.X, self.X_val, self.y, self.y_val = data\n\n        self.pdist_params = {\"metric\": metric, \"n_jobs\": n_jobs}\n\n    def time_pairwise_distances(self, *args):\n        pairwise_distances(self.X, **self.pdist_params)\n\n    def peakmem_pairwise_distances(self, *args):\n        pairwise_distances(self.X, **self.pdist_params)",
                "filename": "asv_benchmarks/benchmarks/metrics.py",
                "start_index": 0,
                "end_index": 1362,
                "start_line": 1,
                "end_line": 45,
                "max_line": 45,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "@validate_params(\n    {\n        \"X\": [\"array-like\", \"sparse matrix\"],\n        \"Y\": [\"array-like\", \"sparse matrix\", None],\n    },\n    prefer_skip_nested_validation=True,\n)\ndef cosine_distances(X, Y=None):\n    \"\"\"Compute cosine distance between samples in X and Y.\n\n    Cosine distance is defined as 1.0 minus the cosine similarity.\n\n    Read more in the :ref:`User Guide <metrics>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)\n        Matrix `X`.\n\n    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \\\n            default=None\n        Matrix `Y`.\n\n    Returns\n    -------\n    distance matrix : ndarray of shape (n_samples_X, n_samples_Y)\n        Returns the cosine distance between samples in X and Y.\n\n    See Also\n    --------\n    cosine_similarity : Compute cosine similarity between samples in X and Y.\n    scipy.spatial.distance.cosine : Dense matrices only.\n    \"\"\"\n    # 1.0 - cosine_similarity(X, Y) without copy\n    S = cosine_similarity(X, Y)\n    S *= -1\n    S += 1\n    np.clip(S, 0, 2, out=S)\n    if X is Y or Y is None:\n        # Ensure that distances between vectors and themselves are set to 0.0.\n        # This may not be the case due to floating point rounding errors.\n        S[np.diag_indices_from(S)] = 0.0\n    return S\n\n\n# Paired distances\n@validate_params(\n    {\"X\": [\"array-like\", \"sparse matrix\"], \"Y\": [\"array-like\", \"sparse matrix\"]},\n    prefer_skip_nested_validation=True,\n)\ndef paired_euclidean_distances(X, Y):\n    \"\"\"Compute the paired euclidean distances between X and Y.\n\n    Read more in the :ref:`User Guide <metrics>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Input array/matrix X.\n\n    Y : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Input array/matrix Y.\n\n    Returns\n    -------\n    distances : ndarray of shape (n_samples,)\n        Output array/matrix containing the calculated paired euclidean\n        distances.\n    \"\"\"\n    X, Y = check_paired_arrays(X, Y)\n    return row_norms(X - Y)",
                "filename": "sklearn/metrics/pairwise.py",
                "start_index": 37097,
                "end_index": 39191,
                "start_line": 233,
                "end_line": 1163,
                "max_line": 2425,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "if metric == \"precomputed\":\n        X, _ = check_pairwise_arrays(\n            X, Y, precomputed=True, force_all_finite=force_all_finite\n        )\n\n        whom = (\n            \"`pairwise_distances`. Precomputed distance \"\n            \" need to have non-negative values.\"\n        )\n        check_non_negative(X, whom=whom)\n        return X\n    elif metric in PAIRWISE_DISTANCE_FUNCTIONS:\n        func = PAIRWISE_DISTANCE_FUNCTIONS[metric]\n    elif callable(metric):\n        func = partial(\n            _pairwise_callable, metric=metric, force_all_finite=force_all_finite, **kwds\n        )\n    else:\n        if issparse(X) or issparse(Y):\n            raise TypeError(\"scipy distance metrics do not support sparse matrices.\")\n\n        dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None\n\n        if dtype == bool and (X.dtype != bool or (Y is not None and Y.dtype != bool)):\n            msg = \"Data was converted to boolean for metric %s\" % metric\n            warnings.warn(msg, DataConversionWarning)\n\n        X, Y = check_pairwise_arrays(\n            X, Y, dtype=dtype, force_all_finite=force_all_finite\n        )\n\n        # precompute data-derived metric params\n        params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n        kwds.update(**params)\n\n        if effective_n_jobs(n_jobs) == 1 and X is Y:\n            return distance.squareform(distance.pdist(X, metric=metric, **kwds))\n        func = partial(distance.cdist, metric=metric, **kwds)\n\n    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)",
                "filename": "sklearn/metrics/pairwise.py",
                "start_index": 74834,
                "end_index": 76364,
                "start_line": 2035,
                "end_line": 2425,
                "max_line": 2425,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "if metric == \"precomputed\":\n        error_msg = ValueError(\n            \"The precomputed distance matrix contains non-zero \"\n            \"elements on the diagonal. Use np.fill_diagonal(X, 0).\"\n        )\n        if X.dtype.kind == \"f\":\n            atol = np.finfo(X.dtype).eps * 100\n            if np.any(np.abs(X.diagonal()) > atol):\n                raise error_msg\n        elif np.any(X.diagonal() != 0):  # integral dtype\n            raise error_msg\n\n    le = LabelEncoder()\n    labels = le.fit_transform(labels)\n    n_samples = len(labels)\n    label_freqs = np.bincount(labels)\n    check_number_of_labels(len(le.classes_), n_samples)\n\n    kwds[\"metric\"] = metric\n    reduce_func = functools.partial(\n        _silhouette_reduce, labels=labels, label_freqs=label_freqs\n    )\n    results = zip(*pairwise_distances_chunked(X, reduce_func=reduce_func, **kwds))\n    intra_clust_dists, inter_clust_dists = results\n    intra_clust_dists = np.concatenate(intra_clust_dists)\n    inter_clust_dists = np.concatenate(inter_clust_dists)\n\n    denom = (label_freqs - 1).take(labels, mode=\"clip\")\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        intra_clust_dists /= denom\n\n    sil_samples = inter_clust_dists - intra_clust_dists\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        sil_samples /= np.maximum(intra_clust_dists, inter_clust_dists)\n    # nan values are for clusters of size 1, and should be 0\n    return np.nan_to_num(sil_samples)",
                "filename": "sklearn/metrics/cluster/_unsupervised.py",
                "start_index": 10370,
                "end_index": 11829,
                "start_line": 126,
                "end_line": 295,
                "max_line": 425,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "ef pairwise_distances(\n    X, Y=None, metric=\"euclidean\", *, n_jobs=None, force_all_finite=True, **kwds\n):",
                "filename": "sklearn/metrics/pairwise.py",
                "start_index": 69573,
                "end_index": 69679,
                "start_line": 2089,
                "end_line": 2422,
                "max_line": 2425,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "def distance_metrics():\n    \"\"\"Valid metrics for pairwise_distances.\n\n    This function simply returns the valid pairwise distance metrics.\n    It exists to allow for a description of the mapping for\n    each of the valid strings.\n\n    The valid distance metrics, and the function they map to, are:\n\n    =============== ========================================\n    metric          Function\n    =============== ========================================\n    'cityblock'     metrics.pairwise.manhattan_distances\n    'cosine'        metrics.pairwise.cosine_distances\n    'euclidean'     metrics.pairwise.euclidean_distances\n    'haversine'     metrics.pairwise.haversine_distances\n    'l1'            metrics.pairwise.manhattan_distances\n    'l2'            metrics.pairwise.euclidean_distances\n    'manhattan'     metrics.pairwise.manhattan_distances\n    'nan_euclidean' metrics.pairwise.nan_euclidean_distances\n    =============== ========================================\n\n    Read more in the :ref:`User Guide <metrics>`.\n\n    Returns\n    -------\n    distance_metrics : dict\n        Returns valid metrics for pairwise_distances.\n    \"\"\"\n    return PAIRWISE_DISTANCE_FUNCTIONS\n\n\ndef _dist_wrapper(dist_func, dist_matrix, slice_, *args, **kwargs):\n    \"\"\"Write in-place to a slice of a distance matrix.\"\"\"\n    dist_matrix[:, slice_] = dist_func(*args, **kwargs)\n\n\ndef _parallel_pairwise(X, Y, func, n_jobs, **kwds):\n    \"\"\"Break the pairwise matrix in n_jobs even slices\n    and compute them in parallel.\"\"\"\n\n    if Y is None:\n        Y = X\n    X, Y, dtype = _return_float_dtype(X, Y)\n\n    if effective_n_jobs(n_jobs) == 1:\n        return func(X, Y, **kwds)\n\n    # enforce a threading backend to prevent data communication overhead\n    fd = delayed(_dist_wrapper)\n    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order=\"F\")\n    Parallel(backend=\"threading\", n_jobs=n_jobs)(\n        fd(func, ret, s, X, Y[s], **kwds)\n        for s in gen_even_slices(_num_samples(Y), effective_n_jobs(n_jobs))\n    )\n\n    if (X is Y or Y is None) and func is euclidean_distances:\n        # zeroing diagonal for euclidean norm.\n        # TODO: do it also for other norms.\n        np.fill_diagonal(ret, 0)\n\n    return ret",
                "filename": "sklearn/metrics/pairwise.py",
                "start_index": 56859,
                "end_index": 59064,
                "start_line": 1756,
                "end_line": 1817,
                "max_line": 2425,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "\"\"\"\nAgglomerative clustering with different metrics\n===============================================\n\nDemonstrates the effect of different metrics on the hierarchical clustering.\n\nThe example is engineered to show the effect of the choice of different\nmetrics. It is applied to waveforms, which can be seen as\nhigh-dimensional vector. Indeed, the difference between metrics is\nusually more pronounced in high dimension (in particular for euclidean\nand cityblock).\n\nWe generate data from three groups of waveforms. Two of the waveforms\n(waveform 1 and waveform 2) are proportional one to the other. The cosine\ndistance is invariant to a scaling of the data, as a result, it cannot\ndistinguish these two waveforms. Thus even with no noise, clustering\nusing this distance will not separate out waveform 1 and 2.\n\nWe add observation noise to these waveforms. We generate very sparse\nnoise: only 6% of the time points contain noise. As a result, the\nl1 norm of this noise (ie \"cityblock\" distance) is much smaller than it's\nl2 norm (\"euclidean\" distance). This can be seen on the inter-class\ndistance matrices: the values on the diagonal, that characterize the\nspread of the class, are much bigger for the Euclidean distance than for\nthe cityblock distance.\n\nWhen we apply clustering to the data, we find that the clustering\nreflects what was in the distance matrices. Indeed, for the Euclidean\ndistance, the classes are ill-separated because of the noise, and thus\nthe clustering does not separate the waveforms. For the cityblock\ndistance, the separation is good and the waveform classes are recovered.\nFinally, the cosine distance does not separate at all waveform 1 and 2,\nthus the clustering puts them in the same cluster.\n\n\"\"\"\n\n# Author: Gael Varoquaux\n# License: BSD 3-Clause or CC-0\n\nimport matplotlib.patheffects as PathEffects\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom sklearn.cluster import AgglomerativeClustering\nfrom sklearn.metrics import pairwise_distances\n\nnp.random.seed(0)\n\n# Generate waveform data\nn_features = 2000\nt = np.pi * np.linspace(0, 1, n_features)\n\n\ndef sqr(x):\n    return np.sign(np.cos(x))\n\n\nX = list()\ny = list()\nfor i, (phi, a) in enumerate([(0.5, 0.15), (0.5, 0.6), (0.3, 0.2)]):\n    for _ in range(30):\n        phase_noise = 0.01 * np.random.normal()\n        amplitude_noise = 0.04 * np.random.normal()\n        additional_noise = 1 - 2 * np.random.rand(n_features)\n        # Make the noise sparse\n        additional_noise[np.abs(additional_noise) < 0.997] = 0\n\n        X.append(\n            12\n            * (\n                (a + amplitude_noise) * (sqr(6 * (t + phi + phase_noise)))\n                + additional_noise\n            )\n        )\n        y.append(i)\n\nX = np.array(X)\ny = np.array(y)\n\nn_clusters = 3\n\nlabels = (\"Waveform 1\", \"Waveform 2\", \"Waveform 3\")\n\ncolors = [\"#f7bd01\", \"#377eb8\", \"#f781bf\"]\n\n# Plot the ground-truth labelling\nplt.figure()\nplt.axes([0, 0, 1, 1])",
                "filename": "examples/cluster/plot_agglomerative_clustering_metrics.py",
                "start_index": 0,
                "end_index": 2925,
                "start_line": 1,
                "end_line": 138,
                "max_line": 146,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "\"metrics._pairwise_distances_reduction\": [\n        {\n            \"sources\": [\"_datasets_pair.pyx.tp\", \"_datasets_pair.pxd.tp\"],\n            \"language\": \"c++\",\n            \"include_np\": True,\n            \"extra_compile_args\": [\"-std=c++11\"],\n        },\n        {\n            \"sources\": [\"_middle_term_computer.pyx.tp\", \"_middle_term_computer.pxd.tp\"],\n            \"language\": \"c++\",\n            \"extra_compile_args\": [\"-std=c++11\"],\n        },\n        {\n            \"sources\": [\"_base.pyx.tp\", \"_base.pxd.tp\"],\n            \"language\": \"c++\",\n            \"include_np\": True,\n            \"extra_compile_args\": [\"-std=c++11\"],\n        },\n        {\n            \"sources\": [\"_argkmin.pyx.tp\", \"_argkmin.pxd.tp\"],\n            \"language\": \"c++\",\n            \"include_np\": True,\n            \"extra_compile_args\": [\"-std=c++11\"],\n        },\n        {\n            \"sources\": [\"_argkmin_classmode.pyx.tp\"],\n            \"language\": \"c++\",\n            \"include_np\": True,\n            \"extra_compile_args\": [\"-std=c++11\"],\n        },\n        {\n            \"sources\": [\"_radius_neighbors.pyx.tp\", \"_radius_neighbors.pxd.tp\"],\n            \"language\": \"c++\",\n            \"include_np\": True,\n            \"extra_compile_args\": [\"-std=c++11\"],\n        },\n    ],\n    \"preprocessing\": [\n        {\"sources\": [\"_csr_polynomial_expansion.pyx\"]},\n        {\n            \"sources\": [\"_target_encoder_fast.pyx\"],\n            \"include_np\": True,\n            \"language\": \"c++\",\n            \"extra_compile_args\": [\"-std=c++11\"],\n        },\n    ],\n    \"neighbors\": [\n        {\"sources\": [\"_ball_tree.pyx\"], \"include_np\": True},\n        {\"sources\": [\"_kd_tree.pyx\"], \"include_np\": True},\n        {\"sources\": [\"_partition_nodes.pyx\"], \"language\": \"c++\", \"include_np\": True},\n        {\"sources\": [\"_quad_tree.pyx\"], \"include_np\": True},\n    ],",
                "filename": "setup.py",
                "start_index": 9151,
                "end_index": 10957,
                "start_line": 262,
                "end_line": 592,
                "max_line": 626,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "n_samples_X = _num_samples(X)\n    if metric == \"precomputed\":\n        slices = (slice(0, n_samples_X),)\n    else:\n        if Y is None:\n            Y = X\n        # We get as many rows as possible within our working_memory budget to\n        # store len(Y) distances in each row of output.\n        #\n        # Note:\n        #  - this will get at least 1 row, even if 1 row of distances will\n        #    exceed working_memory.\n        #  - this does not account for any temporary memory usage while\n        #    calculating distances (e.g. difference of vectors in manhattan\n        #    distance.\n        chunk_n_rows = get_chunk_n_rows(\n            row_bytes=8 * _num_samples(Y),\n            max_n_rows=n_samples_X,\n            working_memory=working_memory,\n        )\n        slices = gen_batches(n_samples_X, chunk_n_rows)\n\n    # precompute data-derived metric params\n    params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n    kwds.update(**params)\n\n    for sl in slices:\n        if sl.start == 0 and sl.stop == n_samples_X:\n            X_chunk = X  # enable optimised paths for X is Y\n        else:\n            X_chunk = X[sl]\n        D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)\n        if (X is Y or Y is None) and PAIRWISE_DISTANCE_FUNCTIONS.get(\n            metric, None\n        ) is euclidean_distances:\n            # zeroing diagonal, taking care of aliases of \"euclidean\",\n            # i.e. \"l2\"\n            D_chunk.flat[sl.start :: _num_samples(X) + 1] = 0\n        if reduce_func is not None:\n            chunk_size = D_chunk.shape[0]\n            D_chunk = reduce_func(D_chunk, sl.start)\n            _check_chunk_size(D_chunk, chunk_size)\n        yield D_chunk",
                "filename": "sklearn/metrics/pairwise.py",
                "start_index": 67494,
                "end_index": 69213,
                "start_line": 2034,
                "end_line": 2076,
                "max_line": 2425,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sklearn/metrics/pairwise.py": [
                {
                    "chunk": {
                        "code": "@validate_params(\n    {\n        \"X\": [\"array-like\", \"sparse matrix\"],\n        \"Y\": [\"array-like\", \"sparse matrix\", None],\n    },\n    prefer_skip_nested_validation=True,\n)\ndef cosine_distances(X, Y=None):\n    \"\"\"Compute cosine distance between samples in X and Y.\n\n    Cosine distance is defined as 1.0 minus the cosine similarity.\n\n    Read more in the :ref:`User Guide <metrics>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples_X, n_features)\n        Matrix `X`.\n\n    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \\\n            default=None\n        Matrix `Y`.\n\n    Returns\n    -------\n    distance matrix : ndarray of shape (n_samples_X, n_samples_Y)\n        Returns the cosine distance between samples in X and Y.\n\n    See Also\n    --------\n    cosine_similarity : Compute cosine similarity between samples in X and Y.\n    scipy.spatial.distance.cosine : Dense matrices only.\n    \"\"\"\n    # 1.0 - cosine_similarity(X, Y) without copy\n    S = cosine_similarity(X, Y)\n    S *= -1\n    S += 1\n    np.clip(S, 0, 2, out=S)\n    if X is Y or Y is None:\n        # Ensure that distances between vectors and themselves are set to 0.0.\n        # This may not be the case due to floating point rounding errors.\n        S[np.diag_indices_from(S)] = 0.0\n    return S\n\n\n# Paired distances\n@validate_params(\n    {\"X\": [\"array-like\", \"sparse matrix\"], \"Y\": [\"array-like\", \"sparse matrix\"]},\n    prefer_skip_nested_validation=True,\n)\ndef paired_euclidean_distances(X, Y):\n    \"\"\"Compute the paired euclidean distances between X and Y.\n\n    Read more in the :ref:`User Guide <metrics>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Input array/matrix X.\n\n    Y : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Input array/matrix Y.\n\n    Returns\n    -------\n    distances : ndarray of shape (n_samples,)\n        Output array/matrix containing the calculated paired euclidean\n        distances.\n    \"\"\"\n    X, Y = check_paired_arrays(X, Y)\n    return row_norms(X - Y)",
                        "filename": "sklearn/metrics/pairwise.py",
                        "start_index": 37097,
                        "end_index": 39191,
                        "start_line": 233,
                        "end_line": 1163,
                        "max_line": 2425,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of cosine_distances, which is relevant because the issue is with the cosine metric returning zeros."
                },
                {
                    "chunk": {
                        "code": "if metric == \"precomputed\":\n        X, _ = check_pairwise_arrays(\n            X, Y, precomputed=True, force_all_finite=force_all_finite\n        )\n\n        whom = (\n            \"`pairwise_distances`. Precomputed distance \"\n            \" need to have non-negative values.\"\n        )\n        check_non_negative(X, whom=whom)\n        return X\n    elif metric in PAIRWISE_DISTANCE_FUNCTIONS:\n        func = PAIRWISE_DISTANCE_FUNCTIONS[metric]\n    elif callable(metric):\n        func = partial(\n            _pairwise_callable, metric=metric, force_all_finite=force_all_finite, **kwds\n        )\n    else:\n        if issparse(X) or issparse(Y):\n            raise TypeError(\"scipy distance metrics do not support sparse matrices.\")\n\n        dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None\n\n        if dtype == bool and (X.dtype != bool or (Y is not None and Y.dtype != bool)):\n            msg = \"Data was converted to boolean for metric %s\" % metric\n            warnings.warn(msg, DataConversionWarning)\n\n        X, Y = check_pairwise_arrays(\n            X, Y, dtype=dtype, force_all_finite=force_all_finite\n        )\n\n        # precompute data-derived metric params\n        params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n        kwds.update(**params)\n\n        if effective_n_jobs(n_jobs) == 1 and X is Y:\n            return distance.squareform(distance.pdist(X, metric=metric, **kwds))\n        func = partial(distance.cdist, metric=metric, **kwds)\n\n    return _parallel_pairwise(X, Y, func, n_jobs, **kwds)",
                        "filename": "sklearn/metrics/pairwise.py",
                        "start_index": 74834,
                        "end_index": 76364,
                        "start_line": 2035,
                        "end_line": 2425,
                        "max_line": 2425,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the logic for handling different metrics and parallel execution in pairwise_distances, which is directly related to the issue."
                },
                {
                    "chunk": {
                        "code": "def distance_metrics():\n    \"\"\"Valid metrics for pairwise_distances.\n\n    This function simply returns the valid pairwise distance metrics.\n    It exists to allow for a description of the mapping for\n    each of the valid strings.\n\n    The valid distance metrics, and the function they map to, are:\n\n    =============== ========================================\n    metric          Function\n    =============== ========================================\n    'cityblock'     metrics.pairwise.manhattan_distances\n    'cosine'        metrics.pairwise.cosine_distances\n    'euclidean'     metrics.pairwise.euclidean_distances\n    'haversine'     metrics.pairwise.haversine_distances\n    'l1'            metrics.pairwise.manhattan_distances\n    'l2'            metrics.pairwise.euclidean_distances\n    'manhattan'     metrics.pairwise.manhattan_distances\n    'nan_euclidean' metrics.pairwise.nan_euclidean_distances\n    =============== ========================================\n\n    Read more in the :ref:`User Guide <metrics>`.\n\n    Returns\n    -------\n    distance_metrics : dict\n        Returns valid metrics for pairwise_distances.\n    \"\"\"\n    return PAIRWISE_DISTANCE_FUNCTIONS\n\n\ndef _dist_wrapper(dist_func, dist_matrix, slice_, *args, **kwargs):\n    \"\"\"Write in-place to a slice of a distance matrix.\"\"\"\n    dist_matrix[:, slice_] = dist_func(*args, **kwargs)\n\n\ndef _parallel_pairwise(X, Y, func, n_jobs, **kwds):\n    \"\"\"Break the pairwise matrix in n_jobs even slices\n    and compute them in parallel.\"\"\"\n\n    if Y is None:\n        Y = X\n    X, Y, dtype = _return_float_dtype(X, Y)\n\n    if effective_n_jobs(n_jobs) == 1:\n        return func(X, Y, **kwds)\n\n    # enforce a threading backend to prevent data communication overhead\n    fd = delayed(_dist_wrapper)\n    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order=\"F\")\n    Parallel(backend=\"threading\", n_jobs=n_jobs)(\n        fd(func, ret, s, X, Y[s], **kwds)\n        for s in gen_even_slices(_num_samples(Y), effective_n_jobs(n_jobs))\n    )\n\n    if (X is Y or Y is None) and func is euclidean_distances:\n        # zeroing diagonal for euclidean norm.\n        # TODO: do it also for other norms.\n        np.fill_diagonal(ret, 0)\n\n    return ret",
                        "filename": "sklearn/metrics/pairwise.py",
                        "start_index": 56859,
                        "end_index": 59064,
                        "start_line": 1756,
                        "end_line": 1817,
                        "max_line": 2425,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet lists the valid metrics for pairwise_distances and could be relevant to ensure that the cosine and euclidean metrics are correctly mapped to their functions."
                },
                {
                    "chunk": {
                        "code": "n_samples_X = _num_samples(X)\n    if metric == \"precomputed\":\n        slices = (slice(0, n_samples_X),)\n    else:\n        if Y is None:\n            Y = X\n        # We get as many rows as possible within our working_memory budget to\n        # store len(Y) distances in each row of output.\n        #\n        # Note:\n        #  - this will get at least 1 row, even if 1 row of distances will\n        #    exceed working_memory.\n        #  - this does not account for any temporary memory usage while\n        #    calculating distances (e.g. difference of vectors in manhattan\n        #    distance.\n        chunk_n_rows = get_chunk_n_rows(\n            row_bytes=8 * _num_samples(Y),\n            max_n_rows=n_samples_X,\n            working_memory=working_memory,\n        )\n        slices = gen_batches(n_samples_X, chunk_n_rows)\n\n    # precompute data-derived metric params\n    params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n    kwds.update(**params)\n\n    for sl in slices:\n        if sl.start == 0 and sl.stop == n_samples_X:\n            X_chunk = X  # enable optimised paths for X is Y\n        else:\n            X_chunk = X[sl]\n        D_chunk = pairwise_distances(X_chunk, Y, metric=metric, n_jobs=n_jobs, **kwds)\n        if (X is Y or Y is None) and PAIRWISE_DISTANCE_FUNCTIONS.get(\n            metric, None\n        ) is euclidean_distances:\n            # zeroing diagonal, taking care of aliases of \"euclidean\",\n            # i.e. \"l2\"\n            D_chunk.flat[sl.start :: _num_samples(X) + 1] = 0\n        if reduce_func is not None:\n            chunk_size = D_chunk.shape[0]\n            D_chunk = reduce_func(D_chunk, sl.start)\n            _check_chunk_size(D_chunk, chunk_size)\n        yield D_chunk",
                        "filename": "sklearn/metrics/pairwise.py",
                        "start_index": 67494,
                        "end_index": 69213,
                        "start_line": 2034,
                        "end_line": 2076,
                        "max_line": 2425,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the logic for chunking the data in pairwise_distances, which could be relevant since the issue occurs when n_jobs is not equal to 1."
                }
            ]
        },
        "solution_task": "- Investigate the implementation of `pairwise_distances` in `sklearn/metrics/pairwise.py` to ensure that it correctly handles the `n_jobs` parameter for parallel computation.\n- Ensure that the `dtype` of the output distance matrix is `float` and not inadvertently cast to `int` when using `metric='euclidean'`.\n- Check the `return` statement of the `_parallel_pairwise` function to confirm that the output matrix `ret` retains its `float` data type after parallel computation.\n- Verify that the `np.fill_diagonal(ret, 0)` call in `_parallel_pairwise` does not alter the data type of the matrix `ret`.\n- If the issue persists, consider adding an explicit cast to `float` for the output of the distance computation to ensure the correct data type is returned, for example:\n  ```python\n  return ret.astype(float)\n  ```\n- Review any recent changes to the `pairwise_distances` function or related utility functions that may have introduced the issue with `n_jobs` and data type handling.\n- If the issue is specific to certain versions of dependencies (NumPy, SciPy, scikit-learn), consider adding version checks and warnings to inform users about potential incompatibilities.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a detailed and structured approach to debugging the issue with `pairwise_distances` in scikit-learn. It suggests checking the implementation of the function, ensuring the data type is correct, and reviewing recent changes that might have caused the bug. The RESPONSE also provides specific code snippets to check, which are highly relevant to the problem at hand. The advice to add an explicit cast to `float` is actionable and could resolve the issue with the `euclidean` metric. The RESPONSE addresses both the `cosine` metric returning zeros and the `euclidean` metric returning integers instead of floats, which are the two main issues described in the PROMPT.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711739949.858203,
        "result": "- Investigate the implementation of `pairwise_distances` in `sklearn/metrics/pairwise.py` to ensure that it correctly handles the `n_jobs` parameter for parallel computation.\n- Ensure that the `dtype` of the output distance matrix is `float` and not inadvertently cast to `int` when using `metric='euclidean'`.\n- Check the `return` statement of the `_parallel_pairwise` function to confirm that the output matrix `ret` retains its `float` data type after parallel computation.\n- Verify that the `np.fill_diagonal(ret, 0)` call in `_parallel_pairwise` does not alter the data type of the matrix `ret`.\n- If the issue persists, consider adding an explicit cast to `float` for the output of the distance computation to ensure the correct data type is returned, for example:\n  ```python\n  return ret.astype(float)\n  ```\n- Review any recent changes to the `pairwise_distances` function or related utility functions that may have introduced the issue with `n_jobs` and data type handling.\n- If the issue is specific to certain versions of dependencies (NumPy, SciPy, scikit-learn), consider adding version checks and warnings to inform users about potential incompatibilities.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [metrics](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/metrics)- [Lines 233 - 1163](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L233-L1163)\n\n This snippet contains the implementation of cosine_distances, which is relevant because the issue is with the cosine metric returning zeros. \n\n\n   - [Lines 2035 - 2425](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L2035-L2425)\n\n This snippet contains the logic for handling different metrics and parallel execution in pairwise_distances, which is directly related to the issue. \n\n\n   - [Lines 1756 - 1817](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L1756-L1817)\n\n This snippet lists the valid metrics for pairwise_distances and could be relevant to ensure that the cosine and euclidean metrics are correctly mapped to their functions. \n\n\n   - [Lines 2034 - 2076](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/metrics/pairwise.py#L2034-L2076)\n\n This snippet includes the logic for chunking the data in pairwise_distances, which could be relevant since the issue occurs when n_jobs is not equal to 1."
    }
}