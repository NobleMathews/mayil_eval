{
    "id": "django__django-11149",
    "repo_name": "testbed/django__django__3.0",
    "task_id": 1131906942930329412,
    "title": "Admin inlines for auto-created ManyToManyFields are editable if the user only has the view permission",
    "body": "Description\n\t\nFrom https://code.djangoproject.com/ticket/8060#comment:34\nReplying to Will Gordon:\nThis seems to have regressed in (at least) 2.1. I have 2 view only permissions. I have a ManyToManyField represented in my main model as a TabularInline. But, my user with view only permissions can now add or remove these items at will!\nI am having the same issue, so I assume this is a bug. I did not find Will had created a separate ticket.\nmodels.py:\nclass Photo(models.Model):\n\tpass\nclass Report(models.Model):\n\tphotos = models.ManyToManyField(Photo)\nadmin.py:\n\t\tclass ReportPhotoInlineModelAdmin(admin.TabularInline):\n\t\t\tmodel = Report.photos.through\n\t\t\tshow_change_link = True\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.0.git",
    "requested_commit": "",
    "mayil_response": "Based on the provided information and code snippets, the issue seems to be related to the handling of view-only permissions for inlines in the Django admin. Users with view-only permissions are experiencing a regression where they can see editable inlines, which they should not be able to edit.\n\nTo address this issue:\n\n- Ensure that the `has_change_permission` method in `InlineModelAdmin` returns `False` when a user only has view permissions. This will prevent the rendering of form fields as editable for users with view-only permissions.\n\n- Modify the `get_formset` method in `InlineModelAdmin` to check for view permissions and adjust the formset to be read-only if the user only has view permissions.\n\nHere is a potential solution:\n\n```python\n# admin.py\nfrom django.contrib import admin\nfrom .models import Report, Photo\n\nclass ReportPhotoInlineModelAdmin(admin.TabularInline):\n    model = Report.photos.through\n    show_change_link = True\n\n    def get_formset(self, request, obj=None, **kwargs):\n        formset = super().get_formset(request, obj, **kwargs)\n        if not self.has_change_permission(request, obj):\n            formset.form.base_fields['photos'].disabled = True\n        return formset\n\n    def has_change_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_change_permission(request, obj) and not self.has_view_permission(request, obj)\n\nadmin.site.register(Report)\nadmin.site.register(Photo)\n```\n\nIn this solution:\n\n- The `has_change_permission` method is overridden to ensure that it returns `False` if the user only has view permissions, even if the inline model is auto-created.\n\n- The `get_formset` method is overridden to disable the form fields if the user does not have change permissions.\n\nThis should ensure that users with view-only permissions cannot edit inlines in the Django admin.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [contrib](https://github.com/testbed/django__django__3.0/tree//django/contrib) \u2192 [admin](https://github.com/testbed/django__django__3.0/tree//django/contrib/admin)- [Lines 380 - 2524](https://github.com/testbed/django__django__3.0/blob//django/contrib/admin/options.py#L380-L2524)\n\n This snippet contains the permission checks for add, change, delete, and view operations on inlines, which are directly related to the issue of view-only users being able to edit ManyToManyFields represented as TabularInline. \n\n\n   - [Lines 1244 - 2313](https://github.com/testbed/django__django__3.0/blob//django/contrib/admin/options.py#L1244-L2313)\n\n This snippet includes logic for handling formsets in the admin add/change views, which may be relevant to the issue as it involves bypassing validation for view-only inline forms unless the form was deleted.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000221,
        "snippet_processor": 0.07593000000000001,
        "issue_star_creation": 0.025869999999999997,
        "issue_star_solver": 0.057080000000000006,
        "bouncer": 0.026260000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711730072.060887,
        "relevant_snippets": [
            {
                "code": "st, obj=None):\n        return self.get_formset(request, obj, fields=None).form\n\n    def get_queryset(self, request):\n        queryset = super().get_queryset(request)\n        if not self.has_view_or_change_permission(request):\n            queryset = queryset.none()\n        return queryset\n\n    def _has_any_perms_for_target_model(self, request, perms):\n        \"\"\"\n        This method is called only when the ModelAdmin's model is for an\n        ManyToManyField's implicit through model (if self.opts.auto_created).\n        Return True if the user has any of the given permissions ('add',\n        'change', etc.) for the model that points to the through model.\n        \"\"\"\n        opts = self.opts\n        # Find the target model of an auto-created many-to-many relationship.\n        for field in opts.fields:\n            if field.remote_field and field.remote_field.model != self.parent_model:\n                opts = field.remote_field.model._meta\n                break\n        return any(\n            request.user.has_perm(\n                \"%s.%s\" % (opts.app_label, get_permission_codename(perm, opts))\n            )\n            for perm in perms\n        )\n\n    def has_add_permission(self, request, obj):\n        if self.opts.auto_created:\n            # Auto-created intermediate models don't have their own\n            # permissions. The user needs to have the change permission for the\n            # related model in order to be able to do anything with the\n            # intermediate model.\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_add_permission(request)\n\n    def has_change_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            # Same comment as has_add_permission().\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_change_permission(request)\n\n    def has_delete_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            # Same comment as has_add_permission().\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_delete_permission(request, obj)\n\n    def has_view_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            # Same comment as has_add_permission(). The 'change' permission\n            # also implies the 'view' permission.\n            return self._has_any_perms_for_target_model(request, [\"view\", \"change\"])\n        return super().has_view_permission(request)\n\n\nclass StackedInline(InlineModelAdmin):",
                "filename": "django/contrib/admin/options.py",
                "start_index": 96189,
                "end_index": 98763,
                "start_line": 380,
                "end_line": 2524,
                "max_line": 2529,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "or use in admin add/change views.\"\"\"\n        if \"fields\" in kwargs:\n            fields = kwargs.pop(\"fields\")\n        else:\n            fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n        excluded = self.get_exclude(request, obj)\n        exclude = [] if excluded is None else list(excluded)\n        exclude.extend(self.get_readonly_fields(request, obj))\n        if excluded is None and hasattr(self.form, \"_meta\") and self.form._meta.exclude:\n            # Take the custom ModelForm's Meta.exclude into account only if the\n            # InlineModelAdmin doesn't define its own.\n            exclude.extend(self.form._meta.exclude)\n        # If exclude is an empty list we use None, since that's the actual\n        # default.\n        exclude = exclude or None\n        can_delete = self.can_delete and self.has_delete_permission(request, obj)\n        defaults = {\n            \"form\": self.form,\n            \"formset\": self.formset,\n            \"fk_name\": self.fk_name,\n            \"fields\": fields,\n            \"exclude\": exclude,\n            \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n            \"extra\": self.get_extra(request, obj, **kwargs),\n            \"min_num\": self.get_min_num(request, obj, **kwargs),\n            \"max_num\": self.get_max_num(request, obj, **kwargs),\n            \"can_delete\": can_delete,\n            **kwargs,\n        }\n\n        base_model_form = defaults[\"form\"]\n        can_change = self.has_change_permission(request, obj) if request else True\n        can_add = self.has_add_permission(request, obj) if request else True\n\n        class DeleteProtectedModelForm(base_",
                "filename": "django/contrib/admin/options.py",
                "start_index": 91823,
                "end_index": 93466,
                "start_line": 2373,
                "end_line": 2407,
                "max_line": 2529,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "class PermissionsMixin(models.Model):",
                "filename": "django/contrib/auth/models.py",
                "start_index": 8425,
                "end_index": 8462,
                "start_line": 242,
                "end_line": 242,
                "max_line": 499,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "f to_field_allowed(self, request, to_field):\n        \"\"\"\n        Return True if the model associated with this admin should be\n        allowed to be referenced by the specified field.\n        \"\"\"\n        try:\n            field = self.opts.get_field(to_field)\n        except FieldDoesNotExist:\n            return False\n\n        # Always allow referencing the primary key since it's already possible\n        # to get this information from the change view URL.\n        if field.primary_key:\n            return True\n\n        # Allow reverse relationships to models defining m2m fields if they\n        # target the specified field.\n        for many_to_many in self.opts.many_to_many:\n            if many_to_many.m2m_target_field_name() == to_field:\n                return True\n\n        # Make sure at least one of the models registered for this site\n        # references this field through a FK or a M2M relationship.\n        registered_models = set()\n        for model, admin in self.admin_site._registry.items():\n            registered_models.add(model)\n            for inline in admin.inlines:\n                registered_models.add(inline.model)\n\n        related_objects = (\n            f\n            for f in self.opts.get_fields(include_hidden=True)\n            if (f.auto_created and not f.concrete)\n        )\n        for related_object in related_objects:\n            related_model = related_object.related_model\n            remote_field = related_object.field.remote_field\n            if (\n                any(issubclass(model, related_model) for model in registered_models)\n                and hasattr(remote_field, \"get_related_field\")\n                and remote_field.get_related_field() == field\n            ):\n                return True\n\n        return False\n\n    def has_add_permission(self, request):\n        \"\"\"\n        Return True if the given request has permission to add an object.\n        Can be overridden by the user in subclasses.\n        \"\"\"\n        opts = self.opts\n        codename = get_permission_codename(\"add\", opts)\n        return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n\n    def has_change_permission(self, request, obj=None):\n        \"\"\"\n        Return True if the given request has permission to change the given\n        Django model instance, the default implementation doesn't examine the\n        `obj` parameter.\n\n        Can be overridden by the user in subclasses. In such case it should\n        return True if the given request has permission to change the `obj`\n        model instance. If `obj` is None, this should return True if the given\n        request has permission to change *any* object of the given type.\n        \"\"\"\n        opts = self.opts\n        codename = get_permission_codename(\"change\", opts)\n        return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n\n    de",
                "filename": "django/contrib/admin/options.py",
                "start_index": 19380,
                "end_index": 22230,
                "start_line": 515,
                "end_line": 2516,
                "max_line": 2529,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "/*global DateTimeShortcuts, SelectFilter*/\n/**\n * Django admin inlines\n *\n * Based on jQuery Formset 1.1\n * @author Stanislaus Madueke (stan DOT madueke AT gmail DOT com)\n * @requires jQuery 1.2.6 or later\n *\n * Copyright (c) 2009, Stanislaus Madueke\n * All rights reserved.\n *\n * Spiced up with Code from Zain Memon's GSoC project 2009\n * and modified for Django by Jannis Leidel, Travis Swicegood and Julien Phalip.\n *\n * Licensed under the New BSD License\n * See: https://opensource.org/licenses/bsd-license.php\n */\n'use strict';",
                "filename": "django/contrib/admin/static/admin/js/inlines.js",
                "start_index": 0,
                "end_index": 532,
                "start_line": 1,
                "end_line": 18,
                "max_line": 359,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "from functools import partial\n\nfrom django.contrib.admin.checks import InlineModelAdminChecks\nfrom django.contrib.admin.options import InlineModelAdmin, flatten_fieldsets\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.forms import (\n    BaseGenericInlineFormSet,\n    generic_inlineformset_factory,\n)\nfrom django.core import checks\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.forms import ALL_FIELDS\nfrom django.forms.models import modelform_defines_fields",
                "filename": "django/contrib/contenttypes/admin.py",
                "start_index": 0,
                "end_index": 527,
                "start_line": 1,
                "end_line": 13,
                "max_line": 143,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def _check_inlines_item(self, obj, inline, label):\n        \"\"\"Check one inline model admin.\"\"\"\n        try:\n            inline_label = inline.__module__ + \".\" + inline.__name__\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"'%s' must inherit from 'InlineModelAdmin'.\" % obj,\n                    obj=obj.__class__,\n                    id=\"admin.E104\",\n                )\n            ]\n\n        from django.contrib.admin.options import InlineModelAdmin\n\n        if not _issubclass(inline, InlineModelAdmin):\n            return [\n                checks.Error(\n                    \"'%s' must inherit from 'InlineModelAdmin'.\" % inline_label,\n                    obj=obj.__class__,\n                    id=\"admin.E104\",\n                )\n            ]\n        elif not inline.model:\n            return [\n                checks.Error(\n                    \"'%s' must have a 'model' attribute.\" % inline_label,\n                    obj=obj.__class__,\n                    id=\"admin.E105\",\n                )\n            ]\n        elif not _issubclass(inline.model, models.Model):\n            return must_be(\n                \"a Model\", option=\"%s.model\" % inline_label, obj=obj, id=\"admin.E106\"\n            )\n        else:\n            return inline(obj.model, obj.admin_site).check()\n\n    def _check_list_display(self, obj):\n        \"\"\"Check that list_display only contains fields or usable attributes.\"\"\"\n\n        if not isinstance(obj.list_display, (list, tuple)):\n            return must_be(\n                \"a list or tuple\", option=\"list_display\", obj=obj, id=\"admin.E107\"\n            )\n        else:\n            return list(\n                chain.from_iterable(\n                    self._check_list_display_item(obj, item, \"list_display[%d]\" % index)\n                    for index, item in enumerate(obj.list_display)\n                )\n            )",
                "filename": "django/contrib/admin/checks.py",
                "start_index": 32023,
                "end_index": 33920,
                "start_line": 854,
                "end_line": 1334,
                "max_line": 1367,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "FieldListFilter.register(lambda f: True, AllValuesFieldListFilter)\n\n\nclass RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n    def field_choices(self, field, request, model_admin):\n        pk_qs = (\n            model_admin.get_queryset(request)\n            .distinct()\n            .values_list(\"%s__pk\" % self.field_path, flat=True)\n        )\n        ordering = self.field_admin_ordering(field, request, model_admin)\n        return field.get_choices(\n            include_blank=False, limit_choices_to={\"pk__in\": pk_qs}, ordering=ordering\n        )",
                "filename": "django/contrib/admin/filters.py",
                "start_index": 24496,
                "end_index": 25047,
                "start_line": 637,
                "end_line": 713,
                "max_line": 715,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "class UserAdmin(admin.ModelAdmin):",
                "filename": "django/contrib/auth/admin.py",
                "start_index": 1724,
                "end_index": 1758,
                "start_line": 44,
                "end_line": 44,
                "max_line": 232,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "change):\n        \"Helper function to generate formsets for add/change_view.\"\n        formsets = []\n        inline_instances = []\n        prefixes = {}\n        get_formsets_args = [request]\n        if change:\n            get_formsets_args.append(obj)\n        for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n            prefix = FormSet.get_default_prefix()\n            prefixes[prefix] = prefixes.get(prefix, 0) + 1\n            if prefixes[prefix] != 1 or not prefix:\n                prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n            formset_params = self.get_formset_kwargs(request, obj, inline, prefix)\n            formset = FormSet(**formset_params)\n\n            def user_deleted_form(request, obj, formset, index, inline):\n                \"\"\"Return whether or not the user deleted the form.\"\"\"\n                return (\n                    inline.has_delete_permission(request, obj)\n                    and \"{}-{}-DELETE\".format(formset.prefix, index) in request.POST\n                )\n\n            # Bypass validation of each view-only inline form (since the form's\n            # data won't be in request.POST), unless the form was deleted.\n            if not inline.has_change_permission(request, obj if change else None):\n                for index, form in enumerate(formset.initial_forms):\n                    if user_deleted_form(request, obj, formset, index, inline):\n                        continue\n                    form._errors = {}\n                    form.cleaned_data = form.initial\n            formsets.append(formset)\n            inline_instances.append(inline)\n        return formsets, inline_instances\n\n\nclass InlineModelAdmin(BaseModelAdmin):",
                "filename": "django/contrib/admin/options.py",
                "start_index": 87924,
                "end_index": 89623,
                "start_line": 1244,
                "end_line": 2313,
                "max_line": 2529,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/contrib/admin/options.py": [
                {
                    "chunk": {
                        "code": "st, obj=None):\n        return self.get_formset(request, obj, fields=None).form\n\n    def get_queryset(self, request):\n        queryset = super().get_queryset(request)\n        if not self.has_view_or_change_permission(request):\n            queryset = queryset.none()\n        return queryset\n\n    def _has_any_perms_for_target_model(self, request, perms):\n        \"\"\"\n        This method is called only when the ModelAdmin's model is for an\n        ManyToManyField's implicit through model (if self.opts.auto_created).\n        Return True if the user has any of the given permissions ('add',\n        'change', etc.) for the model that points to the through model.\n        \"\"\"\n        opts = self.opts\n        # Find the target model of an auto-created many-to-many relationship.\n        for field in opts.fields:\n            if field.remote_field and field.remote_field.model != self.parent_model:\n                opts = field.remote_field.model._meta\n                break\n        return any(\n            request.user.has_perm(\n                \"%s.%s\" % (opts.app_label, get_permission_codename(perm, opts))\n            )\n            for perm in perms\n        )\n\n    def has_add_permission(self, request, obj):\n        if self.opts.auto_created:\n            # Auto-created intermediate models don't have their own\n            # permissions. The user needs to have the change permission for the\n            # related model in order to be able to do anything with the\n            # intermediate model.\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_add_permission(request)\n\n    def has_change_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            # Same comment as has_add_permission().\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_change_permission(request)\n\n    def has_delete_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            # Same comment as has_add_permission().\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_delete_permission(request, obj)\n\n    def has_view_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            # Same comment as has_add_permission(). The 'change' permission\n            # also implies the 'view' permission.\n            return self._has_any_perms_for_target_model(request, [\"view\", \"change\"])\n        return super().has_view_permission(request)\n\n\nclass StackedInline(InlineModelAdmin):",
                        "filename": "django/contrib/admin/options.py",
                        "start_index": 96189,
                        "end_index": 98763,
                        "start_line": 380,
                        "end_line": 2524,
                        "max_line": 2529,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the permission checks for add, change, delete, and view operations on inlines, which are directly related to the issue of view-only users being able to edit ManyToManyFields represented as TabularInline."
                },
                {
                    "chunk": {
                        "code": "change):\n        \"Helper function to generate formsets for add/change_view.\"\n        formsets = []\n        inline_instances = []\n        prefixes = {}\n        get_formsets_args = [request]\n        if change:\n            get_formsets_args.append(obj)\n        for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n            prefix = FormSet.get_default_prefix()\n            prefixes[prefix] = prefixes.get(prefix, 0) + 1\n            if prefixes[prefix] != 1 or not prefix:\n                prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n            formset_params = self.get_formset_kwargs(request, obj, inline, prefix)\n            formset = FormSet(**formset_params)\n\n            def user_deleted_form(request, obj, formset, index, inline):\n                \"\"\"Return whether or not the user deleted the form.\"\"\"\n                return (\n                    inline.has_delete_permission(request, obj)\n                    and \"{}-{}-DELETE\".format(formset.prefix, index) in request.POST\n                )\n\n            # Bypass validation of each view-only inline form (since the form's\n            # data won't be in request.POST), unless the form was deleted.\n            if not inline.has_change_permission(request, obj if change else None):\n                for index, form in enumerate(formset.initial_forms):\n                    if user_deleted_form(request, obj, formset, index, inline):\n                        continue\n                    form._errors = {}\n                    form.cleaned_data = form.initial\n            formsets.append(formset)\n            inline_instances.append(inline)\n        return formsets, inline_instances\n\n\nclass InlineModelAdmin(BaseModelAdmin):",
                        "filename": "django/contrib/admin/options.py",
                        "start_index": 87924,
                        "end_index": 89623,
                        "start_line": 1244,
                        "end_line": 2313,
                        "max_line": 2529,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes logic for handling formsets in the admin add/change views, which may be relevant to the issue as it involves bypassing validation for view-only inline forms unless the form was deleted."
                }
            ]
        },
        "solution_task": "Based on the provided information and code snippets, the issue seems to be related to the handling of view-only permissions for inlines in the Django admin. Users with view-only permissions are experiencing a regression where they can see editable inlines, which they should not be able to edit.\n\nTo address this issue:\n\n- Ensure that the `has_change_permission` method in `InlineModelAdmin` returns `False` when a user only has view permissions. This will prevent the rendering of form fields as editable for users with view-only permissions.\n\n- Modify the `get_formset` method in `InlineModelAdmin` to check for view permissions and adjust the formset to be read-only if the user only has view permissions.\n\nHere is a potential solution:\n\n```python\n# admin.py\nfrom django.contrib import admin\nfrom .models import Report, Photo\n\nclass ReportPhotoInlineModelAdmin(admin.TabularInline):\n    model = Report.photos.through\n    show_change_link = True\n\n    def get_formset(self, request, obj=None, **kwargs):\n        formset = super().get_formset(request, obj, **kwargs)\n        if not self.has_change_permission(request, obj):\n            formset.form.base_fields['photos'].disabled = True\n        return formset\n\n    def has_change_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_change_permission(request, obj) and not self.has_view_permission(request, obj)\n\nadmin.site.register(Report)\nadmin.site.register(Photo)\n```\n\nIn this solution:\n\n- The `has_change_permission` method is overridden to ensure that it returns `False` if the user only has view permissions, even if the inline model is auto-created.\n\n- The `get_formset` method is overridden to disable the form fields if the user does not have change permissions.\n\nThis should ensure that users with view-only permissions cannot edit inlines in the Django admin.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem of view-only users being able to edit ManyToManyFields in Django admin inlines. It suggests overriding the `has_change_permission` and `get_formset` methods in `InlineModelAdmin` to ensure that users with view-only permissions cannot edit the inlines. The code snippet provided is directly relevant and offers a practical implementation that can be tested and applied. Additionally, the RESPONSE includes references to specific lines of code in the Django repository that are related to the issue, which could be useful for further investigation or confirmation of the solution's validity.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711730208.51755,
        "result": "Based on the provided information and code snippets, the issue seems to be related to the handling of view-only permissions for inlines in the Django admin. Users with view-only permissions are experiencing a regression where they can see editable inlines, which they should not be able to edit.\n\nTo address this issue:\n\n- Ensure that the `has_change_permission` method in `InlineModelAdmin` returns `False` when a user only has view permissions. This will prevent the rendering of form fields as editable for users with view-only permissions.\n\n- Modify the `get_formset` method in `InlineModelAdmin` to check for view permissions and adjust the formset to be read-only if the user only has view permissions.\n\nHere is a potential solution:\n\n```python\n# admin.py\nfrom django.contrib import admin\nfrom .models import Report, Photo\n\nclass ReportPhotoInlineModelAdmin(admin.TabularInline):\n    model = Report.photos.through\n    show_change_link = True\n\n    def get_formset(self, request, obj=None, **kwargs):\n        formset = super().get_formset(request, obj, **kwargs)\n        if not self.has_change_permission(request, obj):\n            formset.form.base_fields['photos'].disabled = True\n        return formset\n\n    def has_change_permission(self, request, obj=None):\n        if self.opts.auto_created:\n            return self._has_any_perms_for_target_model(request, [\"change\"])\n        return super().has_change_permission(request, obj) and not self.has_view_permission(request, obj)\n\nadmin.site.register(Report)\nadmin.site.register(Photo)\n```\n\nIn this solution:\n\n- The `has_change_permission` method is overridden to ensure that it returns `False` if the user only has view permissions, even if the inline model is auto-created.\n\n- The `get_formset` method is overridden to disable the form fields if the user does not have change permissions.\n\nThis should ensure that users with view-only permissions cannot edit inlines in the Django admin.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [contrib](https://github.com/testbed/django__django__3.0/tree//django/contrib) \u2192 [admin](https://github.com/testbed/django__django__3.0/tree//django/contrib/admin)- [Lines 380 - 2524](https://github.com/testbed/django__django__3.0/blob//django/contrib/admin/options.py#L380-L2524)\n\n This snippet contains the permission checks for add, change, delete, and view operations on inlines, which are directly related to the issue of view-only users being able to edit ManyToManyFields represented as TabularInline. \n\n\n   - [Lines 1244 - 2313](https://github.com/testbed/django__django__3.0/blob//django/contrib/admin/options.py#L1244-L2313)\n\n This snippet includes logic for handling formsets in the admin add/change views, which may be relevant to the issue as it involves bypassing validation for view-only inline forms unless the form was deleted."
    }
}