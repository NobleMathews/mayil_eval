{
    "id": "django__django-13192",
    "repo_name": "testbed/django__django__3.2",
    "task_id": 3423307468467956999,
    "title": "Emails name over 75 characters are incompatible with the latest versions of python.",
    "body": "Description\n\t\nIn the process of sending an email the addresses is sanatized:\ndjango/core/mail/message.py:98 => def sanitize_address(addr, encoding)\nThe Name portion is encoded via the Header class email.header.Header.encode which will introduce newlines at 75 characters.\nUnfortunately the most recent python security update no longer allows that to happen. So when Address(nm, addr_spec=addr) is called in sanitize_address a new error is raised from the Python Standard library.\nThe update to python can be found here: \u200bhttps://github.com/python/cpython/commit/f91a0b6df14d6c5133fe3d5889fad7d84fc0c046#diff-3c5a266cd05e7d4173bf110ee93edd16\nEssentially Django can no longer send emails with names longer then 75 chracters.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.2.git",
    "requested_commit": "",
    "mayil_response": "- Review the Python security update linked in the issue description to understand the changes that affect the `email.header.Header.encode` method and the `Address` constructor.\n- Modify the `sanitize_address` function in `django/core/mail/message.py` to ensure that the name part of the email address does not exceed the new 75-character limit imposed by the Python security update.\n- Update the `forbid_multi_line_headers` function to handle the case where the name part of the email address exceeds the 75-character limit by truncating or splitting the name into multiple encoded words, ensuring that each encoded word does not exceed the limit.\n- Ensure that the `Header.encode` method is called with the correct arguments to prevent the introduction of newlines at inappropriate positions, which could cause the new error to be raised.\n- Test the changes with email addresses that have names longer than 75 characters to ensure that emails can be sent without raising the new error from the Python Standard library.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.2/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.2/tree//django/core) \u2192 [mail](https://github.com/testbed/django__django__3.2/tree//django/core/mail)- [Lines 1 - 75](https://github.com/testbed/django__django__3.2/blob//django/core/mail/message.py#L1-L75)\n\n This snippet contains the import of the Header class and the definition of the sanitize_address function, which is directly related to the issue of encoding the name portion of an email address and the new error being raised due to the recent Python security update.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0001885,
        "snippet_processor": 0.04465,
        "issue_star_creation": 0.01902,
        "issue_star_solver": 0.04778,
        "bouncer": 0.02139
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711727210.153392,
        "relevant_snippets": [
            {
                "code": "import mimetypes\nfrom email import charset as Charset\nfrom email import encoders as Encoders\nfrom email import generator, message_from_string\nfrom email.errors import HeaderParseError\nfrom email.header import Header\nfrom email.headerregistry import Address, parser\nfrom email.message import Message\nfrom email.mime.base import MIMEBase\nfrom email.mime.message import MIMEMessage\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.utils import formataddr, formatdate, getaddresses, make_msgid\nfrom io import BytesIO, StringIO\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.core.mail.utils import DNS_NAME\nfrom django.utils.encoding import force_str, punycode\n\n# Don't BASE64-encode UTF-8 messages so that we avoid unwanted attention from\n# some spam filters.\nutf8_charset = Charset.Charset(\"utf-8\")\nutf8_charset.body_encoding = None  # Python defaults to BASE64\nutf8_charset_qp = Charset.Charset(\"utf-8\")\nutf8_charset_qp.body_encoding = Charset.QP\n\n# Default MIME type to use on attachments (if it is not explicitly given\n# and cannot be guessed).\nDEFAULT_ATTACHMENT_MIME_TYPE = \"application/octet-stream\"\n\nRFC5322_EMAIL_LINE_LENGTH_LIMIT = 998\n\n\nclass BadHeaderError(ValueError):\n    pass\n\n\n# Header names that contain structured address data (RFC 5322).\nADDRESS_HEADERS = {\n    \"from\",\n    \"sender\",\n    \"reply-to\",\n    \"to\",\n    \"cc\",\n    \"bcc\",\n    \"resent-from\",\n    \"resent-sender\",\n    \"resent-to\",\n    \"resent-cc\",\n    \"resent-bcc\",\n}\n\n\ndef forbid_multi_line_headers(name, val, encoding):\n    \"\"\"Forbid multi-line headers to prevent header injection.\"\"\"\n    encoding = encoding or settings.DEFAULT_CHARSET\n    val = str(val)  # val may be lazy\n    if \"\\n\" in val or \"\\r\" in val:\n        raise BadHeaderError(\n            \"Header values can't contain newlines (got %r for header %r)\" % (val, name)\n        )\n    try:\n        val.encode(\"ascii\")\n    except UnicodeEncodeError:\n        if name.lower() in ADDRESS_HEADERS:\n            val = \", \".join(\n                sanitize_address(addr, encoding) for addr in getaddresses((val,))\n            )\n        else:\n            val = Header(val, encoding).encode()\n    else:\n        if name.lower() == \"subject\":\n            val = Header(val).encode()\n    return name, val",
                "filename": "django/core/mail/message.py",
                "start_index": 0,
                "end_index": 2289,
                "start_line": 1,
                "end_line": 75,
                "max_line": 495,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "from django.contrib.auth import validators\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0003_alter_user_email_max_length\"),\n    ]\n\n    # No database changes; modifies validators and error_messages (#13147).\n    operations = [\n        migrations.AlterField(\n            model_name=\"user\",\n            name=\"username\",\n            field=models.CharField(\n                error_messages={\"unique\": \"A user with that username already exists.\"},\n                max_length=30,\n                validators=[validators.UnicodeUsernameValidator()],\n                help_text=(\n                    \"Required. 30 characters or fewer. Letters, digits and @/./+/-/_ \"\n                    \"only.\"\n                ),\n                unique=True,\n                verbose_name=\"username\",\n            ),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0004_alter_user_username_opts.py",
                "start_index": 0,
                "end_index": 879,
                "start_line": 1,
                "end_line": 27,
                "max_line": 27,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "from django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0002_alter_permission_name_max_length\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"user\",\n            name=\"email\",\n            field=models.EmailField(\n                max_length=254, verbose_name=\"email address\", blank=True\n            ),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0003_alter_user_email_max_length.py",
                "start_index": 0,
                "end_index": 417,
                "start_line": 1,
                "end_line": 17,
                "max_line": 17,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "\"\"\"\nEmail message and email sending related helper functions.\n\"\"\"\n\nimport socket\n\nfrom django.utils.encoding import punycode\n\n\n# Cache the hostname, but do it lazily: socket.getfqdn() can take a couple of\n# seconds, which slows down the restart of the server.\nclass CachedDnsName:\n    def __str__(self):\n        return self.get_fqdn()\n\n    def get_fqdn(self):\n        if not hasattr(self, \"_fqdn\"):\n            self._fqdn = punycode(socket.getfqdn())\n        return self._fqdn\n\n\nDNS_NAME = CachedDnsName()",
                "filename": "django/core/mail/utils.py",
                "start_index": 0,
                "end_index": 505,
                "start_line": 1,
                "end_line": 22,
                "max_line": 22,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "from django.contrib.auth import validators\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0007_alter_validators_add_error_messages\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"user\",\n            name=\"username\",\n            field=models.CharField(\n                error_messages={\"unique\": \"A user with that username already exists.\"},\n                help_text=(\n                    \"Required. 150 characters or fewer. Letters, digits and @/./+/-/_ \"\n                    \"only.\"\n                ),\n                max_length=150,\n                unique=True,\n                validators=[validators.UnicodeUsernameValidator()],\n                verbose_name=\"username\",\n            ),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0008_alter_user_username_max_length.py",
                "start_index": 0,
                "end_index": 813,
                "start_line": 1,
                "end_line": 26,
                "max_line": 26,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "opts = model._meta\n        builtin_permissions = dict(_get_builtin_permissions(opts))\n        # Check builtin permission name length.\n        max_builtin_permission_name_length = (\n            max(len(name) for name in builtin_permissions.values())\n            if builtin_permissions\n            else 0\n        )\n        if max_builtin_permission_name_length > permission_name_max_length:\n            verbose_name_max_length = permission_name_max_length - (\n                max_builtin_permission_name_length - len(opts.verbose_name_raw)\n            )\n            errors.append(\n                checks.Error(\n                    \"The verbose_name of model '%s' must be at most %d \"\n                    \"characters for its builtin permission names to be at \"\n                    \"most %d characters.\"\n                    % (opts.label, verbose_name_max_length, permission_name_max_length),\n                    obj=model,\n                    id=\"auth.E007\",\n                )\n            )\n        # Check builtin permission codename length.\n        max_builtin_permission_codename_length = (\n            max(len(codename) for codename in builtin_permissions.keys())\n            if builtin_permissions\n            else 0\n        )\n        if max_builtin_permission_codename_length > permission_codename_max_length:\n            model_name_max_length = permission_codename_max_length - (\n                max_builtin_permission_codename_length - len(opts.model_name)\n            )\n            errors.append(\n                checks.Error(\n                    \"The name of model '%s' must be at most %d characters \"\n                    \"for its builtin permission codenames to be at most %d \"\n                    \"characters.\"\n                    % (\n                        opts.label,\n                        model_name_max_length,\n                        permission_codename_max_length,\n                    ),\n                    obj=model,\n                    id=\"auth.E011\",\n                )\n            )\n        codenames = set()",
                "filename": "django/contrib/auth/checks.py",
                "start_index": 4292,
                "end_index": 6322,
                "start_line": 121,
                "end_line": 167,
                "max_line": 220,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "from django.contrib.auth import validators\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0006_require_contenttypes_0002\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"user\",\n            name=\"username\",\n            field=models.CharField(\n                error_messages={\"unique\": \"A user with that username already exists.\"},\n                help_text=(\n                    \"Required. 30 characters or fewer. Letters, digits and @/./+/-/_ \"\n                    \"only.\"\n                ),\n                max_length=30,\n                unique=True,\n                validators=[validators.UnicodeUsernameValidator()],\n                verbose_name=\"username\",\n            ),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0007_alter_validators_add_error_messages.py",
                "start_index": 0,
                "end_index": 801,
                "start_line": 1,
                "end_line": 26,
                "max_line": 26,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "for f in cls._meta.local_many_to_many:\n            # Skip nonexistent models.\n            if isinstance(f.remote_field.through, str):\n                continue\n\n            # Check if auto-generated name for the M2M field is too long\n            # for the database.\n            for m2m in f.remote_field.through._meta.local_fields:\n                _, rel_name = m2m.get_attname_column()\n                if (\n                    m2m.db_column is None\n                    and rel_name is not None\n                    and len(rel_name) > allowed_len\n                ):\n                    errors.append(\n                        checks.Error(\n                            \"Autogenerated column name too long for M2M field \"\n                            '\"%s\". Maximum length is \"%s\" for database \"%s\".'\n                            % (rel_name, allowed_len, db_alias),\n                            hint=(\n                                \"Use 'through' to create a separate model for \"\n                                \"M2M and then set column_name using 'db_column'.\"\n                            ),\n                            obj=cls,\n                            id=\"models.E019\",\n                        )\n                    )\n\n        return errors",
                "filename": "django/db/models/base.py",
                "start_index": 90213,
                "end_index": 91455,
                "start_line": 2293,
                "end_line": 2553,
                "max_line": 2607,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "for codename, name in opts.permissions:\n            # Check custom permission name length.\n            if len(name) > permission_name_max_length:\n                errors.append(\n                    checks.Error(\n                        \"The permission named '%s' of model '%s' is longer \"\n                        \"than %d characters.\"\n                        % (\n                            name,\n                            opts.label,\n                            permission_name_max_length,\n                        ),\n                        obj=model,\n                        id=\"auth.E008\",\n                    )\n                )\n            # Check custom permission codename length.\n            if len(codename) > permission_codename_max_length:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' of model '%s' is \"\n                        \"longer than %d characters.\"\n                        % (\n                            codename,\n                            opts.label,\n                            permission_codename_max_length,\n                        ),\n                        obj=model,\n                        id=\"auth.E012\",\n                    )\n                )\n            # Check custom permissions codename clashing.\n            if codename in builtin_permissions:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' clashes with a builtin \"\n                        \"permission for model '%s'.\" % (codename, opts.label),\n                        obj=model,\n                        id=\"auth.E005\",\n                    )\n                )\n            elif codename in codenames:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' is duplicated for \"\n                        \"model '%s'.\" % (codename, opts.label),\n                        obj=model,\n                        id=\"auth.E006\",\n                    )\n                )\n            codenames.add(codename)",
                "filename": "django/contrib/auth/checks.py",
                "start_index": 6331,
                "end_index": 8422,
                "start_line": 168,
                "end_line": 218,
                "max_line": 220,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            },
            {
                "code": "\"\"\"\nTools for sending email.\n\"\"\"\nfrom django.conf import settings\n\n# Imported for backwards compatibility and for the sake\n# of a cleaner namespace. These symbols used to be in\n# django/core/mail.py before the introduction of email\n# backends and the subsequent reorganization (See #10355)\nfrom django.core.mail.message import (\n    DEFAULT_ATTACHMENT_MIME_TYPE,\n    BadHeaderError,\n    EmailMessage,\n    EmailMultiAlternatives,\n    SafeMIMEMultipart,\n    SafeMIMEText,\n    forbid_multi_line_headers,\n    make_msgid,\n)\nfrom django.core.mail.utils import DNS_NAME, CachedDnsName\nfrom django.utils.module_loading import import_string\n\n__all__ = [\n    \"CachedDnsName\",\n    \"DNS_NAME\",\n    \"EmailMessage\",\n    \"EmailMultiAlternatives\",\n    \"SafeMIMEText\",\n    \"SafeMIMEMultipart\",\n    \"DEFAULT_ATTACHMENT_MIME_TYPE\",\n    \"make_msgid\",\n    \"BadHeaderError\",\n    \"forbid_multi_line_headers\",\n    \"get_connection\",\n    \"send_mail\",\n    \"send_mass_mail\",\n    \"mail_admins\",\n    \"mail_managers\",\n]\n\n\ndef get_connection(backend=None, fail_silently=False, **kwds):\n    \"\"\"Load an email backend and return an instance of it.\n\n    If backend is None (default), use settings.EMAIL_BACKEND.\n\n    Both fail_silently and other keyword arguments are used in the\n    constructor of the backend.\n    \"\"\"\n    klass = import_string(backend or settings.EMAIL_BACKEND)\n    return klass(fail_silently=fail_silently, **kwds)\n\n\ndef send_mail(\n    subject,\n    message,\n    from_email,\n    recipient_list,\n    fail_silently=False,\n    auth_user=None,\n    auth_password=None,\n    connection=None,\n    html_message=None,\n):\n    \"\"\"\n    Easy wrapper for sending a single message to a recipient list. All members\n    of the recipient list will see the other recipients in the 'To' field.\n\n    If from_email is None, use the DEFAULT_FROM_EMAIL setting.\n    If auth_user is None, use the EMAIL_HOST_USER setting.\n    If auth_password is None, use the EMAIL_HOST_PASSWORD setting.\n\n    Note: The API for this method is frozen. New code wanting to extend the\n    functionality should use the EmailMessage class directly.\n    \"\"\"\n    connection = connection or get_connection(\n        username=auth_user,\n        password=auth_password,\n        fail_silently=fail_silently,\n    )\n    mail = EmailMultiAlternatives(\n        subject, message, from_email, recipient_list, connection=connection\n    )\n    if html_message:\n        mail.attach_alternative(html_message, \"text/html\")\n\n    return mail.send()",
                "filename": "django/core/mail/__init__.py",
                "start_index": 0,
                "end_index": 2463,
                "start_line": 1,
                "end_line": 87,
                "max_line": 154,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.2",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/core/mail/message.py": [
                {
                    "chunk": {
                        "code": "import mimetypes\nfrom email import charset as Charset\nfrom email import encoders as Encoders\nfrom email import generator, message_from_string\nfrom email.errors import HeaderParseError\nfrom email.header import Header\nfrom email.headerregistry import Address, parser\nfrom email.message import Message\nfrom email.mime.base import MIMEBase\nfrom email.mime.message import MIMEMessage\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.utils import formataddr, formatdate, getaddresses, make_msgid\nfrom io import BytesIO, StringIO\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.core.mail.utils import DNS_NAME\nfrom django.utils.encoding import force_str, punycode\n\n# Don't BASE64-encode UTF-8 messages so that we avoid unwanted attention from\n# some spam filters.\nutf8_charset = Charset.Charset(\"utf-8\")\nutf8_charset.body_encoding = None  # Python defaults to BASE64\nutf8_charset_qp = Charset.Charset(\"utf-8\")\nutf8_charset_qp.body_encoding = Charset.QP\n\n# Default MIME type to use on attachments (if it is not explicitly given\n# and cannot be guessed).\nDEFAULT_ATTACHMENT_MIME_TYPE = \"application/octet-stream\"\n\nRFC5322_EMAIL_LINE_LENGTH_LIMIT = 998\n\n\nclass BadHeaderError(ValueError):\n    pass\n\n\n# Header names that contain structured address data (RFC 5322).\nADDRESS_HEADERS = {\n    \"from\",\n    \"sender\",\n    \"reply-to\",\n    \"to\",\n    \"cc\",\n    \"bcc\",\n    \"resent-from\",\n    \"resent-sender\",\n    \"resent-to\",\n    \"resent-cc\",\n    \"resent-bcc\",\n}\n\n\ndef forbid_multi_line_headers(name, val, encoding):\n    \"\"\"Forbid multi-line headers to prevent header injection.\"\"\"\n    encoding = encoding or settings.DEFAULT_CHARSET\n    val = str(val)  # val may be lazy\n    if \"\\n\" in val or \"\\r\" in val:\n        raise BadHeaderError(\n            \"Header values can't contain newlines (got %r for header %r)\" % (val, name)\n        )\n    try:\n        val.encode(\"ascii\")\n    except UnicodeEncodeError:\n        if name.lower() in ADDRESS_HEADERS:\n            val = \", \".join(\n                sanitize_address(addr, encoding) for addr in getaddresses((val,))\n            )\n        else:\n            val = Header(val, encoding).encode()\n    else:\n        if name.lower() == \"subject\":\n            val = Header(val).encode()\n    return name, val",
                        "filename": "django/core/mail/message.py",
                        "start_index": 0,
                        "end_index": 2289,
                        "start_line": 1,
                        "end_line": 75,
                        "max_line": 495,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the import of the Header class and the definition of the sanitize_address function, which is directly related to the issue of encoding the name portion of an email address and the new error being raised due to the recent Python security update."
                }
            ]
        },
        "solution_task": "- Review the Python security update linked in the issue description to understand the changes that affect the `email.header.Header.encode` method and the `Address` constructor.\n- Modify the `sanitize_address` function in `django/core/mail/message.py` to ensure that the name part of the email address does not exceed the new 75-character limit imposed by the Python security update.\n- Update the `forbid_multi_line_headers` function to handle the case where the name part of the email address exceeds the 75-character limit by truncating or splitting the name into multiple encoded words, ensuring that each encoded word does not exceed the limit.\n- Ensure that the `Header.encode` method is called with the correct arguments to prevent the introduction of newlines at inappropriate positions, which could cause the new error to be raised.\n- Test the changes with email addresses that have names longer than 75 characters to ensure that emails can be sent without raising the new error from the Python Standard library.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a structured approach to addressing the issue with the email header encoding in Django due to the Python security update. It suggests reviewing the Python update to understand the changes, modifying the Django function to comply with the new character limit, updating related functions to handle long names, ensuring correct usage of the Header.encode method, and testing the changes. These steps are actionable and relevant to the problem described in the PROMPT. The RESPONSE does not address all aspects of the bug, such as providing a specific code solution or workaround, which would be necessary for a score of 10. However, it does provide a clear path forward for developers to begin resolving the issue.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711727406.272324,
        "result": "- Review the Python security update linked in the issue description to understand the changes that affect the `email.header.Header.encode` method and the `Address` constructor.\n- Modify the `sanitize_address` function in `django/core/mail/message.py` to ensure that the name part of the email address does not exceed the new 75-character limit imposed by the Python security update.\n- Update the `forbid_multi_line_headers` function to handle the case where the name part of the email address exceeds the 75-character limit by truncating or splitting the name into multiple encoded words, ensuring that each encoded word does not exceed the limit.\n- Ensure that the `Header.encode` method is called with the correct arguments to prevent the introduction of newlines at inappropriate positions, which could cause the new error to be raised.\n- Test the changes with email addresses that have names longer than 75 characters to ensure that emails can be sent without raising the new error from the Python Standard library.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.2/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.2/tree//django/core) \u2192 [mail](https://github.com/testbed/django__django__3.2/tree//django/core/mail)- [Lines 1 - 75](https://github.com/testbed/django__django__3.2/blob//django/core/mail/message.py#L1-L75)\n\n This snippet contains the import of the Header class and the definition of the sanitize_address function, which is directly related to the issue of encoding the name portion of an email address and the new error being raised due to the recent Python security update."
    }
}