{
    "id": "pytest-dev__pytest-8422",
    "repo_name": "testbed/pytest-dev__pytest__6.3",
    "task_id": 3780233752626614661,
    "title": "approx: Better handle Decimal in sequences and mappings",
    "body": "<!--\r\nThanks for suggesting a feature!\r\n\r\nQuick check-list while suggesting features:\r\n-->\r\n\r\n#### What's the problem this feature will solve?\r\n\r\nRight now `approx` handles Decimal comparisons gracefully, thanks to https://github.com/pytest-dev/pytest/issues/3247. We can do this:\r\n```python\r\nclass TestApprox:\r\n    ...\r\n\r\n    def test_decimal(self):\r\n        within_1e6 = [\r\n            (Decimal(\"1.000001\"), Decimal(\"1.0\")),\r\n            (Decimal(\"-1.000001\"), Decimal(\"-1.0\")),\r\n        ]\r\n        for a, x in within_1e6:\r\n            assert a == approx(x)\r\n```\r\n\r\n`approx` also knows how to handle sequences and mappings:\r\n```python\r\nclass TestApprox:\r\n    ...\r\n\r\n    def test_list(self):\r\n        actual = [1 + 1e-7, 2 + 1e-8]\r\n        expected = [1, 2]\r\n\r\n        # Return false if any element is outside the tolerance.\r\n        assert actual == approx(expected, rel=5e-7, abs=0)\r\n        assert actual != approx(expected, rel=5e-8, abs=0)\r\n        assert approx(expected, rel=5e-7, abs=0) == actual\r\n        assert approx(expected, rel=5e-8, abs=0) != actual\r\n\r\n    ...\r\n\r\n    def test_dict(self):\r\n        actual = {\"a\": 1 + 1e-7, \"b\": 2 + 1e-8}\r\n        # Dictionaries became ordered in python3.6, so switch up the order here\r\n        # to make sure it doesn't matter.\r\n        expected = {\"b\": 2, \"a\": 1}\r\n\r\n        # Return false if any element is outside the tolerance.\r\n        assert actual == approx(expected, rel=5e-7, abs=0)\r\n        assert actual != approx(expected, rel=5e-8, abs=0)\r\n        assert approx(expected, rel=5e-7, abs=0) == actual\r\n        assert approx(expected, rel=5e-8, abs=0) != actual\r\n```\r\n\r\n`approx` doesn't handle Decimal within sequences and mappings:\r\n```python\r\nclass TestApprox:\r\n    ...\r\n\r\n    def test_list_decimal(self):\r\n        actual = [Decimal(\"1.000001\"), Decimal(\"2.000001\")]\r\n        expected = [Decimal(\"1\"), Decimal(\"2\")]\r\n\r\n        assert actual == approx(expected)\r\n\r\n    ...\r\n\r\n    def test_dict_decimal(self):\r\n        actual = {\"a\": Decimal(\"1.000001\"), \"b\": Decimal(\"2.000001\")}\r\n        # Dictionaries became ordered in python3.6, so switch up the order here\r\n        # to make sure it doesn't matter.\r\n        expected = {\"b\": Decimal(\"2\"), \"a\": Decimal(\"1\")}\r\n\r\n        assert actual == approx(expected)\r\n```\r\n\r\nBoth of these tests fail with `TypeError: unsupported operand type(s) for *: 'float' and 'decimal.Decimal'`\r\n\r\n#### Describe the solution you'd like\r\n<!-- A clear and concise description of what you want to happen. -->\r\n\r\nI would like these kind of tests to be passing :) A linked PR should be following shortly :eyes: \r\n\r\n<!-- Provide examples of real-world use cases that this would enable and how it solves the problem described above. -->\r\n\r\n#### Alternative Solutions\r\n<!-- Have you tried to workaround the problem using a pytest plugin or other tools? Or a different approach to solving this issue? Please elaborate here. -->\r\n\r\n#### Additional context\r\n<!-- Add any other context, links, etc. about the feature here. -->\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pytest-dev__pytest__6.3.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature where `approx` can handle `Decimal` within sequences and mappings, you will need to modify the `approx` function to correctly handle `Decimal` types when they are elements of a list or values in a dictionary. Here's a high-level overview of the steps to implement this feature:\n\n- Modify the `approx` function to check if the elements in a sequence or the values in a mapping are instances of `Decimal`.\n- Implement a comparison method that can handle `Decimal` types without raising a `TypeError`.\n- Ensure that the comparison respects the specified relative (`rel`) and absolute (`abs`) tolerances.\n- Add unit tests to verify that the `approx` function works as expected with sequences and mappings containing `Decimal` objects.\n\nHere's a pseudo-code snippet to illustrate the changes to the `approx` function:\n\n```python\nfrom decimal import Decimal\n\ndef approx(expected, rel=None, abs=None):\n    # ... existing implementation ...\n\n    def __eq__(self, actual):\n        if isinstance(actual, (list, tuple)):\n            return all(self._compare_decimal(x, y, rel, abs) for x, y in zip(self.expected, actual))\n        elif isinstance(actual, dict):\n            return all(self._compare_decimal(self.expected[k], v, rel, abs) for k, v in actual.items())\n        # ... existing comparison logic ...\n\n    def _compare_decimal(self, x, y, rel, abs):\n        if isinstance(x, Decimal) and isinstance(y, Decimal):\n            # Implement Decimal comparison logic here\n            # respecting the rel and abs tolerances\n            return compare_decimals(x, y, rel, abs)\n        else:\n            # Fallback to existing comparison logic\n            return compare_others(x, y, rel, abs)\n\n    # ... rest of the approx class ...\n\n# Helper function to compare two Decimal objects with tolerance\ndef compare_decimals(x, y, rel, abs):\n    # Implement the logic to compare two Decimal objects\n    # taking into account the relative and absolute tolerances\n    # Return True if they are approximately equal, False otherwise\n    pass\n\n# ... rest of the code ...\n```\n\nYou will also need to add new test cases to the `TestApprox` class to ensure that the new functionality is working correctly:\n\n```python\nclass TestApprox:\n    # ... existing tests ...\n\n    def test_list_decimal_with_tolerance(self):\n        actual = [Decimal(\"1.000001\"), Decimal(\"2.000001\")]\n        expected = [Decimal(\"1\"), Decimal(\"2\")]\n        assert actual == approx(expected, rel=1e-6, abs=0)\n\n    def test_dict_decimal_with_tolerance(self):\n        actual = {\"a\": Decimal(\"1.000001\"), \"b\": Decimal(\"2.000001\")}\n        expected = {\"b\": Decimal(\"2\"), \"a\": Decimal(\"1\")}\n        assert actual == approx(expected, rel=1e-6, abs=0)\n\n    # ... more tests ...\n```\n\nRemember to handle edge cases and ensure that the existing functionality of `approx` is not affected by these changes.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000784,
        "snippet_processor": 0.050530000000000005,
        "issue_star_creation": 0.03726,
        "issue_star_solver": 0.03486,
        "bouncer": 0.04079
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711734564.848038,
        "relevant_snippets": [
            {
                "code": "rtd:\n  project: pytest",
                "filename": ".github/config.yml",
                "start_index": 0,
                "end_index": 22,
                "start_line": 1,
                "end_line": 2,
                "max_line": 2,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "blank_issues_enabled: false\ncontact_links:\n  - name: \u2753 Support Question\n    url: https://github.com/pytest-dev/pytest/discussions\n    about: Use GitHub's new Discussions feature for questions",
                "filename": ".github/ISSUE_TEMPLATE/config.yml",
                "start_index": 0,
                "end_index": 191,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "# info:\n# * https://help.github.com/en/articles/displaying-a-sponsor-button-in-your-repository\n# * https://tidelift.com/subscription/how-to-connect-tidelift-with-github\ntidelift: pypi/pytest\nopen_collective: pytest",
                "filename": ".github/FUNDING.yml",
                "start_index": 0,
                "end_index": 214,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "import pytest\n\n\n@pytest.fixture(scope=\"module\", params=range(966))\ndef foo(request):\n    return request.param\n\n\ndef test_it(foo):\n    pass\n\n\ndef test_it2(foo):\n    pass",
                "filename": "bench/manyparam.py",
                "start_index": 0,
                "end_index": 168,
                "start_line": 1,
                "end_line": 14,
                "max_line": 14,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "# 10000 iterations, just for relative comparison\n#                      2.7.5     3.3.2\n# FilesCompleter       75.1109   69.2116\n# FastFilesCompleter    0.7383    1.0760\nimport timeit\n\nimports = [\n    \"from argcomplete.completers import FilesCompleter as completer\",\n    \"from _pytest._argcomplete import FastFilesCompleter as completer\",\n]\n\ncount = 1000  # only a few seconds\nsetup = \"%s\\nfc = completer()\"\nrun = 'fc(\"/d\")'\n\n\nif __name__ == \"__main__\":\n    print(timeit.timeit(run, setup=setup % imports[0], number=count))\n    print(timeit.timeit(run, setup=setup % imports[1], number=count))",
                "filename": "bench/bench_argcomplete.py",
                "start_index": 0,
                "end_index": 593,
                "start_line": 1,
                "end_line": 19,
                "max_line": 19,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "-   repo: https://github.com/psf/black\n    rev: 23.7.0\n    hooks:\n    -   id: black\n        args: [--safe, --quiet]\n-   repo: https://github.com/asottile/blacken-docs\n    rev: 1.16.0\n    hooks:\n    -   id: blacken-docs\n        additional_dependencies: [black==23.7.0]\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n    -   id: fix-encoding-pragma\n        args: [--remove]\n    -   id: check-yaml\n    -   id: debug-statements\n        exclude: _pytest/(debugging|hookspec).py\n        language_version: python3\n-   repo: https://github.com/PyCQA/autoflake\n    rev: v2.2.0\n    hooks:\n    -   id: autoflake\n        name: autoflake\n        args: [\"--in-place\", \"--remove-unused-variables\", \"--remove-all-unused-imports\"]\n        language: python\n        files: \\.py$\n-   repo: https://github.com/PyCQA/flake8\n    rev: 6.1.0\n    hooks:\n    -   id: flake8\n        language_version: python3\n        additional_dependencies:\n          - flake8-typing-imports==1.12.0\n          - flake8-docstrings==1.5.0\n-   repo: https://github.com/asottile/reorder-python-imports\n    rev: v3.10.0\n    hooks:\n    -   id: reorder-python-imports\n        args: ['--application-directories=.:src', --py38-plus]\n-   repo: https://github.com/asottile/pyupgrade\n    rev: v3.10.1\n    hooks:\n    -   id: pyupgrade\n        args: [--py38-plus]\n-   repo: https://github.com/asottile/setup-cfg-fmt\n    rev: v2.4.0\n    hooks:\n    -   id: setup-cfg-fmt\n        args: [\"--max-py-version=3.12\", \"--include-version-classifiers\"]\n-   repo: https://github.com/pre-commit/pygrep-hooks\n    rev: v1.10.0\n    hooks:\n    -   id: python-use-type-annotations\n-   repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.5.1\n    hooks:\n    -   id: mypy\n        files: ^(src/|testing/)\n        args: []\n        additional_dependencies:\n          - iniconfig>=1.1.0\n          - attrs>=19.2.0\n          - packaging\n          - tomli\n          - types-pkg_resources\n            # for mypy running on python>=3.11 since exceptiongroup is only a dependency\n            # on <3.11\n          - exceptiongroup>=1.0.0rc8",
                "filename": ".pre-commit-config.yaml",
                "start_index": 7,
                "end_index": 2165,
                "start_line": 2,
                "end_line": 72,
                "max_line": 108,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "import pytest\n\nSKIP = True\n\n\n@pytest.mark.parametrize(\"x\", range(5000))\ndef test_foo(x):\n    if SKIP:\n        pytest.skip(\"heh\")",
                "filename": "bench/skip.py",
                "start_index": 0,
                "end_index": 128,
                "start_line": 1,
                "end_line": 9,
                "max_line": 9,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "# reference: https://docs.codecov.io/docs/codecovyml-reference\ncoverage:\n  status:\n    patch: true\n    project: false\ncomment: false",
                "filename": "codecov.yml",
                "start_index": 0,
                "end_index": 132,
                "start_line": 1,
                "end_line": 6,
                "max_line": 6,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "version: 2\nupdates:\n- package-ecosystem: pip\n  directory: \"/testing/plugins_integration\"\n  schedule:\n    interval: weekly\n    time: \"03:00\"\n  open-pull-requests-limit: 10\n  allow:\n  - dependency-type: direct\n  - dependency-type: indirect\n- package-ecosystem: github-actions\n  directory: /\n  schedule:\n    interval: weekly\n    time: \"03:00\"\n  open-pull-requests-limit: 10",
                "filename": ".github/dependabot.yml",
                "start_index": 0,
                "end_index": 370,
                "start_line": 1,
                "end_line": 17,
                "max_line": 17,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            },
            {
                "code": "\"\"\"\nThis script is part of the pytest release process which is triggered manually in the Actions\ntab of the repository.\n\nThe user will need to enter the base branch to start the release from (for example\n``6.1.x`` or ``main``) and if it should be a major release.\n\nThe appropriate version will be obtained based on the given branch automatically.\n\nAfter that, it will create a release using the `release` tox environment, and push a new PR.\n\n**Token**: currently the token from the GitHub Actions is used, pushed with\n`pytest bot <pytestbot@gmail.com>` commit author.\n\"\"\"\nimport argparse\nimport re\nfrom pathlib import Path\nfrom subprocess import check_call\nfrom subprocess import check_output\nfrom subprocess import run\n\nfrom colorama import Fore\nfrom colorama import init\nfrom github3.repos import Repository\n\n\nclass InvalidFeatureRelease(Exception):\n    pass\n\n\nSLUG = \"pytest-dev/pytest\"\n\nPR_BODY = \"\"\"\\\nCreated automatically from manual trigger.\n\nOnce all builds pass and it has been **approved** by one or more maintainers, the build\ncan be released by pushing a tag `{version}` to this repository.\n\"\"\"\n\n\ndef login(token: str) -> Repository:\n    import github3\n\n    github = github3.login(token=token)\n    owner, repo = SLUG.split(\"/\")\n    return github.repository(owner, repo)",
                "filename": "scripts/prepare-release-pr.py",
                "start_index": 0,
                "end_index": 1281,
                "start_line": 1,
                "end_line": 46,
                "max_line": 174,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__6.3",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {},
        "solution_task": "To implement the feature where `approx` can handle `Decimal` within sequences and mappings, you will need to modify the `approx` function to correctly handle `Decimal` types when they are elements of a list or values in a dictionary. Here's a high-level overview of the steps to implement this feature:\n\n- Modify the `approx` function to check if the elements in a sequence or the values in a mapping are instances of `Decimal`.\n- Implement a comparison method that can handle `Decimal` types without raising a `TypeError`.\n- Ensure that the comparison respects the specified relative (`rel`) and absolute (`abs`) tolerances.\n- Add unit tests to verify that the `approx` function works as expected with sequences and mappings containing `Decimal` objects.\n\nHere's a pseudo-code snippet to illustrate the changes to the `approx` function:\n\n```python\nfrom decimal import Decimal\n\ndef approx(expected, rel=None, abs=None):\n    # ... existing implementation ...\n\n    def __eq__(self, actual):\n        if isinstance(actual, (list, tuple)):\n            return all(self._compare_decimal(x, y, rel, abs) for x, y in zip(self.expected, actual))\n        elif isinstance(actual, dict):\n            return all(self._compare_decimal(self.expected[k], v, rel, abs) for k, v in actual.items())\n        # ... existing comparison logic ...\n\n    def _compare_decimal(self, x, y, rel, abs):\n        if isinstance(x, Decimal) and isinstance(y, Decimal):\n            # Implement Decimal comparison logic here\n            # respecting the rel and abs tolerances\n            return compare_decimals(x, y, rel, abs)\n        else:\n            # Fallback to existing comparison logic\n            return compare_others(x, y, rel, abs)\n\n    # ... rest of the approx class ...\n\n# Helper function to compare two Decimal objects with tolerance\ndef compare_decimals(x, y, rel, abs):\n    # Implement the logic to compare two Decimal objects\n    # taking into account the relative and absolute tolerances\n    # Return True if they are approximately equal, False otherwise\n    pass\n\n# ... rest of the code ...\n```\n\nYou will also need to add new test cases to the `TestApprox` class to ensure that the new functionality is working correctly:\n\n```python\nclass TestApprox:\n    # ... existing tests ...\n\n    def test_list_decimal_with_tolerance(self):\n        actual = [Decimal(\"1.000001\"), Decimal(\"2.000001\")]\n        expected = [Decimal(\"1\"), Decimal(\"2\")]\n        assert actual == approx(expected, rel=1e-6, abs=0)\n\n    def test_dict_decimal_with_tolerance(self):\n        actual = {\"a\": Decimal(\"1.000001\"), \"b\": Decimal(\"2.000001\")}\n        expected = {\"b\": Decimal(\"2\"), \"a\": Decimal(\"1\")}\n        assert actual == approx(expected, rel=1e-6, abs=0)\n\n    # ... more tests ...\n```\n\nRemember to handle edge cases and ensure that the existing functionality of `approx` is not affected by these changes.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The VALUE score should reflect how well the RESPONSE addresses the specific needs and context presented in the PROMPT, regardless of the completeness of the PROMPT itself.",
            "supporting_evidence": "The RESPONSE provides a comprehensive and actionable plan for implementing the feature request to handle Decimal within sequences and mappings in the `approx` function. It suggests modifying the `approx` function to check for Decimal instances and implementing a comparison method that respects the specified tolerances. The RESPONSE also includes pseudo-code to illustrate the proposed changes and suggests adding new unit tests to ensure the functionality works as expected. The RESPONSE addresses all aspects of the feature request, providing clear guidance for implementation. It only lacks minor details, such as the specific implementation of the Decimal comparison logic, which prevents it from being a perfect score.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711734619.467316,
        "result": "To implement the feature where `approx` can handle `Decimal` within sequences and mappings, you will need to modify the `approx` function to correctly handle `Decimal` types when they are elements of a list or values in a dictionary. Here's a high-level overview of the steps to implement this feature:\n\n- Modify the `approx` function to check if the elements in a sequence or the values in a mapping are instances of `Decimal`.\n- Implement a comparison method that can handle `Decimal` types without raising a `TypeError`.\n- Ensure that the comparison respects the specified relative (`rel`) and absolute (`abs`) tolerances.\n- Add unit tests to verify that the `approx` function works as expected with sequences and mappings containing `Decimal` objects.\n\nHere's a pseudo-code snippet to illustrate the changes to the `approx` function:\n\n```python\nfrom decimal import Decimal\n\ndef approx(expected, rel=None, abs=None):\n    # ... existing implementation ...\n\n    def __eq__(self, actual):\n        if isinstance(actual, (list, tuple)):\n            return all(self._compare_decimal(x, y, rel, abs) for x, y in zip(self.expected, actual))\n        elif isinstance(actual, dict):\n            return all(self._compare_decimal(self.expected[k], v, rel, abs) for k, v in actual.items())\n        # ... existing comparison logic ...\n\n    def _compare_decimal(self, x, y, rel, abs):\n        if isinstance(x, Decimal) and isinstance(y, Decimal):\n            # Implement Decimal comparison logic here\n            # respecting the rel and abs tolerances\n            return compare_decimals(x, y, rel, abs)\n        else:\n            # Fallback to existing comparison logic\n            return compare_others(x, y, rel, abs)\n\n    # ... rest of the approx class ...\n\n# Helper function to compare two Decimal objects with tolerance\ndef compare_decimals(x, y, rel, abs):\n    # Implement the logic to compare two Decimal objects\n    # taking into account the relative and absolute tolerances\n    # Return True if they are approximately equal, False otherwise\n    pass\n\n# ... rest of the code ...\n```\n\nYou will also need to add new test cases to the `TestApprox` class to ensure that the new functionality is working correctly:\n\n```python\nclass TestApprox:\n    # ... existing tests ...\n\n    def test_list_decimal_with_tolerance(self):\n        actual = [Decimal(\"1.000001\"), Decimal(\"2.000001\")]\n        expected = [Decimal(\"1\"), Decimal(\"2\")]\n        assert actual == approx(expected, rel=1e-6, abs=0)\n\n    def test_dict_decimal_with_tolerance(self):\n        actual = {\"a\": Decimal(\"1.000001\"), \"b\": Decimal(\"2.000001\")}\n        expected = {\"b\": Decimal(\"2\"), \"a\": Decimal(\"1\")}\n        assert actual == approx(expected, rel=1e-6, abs=0)\n\n    # ... more tests ...\n```\n\nRemember to handle edge cases and ensure that the existing functionality of `approx` is not affected by these changes."
    }
}