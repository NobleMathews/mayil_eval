{
    "id": "pytest-dev__pytest-9911",
    "repo_name": "testbed/pytest-dev__pytest__7.2",
    "task_id": 6918114557568155922,
    "title": "Improved error when `()` (empty tuple) is passed to `pytest.raises()` or `pytest.warns()`",
    "body": "When using `pytest.raises()` as a context manager, you can pass an exception type or tuple of exception types; it's then an error if no exception is raised or if the exception raised is not an instance of the expected type(s).  The same logic applies to `pytest.warns()`, which has a near-identical API.\r\n\r\nThe *problem* is that if you pass the empty tuple `()`, this will *always* result in an error: even if an exception is raised, it can't be an instance of `()`!  I think we should explicitly check tuple inputs, and raise a more helpful error message if they're empty.  For example:\r\n\r\n- \"Passing `expected_exception=()` is an error, because it's impossible to raise an exception which is not an instance of any type.  Raising exceptions is already understood as failing the test, so you don't need any special code to say 'this should never raise an exception'.\"  \r\n  (for bonus points, `pytest.raises(None)` should have the same message, with `=None` instead of `=()`)\r\n- The same logic, and same error message, applies to the `raises=` argument to `pytest.mark.xfail()`.\r\n- \"Passing `expected_warning=()` is an error, because it's impossible to emit a warning which is not an instance of any type.  To assert that no warnings are emitted, use <whatever we come up with for #9002>\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pytest-dev__pytest__7.2.git",
    "requested_commit": "",
    "mayil_response": "- Update the `raises` function to check for `None` or an empty tuple `()` and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  def raises(expected_exception, *args, **kwargs):\n      if expected_exception is None or expected_exception == ():\n          raise TypeError(\"expected_exception must be an exception type or a non-empty tuple of exception types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Update the `warns` function to check for `None` or an empty tuple `()` and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  def warns(expected_warning, *args, **kwargs):\n      if expected_warning is None or expected_warning == ():\n          raise TypeError(\"expected_warning must be a warning type or a non-empty tuple of warning types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Update the `xfail` decorator to check for `None` or an empty tuple `()` in the `raises` argument and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  @mark.xfail(raises=None, reason=\"\")\n  def xfail(*args, **kwargs):\n      raises = kwargs.get('raises')\n      if raises is None or raises == ():\n          raise TypeError(\"raises must be an exception type or a non-empty tuple of exception types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Ensure that the error message for passing `None` or `()` is consistent across `raises`, `warns`, and `xfail`.\n\n- Reference issue #9002 for the assertion of no warnings emitted and implement a check in `warns` to assert that no warnings are emitted if `expected_warning` is not provided.\n  ```python\n  def warns(expected_warning=None, *args, **kwargs):\n      if expected_warning is None:\n          # Logic to assert no warnings are emitted, possibly using warnings.catch_warnings\n          # Reference issue #9002 for implementation details\n      elif expected_warning == ():\n          raise TypeError(\"expected_warning must be a warning type or a non-empty tuple of warning types, not an empty tuple.\")\n      # Rest of the implementation ...\n  ```",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000239,
        "snippet_processor": 0.03833,
        "issue_star_creation": 0.025259999999999998,
        "issue_star_solver": 0.03222,
        "bouncer": 0.02645
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711733684.477822,
        "relevant_snippets": [
            {
                "code": "blank_issues_enabled: false\ncontact_links:\n  - name: \u2753 Support Question\n    url: https://github.com/pytest-dev/pytest/discussions\n    about: Use GitHub's new Discussions feature for questions",
                "filename": ".github/ISSUE_TEMPLATE/config.yml",
                "start_index": 0,
                "end_index": 191,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "rtd:\n  project: pytest",
                "filename": ".github/config.yml",
                "start_index": 0,
                "end_index": 22,
                "start_line": 1,
                "end_line": 2,
                "max_line": 2,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "# shim for pylib going away\n# if pylib is installed this file will get skipped\n# (`py/__init__.py` has higher precedence)\nimport sys\n\nimport _pytest._py.error as error\nimport _pytest._py.path as path\n\nsys.modules[\"py.error\"] = error\nsys.modules[\"py.path\"] = path",
                "filename": "src/py.py",
                "start_index": 0,
                "end_index": 262,
                "start_line": 1,
                "end_line": 10,
                "max_line": 10,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "# info:\n# * https://help.github.com/en/articles/displaying-a-sponsor-button-in-your-repository\n# * https://tidelift.com/subscription/how-to-connect-tidelift-with-github\ntidelift: pypi/pytest\nopen_collective: pytest",
                "filename": ".github/FUNDING.yml",
                "start_index": 0,
                "end_index": 214,
                "start_line": 1,
                "end_line": 5,
                "max_line": 5,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "\"\"\"\nThis script is part of the pytest release process which is triggered manually in the Actions\ntab of the repository.\n\nThe user will need to enter the base branch to start the release from (for example\n``6.1.x`` or ``main``) and if it should be a major release.\n\nThe appropriate version will be obtained based on the given branch automatically.\n\nAfter that, it will create a release using the `release` tox environment, and push a new PR.\n\n**Token**: currently the token from the GitHub Actions is used, pushed with\n`pytest bot <pytestbot@gmail.com>` commit author.\n\"\"\"\nimport argparse\nimport re\nfrom pathlib import Path\nfrom subprocess import check_call\nfrom subprocess import check_output\nfrom subprocess import run\n\nfrom colorama import Fore\nfrom colorama import init\nfrom github3.repos import Repository\n\n\nclass InvalidFeatureRelease(Exception):\n    pass\n\n\nSLUG = \"pytest-dev/pytest\"\n\nPR_BODY = \"\"\"\\\nCreated automatically from manual trigger.\n\nOnce all builds pass and it has been **approved** by one or more maintainers, the build\ncan be released by pushing a tag `{version}` to this repository.\n\"\"\"\n\n\ndef login(token: str) -> Repository:\n    import github3\n\n    github = github3.login(token=token)\n    owner, repo = SLUG.split(\"/\")\n    return github.repository(owner, repo)",
                "filename": "scripts/prepare-release-pr.py",
                "start_index": 0,
                "end_index": 1281,
                "start_line": 1,
                "end_line": 46,
                "max_line": 174,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "import pytest\n\n\n@pytest.fixture(scope=\"module\", params=range(966))\ndef foo(request):\n    return request.param\n\n\ndef test_it(foo):\n    pass\n\n\ndef test_it2(foo):\n    pass",
                "filename": "bench/manyparam.py",
                "start_index": 0,
                "end_index": 168,
                "start_line": 1,
                "end_line": 14,
                "max_line": 14,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "-   repo: local\n    hooks:\n    -   id: rst\n        name: rst\n        entry: rst-lint --encoding utf-8\n        files: ^(RELEASING.rst|README.rst|TIDELIFT.rst)$\n        language: python\n        additional_dependencies: [pygments, restructuredtext_lint]\n    -   id: changelogs-rst\n        name: changelog filenames\n        language: fail\n        entry: 'changelog files must be named ####.(breaking|bugfix|deprecation|doc|feature|improvement|trivial|vendor).rst'\n        exclude: changelog/(\\d+\\.(breaking|bugfix|deprecation|doc|feature|improvement|trivial|vendor).rst|README.rst|_template.rst)\n        files: ^changelog/\n    -   id: py-deprecated\n        name: py library is deprecated\n        language: pygrep\n        entry: >\n            (?x)\\bpy\\.(\n                _code\\.|\n                builtin\\.|\n                code\\.|\n                io\\.|\n                path\\.local\\.sysfind|\n                process\\.|\n                std\\.|\n                error\\.|\n                xml\\.\n            )\n        types: [python]\n    -   id: py-path-deprecated\n        name: py.path usage is deprecated\n        exclude: docs|src/_pytest/deprecated.py|testing/deprecated_test.py|src/_pytest/legacypath.py\n        language: pygrep\n        entry: \\bpy\\.path\\.local\n        types: [python]",
                "filename": ".pre-commit-config.yaml",
                "start_index": 2166,
                "end_index": 3442,
                "start_line": 73,
                "end_line": 108,
                "max_line": 108,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "import pytest\n\nSKIP = True\n\n\n@pytest.mark.parametrize(\"x\", range(5000))\ndef test_foo(x):\n    if SKIP:\n        pytest.skip(\"heh\")",
                "filename": "bench/skip.py",
                "start_index": 0,
                "end_index": 128,
                "start_line": 1,
                "end_line": 9,
                "max_line": 9,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "import sys\nfrom subprocess import call\n\n\ndef main():\n    \"\"\"\n    Platform agnostic wrapper script for towncrier.\n    Fixes the issue (#7251) where windows users are unable to natively run tox -e docs to build pytest docs.\n    \"\"\"\n    with open(\n        \"doc/en/_changelog_towncrier_draft.rst\", \"w\", encoding=\"utf-8\"\n    ) as draft_file:\n        return call((\"towncrier\", \"--draft\"), stdout=draft_file)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
                "filename": "scripts/towncrier-draft-to-file.py",
                "start_index": 0,
                "end_index": 451,
                "start_line": 1,
                "end_line": 17,
                "max_line": 17,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            },
            {
                "code": "import sys\n\nif __name__ == \"__main__\":\n    import cProfile\n    import pytest  # NOQA\n    import pstats\n\n    script = sys.argv[1:] if len(sys.argv) > 1 else [\"empty.py\"]\n    cProfile.run(\"pytest.cmdline.main(%r)\" % script, \"prof\")\n    p = pstats.Stats(\"prof\")\n    p.strip_dirs()\n    p.sort_stats(\"cumulative\")\n    print(p.print_stats(500))",
                "filename": "bench/bench.py",
                "start_index": 0,
                "end_index": 338,
                "start_line": 1,
                "end_line": 13,
                "max_line": 13,
                "git_instance": "github",
                "repo_name": "testbed/pytest-dev__pytest__7.2",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {},
        "solution_task": "- Update the `raises` function to check for `None` or an empty tuple `()` and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  def raises(expected_exception, *args, **kwargs):\n      if expected_exception is None or expected_exception == ():\n          raise TypeError(\"expected_exception must be an exception type or a non-empty tuple of exception types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Update the `warns` function to check for `None` or an empty tuple `()` and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  def warns(expected_warning, *args, **kwargs):\n      if expected_warning is None or expected_warning == ():\n          raise TypeError(\"expected_warning must be a warning type or a non-empty tuple of warning types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Update the `xfail` decorator to check for `None` or an empty tuple `()` in the `raises` argument and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  @mark.xfail(raises=None, reason=\"\")\n  def xfail(*args, **kwargs):\n      raises = kwargs.get('raises')\n      if raises is None or raises == ():\n          raise TypeError(\"raises must be an exception type or a non-empty tuple of exception types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Ensure that the error message for passing `None` or `()` is consistent across `raises`, `warns`, and `xfail`.\n\n- Reference issue #9002 for the assertion of no warnings emitted and implement a check in `warns` to assert that no warnings are emitted if `expected_warning` is not provided.\n  ```python\n  def warns(expected_warning=None, *args, **kwargs):\n      if expected_warning is None:\n          # Logic to assert no warnings are emitted, possibly using warnings.catch_warnings\n          # Reference issue #9002 for implementation details\n      elif expected_warning == ():\n          raise TypeError(\"expected_warning must be a warning type or a non-empty tuple of warning types, not an empty tuple.\")\n      # Rest of the implementation ...\n  ```",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT by suggesting code changes to the `raises`, `warns`, and `xfail` functions to check for `None` or an empty tuple `()` and raise a `TypeError` with a helpful error message. This directly addresses the issue of providing a more helpful error message when an empty tuple or `None` is passed to these functions. The RESPONSE also ensures that the error message is consistent across the functions, which is a good practice for maintaining clarity and consistency in error handling. Additionally, the RESPONSE references issue #9002 for the implementation of a check in `warns` to assert that no warnings are emitted if `expected_warning` is not provided, which shows an understanding of the broader context of the problem. The only reason it does not score a 10 is that it does not provide the exact wording for the error message as suggested in the PROMPT, which would have made the solution complete.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711733830.0630789,
        "result": "- Update the `raises` function to check for `None` or an empty tuple `()` and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  def raises(expected_exception, *args, **kwargs):\n      if expected_exception is None or expected_exception == ():\n          raise TypeError(\"expected_exception must be an exception type or a non-empty tuple of exception types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Update the `warns` function to check for `None` or an empty tuple `()` and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  def warns(expected_warning, *args, **kwargs):\n      if expected_warning is None or expected_warning == ():\n          raise TypeError(\"expected_warning must be a warning type or a non-empty tuple of warning types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Update the `xfail` decorator to check for `None` or an empty tuple `()` in the `raises` argument and raise a `TypeError` with a helpful error message if encountered.\n  ```python\n  @mark.xfail(raises=None, reason=\"\")\n  def xfail(*args, **kwargs):\n      raises = kwargs.get('raises')\n      if raises is None or raises == ():\n          raise TypeError(\"raises must be an exception type or a non-empty tuple of exception types, not None or an empty tuple.\")\n      # Rest of the implementation ...\n  ```\n\n- Ensure that the error message for passing `None` or `()` is consistent across `raises`, `warns`, and `xfail`.\n\n- Reference issue #9002 for the assertion of no warnings emitted and implement a check in `warns` to assert that no warnings are emitted if `expected_warning` is not provided.\n  ```python\n  def warns(expected_warning=None, *args, **kwargs):\n      if expected_warning is None:\n          # Logic to assert no warnings are emitted, possibly using warnings.catch_warnings\n          # Reference issue #9002 for implementation details\n      elif expected_warning == ():\n          raise TypeError(\"expected_warning must be a warning type or a non-empty tuple of warning types, not an empty tuple.\")\n      # Rest of the implementation ...\n  ```"
    }
}