{
    "id": "scikit-learn__scikit-learn-13974",
    "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
    "task_id": 2373186143212146907,
    "title": "Design of add_indicator in SimpleImputer may fail when running cross validation",
    "body": "<!--\r\nIf your issue is a usage question, submit it here instead:\r\n- StackOverflow with the scikit-learn tag: https://stackoverflow.com/questions/tagged/scikit-learn\r\n- Mailing List: https://mail.python.org/mailman/listinfo/scikit-learn\r\nFor more information, see User Questions: http://scikit-learn.org/stable/support.html#user-questions\r\n-->\r\n\r\n<!-- Instructions For Filing a Bug: https://github.com/scikit-learn/scikit-learn/blob/master/CONTRIBUTING.md#filing-bugs -->\r\n\r\n#### Description\r\n<!-- Example: Joblib Error thrown when calling fit on LatentDirichletAllocation with evaluate_every > 0-->\r\nThe design of `add_indicator` depends on missing values exist in the training data. This will break cross validation.\r\n\r\n#### Steps/Code to Reproduce\r\n<!--\r\nExample:\r\n```python\r\nfrom sklearn.feature_extraction.text import CountVectorizer\r\nfrom sklearn.decomposition import LatentDirichletAllocation\r\n\r\ndocs = [\"Help I have a bug\" for i in range(1000)]\r\n\r\nvectorizer = CountVectorizer(input=docs, analyzer='word')\r\nlda_features = vectorizer.fit_transform(docs)\r\n\r\nlda_model = LatentDirichletAllocation(\r\n    n_topics=10,\r\n    learning_method='online',\r\n    evaluate_every=10,\r\n    n_jobs=4,\r\n)\r\nmodel = lda_model.fit(lda_features)\r\n```\r\nIf the code is too long, feel free to put it in a public gist and link\r\nit in the issue: https://gist.github.com\r\n-->\r\n```py\r\nimport numpy as np\r\nfrom sklearn.impute import SimpleImputer\r\nfrom sklearn.linear_model import LogisticRegression\r\nfrom sklearn.model_selection import PredefinedSplit\r\nfrom sklearn.model_selection import cross_val_score\r\nfrom sklearn.pipeline import make_pipeline\r\n\r\nX = np.array([[1, 2, 3, np.nan]]).T\r\ny = np.array([0, 0, 1, 1])\r\ntest_fold = np.array([0, 1, 0, 1])\r\n\r\nps = PredefinedSplit(test_fold)\r\npipe1 = make_pipeline(SimpleImputer(add_indicator=True), \r\n                      LogisticRegression(solver='lbfgs'))\r\n\r\ncross_val_score(pipe1, X, y, cv=ps)\r\n```\r\n\r\n#### Expected Results\r\n<!-- Example: No error is thrown. Please paste or describe the expected results.-->\r\nNo error is thrown.\r\n\r\n#### Actual Results\r\n<!-- Please paste or specifically describe the actual output or traceback. -->\r\n```\r\nValueError: The features [0] have missing values in transform \r\nbut have no missing values in fit.\r\n```\r\n\r\n#### Thoughts\r\n\r\nThe original design was adopted because, if the training data has no missing value, there will be a column with all zeros. This type of error will appear when we try to do grid search over the `add_indicator` parameter. One way to work around this is to split the data in such a way that missing values are available (for each column that has a missing value) in both the training set and test set.\r\n\r\n<!-- Thanks for contributing! -->\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__0.22.git",
    "requested_commit": "",
    "mayil_response": "Based on the provided information, the issue seems to be related to the use of `SimpleImputer` with `add_indicator=True` in a cross-validation setup where missing values are present only in the test data but not in the training data. This causes a `ValueError` during the transformation phase because the missing value indicator expects consistency between fit and transform datasets.\n\nTo resolve the issue:\n\n- Set the `error_on_new` parameter of `MissingIndicator` to `False` when initializing it within the `_fit_indicator` method of the `_BaseImputer` class. This will prevent the error when new features with missing values are encountered during the transform phase that were not seen during the fit phase.\n\nHere is the modified code snippet from the `_BaseImputer` class:\n\n```python\ndef _fit_indicator(self, X):\n    \"\"\"Fit a MissingIndicator.\"\"\"\n    if self.add_indicator:\n        self.indicator_ = MissingIndicator(\n            missing_values=self.missing_values, error_on_new=False  # Set error_on_new to False\n        )\n        self.indicator_._fit(X, precomputed=True)\n    else:\n        self.indicator_ = None\n```\n\nThis change will allow the `SimpleImputer` to handle cases where missing values are present in the test set but not in the training set without raising an error.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [impute](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/impute)- [Lines 695 - 1036](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/impute/_base.py#L695-L1036)\n\n This snippet defines the MissingIndicator class and its parameters, which are relevant to the issue since the add_indicator parameter in SimpleImputer is related to MissingIndicator behavior. \n\n\n   - [Lines 71 - 136](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/impute/_base.py#L71-L136)\n\n This snippet is part of the _BaseImputer class which SimpleImputer inherits from. It includes the implementation of the add_indicator logic, which is directly related to the issue. \n\n\n   - [Lines 287 - 926](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/impute/_base.py#L287-L926)\n\n This snippet contains the _validate_input method of the MissingIndicator class, which is relevant to the issue as it deals with the handling of missing values and could be part of the problem when running cross-validation.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005394999999999999,
        "snippet_processor": 0.08021,
        "issue_star_creation": 0.03338,
        "issue_star_solver": 0.08541,
        "bouncer": 0.023790000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711739736.7837381,
        "relevant_snippets": [
            {
                "code": "\"\"\"Binary indicators for missing values.\n\n    Note that this component typically should not be used in a vanilla\n    :class:`~sklearn.pipeline.Pipeline` consisting of transformers and a\n    classifier, but rather could be added using a\n    :class:`~sklearn.pipeline.FeatureUnion` or\n    :class:`~sklearn.compose.ColumnTransformer`.\n\n    Read more in the :ref:`User Guide <impute>`.\n\n    .. versionadded:: 0.20\n\n    Parameters\n    ----------\n    missing_values : int, float, str, np.nan or None, default=np.nan\n        The placeholder for the missing values. All occurrences of\n        `missing_values` will be imputed. For pandas' dataframes with\n        nullable integer dtypes with missing values, `missing_values`\n        should be set to `np.nan`, since `pd.NA` will be converted to `np.nan`.\n\n    features : {'missing-only', 'all'}, default='missing-only'\n        Whether the imputer mask should represent all or a subset of\n        features.\n\n        - If `'missing-only'` (default), the imputer mask will only represent\n          features containing missing values during fit time.\n        - If `'all'`, the imputer mask will represent all features.\n\n    sparse : bool or 'auto', default='auto'\n        Whether the imputer mask format should be sparse or dense.\n\n        - If `'auto'` (default), the imputer mask will be of same type as\n          input.\n        - If `True`, the imputer mask will be a sparse matrix.\n        - If `False`, the imputer mask will be a numpy array.\n\n    error_on_new : bool, default=True\n        If `True`, :meth:`transform` will raise an error when there are\n        features with missing values that have no missing values in\n        :meth:`fit`. This is applicable only when `features='missing-only'`.\n\n    Attributes\n    ----------\n    features_ : ndarray of shape (n_missing_features,) or (n_features,)\n        The features indices which will be returned when calling\n        :meth:`transform`. They are computed during :meth:`fit`. If\n        `features='all'`, `features_` is equal to `range(n_features)`.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    SimpleImputer : Univariate imputation of missing values.\n    IterativeImputer : Multivariate imputation of missing values.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.impute import MissingIndicator\n    >>> X1 = np.array([[np.nan, 1, 3],\n    ...                [4, 0, np.nan],\n    ...                [8, 1, 0]])\n    >>> X2 = np.array([[5, 1, np.nan],\n    ...                [np.nan, 2, 3],\n    ...                [2, 4, 0]])\n    >>> indicator = MissingIndicator()\n    >>> indicator.fit(X1)\n    MissingIndicator()\n    >>> X2_tr = indicator.transform(X2)\n    >>> X2_tr\n    array([[False,  True],\n           [ True, False],\n           [False, False]])\n    \"\"\"",
                "filename": "sklearn/impute/_base.py",
                "start_index": 26316,
                "end_index": 29406,
                "start_line": 695,
                "end_line": 1036,
                "max_line": 1053,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "class _BaseImputer(TransformerMixin, BaseEstimator):\n    \"\"\"Base class for all imputers.\n\n    It adds automatically support for `add_indicator`.\n    \"\"\"\n\n    _parameter_constraints: dict = {\n        \"missing_values\": [MissingValues()],\n        \"add_indicator\": [\"boolean\"],\n        \"keep_empty_features\": [\"boolean\"],\n    }\n\n    def __init__(\n        self, *, missing_values=np.nan, add_indicator=False, keep_empty_features=False\n    ):\n        self.missing_values = missing_values\n        self.add_indicator = add_indicator\n        self.keep_empty_features = keep_empty_features\n\n    def _fit_indicator(self, X):\n        \"\"\"Fit a MissingIndicator.\"\"\"\n        if self.add_indicator:\n            self.indicator_ = MissingIndicator(\n                missing_values=self.missing_values, error_on_new=False\n            )\n            self.indicator_._fit(X, precomputed=True)\n        else:\n            self.indicator_ = None\n\n    def _transform_indicator(self, X):\n        \"\"\"Compute the indicator mask.'\n\n        Note that X must be the original data as passed to the imputer before\n        any imputation, since imputation may be done inplace in some cases.\n        \"\"\"\n        if self.add_indicator:\n            if not hasattr(self, \"indicator_\"):\n                raise ValueError(\n                    \"Make sure to call _fit_indicator before _transform_indicator\"\n                )\n            return self.indicator_.transform(X)\n\n    def _concatenate_indicator(self, X_imputed, X_indicator):\n        \"\"\"Concatenate indicator mask with the imputed data.\"\"\"\n        if not self.add_indicator:\n            return X_imputed\n\n        hstack = sp.hstack if sp.issparse(X_imputed) else np.hstack\n        if X_indicator is None:\n            raise ValueError(\n                \"Data from the missing indicator are not provided. Call \"\n                \"_fit_indicator and _transform_indicator in the imputer \"\n                \"implementation.\"\n            )\n\n        return hstack((X_imputed, X_indicator))\n\n    def _concatenate_indicator_feature_names_out(self, names, input_features):\n        if not self.add_indicator:\n            return names\n\n        indicator_names = self.indicator_.get_feature_names_out(input_features)\n        return np.concatenate([names, indicator_names])\n\n    def _more_tags(self):\n        return {\"allow_nan\": is_scalar_nan(self.missing_values)}",
                "filename": "sklearn/impute/_base.py",
                "start_index": 2536,
                "end_index": 4899,
                "start_line": 71,
                "end_line": 136,
                "max_line": 1053,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "class MissingIndicator(TransformerMixin, BaseEstimator):",
                "filename": "sklearn/impute/_base.py",
                "start_index": 26255,
                "end_index": 26311,
                "start_line": 694,
                "end_line": 694,
                "max_line": 1053,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "\"\"\"\n====================================================\nImputing missing values before building an estimator\n====================================================\n\nMissing values can be replaced by the mean, the median or the most frequent\nvalue using the basic :class:`~sklearn.impute.SimpleImputer`.\n\nIn this example we will investigate different imputation techniques:\n\n- imputation by the constant value 0\n- imputation by the mean value of each feature combined with a missing-ness\n  indicator auxiliary variable\n- k nearest neighbor imputation\n- iterative imputation\n\nWe will use two datasets: Diabetes dataset which consists of 10 feature\nvariables collected from diabetes patients with an aim to predict disease\nprogression and California Housing dataset for which the target is the median\nhouse value for California districts.\n\nAs neither of these datasets have missing values, we will remove some\nvalues to create new versions with artificially missing data. The performance\nof\n:class:`~sklearn.ensemble.RandomForestRegressor` on the full original dataset\nis then compared the performance on the altered datasets with the artificially\nmissing values imputed using different techniques.\n\n\"\"\"\n\n# Authors: Maria Telenczuk  <https://github.com/maikia>\n# License: BSD 3 clause\n\n# %%\n# Download the data and make missing values sets\n################################################\n#\n# First we download the two datasets. Diabetes dataset is shipped with\n# scikit-learn. It has 442 entries, each with 10 features. California Housing\n# dataset is much larger with 20640 entries and 8 features. It needs to be\n# downloaded. We will only use the first 400 entries for the sake of speeding\n# up the calculations but feel free to use the whole dataset.\n#\n\nimport numpy as np\n\nfrom sklearn.datasets import fetch_california_housing, load_diabetes\n\nrng = np.random.RandomState(42)\n\nX_diabetes, y_diabetes = load_diabetes(return_X_y=True)\nX_california, y_california = fetch_california_housing(return_X_y=True)\nX_california = X_california[:300]\ny_california = y_california[:300]\nX_diabetes = X_diabetes[:300]\ny_diabetes = y_diabetes[:300]\n\n\ndef add_missing_values(X_full, y_full):\n    n_samples, n_features = X_full.shape\n\n    # Add missing values in 75% of the lines\n    missing_rate = 0.75\n    n_missing_samples = int(n_samples * missing_rate)\n\n    missing_samples = np.zeros(n_samples, dtype=bool)\n    missing_samples[:n_missing_samples] = True\n\n    rng.shuffle(missing_samples)\n    missing_features = rng.randint(0, n_features, n_missing_samples)\n    X_missing = X_full.copy()\n    X_missing[missing_samples, missing_features] = np.nan\n    y_missing = y_full.copy()\n\n    return X_missing, y_missing\n\n\nX_miss_california, y_miss_california = add_missing_values(X_california, y_california)\n\nX_miss_diabetes, y_miss_diabetes = add_missing_values(X_diabetes, y_diabetes)\n\n\n# %%\n# Impute the missing data and score\n# #################################",
                "filename": "examples/impute/plot_missing_values.py",
                "start_index": 0,
                "end_index": 2940,
                "start_line": 1,
                "end_line": 85,
                "max_line": 308,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "if sp.issparse(X):\n            if self.missing_values == 0:\n                raise ValueError(\n                    \"Imputation not possible when missing_values \"\n                    \"== 0 and input is sparse. Provide a dense \"\n                    \"array instead.\"\n                )\n            else:\n                # if no invalid statistics are found, use the mask computed\n                # before, else recompute mask\n                if valid_statistics_indexes is None:\n                    mask = missing_mask.data\n                else:\n                    mask = _get_mask(X.data, self.missing_values)\n                indexes = np.repeat(\n                    np.arange(len(X.indptr) - 1, dtype=int), np.diff(X.indptr)\n                )[mask]\n\n                X.data[mask] = valid_statistics[indexes].astype(X.dtype, copy=False)\n        else:\n            # use mask computed before eliminating invalid mask\n            if valid_statistics_indexes is None:\n                mask_valid_features = missing_mask\n            else:\n                mask_valid_features = missing_mask[:, valid_statistics_indexes]\n            n_missing = np.sum(mask_valid_features, axis=0)\n            values = np.repeat(valid_statistics, n_missing)\n            coordinates = np.where(mask_valid_features.transpose())[::-1]\n\n            X[coordinates] = values\n\n        X_indicator = super()._transform_indicator(missing_mask)\n\n        return super()._concatenate_indicator(X, X_indicator)",
                "filename": "sklearn/impute/_base.py",
                "start_index": 21022,
                "end_index": 22490,
                "start_line": 390,
                "end_line": 596,
                "max_line": 1053,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "\"\"\"Transformers for missing value imputation\"\"\"\nimport typing\n\nfrom ._base import MissingIndicator, SimpleImputer\nfrom ._knn import KNNImputer\n\nif typing.TYPE_CHECKING:\n    # Avoid errors in type checkers (e.g. mypy) for experimental estimators.\n    # TODO: remove this check once the estimator is no longer experimental.\n    from ._iterative import IterativeImputer  # noqa\n\n__all__ = [\"MissingIndicator\", \"SimpleImputer\", \"KNNImputer\"]\n\n\n# TODO: remove this check once the estimator is no longer experimental.\ndef __getattr__(name):\n    if name == \"IterativeImputer\":\n        raise ImportError(\n            f\"{name} is experimental and the API might change without any \"\n            \"deprecation cycle. To use it, you need to explicitly import \"\n            \"enable_iterative_imputer:\\n\"\n            \"from sklearn.experimental import enable_iterative_imputer\"\n        )\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")",
                "filename": "sklearn/impute/__init__.py",
                "start_index": 0,
                "end_index": 942,
                "start_line": 1,
                "end_line": 24,
                "max_line": 24,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "def _validate_input(self, X, in_fit):\n        if not is_scalar_nan(self.missing_values):\n            force_all_finite = True\n        else:\n            force_all_finite = \"allow-nan\"\n        X = self._validate_data(\n            X,\n            reset=in_fit,\n            accept_sparse=(\"csc\", \"csr\"),\n            dtype=None,\n            force_all_finite=force_all_finite,\n        )\n        _check_inputs_dtype(X, self.missing_values)\n        if X.dtype.kind not in (\"i\", \"u\", \"f\", \"O\"):\n            raise ValueError(\n                \"MissingIndicator does not support data with \"\n                \"dtype {0}. Please provide either a numeric array\"\n                \" (with a floating point or integer dtype) or \"\n                \"categorical data represented either as an array \"\n                \"with integer dtype or an array of string values \"\n                \"with an object dtype.\".format(X.dtype)\n            )\n\n        if sp.issparse(X) and self.missing_values == 0:\n            # missing_values = 0 not allowed with sparse data as it would\n            # force densification\n            raise ValueError(\n                \"Sparse input with missing_values=0 is \"\n                \"not supported. Provide a dense \"\n                \"array instead.\"\n            )\n\n        return X\n\n    def _fit(self, X, y=None, precomputed=False):\n        \"\"\"Fit the transformer on `X`.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Input data, where `n_samples` is the number of samples and\n            `n_features` is the number of features.\n            If `precomputed=True`, then `X` is a mask of the input data.\n\n        precomputed : bool\n            Whether the input data is a mask.\n\n        Returns\n        -------\n        imputer_mask : {ndarray, sparse matrix} of shape (n_samples, \\\n        n_features)\n            The imputer mask of the original data.\n        \"\"\"\n        if precomputed:\n            if not (hasattr(X, \"dtype\") and X.dtype.kind == \"b\"):\n                raise ValueError(\"precomputed is True but the input data is not a mask\")\n            self._precomputed = True\n        else:\n            self._precomputed = False\n\n        # Need not validate X again as it would have already been validated\n        # in the Imputer calling MissingIndicator\n        if not self._precomputed:\n            X = self._validate_input(X, in_fit=True)\n        else:\n            # only create `n_features_in_` in the precomputed case\n            self._check_n_features(X, reset=True)\n\n        self._n_features = X.shape[1]\n\n        missing_features_info = self._get_missing_features_info(X)\n        self.features_ = missing_features_info[1]\n\n        return missing_features_info[0]",
                "filename": "sklearn/impute/_base.py",
                "start_index": 31784,
                "end_index": 34532,
                "start_line": 287,
                "end_line": 926,
                "max_line": 1053,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "# Now we will write a function which will score the results on the differently\n# imputed data. Let's look at each imputer separately:\n#\n\nrng = np.random.RandomState(0)\n\nfrom sklearn.ensemble import RandomForestRegressor\n\n# To use the experimental IterativeImputer, we need to explicitly ask for it:\nfrom sklearn.experimental import enable_iterative_imputer  # noqa\nfrom sklearn.impute import IterativeImputer, KNNImputer, SimpleImputer\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.pipeline import make_pipeline\n\nN_SPLITS = 4\nregressor = RandomForestRegressor(random_state=0)\n\n# %%\n# Missing information\n# -------------------\n# In addition to imputing the missing values, the imputers have an\n# `add_indicator` parameter that marks the values that were missing, which\n# might carry some information.\n#\n\n\ndef get_scores_for_imputer(imputer, X_missing, y_missing):\n    estimator = make_pipeline(imputer, regressor)\n    impute_scores = cross_val_score(\n        estimator, X_missing, y_missing, scoring=\"neg_mean_squared_error\", cv=N_SPLITS\n    )\n    return impute_scores\n\n\nx_labels = []\n\nmses_california = np.zeros(5)\nstds_california = np.zeros(5)\nmses_diabetes = np.zeros(5)\nstds_diabetes = np.zeros(5)\n\n# %%\n# Estimate the score\n# ------------------\n# First, we want to estimate the score on the original data:\n#\n\n\ndef get_full_score(X_full, y_full):\n    full_scores = cross_val_score(\n        regressor, X_full, y_full, scoring=\"neg_mean_squared_error\", cv=N_SPLITS\n    )\n    return full_scores.mean(), full_scores.std()\n\n\nmses_california[0], stds_california[0] = get_full_score(X_california, y_california)\nmses_diabetes[0], stds_diabetes[0] = get_full_score(X_diabetes, y_diabetes)\nx_labels.append(\"Full data\")\n\n\n# %%\n# Replace missing values by 0\n# ---------------------------\n#\n# Now we will estimate the score on the data where the missing values are\n# replaced by 0:\n#\n\n\ndef get_impute_zero_score(X_missing, y_missing):\n    imputer = SimpleImputer(\n        missing_values=np.nan, add_indicator=True, strategy=\"constant\", fill_value=0\n    )\n    zero_impute_scores = get_scores_for_imputer(imputer, X_missing, y_missing)\n    return zero_impute_scores.mean(), zero_impute_scores.std()\n\n\nmses_california[1], stds_california[1] = get_impute_zero_score(\n    X_miss_california, y_miss_california\n)\nmses_diabetes[1], stds_diabetes[1] = get_impute_zero_score(\n    X_miss_diabetes, y_miss_diabetes\n)\nx_labels.append(\"Zero imputation\")\n\n\n# %%\n# kNN-imputation of the missing values\n# ------------------------------------\n#\n# :class:`~sklearn.impute.KNNImputer` imputes missing values using the weighted\n# or unweighted mean of the desired number of nearest neighbors.\n\n\ndef get_impute_knn_score(X_missing, y_missing):\n    imputer = KNNImputer(missing_values=np.nan, add_indicator=True)\n    knn_impute_scores = get_scores_for_imputer(imputer, X_missing, y_missing)\n    return knn_impute_scores.mean(), knn_impute_scores.std()",
                "filename": "examples/impute/plot_missing_values.py",
                "start_index": 2941,
                "end_index": 5878,
                "start_line": 86,
                "end_line": 183,
                "max_line": 308,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "# Estimate the score on the entire dataset, with no missing values\nbr_estimator = BayesianRidge()\nscore_full_data = pd.DataFrame(\n    cross_val_score(\n        br_estimator, X_full, y_full, scoring=\"neg_mean_squared_error\", cv=N_SPLITS\n    ),\n    columns=[\"Full Data\"],\n)\n\n# Add a single missing value to each row\nX_missing = X_full.copy()\ny_missing = y_full\nmissing_samples = np.arange(n_samples)\nmissing_features = rng.choice(n_features, n_samples, replace=True)\nX_missing[missing_samples, missing_features] = np.nan\n\n# Estimate the score after imputation (mean and median strategies)\nscore_simple_imputer = pd.DataFrame()\nfor strategy in (\"mean\", \"median\"):\n    estimator = make_pipeline(\n        SimpleImputer(missing_values=np.nan, strategy=strategy), br_estimator\n    )\n    score_simple_imputer[strategy] = cross_val_score(\n        estimator, X_missing, y_missing, scoring=\"neg_mean_squared_error\", cv=N_SPLITS\n    )\n\n# Estimate the score after iterative imputation of the missing values\n# with different estimators\nestimators = [\n    BayesianRidge(),\n    RandomForestRegressor(\n        # We tuned the hyperparameters of the RandomForestRegressor to get a good\n        # enough predictive performance for a restricted execution time.\n        n_estimators=4,\n        max_depth=10,\n        bootstrap=True,\n        max_samples=0.5,\n        n_jobs=2,\n        random_state=0,\n    ),\n    make_pipeline(\n        Nystroem(kernel=\"polynomial\", degree=2, random_state=0), Ridge(alpha=1e3)\n    ),\n    KNeighborsRegressor(n_neighbors=15),\n]\nscore_iterative_imputer = pd.DataFrame()\n# iterative imputer is sensible to the tolerance and\n# dependent on the estimator used internally.\n# we tuned the tolerance to keep this example run with limited computational\n# resources while not changing the results too much compared to keeping the\n# stricter default value for the tolerance parameter.\ntolerances = (1e-3, 1e-1, 1e-1, 1e-2)\nfor impute_estimator, tol in zip(estimators, tolerances):\n    estimator = make_pipeline(\n        IterativeImputer(\n            random_state=0, estimator=impute_estimator, max_iter=25, tol=tol\n        ),\n        br_estimator,\n    )\n    score_iterative_imputer[impute_estimator.__class__.__name__] = cross_val_score(\n        estimator, X_missing, y_missing, scoring=\"neg_mean_squared_error\", cv=N_SPLITS\n    )\n\nscores = pd.concat(\n    [score_full_data, score_simple_imputer, score_iterative_imputer],\n    keys=[\"Original\", \"SimpleImputer\", \"IterativeImputer\"],\n    axis=1,\n)\n\n# plot california housing results\nfig, ax = plt.subplots(figsize=(13, 6))\nmeans = -scores.mean()\nerrors = scores.std()\nmeans.plot.barh(xerr=errors, ax=ax)\nax.set_title(\"California Housing Regression with Different Imputation Methods\")\nax.set_xlabel(\"MSE (smaller is better)\")\nax.set_yticks(np.arange(means.shape[0]))\nax.set_yticklabels([\" w/ \".join(label) for label in means.index.tolist()])\nplt.tight_layout(pad=1)\nplt.show()",
                "filename": "examples/impute/plot_iterative_imputer_variants_comparison.py",
                "start_index": 2961,
                "end_index": 5880,
                "start_line": 74,
                "end_line": 153,
                "max_line": 153,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            },
            {
                "code": "@_fit_context(\n        # IterativeImputer.estimator is not validated yet\n        prefer_skip_nested_validation=False\n    )",
                "filename": "sklearn/impute/_iterative.py",
                "start_index": 27132,
                "end_index": 27254,
                "start_line": 679,
                "end_line": 851,
                "max_line": 901,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sklearn/impute/_base.py": [
                {
                    "chunk": {
                        "code": "\"\"\"Binary indicators for missing values.\n\n    Note that this component typically should not be used in a vanilla\n    :class:`~sklearn.pipeline.Pipeline` consisting of transformers and a\n    classifier, but rather could be added using a\n    :class:`~sklearn.pipeline.FeatureUnion` or\n    :class:`~sklearn.compose.ColumnTransformer`.\n\n    Read more in the :ref:`User Guide <impute>`.\n\n    .. versionadded:: 0.20\n\n    Parameters\n    ----------\n    missing_values : int, float, str, np.nan or None, default=np.nan\n        The placeholder for the missing values. All occurrences of\n        `missing_values` will be imputed. For pandas' dataframes with\n        nullable integer dtypes with missing values, `missing_values`\n        should be set to `np.nan`, since `pd.NA` will be converted to `np.nan`.\n\n    features : {'missing-only', 'all'}, default='missing-only'\n        Whether the imputer mask should represent all or a subset of\n        features.\n\n        - If `'missing-only'` (default), the imputer mask will only represent\n          features containing missing values during fit time.\n        - If `'all'`, the imputer mask will represent all features.\n\n    sparse : bool or 'auto', default='auto'\n        Whether the imputer mask format should be sparse or dense.\n\n        - If `'auto'` (default), the imputer mask will be of same type as\n          input.\n        - If `True`, the imputer mask will be a sparse matrix.\n        - If `False`, the imputer mask will be a numpy array.\n\n    error_on_new : bool, default=True\n        If `True`, :meth:`transform` will raise an error when there are\n        features with missing values that have no missing values in\n        :meth:`fit`. This is applicable only when `features='missing-only'`.\n\n    Attributes\n    ----------\n    features_ : ndarray of shape (n_missing_features,) or (n_features,)\n        The features indices which will be returned when calling\n        :meth:`transform`. They are computed during :meth:`fit`. If\n        `features='all'`, `features_` is equal to `range(n_features)`.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Defined only when `X`\n        has feature names that are all strings.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    SimpleImputer : Univariate imputation of missing values.\n    IterativeImputer : Multivariate imputation of missing values.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.impute import MissingIndicator\n    >>> X1 = np.array([[np.nan, 1, 3],\n    ...                [4, 0, np.nan],\n    ...                [8, 1, 0]])\n    >>> X2 = np.array([[5, 1, np.nan],\n    ...                [np.nan, 2, 3],\n    ...                [2, 4, 0]])\n    >>> indicator = MissingIndicator()\n    >>> indicator.fit(X1)\n    MissingIndicator()\n    >>> X2_tr = indicator.transform(X2)\n    >>> X2_tr\n    array([[False,  True],\n           [ True, False],\n           [False, False]])\n    \"\"\"",
                        "filename": "sklearn/impute/_base.py",
                        "start_index": 26316,
                        "end_index": 29406,
                        "start_line": 695,
                        "end_line": 1036,
                        "max_line": 1053,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the MissingIndicator class and its parameters, which are relevant to the issue since the add_indicator parameter in SimpleImputer is related to MissingIndicator behavior."
                },
                {
                    "chunk": {
                        "code": "class _BaseImputer(TransformerMixin, BaseEstimator):\n    \"\"\"Base class for all imputers.\n\n    It adds automatically support for `add_indicator`.\n    \"\"\"\n\n    _parameter_constraints: dict = {\n        \"missing_values\": [MissingValues()],\n        \"add_indicator\": [\"boolean\"],\n        \"keep_empty_features\": [\"boolean\"],\n    }\n\n    def __init__(\n        self, *, missing_values=np.nan, add_indicator=False, keep_empty_features=False\n    ):\n        self.missing_values = missing_values\n        self.add_indicator = add_indicator\n        self.keep_empty_features = keep_empty_features\n\n    def _fit_indicator(self, X):\n        \"\"\"Fit a MissingIndicator.\"\"\"\n        if self.add_indicator:\n            self.indicator_ = MissingIndicator(\n                missing_values=self.missing_values, error_on_new=False\n            )\n            self.indicator_._fit(X, precomputed=True)\n        else:\n            self.indicator_ = None\n\n    def _transform_indicator(self, X):\n        \"\"\"Compute the indicator mask.'\n\n        Note that X must be the original data as passed to the imputer before\n        any imputation, since imputation may be done inplace in some cases.\n        \"\"\"\n        if self.add_indicator:\n            if not hasattr(self, \"indicator_\"):\n                raise ValueError(\n                    \"Make sure to call _fit_indicator before _transform_indicator\"\n                )\n            return self.indicator_.transform(X)\n\n    def _concatenate_indicator(self, X_imputed, X_indicator):\n        \"\"\"Concatenate indicator mask with the imputed data.\"\"\"\n        if not self.add_indicator:\n            return X_imputed\n\n        hstack = sp.hstack if sp.issparse(X_imputed) else np.hstack\n        if X_indicator is None:\n            raise ValueError(\n                \"Data from the missing indicator are not provided. Call \"\n                \"_fit_indicator and _transform_indicator in the imputer \"\n                \"implementation.\"\n            )\n\n        return hstack((X_imputed, X_indicator))\n\n    def _concatenate_indicator_feature_names_out(self, names, input_features):\n        if not self.add_indicator:\n            return names\n\n        indicator_names = self.indicator_.get_feature_names_out(input_features)\n        return np.concatenate([names, indicator_names])\n\n    def _more_tags(self):\n        return {\"allow_nan\": is_scalar_nan(self.missing_values)}",
                        "filename": "sklearn/impute/_base.py",
                        "start_index": 2536,
                        "end_index": 4899,
                        "start_line": 71,
                        "end_line": 136,
                        "max_line": 1053,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the _BaseImputer class which SimpleImputer inherits from. It includes the implementation of the add_indicator logic, which is directly related to the issue."
                },
                {
                    "chunk": {
                        "code": "def _validate_input(self, X, in_fit):\n        if not is_scalar_nan(self.missing_values):\n            force_all_finite = True\n        else:\n            force_all_finite = \"allow-nan\"\n        X = self._validate_data(\n            X,\n            reset=in_fit,\n            accept_sparse=(\"csc\", \"csr\"),\n            dtype=None,\n            force_all_finite=force_all_finite,\n        )\n        _check_inputs_dtype(X, self.missing_values)\n        if X.dtype.kind not in (\"i\", \"u\", \"f\", \"O\"):\n            raise ValueError(\n                \"MissingIndicator does not support data with \"\n                \"dtype {0}. Please provide either a numeric array\"\n                \" (with a floating point or integer dtype) or \"\n                \"categorical data represented either as an array \"\n                \"with integer dtype or an array of string values \"\n                \"with an object dtype.\".format(X.dtype)\n            )\n\n        if sp.issparse(X) and self.missing_values == 0:\n            # missing_values = 0 not allowed with sparse data as it would\n            # force densification\n            raise ValueError(\n                \"Sparse input with missing_values=0 is \"\n                \"not supported. Provide a dense \"\n                \"array instead.\"\n            )\n\n        return X\n\n    def _fit(self, X, y=None, precomputed=False):\n        \"\"\"Fit the transformer on `X`.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            Input data, where `n_samples` is the number of samples and\n            `n_features` is the number of features.\n            If `precomputed=True`, then `X` is a mask of the input data.\n\n        precomputed : bool\n            Whether the input data is a mask.\n\n        Returns\n        -------\n        imputer_mask : {ndarray, sparse matrix} of shape (n_samples, \\\n        n_features)\n            The imputer mask of the original data.\n        \"\"\"\n        if precomputed:\n            if not (hasattr(X, \"dtype\") and X.dtype.kind == \"b\"):\n                raise ValueError(\"precomputed is True but the input data is not a mask\")\n            self._precomputed = True\n        else:\n            self._precomputed = False\n\n        # Need not validate X again as it would have already been validated\n        # in the Imputer calling MissingIndicator\n        if not self._precomputed:\n            X = self._validate_input(X, in_fit=True)\n        else:\n            # only create `n_features_in_` in the precomputed case\n            self._check_n_features(X, reset=True)\n\n        self._n_features = X.shape[1]\n\n        missing_features_info = self._get_missing_features_info(X)\n        self.features_ = missing_features_info[1]\n\n        return missing_features_info[0]",
                        "filename": "sklearn/impute/_base.py",
                        "start_index": 31784,
                        "end_index": 34532,
                        "start_line": 287,
                        "end_line": 926,
                        "max_line": 1053,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the _validate_input method of the MissingIndicator class, which is relevant to the issue as it deals with the handling of missing values and could be part of the problem when running cross-validation."
                }
            ]
        },
        "solution_task": "Based on the provided information, the issue seems to be related to the use of `SimpleImputer` with `add_indicator=True` in a cross-validation setup where missing values are present only in the test data but not in the training data. This causes a `ValueError` during the transformation phase because the missing value indicator expects consistency between fit and transform datasets.\n\nTo resolve the issue:\n\n- Set the `error_on_new` parameter of `MissingIndicator` to `False` when initializing it within the `_fit_indicator` method of the `_BaseImputer` class. This will prevent the error when new features with missing values are encountered during the transform phase that were not seen during the fit phase.\n\nHere is the modified code snippet from the `_BaseImputer` class:\n\n```python\ndef _fit_indicator(self, X):\n    \"\"\"Fit a MissingIndicator.\"\"\"\n    if self.add_indicator:\n        self.indicator_ = MissingIndicator(\n            missing_values=self.missing_values, error_on_new=False  # Set error_on_new to False\n        )\n        self.indicator_._fit(X, precomputed=True)\n    else:\n        self.indicator_ = None\n```\n\nThis change will allow the `SimpleImputer` to handle cases where missing values are present in the test set but not in the training set without raising an error.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a specific and actionable solution to the problem described in the PROMPT by suggesting a modification to the `MissingIndicator` class within the scikit-learn library. The suggestion to set the `error_on_new` parameter to `False` is directly related to the error encountered during cross-validation when missing values are present only in the test data. The RESPONSE also includes a code snippet showing where to apply the suggested change, which is relevant and helpful. However, the RESPONSE does not address the broader implications of this change or provide alternative solutions if modifying the library code is not feasible. Additionally, the RESPONSE includes links to code snippets that are not directly accessible, which may not be immediately useful to the user.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711739879.2742379,
        "result": "Based on the provided information, the issue seems to be related to the use of `SimpleImputer` with `add_indicator=True` in a cross-validation setup where missing values are present only in the test data but not in the training data. This causes a `ValueError` during the transformation phase because the missing value indicator expects consistency between fit and transform datasets.\n\nTo resolve the issue:\n\n- Set the `error_on_new` parameter of `MissingIndicator` to `False` when initializing it within the `_fit_indicator` method of the `_BaseImputer` class. This will prevent the error when new features with missing values are encountered during the transform phase that were not seen during the fit phase.\n\nHere is the modified code snippet from the `_BaseImputer` class:\n\n```python\ndef _fit_indicator(self, X):\n    \"\"\"Fit a MissingIndicator.\"\"\"\n    if self.add_indicator:\n        self.indicator_ = MissingIndicator(\n            missing_values=self.missing_values, error_on_new=False  # Set error_on_new to False\n        )\n        self.indicator_._fit(X, precomputed=True)\n    else:\n        self.indicator_ = None\n```\n\nThis change will allow the `SimpleImputer` to handle cases where missing values are present in the test set but not in the training set without raising an error.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [impute](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/impute)- [Lines 695 - 1036](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/impute/_base.py#L695-L1036)\n\n This snippet defines the MissingIndicator class and its parameters, which are relevant to the issue since the add_indicator parameter in SimpleImputer is related to MissingIndicator behavior. \n\n\n   - [Lines 71 - 136](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/impute/_base.py#L71-L136)\n\n This snippet is part of the _BaseImputer class which SimpleImputer inherits from. It includes the implementation of the add_indicator logic, which is directly related to the issue. \n\n\n   - [Lines 287 - 926](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/impute/_base.py#L287-L926)\n\n This snippet contains the _validate_input method of the MissingIndicator class, which is relevant to the issue as it deals with the handling of missing values and could be part of the problem when running cross-validation."
    }
}