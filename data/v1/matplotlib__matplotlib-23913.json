{
    "id": "matplotlib__matplotlib-23913",
    "repo_name": "testbed/matplotlib__matplotlib__3.6",
    "task_id": 4755425275938087211,
    "title": "legend draggable as keyword",
    "body": "<!--To help us understand and resolve your issue, please fill out the form to the best of your ability.-->\r\n<!--You can feel free to delete the sections that do not apply.-->\r\n\r\n### Feature request\r\n\r\n**There is not keyword to make legend draggable at creation**\r\n\r\n<!--A short 1-2 sentences that succinctly describes the bug-->\r\n\r\nIs there a code reason why one can not add a \"draggable=True\" keyword to the __init__ function for Legend?  This would be more handy than having to call it after legend creation.  And, naively, it would seem simple to do.  But maybe there is a reason why it would not work?\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.6.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature request of adding a `draggable=True` keyword to the `__init__` function for `Legend`, you can follow these steps:\n\n- Modify the `__init__` method of the `Legend` class in `lib/matplotlib/legend.py` to accept a new keyword argument `draggable`.\n- Set the default value of `draggable` to `False` to maintain backward compatibility.\n- Inside the `__init__` method, after all the setup is done, check if `draggable` is `True`.\n- If `draggable` is `True`, call the `set_draggable` method with the appropriate parameters.\n\nHere is the modified `__init__` method of the `Legend` class:\n\n```python\ndef __init__(\n        self, parent, handles, labels,\n        *,\n        loc=None,\n        # ... [other parameters] ...\n        draggable=False,  # Add this line for the new keyword argument\n        **kwargs\n    ):\n    # ... [existing __init__ code] ...\n    \n    # Set the legend to be draggable if the keyword is provided and True\n    if draggable:\n        self.set_draggable(True)\n```\n\nAnd here is the usage example:\n\n```python\n# When creating a legend, you can now use the draggable keyword\nlegend = Legend(parent, handles, labels, draggable=True)\n```\n\nThis implementation allows users to make the legend draggable at creation time by simply passing `draggable=True` as an argument to the `Legend` constructor.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 55 - 616](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/legend.py#L55-L616)\n\n This snippet contains the __init__ method of the Legend class where the 'draggable' parameter is set. To address the issue, this method would likely need to be modified to accept a 'draggable' keyword argument at creation. \n\n\n   - [Lines 1203 - 1239](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/legend.py#L1203-L1239)\n\n This snippet contains the set_draggable method which is currently used to make a legend draggable after creation. Understanding this method is necessary to integrate the draggable functionality directly into the __init__ method. \n\n\n   - [Lines 54 - 95](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/legend.py#L54-L95)\n\n This snippet defines the DraggableLegend class which is used to make legends draggable. Understanding how this class is used will be important for integrating the draggable feature into the legend creation process.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 1 - 1536](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/offsetbox.py#L1-L1536)\n\n This snippet from offsetbox.py contains the base class for draggable artists, which is relevant for understanding how draggable functionality is implemented in Matplotlib and could influence how the feature is integrated at legend creation.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0004085,
        "snippet_processor": 0.05766,
        "issue_star_creation": 0.03822,
        "issue_star_solver": 0.053630000000000004,
        "bouncer": 0.034140000000000004
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711697695.4107158,
        "relevant_snippets": [
            {
                "code": "class DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)",
                "filename": "lib/matplotlib/legend.py",
                "start_index": 1881,
                "end_index": 3597,
                "start_line": 54,
                "end_line": 95,
                "max_line": 1377,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "name: Feature Request\ndescription: Suggest something to add to Matplotlib!\ntitle: \"[ENH]: \"\nlabels: [New feature]\nbody:\n  - type: markdown\n    attributes:\n      value: |\n         Please search the [issues](https://github.com/matplotlib/matplotlib/issues) for relevant feature requests before creating a new feature request.\n  - type: textarea\n    id: problem\n    attributes:\n      label: Problem\n      description: Briefly describe the problem this feature will solve. (2-4 sentences)\n      placeholder: |\n        * I'm always frustrated when [...] because [...]\n        * I would like it if [...] happened when I [...] because [...]\n        * Here is a sample image of what I am asking for [...]\n    validations:\n      required: true\n  - type: textarea\n    id: solution\n    attributes:\n      label: Proposed solution\n      description: Describe a way to accomplish the goals of this feature request.",
                "filename": ".github/ISSUE_TEMPLATE/feature_request.yml",
                "start_index": 0,
                "end_index": 900,
                "start_line": 1,
                "end_line": 25,
                "max_line": 25,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Helper base class for a draggable artist (legend, offsetbox).\n\n    Derived classes must override the following methods::\n\n        def save_offset(self):\n            '''\n            Called when the object is picked for dragging; should save the\n            reference position of the artist.\n            '''\n\n        def update_offset(self, dx, dy):\n            '''\n            Called during the dragging; (*dx*, *dy*) is the pixel offset from\n            the point where the mouse drag started.\n            '''\n\n    Optionally, you may override the following method::\n\n        def finalize_offset(self):\n            '''Called when the mouse is released.'''\n\n    In the current implementation of `.DraggableLegend` and\n    `DraggableAnnotation`, `update_offset` places the artists in display\n    coordinates, and `finalize_offset` recalculates their position in axes\n    coordinate and set a relevant attribute.\n    \"\"\"\n\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self._use_blit = use_blit and self.canvas.supports_blit\n        callbacks = ref_artist.figure._canvas_callbacks\n        self._disconnectors = [\n            functools.partial(\n                callbacks.disconnect, callbacks._connect_picklable(name, func))\n            for name, func in [\n                (\"pick_event\", self.on_pick),\n                (\"button_release_event\", self.on_release),\n                (\"motion_notify_event\", self.on_motion),\n            ]\n        ]\n\n    # A property, not an attribute, to maintain picklability.\n    canvas = property(lambda self: self.ref_artist.figure.canvas)\n\n    cids = property(lambda self: [\n        disconnect.args[0] for disconnect in self._disconnectors[:2]])\n\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self.save_offset()",
                "filename": "lib/matplotlib/offsetbox.py",
                "start_index": 48967,
                "end_index": 51913,
                "start_line": 1,
                "end_line": 1536,
                "max_line": 1604,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "_loc_doc_base = \"\"\"\nloc : str or pair of floats, default: {default}\n    The location of the legend.\n\n    The strings ``'upper left'``, ``'upper right'``, ``'lower left'``,\n    ``'lower right'`` place the legend at the corresponding corner of the\n    {parent}.\n\n    The strings ``'upper center'``, ``'lower center'``, ``'center left'``,\n    ``'center right'`` place the legend at the center of the corresponding edge\n    of the {parent}.\n\n    The string ``'center'`` places the legend at the center of the {parent}.\n{best}\n    The location can also be a 2-tuple giving the coordinates of the lower-left\n    corner of the legend in {parent} coordinates (in which case *bbox_to_anchor*\n    will be ignored).\n\n    For back-compatibility, ``'center right'`` (but no other location) can also\n    be spelled ``'right'``, and each \"string\" location can also be given as a\n    numeric value:\n\n    ==================   =============\n    Location String      Location Code\n    ==================   =============\n    'best' (Axes only)   0\n    'upper right'        1\n    'upper left'         2\n    'lower left'         3\n    'lower right'        4\n    'right'              5\n    'center left'        6\n    'center right'       7\n    'lower center'       8\n    'upper center'       9\n    'center'             10\n    ==================   =============\n    {outside}\"\"\"\n\n_loc_doc_best = \"\"\"\n    The string ``'best'`` places the legend at the location, among the nine\n    locations defined so far, with the minimum overlap with other drawn\n    artists.  This option can be quite slow for plots with large amounts of\n    data; your plotting speed may benefit from providing a specific location.\n\"\"\"\n\n_legend_kw_axes_st = (\n    _loc_doc_base.format(parent='axes', default=':rc:`legend.loc`',\n                         best=_loc_doc_best, outside='') +\n    _legend_kw_doc_base)\n_docstring.interpd.update(_legend_kw_axes=_legend_kw_axes_st)\n\n_outside_doc = \"\"\"\n    If a figure is using the constrained layout manager, the string codes\n    of the *loc* keyword argument can get better layout behaviour using the\n    prefix 'outside'. There is ambiguity at the corners, so 'outside\n    upper right' will make space for the legend above the rest of the\n    axes in the layout, and 'outside right upper' will make space on the\n    right side of the layout.  In addition to the values of *loc*\n    listed above, we have 'outside right upper', 'outside right lower',\n    'outside left upper', and 'outside left lower'.  See\n    :ref:`legend_guide` for more details.\n\"\"\"\n\n_legend_kw_figure_st = (\n    _loc_doc_base.format(parent='figure', default=\"'upper right'\",\n                         best='', outside=_outside_doc) +\n    _legend_kw_doc_base)\n_docstring.interpd.update(_legend_kw_figure=_legend_kw_figure_st)",
                "filename": "lib/matplotlib/legend.py",
                "start_index": 10603,
                "end_index": 13387,
                "start_line": 258,
                "end_line": 326,
                "max_line": 1377,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def _parse_legend_args(axs, *args, handles=None, labels=None, **kwargs):",
                "filename": "lib/matplotlib/legend.py",
                "start_index": 52253,
                "end_index": 52325,
                "start_line": 1290,
                "end_line": 1290,
                "max_line": 1377,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "red_patch = mpatches.Patch(color='red', label='The red data')\nax.legend(handles=[red_patch])\n\nplt.show()\n\n# %%\n# There are many supported legend handles. Instead of creating a patch of color\n# we could have created a line with a marker:\n\nimport matplotlib.lines as mlines\n\nfig, ax = plt.subplots()\nblue_line = mlines.Line2D([], [], color='blue', marker='*',\n                          markersize=15, label='Blue stars')\nax.legend(handles=[blue_line])\n\nplt.show()\n\n# %%\n# Legend location\n# ===============\n#\n# The location of the legend can be specified by the keyword argument\n# *loc*. Please see the documentation at :func:`legend` for more details.\n#\n# The ``bbox_to_anchor`` keyword gives a great degree of control for manual\n# legend placement. For example, if you want your axes legend located at the\n# figure's top right-hand corner instead of the axes' corner, simply specify\n# the corner's location and the coordinate system of that location::\n#\n#     ax.legend(bbox_to_anchor=(1, 1),\n#               bbox_transform=fig.transFigure)\n#\n# More examples of custom legend placement:\n\nfig, ax_dict = plt.subplot_mosaic([['top', 'top'], ['bottom', 'BLANK']],\n                                  empty_sentinel=\"BLANK\")\nax_dict['top'].plot([1, 2, 3], label=\"test1\")\nax_dict['top'].plot([3, 2, 1], label=\"test2\")\n# Place a legend above this subplot, expanding itself to\n# fully use the given bounding box.\nax_dict['top'].legend(bbox_to_anchor=(0., 1.02, 1., .102), loc='lower left',\n                      ncols=2, mode=\"expand\", borderaxespad=0.)\n\nax_dict['bottom'].plot([1, 2, 3], label=\"test1\")\nax_dict['bottom'].plot([3, 2, 1], label=\"test2\")\n# Place a legend to the right of this smaller subplot.\nax_dict['bottom'].legend(bbox_to_anchor=(1.05, 1),\n                         loc='upper left', borderaxespad=0.)\n\n# %%\n# Figure legends\n# --------------\n#\n# Sometimes it makes more sense to place a legend relative to the (sub)figure\n# rather than individual Axes.  By using *constrained layout* and\n# specifying \"outside\" at the beginning of the *loc* keyword argument,\n# the legend is drawn outside the Axes on the (sub)figure.\n\nfig, axs = plt.subplot_mosaic([['left', 'right']], layout='constrained')\n\naxs['left'].plot([1, 2, 3], label=\"test1\")\naxs['left'].plot([3, 2, 1], label=\"test2\")\n\naxs['right'].plot([1, 2, 3], 'C2', label=\"test3\")\naxs['right'].plot([3, 2, 1], 'C3', label=\"test4\")\n# Place a legend to the right of this smaller subplot.\nfig.legend(loc='outside upper right')\n\n# %%\n# This accepts a slightly different grammar than the normal *loc* keyword,\n# where \"outside right upper\" is different from \"outside upper right\".\n#\nucl = ['upper', 'center', 'lower']\nlcr = ['left', 'center', 'right']\nfig, ax = plt.subplots(figsize=(6, 4), layout='constrained', facecolor='0.7')\n\nax.plot([1, 2], [1, 2], label='TEST')\n# Place a legend to the right of this smaller subplot.",
                "filename": "galleries/users_explain/axes/legend_guide.py",
                "start_index": 2962,
                "end_index": 5837,
                "start_line": 92,
                "end_line": 170,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def __init__(\n        self, parent, handles, labels,\n        *,\n        loc=None,\n        numpoints=None,      # number of points in the legend line\n        markerscale=None,    # relative size of legend markers vs. original\n        markerfirst=True,    # left/right ordering of legend marker and label\n        reverse=False,       # reverse ordering of legend marker and label\n        scatterpoints=None,  # number of scatter points\n        scatteryoffsets=None,\n        prop=None,           # properties for the legend texts\n        fontsize=None,       # keyword to set font size directly\n        labelcolor=None,     # keyword to set the text color\n\n        # spacing & pad defined as a fraction of the font-size\n        borderpad=None,      # whitespace inside the legend border\n        labelspacing=None,   # vertical space between the legend entries\n        handlelength=None,   # length of the legend handles\n        handleheight=None,   # height of the legend handles\n        handletextpad=None,  # pad between the legend handle and text\n        borderaxespad=None,  # pad between the axes and legend border\n        columnspacing=None,  # spacing between columns\n\n        ncols=1,     # number of columns\n        mode=None,  # horizontal distribution of columns: None or \"expand\"\n\n        fancybox=None,  # True: fancy box, False: rounded box, None: rcParam\n        shadow=None,\n        title=None,           # legend title\n        title_fontsize=None,  # legend title font size\n        framealpha=None,      # set frame alpha\n        edgecolor=None,       # frame patch edgecolor\n        facecolor=None,       # frame patch facecolor\n\n        bbox_to_anchor=None,  # bbox to which the legend will be anchored\n        bbox_transform=None,  # transform for the bbox\n        frameon=None,         # draw frame\n        handler_map=None,\n        title_fontproperties=None,  # properties for the legend title\n        alignment=\"center\",       # control the alignment within the legend box\n        ncol=1,  # synonym for ncols (backward compatibility)\n        draggable=False  # whether the legend can be dragged with the mouse\n    ):",
                "filename": "lib/matplotlib/legend.py",
                "start_index": 14284,
                "end_index": 16421,
                "start_line": 55,
                "end_line": 616,
                "max_line": 1377,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n\n    def get_draggable(self):\n        \"\"\"Return ``True`` if the legend is draggable, ``False`` otherwise.\"\"\"\n        return self._draggable is not None",
                "filename": "lib/matplotlib/legend.py",
                "start_index": 48914,
                "end_index": 50312,
                "start_line": 1203,
                "end_line": 1239,
                "max_line": 1377,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "ax.legend(handler_map={line1: HandlerLine2D(numpoints=4)})\n\n# %%\n# As you can see, \"Line 1\" now has 4 marker points, where \"Line 2\" has 2 (the\n# default). Try the above code, only change the map's key from ``line1`` to\n# ``type(line1)``. Notice how now both `.Line2D` instances get 4 markers.\n#\n# Along with handlers for complex plot types such as errorbars, stem plots\n# and histograms, the default ``handler_map`` has a special ``tuple`` handler\n# (`.legend_handler.HandlerTuple`) which simply plots the handles on top of one\n# another for each item in the given tuple. The following example demonstrates\n# combining two legend keys on top of one another:\n\nfrom numpy.random import randn\n\nz = randn(10)\n\nfig, ax = plt.subplots()\nred_dot, = ax.plot(z, \"ro\", markersize=15)\n# Put a white cross over some of the data.\nwhite_cross, = ax.plot(z[:5], \"w+\", markeredgewidth=3, markersize=15)\n\nax.legend([red_dot, (red_dot, white_cross)], [\"Attr A\", \"Attr A+B\"])\n\n# %%\n# The `.legend_handler.HandlerTuple` class can also be used to\n# assign several legend keys to the same entry:\n\nfrom matplotlib.legend_handler import HandlerLine2D, HandlerTuple\n\nfig, ax = plt.subplots()\np1, = ax.plot([1, 2.5, 3], 'r-d')\np2, = ax.plot([3, 2, 1], 'k-o')\n\nl = ax.legend([(p1, p2)], ['Two keys'], numpoints=1,\n              handler_map={tuple: HandlerTuple(ndivide=None)})\n\n# %%\n# Implementing a custom legend handler\n# ------------------------------------\n#\n# A custom handler can be implemented to turn any handle into a legend key\n# (handles don't necessarily need to be matplotlib artists).  The handler must\n# implement a ``legend_artist`` method which returns a single artist for the\n# legend to use. The required signature for ``legend_artist`` is documented at\n# `~.legend_handler.HandlerBase.legend_artist`.\n\nimport matplotlib.patches as mpatches\n\n\nclass AnyObject:\n    pass\n\n\nclass AnyObjectHandler:\n    def legend_artist(self, legend, orig_handle, fontsize, handlebox):\n        x0, y0 = handlebox.xdescent, handlebox.ydescent\n        width, height = handlebox.width, handlebox.height\n        patch = mpatches.Rectangle([x0, y0], width, height, facecolor='red',\n                                   edgecolor='black', hatch='xx', lw=3,\n                                   transform=handlebox.get_transform())\n        handlebox.add_artist(patch)\n        return patch\n\nfig, ax = plt.subplots()\n\nax.legend([AnyObject()], ['My first handler'],\n          handler_map={AnyObject: AnyObjectHandler()})\n\n# %%\n# Alternatively, had we wanted to globally accept ``AnyObject`` instances\n# without needing to manually set the *handler_map* keyword all the time, we\n# could have registered the new handler with::\n#\n#     from matplotlib.legend import Legend\n#     Legend.update_default_handler_map({AnyObject: AnyObjectHandler()})\n#\n# Whilst the power here is clear, remember that there are already many handlers\n# implemented and what you want to achieve may already be easily possible with",
                "filename": "galleries/users_explain/axes/legend_guide.py",
                "start_index": 8791,
                "end_index": 11752,
                "start_line": 252,
                "end_line": 330,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Place a legend on the figure/axes.\n    \"\"\"\n\n    # 'best' is only implemented for axes legends\n    codes = {'best': 0, **AnchoredOffsetbox.codes}\n    zorder = 5\n\n    def __str__(self):\n        return \"Legend\"",
                "filename": "lib/matplotlib/legend.py",
                "start_index": 14032,
                "end_index": 14247,
                "start_line": 1,
                "end_line": 352,
                "max_line": 1377,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.6",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "lib/matplotlib/legend.py": [
                {
                    "chunk": {
                        "code": "def __init__(\n        self, parent, handles, labels,\n        *,\n        loc=None,\n        numpoints=None,      # number of points in the legend line\n        markerscale=None,    # relative size of legend markers vs. original\n        markerfirst=True,    # left/right ordering of legend marker and label\n        reverse=False,       # reverse ordering of legend marker and label\n        scatterpoints=None,  # number of scatter points\n        scatteryoffsets=None,\n        prop=None,           # properties for the legend texts\n        fontsize=None,       # keyword to set font size directly\n        labelcolor=None,     # keyword to set the text color\n\n        # spacing & pad defined as a fraction of the font-size\n        borderpad=None,      # whitespace inside the legend border\n        labelspacing=None,   # vertical space between the legend entries\n        handlelength=None,   # length of the legend handles\n        handleheight=None,   # height of the legend handles\n        handletextpad=None,  # pad between the legend handle and text\n        borderaxespad=None,  # pad between the axes and legend border\n        columnspacing=None,  # spacing between columns\n\n        ncols=1,     # number of columns\n        mode=None,  # horizontal distribution of columns: None or \"expand\"\n\n        fancybox=None,  # True: fancy box, False: rounded box, None: rcParam\n        shadow=None,\n        title=None,           # legend title\n        title_fontsize=None,  # legend title font size\n        framealpha=None,      # set frame alpha\n        edgecolor=None,       # frame patch edgecolor\n        facecolor=None,       # frame patch facecolor\n\n        bbox_to_anchor=None,  # bbox to which the legend will be anchored\n        bbox_transform=None,  # transform for the bbox\n        frameon=None,         # draw frame\n        handler_map=None,\n        title_fontproperties=None,  # properties for the legend title\n        alignment=\"center\",       # control the alignment within the legend box\n        ncol=1,  # synonym for ncols (backward compatibility)\n        draggable=False  # whether the legend can be dragged with the mouse\n    ):",
                        "filename": "lib/matplotlib/legend.py",
                        "start_index": 14284,
                        "end_index": 16421,
                        "start_line": 55,
                        "end_line": 616,
                        "max_line": 1377,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the __init__ method of the Legend class where the 'draggable' parameter is set. To address the issue, this method would likely need to be modified to accept a 'draggable' keyword argument at creation."
                },
                {
                    "chunk": {
                        "code": "def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n\n    def get_draggable(self):\n        \"\"\"Return ``True`` if the legend is draggable, ``False`` otherwise.\"\"\"\n        return self._draggable is not None",
                        "filename": "lib/matplotlib/legend.py",
                        "start_index": 48914,
                        "end_index": 50312,
                        "start_line": 1203,
                        "end_line": 1239,
                        "max_line": 1377,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the set_draggable method which is currently used to make a legend draggable after creation. Understanding this method is necessary to integrate the draggable functionality directly into the __init__ method."
                },
                {
                    "chunk": {
                        "code": "class DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)",
                        "filename": "lib/matplotlib/legend.py",
                        "start_index": 1881,
                        "end_index": 3597,
                        "start_line": 54,
                        "end_line": 95,
                        "max_line": 1377,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the DraggableLegend class which is used to make legends draggable. Understanding how this class is used will be important for integrating the draggable feature into the legend creation process."
                }
            ],
            "lib/matplotlib/offsetbox.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\n    Helper base class for a draggable artist (legend, offsetbox).\n\n    Derived classes must override the following methods::\n\n        def save_offset(self):\n            '''\n            Called when the object is picked for dragging; should save the\n            reference position of the artist.\n            '''\n\n        def update_offset(self, dx, dy):\n            '''\n            Called during the dragging; (*dx*, *dy*) is the pixel offset from\n            the point where the mouse drag started.\n            '''\n\n    Optionally, you may override the following method::\n\n        def finalize_offset(self):\n            '''Called when the mouse is released.'''\n\n    In the current implementation of `.DraggableLegend` and\n    `DraggableAnnotation`, `update_offset` places the artists in display\n    coordinates, and `finalize_offset` recalculates their position in axes\n    coordinate and set a relevant attribute.\n    \"\"\"\n\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self._use_blit = use_blit and self.canvas.supports_blit\n        callbacks = ref_artist.figure._canvas_callbacks\n        self._disconnectors = [\n            functools.partial(\n                callbacks.disconnect, callbacks._connect_picklable(name, func))\n            for name, func in [\n                (\"pick_event\", self.on_pick),\n                (\"button_release_event\", self.on_release),\n                (\"motion_notify_event\", self.on_motion),\n            ]\n        ]\n\n    # A property, not an attribute, to maintain picklability.\n    canvas = property(lambda self: self.ref_artist.figure.canvas)\n\n    cids = property(lambda self: [\n        disconnect.args[0] for disconnect in self._disconnectors[:2]])\n\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self.save_offset()",
                        "filename": "lib/matplotlib/offsetbox.py",
                        "start_index": 48967,
                        "end_index": 51913,
                        "start_line": 1,
                        "end_line": 1536,
                        "max_line": 1604,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from offsetbox.py contains the base class for draggable artists, which is relevant for understanding how draggable functionality is implemented in Matplotlib and could influence how the feature is integrated at legend creation."
                }
            ]
        },
        "solution_task": "To implement the feature request of adding a `draggable=True` keyword to the `__init__` function for `Legend`, you can follow these steps:\n\n- Modify the `__init__` method of the `Legend` class in `lib/matplotlib/legend.py` to accept a new keyword argument `draggable`.\n- Set the default value of `draggable` to `False` to maintain backward compatibility.\n- Inside the `__init__` method, after all the setup is done, check if `draggable` is `True`.\n- If `draggable` is `True`, call the `set_draggable` method with the appropriate parameters.\n\nHere is the modified `__init__` method of the `Legend` class:\n\n```python\ndef __init__(\n        self, parent, handles, labels,\n        *,\n        loc=None,\n        # ... [other parameters] ...\n        draggable=False,  # Add this line for the new keyword argument\n        **kwargs\n    ):\n    # ... [existing __init__ code] ...\n    \n    # Set the legend to be draggable if the keyword is provided and True\n    if draggable:\n        self.set_draggable(True)\n```\n\nAnd here is the usage example:\n\n```python\n# When creating a legend, you can now use the draggable keyword\nlegend = Legend(parent, handles, labels, draggable=True)\n```\n\nThis implementation allows users to make the legend draggable at creation time by simply passing `draggable=True` as an argument to the `Legend` constructor.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant suggestions that can directly lead to the successful implementation or improvement of the requested feature.",
            "supporting_evidence": "The RESPONSE provides a clear and detailed step-by-step guide on how to implement the 'draggable=True' keyword in the Legend class's __init__ method. It includes a code snippet showing exactly where to add the new keyword argument and how to set the legend to be draggable if the argument is True. The RESPONSE also provides a usage example demonstrating how to use the new keyword when creating a legend. Additionally, the RESPONSE lists specific code snippets from the Matplotlib repository that should be checked to understand the current implementation of the Legend class and draggable functionality, which is crucial for integrating the new feature. This guidance is actionable and directly addresses the feature request described in the PROMPT.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711697753.3024719,
        "result": "To implement the feature request of adding a `draggable=True` keyword to the `__init__` function for `Legend`, you can follow these steps:\n\n- Modify the `__init__` method of the `Legend` class in `lib/matplotlib/legend.py` to accept a new keyword argument `draggable`.\n- Set the default value of `draggable` to `False` to maintain backward compatibility.\n- Inside the `__init__` method, after all the setup is done, check if `draggable` is `True`.\n- If `draggable` is `True`, call the `set_draggable` method with the appropriate parameters.\n\nHere is the modified `__init__` method of the `Legend` class:\n\n```python\ndef __init__(\n        self, parent, handles, labels,\n        *,\n        loc=None,\n        # ... [other parameters] ...\n        draggable=False,  # Add this line for the new keyword argument\n        **kwargs\n    ):\n    # ... [existing __init__ code] ...\n    \n    # Set the legend to be draggable if the keyword is provided and True\n    if draggable:\n        self.set_draggable(True)\n```\n\nAnd here is the usage example:\n\n```python\n# When creating a legend, you can now use the draggable keyword\nlegend = Legend(parent, handles, labels, draggable=True)\n```\n\nThis implementation allows users to make the legend draggable at creation time by simply passing `draggable=True` as an argument to the `Legend` constructor.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 55 - 616](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/legend.py#L55-L616)\n\n This snippet contains the __init__ method of the Legend class where the 'draggable' parameter is set. To address the issue, this method would likely need to be modified to accept a 'draggable' keyword argument at creation. \n\n\n   - [Lines 1203 - 1239](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/legend.py#L1203-L1239)\n\n This snippet contains the set_draggable method which is currently used to make a legend draggable after creation. Understanding this method is necessary to integrate the draggable functionality directly into the __init__ method. \n\n\n   - [Lines 54 - 95](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/legend.py#L54-L95)\n\n This snippet defines the DraggableLegend class which is used to make legends draggable. Understanding how this class is used will be important for integrating the draggable feature into the legend creation process.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.6/tree//lib/matplotlib)- [Lines 1 - 1536](https://github.com/testbed/matplotlib__matplotlib__3.6/blob//lib/matplotlib/offsetbox.py#L1-L1536)\n\n This snippet from offsetbox.py contains the base class for draggable artists, which is relevant for understanding how draggable functionality is implemented in Matplotlib and could influence how the feature is integrated at legend creation."
    }
}