{
    "id": "astropy__astropy-13668",
    "repo_name": "testbed/astropy__astropy__5.0",
    "task_id": 1179910627203292951,
    "title": "wcslint crashes on valid WCS",
    "body": "`wcslint` calls an underlying function here:\r\n\r\nhttps://github.com/astropy/astropy/blob/8c0581fc68ca1f970d7f4e6c9ca9f2b9567d7b4c/astropy/wcs/wcs.py#L3430\r\n\r\nLooks like all it does is tries to create a `WCS` object with the header and report warnings, so the bug is either inside `WCS` or it is a matter of updating on how validator calls `WCS` in more complicated cases:\r\n\r\nhttps://github.com/astropy/astropy/blob/8c0581fc68ca1f970d7f4e6c9ca9f2b9567d7b4c/astropy/wcs/wcs.py#L3530-L3534\r\n\r\n# Examples\r\n\r\nFile: https://mast.stsci.edu/api/v0.1/Download/file?uri=mast:HST/product/jbqf03gjq_flc.fits\r\n\r\n```\r\n$ fitsinfo jbqf03gjq_flc.fits\r\nFilename: jbqf03gjq_flc.fits\r\nNo.    Name      Ver    Type      Cards   Dimensions   Format\r\n  0  PRIMARY       1 PrimaryHDU     285   ()\r\n  1  SCI           1 ImageHDU       241   (4096, 2048)   float32\r\n  2  ERR           1 ImageHDU        53   (4096, 2048)   float32\r\n  3  DQ            1 ImageHDU        45   (4096, 2048)   int16\r\n  4  SCI           2 ImageHDU       256   (4096, 2048)   float32\r\n  5  ERR           2 ImageHDU        53   (4096, 2048)   float32\r\n  6  DQ            2 ImageHDU        45   (4096, 2048)   int16\r\n  7  D2IMARR       1 ImageHDU        16   (64, 32)   float32\r\n  8  D2IMARR       2 ImageHDU        16   (64, 32)   float32\r\n  9  D2IMARR       3 ImageHDU        16   (64, 32)   float32\r\n 10  D2IMARR       4 ImageHDU        16   (64, 32)   float32\r\n 11  WCSDVARR      1 ImageHDU        16   (64, 32)   float32\r\n 12  WCSDVARR      2 ImageHDU        16   (64, 32)   float32\r\n 13  WCSDVARR      3 ImageHDU        16   (64, 32)   float32\r\n 14  WCSDVARR      4 ImageHDU        16   (64, 32)   float32\r\n 15  HDRLET        1 NonstandardExtHDU     18   (8640,)\r\n 16  HDRLET        2 NonstandardExtHDU     26   (112320,)\r\n 17  WCSCORR       1 BinTableHDU     59   14R x 24C   [40A, I, A, 24A, 24A, 24A, 24A, D, ...]\r\n 18  HDRLET       18 NonstandardExtHDU     26   (112320,)\r\n 19  HDRLET        4 NonstandardExtHDU     26   (112320,)\r\n\r\n$ wcslint jbqf03gjq_flc.fits\r\npython: malloc.c:2385: sysmalloc: Assertion `(old_top == initial_top (av) && old_size == 0) ||\r\n((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) &&\r\n((unsigned long) old_end & (pagesize - 1)) == 0)' failed.\r\nAborted\r\n```\r\n\r\nFile: https://github.com/astropy/astropy/blob/main/astropy/wcs/tests/data/tab-time-last-axis.fits\r\n\r\n```\r\n$ fitsinfo  tab-time-last-axis.fits\r\nFilename: tab-time-last-axis.fits\r\nNo.    Name      Ver    Type      Cards   Dimensions   Format\r\n  0  PRIMARY       1 PrimaryHDU      39   (1, 1, 1)   float64\r\n  1  WCS-TABLE     1 BinTableHDU     13   1R x 1C   [128D]\r\n\r\n$ wcslint  tab-time-last-axis.fits\r\n  File \".../astropy/wcs/wcslint.py\", line 18, in main\r\n    print(wcs.validate(args.filename[0]))\r\n  File \".../astropy/wcs/wcs.py\", line 3531, in validate\r\n    WCS(hdu.header,\r\n  File \".../astropy/wcs/wcs.py\", line 466, in __init__\r\n    tmp_wcsprm = _wcs.Wcsprm(header=tmp_header_bytes, key=key,\r\nValueError: HDUList is required to retrieve -TAB coordinates and/or indices.\r\n```\r\n\r\nFile:  https://mast.stsci.edu/api/v0.1/Download/file?uri=mast:HST/product/iabj01a2q_flc.fits \r\n(Reported by @mcara)\r\n\r\n```\r\n$ wcslint iabj01a2q_flc.fits\r\nINFO:\r\n                Inconsistent SIP distortion information is present in the FITS header and the WCS object:\r\n                SIP coefficients were detected, but CTYPE is missing a \"-SIP\" suffix.\r\n                astropy.wcs is using the SIP distortion coefficients,\r\n                therefore the coordinates calculated here might be incorrect.\r\n\r\n                If you do not want to apply the SIP distortion coefficients,\r\n                please remove the SIP coefficients from the FITS header or the\r\n                WCS object.  As an example, if the image is already distortion-corrected\r\n                (e.g., drizzled) then distortion components should not apply and the SIP\r\n                coefficients should be removed.\r\n\r\n                While the SIP distortion coefficients are being applied here, if that was indeed the intent,\r\n                for consistency please append \"-SIP\" to the CTYPE in the FITS header or the WCS object.\r\n\r\n                 [astropy.wcs.wcs]\r\npython3(27402,0x118052dc0) malloc: Incorrect checksum for freed object 0x7ff48b84a800:\r\nprobably modified after being freed.\r\nCorrupt value: 0x0\r\npython3(27402,0x118052dc0) malloc: *** set a breakpoint in malloc_error_break to debug\r\nAbort trap: 6\r\n```\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__5.0.git",
    "requested_commit": "",
    "mayil_response": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83d\ude41.                   But we've outlined some ideas that might help you get started:\n\nBased on the provided information, the following solutions can be applied to address the issues:\n\n- **malloc.c:2385: sysmalloc: Assertion ... failed.**\n  - This error suggests a memory allocation issue within the WCSLIB C library. Ensure that all memory allocations are checked for success before use and that all allocated memory is properly freed.\n  - Review the `wcs.c` and `wcsfix.c` files for proper use of `malloc` and `free`. Ensure that `free` is called only on memory that was successfully allocated and that it is not called multiple times on the same pointer without an intervening allocation.\n\n- **ValueError: HDUList is required to retrieve -TAB coordinates and/or indices.**\n  - This error indicates that an `HDUList` object is required but not provided when attempting to retrieve -TAB coordinates or indices.\n  - Ensure that the `HDUList` object is passed to functions that require it, such as when using the `_load_tab_bintable` callback function in `wcs.py`.\n  - Check the `wcstab` function in `wcshdr.c` to ensure that it correctly handles the `HDUList` and associated -TAB coordinate information.\n\n- **Inconsistent SIP distortion information is present in the FITS header and the WCS object: SIP coefficients were detected, but CTYPE is missing a \"-SIP\" suffix.**\n  - This error is related to the handling of SIP (Simple Imaging Polynomial) distortion coefficients in the FITS header.\n  - Ensure that the `CTYPE` keyword in the FITS header includes the `-SIP` suffix if SIP coefficients are present. This can be done by checking and updating the `CTYPE` keyword in the `header` object before creating the `WCS` object.\n  - Review the `WCS` class constructor and the `validate` method to ensure that they correctly handle SIP coefficients and the `CTYPE` keyword.\n\n- General recommendations:\n  - Check the `WCS` class and associated functions in `wcs.py` for proper error handling and memory management.\n  - Review the `wcsfix` function in `wcsfix.c` to ensure that it correctly fixes any inconsistencies in the WCS parameters.\n  - Ensure that the `wcsprm` struct is correctly initialized and that any undefined values are properly handled, as shown in `pyutil.c`.\n  - Verify that the `wcstab` function in `wcshdr.c` correctly processes the PSi_ma and PVi_ma keyvalues for -TAB axes.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.0/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/wcs)- [Lines 577 - 3796](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/wcs/wcs.py#L577-L3796)\n\n This snippet contains logic that raises a ValueError if the WCS transformation has more axes than the image it is associated with, which could be related to the issue where wcslint crashes on valid WCS. \n\n\n   - [Lines 93 - 173](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/wcs/wcs.py#L93-L173)\n\n This snippet checks the version of wcslib and performs a sanity check, which could be relevant if the issue is related to a specific version of wcslib or if there is a compatibility problem.\n-  \u2192 [cextern](https://github.com/testbed/astropy__astropy__5.0/tree//cextern) \u2192 [wcslib](https://github.com/testbed/astropy__astropy__5.0/tree//cextern/wcslib) \u2192 [C](https://github.com/testbed/astropy__astropy__5.0/tree//cextern/wcslib/C)- [Lines 850 - 1143](https://github.com/testbed/astropy__astropy__5.0/blob//cextern/wcslib/C/wcsfix.c#L850-L1143)\n\n This snippet contains code for fixing spectral coordinate systems, which might be relevant if the issue is related to spectral coordinates in the WCS.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.0/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/wcs/src)- [Lines 147 - 241](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/wcs/src/pyutil.c#L147-L241)\n\n This snippet deals with the conversion of undefined values to NaN in wcsprm structures, which could be relevant if the crash is due to handling of undefined or NaN values in the WCS data.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0020169999999999997,
        "snippet_processor": 0.10021000000000001,
        "issue_star_creation": 0.02848,
        "issue_star_solver": 0.06717000000000001,
        "bouncer": 0.03083
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711736378.831274,
        "relevant_snippets": [
            {
                "code": "if wcsprm.naxis != 2 and (\n                det2im[0] or det2im[1] or cpdis[0] or cpdis[1] or sip\n            ):\n                raise ValueError(\n                    f\"\"\"\nFITS WCS distortion paper lookup tables and SIP distortions only work\nin 2 dimensions.  However, WCSLIB has detected {wcsprm.naxis} dimensions in the\ncore WCS keywords.  To use core WCS in conjunction with FITS WCS\ndistortion paper lookup tables or SIP distortion, you must select or\nreduce these to 2 dimensions using the naxis kwarg.\n\"\"\"\n                )\n\n            header_naxis = header.get(\"NAXIS\", None)\n            if header_naxis is not None and header_naxis < wcsprm.naxis:\n                warnings.warn(\n                    f\"The WCS transformation has more axes ({wcsprm.naxis:d}) than the \"\n                    f\"image it is associated with ({header_naxis:d})\",\n                    FITSFixedWarning,\n                )",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 19719,
                "end_index": 20621,
                "start_line": 577,
                "end_line": 3796,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# Under the hood, there are 3 separate classes that perform different\n# parts of the transformation:\n#\n#    - `~astropy.wcs.Wcsprm`: Is a direct wrapper of the core WCS\n#      functionality in `wcslib`_.  (This includes TPV and TPD\n#      polynomial distortion, but not SIP distortion).\n#\n#    - `~astropy.wcs.Sip`: Handles polynomial distortion as defined in the\n#      `SIP`_ convention.\n#\n#    - `~astropy.wcs.DistortionLookupTable`: Handles `distortion paper`_\n#      lookup tables.\n#\n# Additionally, the class `WCS` aggregates all of these transformations\n# together in a pipeline:\n#\n#    - Detector to image plane correction (by a pair of\n#      `~astropy.wcs.DistortionLookupTable` objects).\n#\n#    - `SIP`_ distortion correction (by an underlying `~astropy.wcs.Sip`\n#      object)\n#\n#    - `distortion paper`_ table-lookup correction (by a pair of\n#      `~astropy.wcs.DistortionLookupTable` objects).\n#\n#    - `wcslib`_ WCS transformation (by a `~astropy.wcs.Wcsprm` object)\n\n# STDLIB\nimport builtins\nimport copy\nimport io\nimport itertools\nimport os\nimport re\nimport textwrap\nimport uuid\nimport warnings\n\n# THIRD-PARTY\nimport numpy as np\nfrom packaging.version import Version\n\n# LOCAL\nfrom astropy import log\nfrom astropy import units as u\nfrom astropy.io import fits\nfrom astropy.utils.decorators import deprecated_renamed_argument\nfrom astropy.utils.exceptions import (\n    AstropyDeprecationWarning,\n    AstropyUserWarning,\n    AstropyWarning,\n)\n\nfrom . import _wcs, docstrings\n\n# Mix-in class that provides the APE 14 API\nfrom .wcsapi.fitswcs import FITSWCSAPIMixin, SlicedFITSWCS\n\n__all__ = [\n    \"FITSFixedWarning\",\n    \"WCS\",\n    \"find_all_wcs\",\n    \"DistortionLookupTable\",\n    \"Sip\",\n    \"Tabprm\",\n    \"Wcsprm\",\n    \"Auxprm\",\n    \"Celprm\",\n    \"Prjprm\",\n    \"Wtbarr\",\n    \"WCSBase\",\n    \"validate\",\n    \"WcsError\",\n    \"SingularMatrixError\",\n    \"InconsistentAxisTypesError\",\n    \"InvalidTransformError\",\n    \"InvalidCoordinateError\",\n    \"InvalidPrjParametersError\",\n    \"NoSolutionError\",\n    \"InvalidSubimageSpecificationError\",\n    \"NoConvergence\",\n    \"NonseparableSubimageCoordinateSystemError\",\n    \"NoWcsKeywordsFoundError\",\n    \"InvalidTabularParametersError\",\n]\n\n\n__doctest_skip__ = [\"WCS.all_world2pix\"]",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 0,
                "end_index": 2297,
                "start_line": 1,
                "end_line": 90,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "{\n  if (wcs == 0x0) return WCSERR_NULL_POINTER;\n\n  if (wcs->flag == -1) {\n    wcs->lin.flag = -1;\n\n  } else {\n    // Optionally allocated by wcsinit() for given parameters.\n    if (wcs->m_flag == WCSSET) {\n      // Start by cleaning the slate.\n      if (wcs->crpix == wcs->m_crpix) wcs->crpix = 0x0;\n      if (wcs->pc    == wcs->m_pc)    wcs->pc    = 0x0;\n      if (wcs->cdelt == wcs->m_cdelt) wcs->cdelt = 0x0;\n      if (wcs->crval == wcs->m_crval) wcs->crval = 0x0;\n      if (wcs->cunit == wcs->m_cunit) wcs->cunit = 0x0;\n      if (wcs->ctype == wcs->m_ctype) wcs->ctype = 0x0;\n      if (wcs->pv    == wcs->m_pv)    wcs->pv    = 0x0;\n      if (wcs->ps    == wcs->m_ps)    wcs->ps    = 0x0;\n      if (wcs->cd    == wcs->m_cd)    wcs->cd    = 0x0;\n      if (wcs->crota == wcs->m_crota) wcs->crota = 0x0;\n      if (wcs->colax == wcs->m_colax) wcs->colax = 0x0;\n      if (wcs->cname == wcs->m_cname) wcs->cname = 0x0;\n      if (wcs->crder == wcs->m_crder) wcs->crder = 0x0;\n      if (wcs->csyer == wcs->m_csyer) wcs->csyer = 0x0;\n      if (wcs->czphs == wcs->m_czphs) wcs->czphs = 0x0;\n      if (wcs->cperi == wcs->m_cperi) wcs->cperi = 0x0;\n\n      if (wcs->aux   == wcs->m_aux)   wcs->aux   = 0x0;\n      if (wcs->tab   == wcs->m_tab)   wcs->tab   = 0x0;\n      if (wcs->wtb   == wcs->m_wtb)   wcs->wtb   = 0x0;\n\n      // Now release the memory.\n      if (wcs->m_crpix)  free(wcs->m_crpix);\n      if (wcs->m_pc)     free(wcs->m_pc);\n      if (wcs->m_cdelt)  free(wcs->m_cdelt);\n      if (wcs->m_crval)  free(wcs->m_crval);\n      if (wcs->m_cunit)  free(wcs->m_cunit);\n      if (wcs->m_ctype)  free(wcs->m_ctype);\n      if (wcs->m_pv)     free(wcs->m_pv);\n      if (wcs->m_ps)     free(wcs->m_ps);\n      if (wcs->m_cd)     free(wcs->m_cd);\n      if (wcs->m_crota)  free(wcs->m_crota);\n      if (wcs->m_colax)  free(wcs->m_colax);\n      if (wcs->m_cname)  free(wcs->m_cname);\n      if (wcs->m_crder)  free(wcs->m_crder);\n      if (wcs->m_csyer)  free(wcs->m_csyer);\n      if (wcs->m_czphs)  free(wcs->m_czphs);\n      if (wcs->m_cperi)  free(wcs->m_cperi);\n\n      // May have been allocated by wcspih() or wcssub().\n      if (wcs->m_aux) free(wcs->m_aux);\n\n      // Allocated unconditionally by wcstab().\n      if (wcs->m_tab) {\n        for (int itab = 0; itab < wcs->ntab; itab++) {\n          tabfree(wcs->m_tab + itab);\n        }\n\n        free(wcs->m_tab);\n      }\n      if (wcs->m_wtb) free(wcs->m_wtb);\n    }\n\n    // Allocated unconditionally by wcsset().\n    if (wcs->types) free(wcs->types);\n\n    if (wcs->lin.crpix == wcs->m_crpix) wcs->lin.crpix = 0x0;\n    if (wcs->lin.pc    == wcs->m_pc)    wcs->lin.pc    = 0x0;\n    if (wcs->lin.cdelt == wcs->m_cdelt) wcs->lin.cdelt = 0x0;\n  }\n\n  wcs->m_flag   = 0;\n  wcs->m_naxis  = 0x0;\n  wcs->m_crpix  = 0x0;\n  wcs->m_pc     = 0x0;\n  wcs->m_cdelt  = 0x0;\n  wcs->m_crval  = 0x0;\n  wcs->m_cunit  = 0x0;\n  wcs->m_ctype  = 0x0;\n  wcs->m_pv     = 0x0;\n  wcs->m_ps     = 0x0;\n  wcs->m_cd     = 0x0;\n  wcs->m_crota  = 0x0;\n  wcs->m_colax  = 0x0;",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 46074,
                "end_index": 49054,
                "start_line": 54,
                "end_line": 1750,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "/*============================================================================\n  WCSLIB 8.1 - an implementation of the FITS WCS standard.\n  Copyright (C) 1995-2023, Mark Calabretta\n\n  This file is part of WCSLIB.\n\n  WCSLIB is free software: you can redistribute it and/or modify it under the\n  terms of the GNU Lesser General Public License as published by the Free\n  Software Foundation, either version 3 of the License, or (at your option)\n  any later version.\n\n  WCSLIB is distributed in the hope that it will be useful, but WITHOUT ANY\n  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n  more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with WCSLIB.  If not, see http://www.gnu.org/licenses.\n\n  Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.\n  http://www.atnf.csiro.au/people/Mark.Calabretta\n  $Id: wcsfix.c,v 8.1 2023/07/05 17:12:07 mcalabre Exp $\n*===========================================================================*/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lin.h\"\n#include \"sph.h\"\n#include \"tab.h\"\n#include \"wcs.h\"\n#include \"wcserr.h\"\n#include \"wcsfix.h\"\n#include \"wcsmath.h\"\n#include \"wcstrig.h\"\n#include \"wcsunits.h\"\n#include \"wcsutil.h\"\n#include \"wtbarr.h\"\n\nextern const int WCSSET;\n\n// Maximum number of coordinate axes that can be handled.\n#define NMAX 16\n\n// Map status return value to message.\nconst char *wcsfix_errmsg[] = {\n  \"Success\",\n  \"Null wcsprm pointer passed\",\n  \"Memory allocation failed\",\n  \"Linear transformation matrix is singular\",\n  \"Inconsistent or unrecognized coordinate axis types\",\n  \"Invalid parameter value\",\n  \"Invalid coordinate transformation parameters\",\n  \"Ill-conditioned coordinate transformation parameters\",\n  \"All of the corner pixel coordinates are invalid\",\n  \"Could not determine reference pixel coordinate\",\n  \"Could not determine reference pixel value\"};\n\n// Map error returns for lower-level routines.\nconst int fix_linerr[] = {\n  FIXERR_SUCCESS,\t\t//  0: LINERR_SUCCESS\n  FIXERR_NULL_POINTER,\t\t//  1: LINERR_NULL_POINTER\n  FIXERR_MEMORY,\t\t//  2: LINERR_MEMORY\n  FIXERR_SINGULAR_MTX,\t\t//  3: LINERR_SINGULAR_MTX\n  FIXERR_BAD_PARAM,\t\t//  4: LINERR_DISTORT_INIT\n  FIXERR_NO_REF_PIX_COORD,\t//  5: LINERR_DISTORT\n  FIXERR_NO_REF_PIX_VAL\t\t//  6: LINERR_DEDISTORT\n};",
                "filename": "cextern/wcslib/C/wcsfix.c",
                "start_index": 0,
                "end_index": 2443,
                "start_line": 1,
                "end_line": 85,
                "max_line": 1481,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "const int fix_wcserr[] = {\n  FIXERR_SUCCESS,\t\t//  0: WCSERR_SUCCESS\n  FIXERR_NULL_POINTER,\t\t//  1: WCSERR_NULL_POINTER\n  FIXERR_MEMORY,\t\t//  2: WCSERR_MEMORY\n  FIXERR_SINGULAR_MTX,\t\t//  3: WCSERR_SINGULAR_MTX\n  FIXERR_BAD_CTYPE,\t\t//  4: WCSERR_BAD_CTYPE\n  FIXERR_BAD_PARAM,\t\t//  5: WCSERR_BAD_PARAM\n  FIXERR_BAD_COORD_TRANS,\t//  6: WCSERR_BAD_COORD_TRANS\n  FIXERR_ILL_COORD_TRANS,\t//  7: WCSERR_ILL_COORD_TRANS\n  FIXERR_BAD_CORNER_PIX,\t//  8: WCSERR_BAD_PIX\n  FIXERR_NO_REF_PIX_VAL,\t//  9: WCSERR_BAD_WORLD\n  FIXERR_NO_REF_PIX_VAL \t// 10: WCSERR_BAD_WORLD_COORD\n\t\t\t\t//     ...others not used\n};\n\n// Convenience macro for invoking wcserr_set().\n#define WCSFIX_ERRMSG(status) WCSERR_SET(status), wcsfix_errmsg[status]\n\n//----------------------------------------------------------------------------\n\nint wcsfix(int ctrl, const int naxis[], struct wcsprm *wcs, int stat[])\n\n{\n  int status = 0;\n\n  if ((stat[CDFIX] = cdfix(wcs)) > 0) {\n    status = 1;\n  }\n\n  if ((stat[DATFIX] = datfix(wcs)) > 0) {\n    status = 1;\n  }\n\n  if ((stat[OBSFIX] = obsfix(0, wcs)) > 0) {\n    status = 1;\n  }\n\n  if ((stat[UNITFIX] = unitfix(ctrl, wcs)) > 0) {\n    status = 1;\n  }\n\n  if ((stat[SPCFIX] = spcfix(wcs)) > 0) {\n    status = 1;\n  }\n\n  if ((stat[CELFIX] = celfix(wcs)) > 0) {\n    status = 1;\n  }\n\n  if ((stat[CYLFIX] = cylfix(naxis, wcs)) > 0) {\n    status = 1;\n  }\n\n  return status;\n}\n\n//----------------------------------------------------------------------------",
                "filename": "cextern/wcslib/C/wcsfix.c",
                "start_index": 2445,
                "end_index": 3891,
                "start_line": 72,
                "end_line": 1143,
                "max_line": 1481,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "/*============================================================================\n  WCSLIB 8.1 - an implementation of the FITS WCS standard.\n  Copyright (C) 1995-2023, Mark Calabretta\n\n  This file is part of WCSLIB.\n\n  WCSLIB is free software: you can redistribute it and/or modify it under the\n  terms of the GNU Lesser General Public License as published by the Free\n  Software Foundation, either version 3 of the License, or (at your option)\n  any later version.\n\n  WCSLIB is distributed in the hope that it will be useful, but WITHOUT ANY\n  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n  more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with WCSLIB.  If not, see http://www.gnu.org/licenses.\n\n  Author: Mark Calabretta, Australia Telescope National Facility, CSIRO.\n  http://www.atnf.csiro.au/people/Mark.Calabretta\n  $Id: wcs.c,v 8.1 2023/07/05 17:12:07 mcalabre Exp $\n*===========================================================================*/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"wcserr.h\"\n#include \"wcsmath.h\"\n#include \"wcsprintf.h\"\n#include \"wcstrig.h\"\n#include \"wcsunits.h\"\n#include \"wcsutil.h\"\n#include \"wtbarr.h\"\n#include \"lin.h\"\n#include \"dis.h\"\n#include \"log.h\"\n#include \"spc.h\"\n#include \"prj.h\"\n#include \"sph.h\"\n#include \"cel.h\"\n#include \"tab.h\"\n#include \"wcs.h\"\n\nconst int WCSSET = 137;\n\n// Maximum number of PVi_ma and PSi_ma keywords.\nint NPVMAX = 64;\nint NPSMAX =  8;\n\n// Map status return value to message.\nconst char *wcs_errmsg[] = {\n  \"Success\",\n  \"Null wcsprm pointer passed\",\n  \"Memory allocation failed\",\n  \"Linear transformation matrix is singular\",\n  \"Inconsistent or unrecognized coordinate axis type\",\n  \"Invalid parameter value\",\n  \"Unrecognized coordinate transformation parameter\",\n  \"Ill-conditioned coordinate transformation parameter\",\n  \"One or more of the pixel coordinates were invalid\",\n  \"One or more of the world coordinates were invalid\",\n  \"Invalid world coordinate\",\n  \"No solution found in the specified interval\",\n  \"Invalid subimage specification\",\n  \"Non-separable subimage coordinate system\",\n  \"wcsprm struct is unset, use wcsset()\"};\n\n// Map error returns for lower-level routines.\nconst int wcs_linerr[] = {\n  WCSERR_SUCCESS,\t\t//  0: LINERR_SUCCESS\n  WCSERR_NULL_POINTER,\t\t//  1: LINERR_NULL_POINTER\n  WCSERR_MEMORY,\t\t//  2: LINERR_MEMORY\n  WCSERR_SINGULAR_MTX,\t\t//  3: LINERR_SINGULAR_MTX\n  WCSERR_BAD_PARAM,\t\t//  4: LINERR_DISTORT_INIT\n  WCSERR_BAD_PIX,\t\t//  5: LINERR_DISTORT\n  WCSERR_BAD_WORLD\t\t//  6: LINERR_DEDISTORT\n};\n\nconst int wcs_logerr[] = {\n  WCSERR_SUCCESS,\t\t//  0: LOGERR_SUCCESS\n  WCSERR_NULL_POINTER,\t\t//  1: LOGERR_NULL_POINTER\n  WCSERR_BAD_PARAM,\t\t//  2: LOGERR_BAD_LOG_REF_VAL\n  WCSERR_BAD_PIX,\t\t//  3: LOGERR_BAD_X\n  WCSERR_BAD_WORLD\t\t//  4: LOGERR_BAD_WORLD\n};",
                "filename": "cextern/wcslib/C/wcs.c",
                "start_index": 0,
                "end_index": 2940,
                "start_line": 1,
                "end_line": 2893,
                "max_line": 4760,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "int spcfix(struct wcsprm *wcs)\n\n{\n  static const char *function = \"spcfix\";\n\n  if (wcs == 0x0) return FIXERR_NULL_POINTER;\n  struct wcserr **err = &(wcs->err);\n\n  for (int i = 0; i < wcs->naxis; i++) {\n    // Translate an AIPS-convention spectral type if present.\n    char ctype[9], specsys[9];\n    int status = spcaips(wcs->ctype[i], wcs->velref, ctype, specsys);\n    if (status == FIXERR_SUCCESS) {\n      // An AIPS type was found but it may match what we already have.\n      status = FIXERR_NO_CHANGE;\n\n      // Was specsys translated?\n      if (wcs->specsys[0] == '\\0' && *specsys) {\n        strncpy(wcs->specsys, specsys, 9);\n        wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),\n          \"Changed SPECSYS to '%s'\", specsys);\n        status = FIXERR_SUCCESS;\n      }\n\n      // Was ctype translated?  Have to null-fill for comparing them.\n      wcsutil_null_fill(9, wcs->ctype[i]);\n      if (strncmp(wcs->ctype[i], ctype, 9)) {\n        // ctype was translated...\n        if (status == FIXERR_SUCCESS) {\n          // ...and specsys was also.\n          wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),\n            \"Changed CTYPE%d from '%s' to '%s', and SPECSYS to '%s' \"\n            \"(VELREF=%d)\", i+1, wcs->ctype[i], ctype, wcs->specsys,\n            wcs->velref);\n        } else {\n          wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),\n            \"Changed CTYPE%d from '%s' to '%s' (VELREF=%d)\", i+1,\n            wcs->ctype[i], ctype, wcs->velref);\n          status = FIXERR_SUCCESS;\n        }\n\n        strncpy(wcs->ctype[i], ctype, 9);\n      }\n\n      // Tidy up.\n      if (status == FIXERR_SUCCESS) {\n        wcsutil_null_fill(72, wcs->ctype[i]);\n        wcsutil_null_fill(72, wcs->specsys);\n      }\n\n      // No need to check for others, wcsset() will fail if so.\n      return status;\n\n    } else if (status == SPCERR_BAD_SPEC_PARAMS) {\n      // An AIPS spectral type was found but with invalid velref.\n      return wcserr_set(WCSERR_SET(FIXERR_BAD_PARAM),\n        \"Invalid parameter value: velref = %d\", wcs->velref);\n    }\n  }\n\n  return FIXERR_NO_CHANGE;\n}\n\n//----------------------------------------------------------------------------",
                "filename": "cextern/wcslib/C/wcsfix.c",
                "start_index": 23139,
                "end_index": 25271,
                "start_line": 850,
                "end_line": 1143,
                "max_line": 1481,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "/* wcslib represents undefined values using its own special constant,\n   UNDEFINED.  To be consistent with the Pythonic way of doing things,\n   it's nicer to represent undefined values using NaN.  Unfortunately,\n   in order to get nice mutable arrays in Python, Python must be able\n   to edit the wcsprm values directly.  The solution is to store NaNs\n   in the struct \"canonically\", but convert those NaNs to/from\n   UNDEFINED around every call into a wcslib function.  It's not as\n   computationally expensive as it sounds, as all these arrays are\n   quite small.\n*/\n\nstatic INLINE void\nwcsprm_fix_values(\n    struct wcsprm* x,\n    value_fixer_t value_fixer) {\n\n  unsigned int naxis = (unsigned int)x->naxis;\n\n  value_fixer(x->cd, naxis * naxis);\n  value_fixer(x->cdelt, naxis);\n  value_fixer(x->crder, naxis);\n  value_fixer(x->crota, naxis);\n  value_fixer(x->crpix, naxis);\n  value_fixer(x->crval, naxis);\n  value_fixer(x->csyer, naxis);\n  value_fixer(&x->equinox, 1);\n  value_fixer(&x->latpole, 1);\n  value_fixer(&x->lonpole, 1);\n  value_fixer(&x->mjdavg, 1);\n  value_fixer(&x->mjdobs, 1);\n  value_fixer(x->obsgeo, 6);\n  value_fixer(&x->cel.phi0, 1);\n  value_fixer(&x->restfrq, 1);\n  value_fixer(&x->restwav, 1);\n  value_fixer(&x->cel.theta0, 1);\n  value_fixer(&x->velangl, 1);\n  value_fixer(&x->velosys, 1);\n  value_fixer(&x->zsource, 1);\n  value_fixer(x->czphs, naxis);\n  value_fixer(x->cperi, naxis);\n  value_fixer(x->mjdref, 2);\n  value_fixer(&x->mjdbeg, 1);\n  value_fixer(&x->mjdend, 1);\n  value_fixer(&x->jepoch, 1);\n  value_fixer(&x->bepoch, 1);\n  value_fixer(&x->tstart, 1);\n  value_fixer(&x->tstop, 1);\n  value_fixer(&x->xposure, 1);\n  value_fixer(&x->timsyer, 1);\n  value_fixer(&x->timrder, 1);\n  value_fixer(&x->timedel, 1);\n  value_fixer(&x->timepixr, 1);\n  value_fixer(&x->timeoffs, 1);\n  value_fixer(&x->telapse, 1);\n}\n\nvoid\nwcsprm_c2python(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &undefined2nan);\n  }\n}\n\nvoid\nwcsprm_python2c(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &nan2undefined);\n  }\n}\n\n/***************************************************************************\n * Exceptions                                                              *\n ***************************************************************************/\n\nPyObject* WcsExc_Wcs;\nPyObject* WcsExc_SingularMatrix;\nPyObject* WcsExc_InconsistentAxisTypes;\nPyObject* WcsExc_InvalidTransform;\nPyObject* WcsExc_InvalidCoordinate;\nPyObject* WcsExc_NoSolution;\nPyObject* WcsExc_InvalidSubimageSpecification;\nPyObject* WcsExc_NonseparableSubimageCoordinateSystem;\nPyObject* WcsExc_NoWcsKeywordsFound;\nPyObject* WcsExc_InvalidTabularParameters;\nPyObject* WcsExc_InvalidPrjParameters;\n\n/* This is an array mapping the wcs status codes to Python exception\n * types.  The exception string is stored as part of wcslib itself in\n * wcs_errmsg.\n */\nPyObject** wcs_errexc[14];",
                "filename": "astropy/wcs/src/pyutil.c",
                "start_index": 2647,
                "end_index": 5571,
                "start_line": 147,
                "end_line": 241,
                "max_line": 957,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "{\n  static const char *function = \"wcstab\";\n\n  char (*PSi_0a)[72] = 0x0, (*PSi_1a)[72] = 0x0, (*PSi_2a)[72] = 0x0;\n  int  *PVi_1a = 0x0, *PVi_2a = 0x0, *PVi_3a = 0x0, *tabax, *tabidx = 0x0;\n  int   getcrd, i, ip, itab, itabax, j, jtabax, m, naxis, ntabax, status;\n  struct wtbarr *wtbp;\n  struct tabprm *tabp;\n  struct wcserr **err;\n\n  if (wcs == 0x0) return WCSHDRERR_NULL_POINTER;\n  err = &(wcs->err);\n\n  // Free memory previously allocated by wcstab().\n  if (wcs->flag != -1 && wcs->m_flag == WCSSET) {\n    if (wcs->wtb == wcs->m_wtb) wcs->wtb = 0x0;\n    if (wcs->tab == wcs->m_tab) wcs->tab = 0x0;\n\n    if (wcs->m_wtb) free(wcs->m_wtb);\n    if (wcs->m_tab) {\n      for (j = 0; j < wcs->ntab; j++) {\n        tabfree(wcs->m_tab + j);\n      }\n\n      free(wcs->m_tab);\n    }\n  }\n\n  wcs->ntab = 0;\n  wcs->nwtb = 0;\n  wcs->wtb  = 0x0;\n  wcs->tab  = 0x0;\n\n\n  // Determine the number of -TAB axes.\n  naxis = wcs->naxis;\n  if (!(tabax = calloc(naxis, sizeof(int)))) {\n    return wcserr_set(WCSHDR_ERRMSG(WCSHDRERR_MEMORY));\n  }\n\n  ntabax = 0;\n  for (i = 0; i < naxis; i++) {\n    // Null fill.\n    wcsutil_null_fill(72, wcs->ctype[i]);\n\n    if (!strcmp(wcs->ctype[i]+4, \"-TAB\")) {\n      tabax[i] = ntabax++;\n    } else {\n      tabax[i] = -1;\n    }\n  }\n\n  if (ntabax == 0) {\n    // No lookup tables.\n    status = 0;\n    goto cleanup;\n  }\n\n\n  // Collect information from the PSi_ma and PVi_ma keyvalues.\n  if (!((PSi_0a = calloc(ntabax, sizeof(char[72]))) &&\n        (PVi_1a = calloc(ntabax, sizeof(int)))      &&\n        (PVi_2a = calloc(ntabax, sizeof(int)))      &&\n        (PSi_1a = calloc(ntabax, sizeof(char[72]))) &&\n        (PSi_2a = calloc(ntabax, sizeof(char[72]))) &&\n        (PVi_3a = calloc(ntabax, sizeof(int)))      &&\n        (tabidx = calloc(ntabax, sizeof(int))))) {\n    status = wcserr_set(WCSHDR_ERRMSG(WCSHDRERR_MEMORY));\n    goto cleanup;\n  }\n\n  for (itabax = 0; itabax < ntabax; itabax++) {\n    // Remember that calloc() zeroes allocated memory.\n    PVi_1a[itabax] = 1;\n    PVi_2a[itabax] = 1;\n    PVi_3a[itabax] = 1;\n  }\n\n  for (ip = 0; ip < wcs->nps; ip++) {\n    itabax = tabax[wcs->ps[ip].i - 1];\n    if (itabax >= 0) {\n      switch (wcs->ps[ip].m) {\n      case 0:\n        // EXTNAME.\n        strcpy(PSi_0a[itabax], wcs->ps[ip].value);\n        wcsutil_null_fill(72, PSi_0a[itabax]);\n        break;\n      case 1:\n        // TTYPEn for coordinate array.\n        strcpy(PSi_1a[itabax], wcs->ps[ip].value);\n        wcsutil_null_fill(72, PSi_1a[itabax]);\n        break;\n      case 2:\n        // TTYPEn for index vector.\n        strcpy(PSi_2a[itabax], wcs->ps[ip].value);\n        wcsutil_null_fill(72, PSi_2a[itabax]);\n        break;\n      }\n    }\n  }",
                "filename": "cextern/wcslib/C/wcshdr.c",
                "start_index": 2550,
                "end_index": 5213,
                "start_line": 45,
                "end_line": 2249,
                "max_line": 2250,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            },
            {
                "code": "if _wcs is not None:\n    if Version(_wcs.__version__) < Version(\"5.8\"):\n        raise ImportError(\n            \"astropy.wcs is built with wcslib {0}, but only versions 5.8 and \"\n            \"later on the 5.x series are known to work.  The version of wcslib \"\n            \"that ships with astropy may be used.\"\n        )\n\n    if not _wcs._sanity_check():\n        raise RuntimeError(\n            \"astropy.wcs did not pass its sanity check for your build on your platform.\"\n        )\n\n    _WCSSUB_TIME_SUPPORT = Version(_wcs.__version__) >= Version(\"7.8\")\n    _WCS_TPD_WARN_LT71 = Version(_wcs.__version__) < Version(\"7.1\")\n    _WCS_TPD_WARN_LT74 = Version(_wcs.__version__) < Version(\"7.4\")\n\n    WCSBase = _wcs._Wcs\n    DistortionLookupTable = _wcs.DistortionLookupTable\n    Sip = _wcs.Sip\n    Wcsprm = _wcs.Wcsprm\n    Auxprm = _wcs.Auxprm\n    Celprm = _wcs.Celprm\n    Prjprm = _wcs.Prjprm\n    Tabprm = _wcs.Tabprm\n    Wtbarr = _wcs.Wtbarr\n    WcsError = _wcs.WcsError\n    SingularMatrixError = _wcs.SingularMatrixError\n    InconsistentAxisTypesError = _wcs.InconsistentAxisTypesError\n    InvalidTransformError = _wcs.InvalidTransformError\n    InvalidCoordinateError = _wcs.InvalidCoordinateError\n    NoSolutionError = _wcs.NoSolutionError\n    InvalidSubimageSpecificationError = _wcs.InvalidSubimageSpecificationError\n    NonseparableSubimageCoordinateSystemError = (\n        _wcs.NonseparableSubimageCoordinateSystemError\n    )\n    NoWcsKeywordsFoundError = _wcs.NoWcsKeywordsFoundError\n    InvalidTabularParametersError = _wcs.InvalidTabularParametersError\n    InvalidPrjParametersError = _wcs.InvalidPrjParametersError\n\n    # Copy all the constants from the C extension into this module's namespace\n    for key, val in _wcs.__dict__.items():\n        if key.startswith((\"WCSSUB_\", \"WCSHDR_\", \"WCSHDO_\", \"WCSCOMPARE_\", \"PRJ_\")):\n            locals()[key] = val\n            __all__.append(key)\n\n    # Set coordinate extraction callback for WCS -TAB:\n    def _load_tab_bintable(hdulist, extnam, extver, extlev, kind, ttype, row, ndim):\n        arr = hdulist[(extnam, extver)].data[ttype][row - 1]\n\n        if arr.ndim != ndim:\n            if kind == \"c\" and ndim == 2:\n                arr = arr.reshape((arr.size, 1))\n            else:\n                raise ValueError(\"Bad TDIM\")\n\n        return np.ascontiguousarray(arr, dtype=np.double)\n\n    _wcs.set_wtbarr_fitsio_callback(_load_tab_bintable)\n\nelse:\n    WCSBase = object\n    Wcsprm = object\n    DistortionLookupTable = object\n    Sip = object\n    Tabprm = object\n    Wtbarr = object\n    WcsError = None\n    SingularMatrixError = None\n    InconsistentAxisTypesError = None\n    InvalidTransformError = None\n    InvalidCoordinateError = None\n    NoSolutionError = None\n    InvalidSubimageSpecificationError = None\n    NonseparableSubimageCoordinateSystemError = None\n    NoWcsKeywordsFoundError = None\n    InvalidTabularParametersError = None\n\n    _WCSSUB_TIME_SUPPORT = False\n    _WCS_TPD_WARN_LT71 = False\n    _WCS_TPD_WARN_LT74 = False",
                "filename": "astropy/wcs/wcs.py",
                "start_index": 2300,
                "end_index": 5287,
                "start_line": 93,
                "end_line": 173,
                "max_line": 3805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "astropy/wcs/wcs.py": [
                {
                    "chunk": {
                        "code": "if wcsprm.naxis != 2 and (\n                det2im[0] or det2im[1] or cpdis[0] or cpdis[1] or sip\n            ):\n                raise ValueError(\n                    f\"\"\"\nFITS WCS distortion paper lookup tables and SIP distortions only work\nin 2 dimensions.  However, WCSLIB has detected {wcsprm.naxis} dimensions in the\ncore WCS keywords.  To use core WCS in conjunction with FITS WCS\ndistortion paper lookup tables or SIP distortion, you must select or\nreduce these to 2 dimensions using the naxis kwarg.\n\"\"\"\n                )\n\n            header_naxis = header.get(\"NAXIS\", None)\n            if header_naxis is not None and header_naxis < wcsprm.naxis:\n                warnings.warn(\n                    f\"The WCS transformation has more axes ({wcsprm.naxis:d}) than the \"\n                    f\"image it is associated with ({header_naxis:d})\",\n                    FITSFixedWarning,\n                )",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 19719,
                        "end_index": 20621,
                        "start_line": 577,
                        "end_line": 3796,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains logic that raises a ValueError if the WCS transformation has more axes than the image it is associated with, which could be related to the issue where wcslint crashes on valid WCS."
                },
                {
                    "chunk": {
                        "code": "if _wcs is not None:\n    if Version(_wcs.__version__) < Version(\"5.8\"):\n        raise ImportError(\n            \"astropy.wcs is built with wcslib {0}, but only versions 5.8 and \"\n            \"later on the 5.x series are known to work.  The version of wcslib \"\n            \"that ships with astropy may be used.\"\n        )\n\n    if not _wcs._sanity_check():\n        raise RuntimeError(\n            \"astropy.wcs did not pass its sanity check for your build on your platform.\"\n        )\n\n    _WCSSUB_TIME_SUPPORT = Version(_wcs.__version__) >= Version(\"7.8\")\n    _WCS_TPD_WARN_LT71 = Version(_wcs.__version__) < Version(\"7.1\")\n    _WCS_TPD_WARN_LT74 = Version(_wcs.__version__) < Version(\"7.4\")\n\n    WCSBase = _wcs._Wcs\n    DistortionLookupTable = _wcs.DistortionLookupTable\n    Sip = _wcs.Sip\n    Wcsprm = _wcs.Wcsprm\n    Auxprm = _wcs.Auxprm\n    Celprm = _wcs.Celprm\n    Prjprm = _wcs.Prjprm\n    Tabprm = _wcs.Tabprm\n    Wtbarr = _wcs.Wtbarr\n    WcsError = _wcs.WcsError\n    SingularMatrixError = _wcs.SingularMatrixError\n    InconsistentAxisTypesError = _wcs.InconsistentAxisTypesError\n    InvalidTransformError = _wcs.InvalidTransformError\n    InvalidCoordinateError = _wcs.InvalidCoordinateError\n    NoSolutionError = _wcs.NoSolutionError\n    InvalidSubimageSpecificationError = _wcs.InvalidSubimageSpecificationError\n    NonseparableSubimageCoordinateSystemError = (\n        _wcs.NonseparableSubimageCoordinateSystemError\n    )\n    NoWcsKeywordsFoundError = _wcs.NoWcsKeywordsFoundError\n    InvalidTabularParametersError = _wcs.InvalidTabularParametersError\n    InvalidPrjParametersError = _wcs.InvalidPrjParametersError\n\n    # Copy all the constants from the C extension into this module's namespace\n    for key, val in _wcs.__dict__.items():\n        if key.startswith((\"WCSSUB_\", \"WCSHDR_\", \"WCSHDO_\", \"WCSCOMPARE_\", \"PRJ_\")):\n            locals()[key] = val\n            __all__.append(key)\n\n    # Set coordinate extraction callback for WCS -TAB:\n    def _load_tab_bintable(hdulist, extnam, extver, extlev, kind, ttype, row, ndim):\n        arr = hdulist[(extnam, extver)].data[ttype][row - 1]\n\n        if arr.ndim != ndim:\n            if kind == \"c\" and ndim == 2:\n                arr = arr.reshape((arr.size, 1))\n            else:\n                raise ValueError(\"Bad TDIM\")\n\n        return np.ascontiguousarray(arr, dtype=np.double)\n\n    _wcs.set_wtbarr_fitsio_callback(_load_tab_bintable)\n\nelse:\n    WCSBase = object\n    Wcsprm = object\n    DistortionLookupTable = object\n    Sip = object\n    Tabprm = object\n    Wtbarr = object\n    WcsError = None\n    SingularMatrixError = None\n    InconsistentAxisTypesError = None\n    InvalidTransformError = None\n    InvalidCoordinateError = None\n    NoSolutionError = None\n    InvalidSubimageSpecificationError = None\n    NonseparableSubimageCoordinateSystemError = None\n    NoWcsKeywordsFoundError = None\n    InvalidTabularParametersError = None\n\n    _WCSSUB_TIME_SUPPORT = False\n    _WCS_TPD_WARN_LT71 = False\n    _WCS_TPD_WARN_LT74 = False",
                        "filename": "astropy/wcs/wcs.py",
                        "start_index": 2300,
                        "end_index": 5287,
                        "start_line": 93,
                        "end_line": 173,
                        "max_line": 3805,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet checks the version of wcslib and performs a sanity check, which could be relevant if the issue is related to a specific version of wcslib or if there is a compatibility problem."
                }
            ],
            "cextern/wcslib/C/wcsfix.c": [
                {
                    "chunk": {
                        "code": "int spcfix(struct wcsprm *wcs)\n\n{\n  static const char *function = \"spcfix\";\n\n  if (wcs == 0x0) return FIXERR_NULL_POINTER;\n  struct wcserr **err = &(wcs->err);\n\n  for (int i = 0; i < wcs->naxis; i++) {\n    // Translate an AIPS-convention spectral type if present.\n    char ctype[9], specsys[9];\n    int status = spcaips(wcs->ctype[i], wcs->velref, ctype, specsys);\n    if (status == FIXERR_SUCCESS) {\n      // An AIPS type was found but it may match what we already have.\n      status = FIXERR_NO_CHANGE;\n\n      // Was specsys translated?\n      if (wcs->specsys[0] == '\\0' && *specsys) {\n        strncpy(wcs->specsys, specsys, 9);\n        wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),\n          \"Changed SPECSYS to '%s'\", specsys);\n        status = FIXERR_SUCCESS;\n      }\n\n      // Was ctype translated?  Have to null-fill for comparing them.\n      wcsutil_null_fill(9, wcs->ctype[i]);\n      if (strncmp(wcs->ctype[i], ctype, 9)) {\n        // ctype was translated...\n        if (status == FIXERR_SUCCESS) {\n          // ...and specsys was also.\n          wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),\n            \"Changed CTYPE%d from '%s' to '%s', and SPECSYS to '%s' \"\n            \"(VELREF=%d)\", i+1, wcs->ctype[i], ctype, wcs->specsys,\n            wcs->velref);\n        } else {\n          wcserr_set(WCSERR_SET(FIXERR_SPC_UPDATE),\n            \"Changed CTYPE%d from '%s' to '%s' (VELREF=%d)\", i+1,\n            wcs->ctype[i], ctype, wcs->velref);\n          status = FIXERR_SUCCESS;\n        }\n\n        strncpy(wcs->ctype[i], ctype, 9);\n      }\n\n      // Tidy up.\n      if (status == FIXERR_SUCCESS) {\n        wcsutil_null_fill(72, wcs->ctype[i]);\n        wcsutil_null_fill(72, wcs->specsys);\n      }\n\n      // No need to check for others, wcsset() will fail if so.\n      return status;\n\n    } else if (status == SPCERR_BAD_SPEC_PARAMS) {\n      // An AIPS spectral type was found but with invalid velref.\n      return wcserr_set(WCSERR_SET(FIXERR_BAD_PARAM),\n        \"Invalid parameter value: velref = %d\", wcs->velref);\n    }\n  }\n\n  return FIXERR_NO_CHANGE;\n}\n\n//----------------------------------------------------------------------------",
                        "filename": "cextern/wcslib/C/wcsfix.c",
                        "start_index": 23139,
                        "end_index": 25271,
                        "start_line": 850,
                        "end_line": 1143,
                        "max_line": 1481,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains code for fixing spectral coordinate systems, which might be relevant if the issue is related to spectral coordinates in the WCS."
                }
            ],
            "astropy/wcs/src/pyutil.c": [
                {
                    "chunk": {
                        "code": "/* wcslib represents undefined values using its own special constant,\n   UNDEFINED.  To be consistent with the Pythonic way of doing things,\n   it's nicer to represent undefined values using NaN.  Unfortunately,\n   in order to get nice mutable arrays in Python, Python must be able\n   to edit the wcsprm values directly.  The solution is to store NaNs\n   in the struct \"canonically\", but convert those NaNs to/from\n   UNDEFINED around every call into a wcslib function.  It's not as\n   computationally expensive as it sounds, as all these arrays are\n   quite small.\n*/\n\nstatic INLINE void\nwcsprm_fix_values(\n    struct wcsprm* x,\n    value_fixer_t value_fixer) {\n\n  unsigned int naxis = (unsigned int)x->naxis;\n\n  value_fixer(x->cd, naxis * naxis);\n  value_fixer(x->cdelt, naxis);\n  value_fixer(x->crder, naxis);\n  value_fixer(x->crota, naxis);\n  value_fixer(x->crpix, naxis);\n  value_fixer(x->crval, naxis);\n  value_fixer(x->csyer, naxis);\n  value_fixer(&x->equinox, 1);\n  value_fixer(&x->latpole, 1);\n  value_fixer(&x->lonpole, 1);\n  value_fixer(&x->mjdavg, 1);\n  value_fixer(&x->mjdobs, 1);\n  value_fixer(x->obsgeo, 6);\n  value_fixer(&x->cel.phi0, 1);\n  value_fixer(&x->restfrq, 1);\n  value_fixer(&x->restwav, 1);\n  value_fixer(&x->cel.theta0, 1);\n  value_fixer(&x->velangl, 1);\n  value_fixer(&x->velosys, 1);\n  value_fixer(&x->zsource, 1);\n  value_fixer(x->czphs, naxis);\n  value_fixer(x->cperi, naxis);\n  value_fixer(x->mjdref, 2);\n  value_fixer(&x->mjdbeg, 1);\n  value_fixer(&x->mjdend, 1);\n  value_fixer(&x->jepoch, 1);\n  value_fixer(&x->bepoch, 1);\n  value_fixer(&x->tstart, 1);\n  value_fixer(&x->tstop, 1);\n  value_fixer(&x->xposure, 1);\n  value_fixer(&x->timsyer, 1);\n  value_fixer(&x->timrder, 1);\n  value_fixer(&x->timedel, 1);\n  value_fixer(&x->timepixr, 1);\n  value_fixer(&x->timeoffs, 1);\n  value_fixer(&x->telapse, 1);\n}\n\nvoid\nwcsprm_c2python(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &undefined2nan);\n  }\n}\n\nvoid\nwcsprm_python2c(\n    /*@null@*/ struct wcsprm* x) {\n\n  if (x != NULL) {\n    wcsprm_fix_values(x, &nan2undefined);\n  }\n}\n\n/***************************************************************************\n * Exceptions                                                              *\n ***************************************************************************/\n\nPyObject* WcsExc_Wcs;\nPyObject* WcsExc_SingularMatrix;\nPyObject* WcsExc_InconsistentAxisTypes;\nPyObject* WcsExc_InvalidTransform;\nPyObject* WcsExc_InvalidCoordinate;\nPyObject* WcsExc_NoSolution;\nPyObject* WcsExc_InvalidSubimageSpecification;\nPyObject* WcsExc_NonseparableSubimageCoordinateSystem;\nPyObject* WcsExc_NoWcsKeywordsFound;\nPyObject* WcsExc_InvalidTabularParameters;\nPyObject* WcsExc_InvalidPrjParameters;\n\n/* This is an array mapping the wcs status codes to Python exception\n * types.  The exception string is stored as part of wcslib itself in\n * wcs_errmsg.\n */\nPyObject** wcs_errexc[14];",
                        "filename": "astropy/wcs/src/pyutil.c",
                        "start_index": 2647,
                        "end_index": 5571,
                        "start_line": 147,
                        "end_line": 241,
                        "max_line": 957,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet deals with the conversion of undefined values to NaN in wcsprm structures, which could be relevant if the crash is due to handling of undefined or NaN values in the WCS data."
                }
            ]
        },
        "solution_task": "Based on the provided information, the following solutions can be applied to address the issues:\n\n- **malloc.c:2385: sysmalloc: Assertion ... failed.**\n  - This error suggests a memory allocation issue within the WCSLIB C library. Ensure that all memory allocations are checked for success before use and that all allocated memory is properly freed.\n  - Review the `wcs.c` and `wcsfix.c` files for proper use of `malloc` and `free`. Ensure that `free` is called only on memory that was successfully allocated and that it is not called multiple times on the same pointer without an intervening allocation.\n\n- **ValueError: HDUList is required to retrieve -TAB coordinates and/or indices.**\n  - This error indicates that an `HDUList` object is required but not provided when attempting to retrieve -TAB coordinates or indices.\n  - Ensure that the `HDUList` object is passed to functions that require it, such as when using the `_load_tab_bintable` callback function in `wcs.py`.\n  - Check the `wcstab` function in `wcshdr.c` to ensure that it correctly handles the `HDUList` and associated -TAB coordinate information.\n\n- **Inconsistent SIP distortion information is present in the FITS header and the WCS object: SIP coefficients were detected, but CTYPE is missing a \"-SIP\" suffix.**\n  - This error is related to the handling of SIP (Simple Imaging Polynomial) distortion coefficients in the FITS header.\n  - Ensure that the `CTYPE` keyword in the FITS header includes the `-SIP` suffix if SIP coefficients are present. This can be done by checking and updating the `CTYPE` keyword in the `header` object before creating the `WCS` object.\n  - Review the `WCS` class constructor and the `validate` method to ensure that they correctly handle SIP coefficients and the `CTYPE` keyword.\n\n- General recommendations:\n  - Check the `WCS` class and associated functions in `wcs.py` for proper error handling and memory management.\n  - Review the `wcsfix` function in `wcsfix.c` to ensure that it correctly fixes any inconsistencies in the WCS parameters.\n  - Ensure that the `wcsprm` struct is correctly initialized and that any undefined values are properly handled, as shown in `pyutil.c`.\n  - Verify that the `wcstab` function in `wcshdr.c` correctly processes the PSi_ma and PVi_ma keyvalues for -TAB axes.",
        "bouncer_response": {
            "score": 3,
            "criteria": "The RESPONSE provides a general analysis of potential issues and suggests areas of the code to review. However, it lacks specific actionable steps directly related to the described bug in the PROMPT.",
            "supporting_evidence": "The RESPONSE offers a broad approach to debugging the issues with `wcslint` and the `WCS` class in the Astropy library. It suggests checking for memory allocation issues, ensuring proper handling of `HDUList` objects, and verifying the handling of SIP coefficients. However, it does not provide specific, actionable steps that are directly related to the crashes and errors described in the PROMPT. The RESPONSE also includes links to code snippets, but these are not directly tied to the issues at hand and do not offer clear next steps for resolving the crashes. The RESPONSE is somewhat relevant as it addresses the general area of the problem but lacks the precision and direct applicability needed to score higher.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711736613.9471512,
        "result": "Doesn't seem like we have fully grasped all the specifics of this ticket \ud83d\ude41.                   But we've outlined some ideas that might help you get started:\n\nBased on the provided information, the following solutions can be applied to address the issues:\n\n- **malloc.c:2385: sysmalloc: Assertion ... failed.**\n  - This error suggests a memory allocation issue within the WCSLIB C library. Ensure that all memory allocations are checked for success before use and that all allocated memory is properly freed.\n  - Review the `wcs.c` and `wcsfix.c` files for proper use of `malloc` and `free`. Ensure that `free` is called only on memory that was successfully allocated and that it is not called multiple times on the same pointer without an intervening allocation.\n\n- **ValueError: HDUList is required to retrieve -TAB coordinates and/or indices.**\n  - This error indicates that an `HDUList` object is required but not provided when attempting to retrieve -TAB coordinates or indices.\n  - Ensure that the `HDUList` object is passed to functions that require it, such as when using the `_load_tab_bintable` callback function in `wcs.py`.\n  - Check the `wcstab` function in `wcshdr.c` to ensure that it correctly handles the `HDUList` and associated -TAB coordinate information.\n\n- **Inconsistent SIP distortion information is present in the FITS header and the WCS object: SIP coefficients were detected, but CTYPE is missing a \"-SIP\" suffix.**\n  - This error is related to the handling of SIP (Simple Imaging Polynomial) distortion coefficients in the FITS header.\n  - Ensure that the `CTYPE` keyword in the FITS header includes the `-SIP` suffix if SIP coefficients are present. This can be done by checking and updating the `CTYPE` keyword in the `header` object before creating the `WCS` object.\n  - Review the `WCS` class constructor and the `validate` method to ensure that they correctly handle SIP coefficients and the `CTYPE` keyword.\n\n- General recommendations:\n  - Check the `WCS` class and associated functions in `wcs.py` for proper error handling and memory management.\n  - Review the `wcsfix` function in `wcsfix.c` to ensure that it correctly fixes any inconsistencies in the WCS parameters.\n  - Ensure that the `wcsprm` struct is correctly initialized and that any undefined values are properly handled, as shown in `pyutil.c`.\n  - Verify that the `wcstab` function in `wcshdr.c` correctly processes the PSi_ma and PVi_ma keyvalues for -TAB axes.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.0/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/wcs)- [Lines 577 - 3796](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/wcs/wcs.py#L577-L3796)\n\n This snippet contains logic that raises a ValueError if the WCS transformation has more axes than the image it is associated with, which could be related to the issue where wcslint crashes on valid WCS. \n\n\n   - [Lines 93 - 173](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/wcs/wcs.py#L93-L173)\n\n This snippet checks the version of wcslib and performs a sanity check, which could be relevant if the issue is related to a specific version of wcslib or if there is a compatibility problem.\n-  \u2192 [cextern](https://github.com/testbed/astropy__astropy__5.0/tree//cextern) \u2192 [wcslib](https://github.com/testbed/astropy__astropy__5.0/tree//cextern/wcslib) \u2192 [C](https://github.com/testbed/astropy__astropy__5.0/tree//cextern/wcslib/C)- [Lines 850 - 1143](https://github.com/testbed/astropy__astropy__5.0/blob//cextern/wcslib/C/wcsfix.c#L850-L1143)\n\n This snippet contains code for fixing spectral coordinate systems, which might be relevant if the issue is related to spectral coordinates in the WCS.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.0/tree//astropy) \u2192 [wcs](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/wcs) \u2192 [src](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/wcs/src)- [Lines 147 - 241](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/wcs/src/pyutil.c#L147-L241)\n\n This snippet deals with the conversion of undefined values to NaN in wcsprm structures, which could be relevant if the crash is due to handling of undefined or NaN values in the WCS data."
    }
}