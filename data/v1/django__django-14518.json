{
    "id": "django__django-14518",
    "repo_name": "testbed/django__django__4.0",
    "task_id": 547553169510370548,
    "title": "Include in CsrfViewMiddleware's bad CSRF token message where the token is from",
    "body": "Description\n\t \n\t\t(last modified by Chris Jerdonek)\n\t \nCurrently, if CsrfViewMiddleware encounters a bad CSRF token, it will reject the request with a message like--\n\"CSRF token incorrect\"\n\"CSRF token has incorrect length\"\nI noticed that it would be relatively easy to include in these messages whether the token was obtained from POST data or a custom header, which would be useful for troubleshooting. The messages are specified \u200bhere in the code. The new messages could look e.g. like--\n\"CSRF token (from POST) incorrect\"\n\"CSRF token (from 'X-CSRFToken' header) has incorrect length\"\nThe changes to CsrfViewMiddlewareTestMixin proposed in #32800 would make these cases easy to test.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__4.0.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature request described in the ticket, you will need to modify the `_bad_token_message` method in the `CsrfViewMiddleware` class to include information about where the CSRF token was obtained from (either POST data or a custom header). Here's how you can do it:\n\n- Locate the `_bad_token_message` method in the `CsrfViewMiddleware` class within the `django/middleware/csrf.py` file.\n- Modify the method to check the `token_source` and include the appropriate message based on whether the token came from POST data or the custom header.\n\nHere's a code snippet that demonstrates the changes:\n\n```python\n# django/middleware/csrf.py\n\nclass CsrfViewMiddleware(MiddlewareMixin):\n    # ... (other methods and properties)\n\n    def _bad_token_message(self, reason, token_source):\n        # Check if the token source is from POST data or from the custom header\n        if token_source == \"POST\":\n            token_source_info = \"from POST\"\n        else:\n            # Assume it is from the custom header specified in settings.CSRF_HEADER_NAME\n            header_name = HttpHeaders.parse_header_name(settings.CSRF_HEADER_NAME)\n            token_source_info = f\"from '{header_name}' header\"\n        \n        # Return the modified message with the token source information\n        return f\"CSRF token ({token_source_info}) {reason}.\"\n\n    # ... (other methods and properties)\n```\n\nMake sure to test the changes thoroughly. You can create unit tests that check for the correct error messages when a bad CSRF token is encountered from either POST data or the custom header. The ticket mentions that the changes to `CsrfViewMiddlewareTestMixin` proposed in #32800 would make these cases easy to test, so you should also review and possibly integrate those test changes.\n\nAfter implementing the feature and testing it, you should follow your project's procedures for code review, documentation, and deployment to integrate the new feature into the software project.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.0/tree//django) \u2192 [middleware](https://github.com/testbed/django__django__4.0/tree//django/middleware)- [Lines 270 - 346](https://github.com/testbed/django__django__4.0/blob//django/middleware/csrf.py#L270-L346)\n\n This snippet contains the _bad_token_message method that constructs the CSRF token error message, which is directly related to the issue. \n\n\n   - [Lines 1 - 67](https://github.com/testbed/django__django__4.0/blob//django/middleware/csrf.py#L1-L67)\n\n This snippet defines the constants for CSRF token error messages, which will need to be updated to include the token source as per the issue. \n\n\n   - [Lines 348 - 411](https://github.com/testbed/django__django__4.0/blob//django/middleware/csrf.py#L348-L411)\n\n This snippet includes the _check_token method where the CSRF token is checked and the error message is generated, which will need to be modified to include the token source.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0001825,
        "snippet_processor": 0.04329,
        "issue_star_creation": 0.02292,
        "issue_star_solver": 0.06581000000000001,
        "bouncer": 0.025120000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711722534.879711,
        "relevant_snippets": [
            {
                "code": "class CsrfViewMiddleware(MiddlewareMixin):",
                "filename": "django/middleware/csrf.py",
                "start_index": 6093,
                "end_index": 6135,
                "start_line": 164,
                "end_line": 164,
                "max_line": 482,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\nCross Site Request Forgery Middleware.\n\nThis module provides a middleware that implements protection\nagainst request forgeries from other sites.\n\"\"\"\nimport logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost, ImproperlyConfigured\nfrom django.http import HttpHeaders, UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare, get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\n\nlogger = logging.getLogger(\"django.security.csrf\")\n# This matches if any character is not in CSRF_ALLOWED_CHARS.\ninvalid_token_chars_re = _lazy_re_compile(\"[^a-zA-Z0-9]\")\n\nREASON_BAD_ORIGIN = \"Origin checking failed - %s does not match any trusted origins.\"\nREASON_NO_REFERER = \"Referer checking failed - no Referer.\"\nREASON_BAD_REFERER = \"Referer checking failed - %s does not match any trusted origins.\"\nREASON_NO_CSRF_COOKIE = \"CSRF cookie not set.\"\nREASON_CSRF_TOKEN_MISSING = \"CSRF token missing.\"\nREASON_MALFORMED_REFERER = \"Referer checking failed - Referer is malformed.\"\nREASON_INSECURE_REFERER = (\n    \"Referer checking failed - Referer is insecure while host is secure.\"\n)\n# The reason strings below are for passing to InvalidTokenFormat. They are\n# phrases without a subject because they can be in reference to either the CSRF\n# cookie or non-cookie token.\nREASON_INCORRECT_LENGTH = \"has incorrect length\"\nREASON_INVALID_CHARACTERS = \"has invalid characters\"\n\nCSRF_SECRET_LENGTH = 32\nCSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH\nCSRF_ALLOWED_CHARS = string.ascii_letters + string.digits\nCSRF_SESSION_KEY = \"_csrftoken\"\n\n\ndef _get_failure_view():\n    \"\"\"Return the view to be used for CSRF rejections.\"\"\"\n    return get_callable(settings.CSRF_FAILURE_VIEW)\n\n\ndef _get_new_csrf_string():\n    return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)\n\n\ndef _mask_cipher_secret(secret):\n    \"\"\"\n    Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a\n    token by adding a mask and applying it to the secret.\n    \"\"\"\n    mask = _get_new_csrf_string()\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))\n    cipher = \"\".join(chars[(x + y) % len(chars)] for x, y in pairs)\n    return mask + cipher",
                "filename": "django/middleware/csrf.py",
                "start_index": 0,
                "end_index": 2628,
                "start_line": 1,
                "end_line": 67,
                "max_line": 482,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "def _origin_verified(self, request):\n        request_origin = request.META[\"HTTP_ORIGIN\"]\n        try:\n            good_host = request.get_host()\n        except DisallowedHost:\n            pass\n        else:\n            good_origin = \"%s://%s\" % (\n                \"https\" if request.is_secure() else \"http\",\n                good_host,\n            )\n            if request_origin == good_origin:\n                return True\n        if request_origin in self.allowed_origins_exact:\n            return True\n        try:\n            parsed_origin = urlparse(request_origin)\n        except ValueError:\n            return False\n        request_scheme = parsed_origin.scheme\n        request_netloc = parsed_origin.netloc\n        return any(\n            is_same_domain(request_netloc, host)\n            for host in self.allowed_origin_subdomains.get(request_scheme, ())\n        )\n\n    def _check_referer(self, request):\n        referer = request.META.get(\"HTTP_REFERER\")\n        if referer is None:\n            raise RejectRequest(REASON_NO_REFERER)\n\n        try:\n            referer = urlparse(referer)\n        except ValueError:\n            raise RejectRequest(REASON_MALFORMED_REFERER)\n\n        # Make sure we have a valid URL for Referer.\n        if \"\" in (referer.scheme, referer.netloc):\n            raise RejectRequest(REASON_MALFORMED_REFERER)\n\n        # Ensure that our Referer is also secure.\n        if referer.scheme != \"https\":\n            raise RejectRequest(REASON_INSECURE_REFERER)\n\n        if any(\n            is_same_domain(referer.netloc, host)\n            for host in self.csrf_trusted_origins_hosts\n        ):\n            return\n        # Allow matching the configured cookie domain.\n        good_referer = (\n            settings.SESSION_COOKIE_DOMAIN\n            if settings.CSRF_USE_SESSIONS\n            else settings.CSRF_COOKIE_DOMAIN\n        )\n        if good_referer is None:\n            # If no cookie domain is configured, allow matching the current\n            # host:port exactly if it's permitted by ALLOWED_HOSTS.\n            try:\n                # request.get_host() includes the port.\n                good_referer = request.get_host()\n            except DisallowedHost:\n                raise RejectRequest(REASON_BAD_REFERER % referer.geturl())\n        else:\n            server_port = request.get_port()\n            if server_port not in (\"443\", \"80\"):\n                good_referer = \"%s:%s\" % (good_referer, server_port)\n\n        if not is_same_domain(referer.netloc, good_referer):\n            raise RejectRequest(REASON_BAD_REFERER % referer.geturl())\n\n    def _bad_token_message(self, reason, token_source):\n        if token_source != \"POST\":\n            # Assume it is a settings.CSRF_HEADER_NAME value.\n            header_name = HttpHeaders.parse_header_name(token_source)\n            token_source = f\"the {header_name!r} HTTP header\"\n        return f\"CSRF token from {token_source} {reason}.\"",
                "filename": "django/middleware/csrf.py",
                "start_index": 10130,
                "end_index": 13056,
                "start_line": 270,
                "end_line": 346,
                "max_line": 482,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    Require a present and correct csrfmiddlewaretoken for POST requests that\n    have a CSRF cookie, and set an outgoing CSRF cookie.\n\n    This middleware should be used in conjunction with the {% csrf_token %}\n    template tag.\n    \"\"\"\n\n    @cached_property\n    def csrf_trusted_origins_hosts(self):\n        return [\n            urlparse(origin).netloc.lstrip(\"*\")\n            for origin in settings.CSRF_TRUSTED_ORIGINS\n        ]\n\n    @cached_property\n    def allowed_origins_exact(self):\n        return {origin for origin in settings.CSRF_TRUSTED_ORIGINS if \"*\" not in origin}\n\n    @cached_property\n    def allowed_origin_subdomains(self):\n        \"\"\"\n        A mapping of allowed schemes to list of allowed netlocs, where all\n        subdomains of the netloc are allowed.\n        \"\"\"\n        allowed_origin_subdomains = defaultdict(list)\n        for parsed in (\n            urlparse(origin)\n            for origin in settings.CSRF_TRUSTED_ORIGINS\n            if \"*\" in origin\n        ):\n            allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip(\"*\"))\n        return allowed_origin_subdomains\n\n    # The _accept and _reject methods currently only exist for the sake of the\n    # requires_csrf_token decorator.\n    def _accept(self, request):\n        # Avoid checking the request twice by adding a custom attribute to\n        # request.  This will be relevant when both decorator and middleware\n        # are used.\n        request.csrf_processing_done = True\n        return None\n\n    def _reject(self, request, reason):\n        response = _get_failure_view()(request, reason=reason)\n        log_response(\n            \"Forbidden (%s): %s\",\n            reason,\n            request.path,\n            response=response,\n            request=request,\n            logger=logger,\n        )\n        return response",
                "filename": "django/middleware/csrf.py",
                "start_index": 6140,
                "end_index": 7974,
                "start_line": 1,
                "end_line": 482,
                "max_line": 482,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "def _unmask_cipher_token(token):\n    \"\"\"\n    Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length\n    CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt\n    the second half to produce the original secret.\n    \"\"\"\n    mask = token[:CSRF_SECRET_LENGTH]\n    token = token[CSRF_SECRET_LENGTH:]\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))\n    return \"\".join(chars[x - y] for x, y in pairs)  # Note negative values are ok\n\n\ndef _add_new_csrf_cookie(request):\n    \"\"\"Generate a new random CSRF_COOKIE value, and add it to request.META.\"\"\"\n    csrf_secret = _get_new_csrf_string()\n    request.META.update(\n        {\n            \"CSRF_COOKIE\": csrf_secret,\n            \"CSRF_COOKIE_NEEDS_UPDATE\": True,\n        }\n    )\n    return csrf_secret\n\n\ndef get_token(request):\n    \"\"\"\n    Return the CSRF token required for a POST form. The token is an\n    alphanumeric value. A new token is created if one is not already set.\n\n    A side effect of calling this function is to make the csrf_protect\n    decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'\n    header to the outgoing response.  For this reason, you may need to use this\n    function lazily, as is done by the csrf context processor.\n    \"\"\"\n    if \"CSRF_COOKIE\" in request.META:\n        csrf_secret = request.META[\"CSRF_COOKIE\"]\n        # Since the cookie is being used, flag to send the cookie in\n        # process_response() (even if the client already has it) in order to\n        # renew the expiry timer.\n        request.META[\"CSRF_COOKIE_NEEDS_UPDATE\"] = True\n    else:\n        csrf_secret = _add_new_csrf_cookie(request)\n    return _mask_cipher_secret(csrf_secret)\n\n\ndef rotate_token(request):\n    \"\"\"\n    Change the CSRF token in use for a request - should be done on login\n    for security purposes.\n    \"\"\"\n    _add_new_csrf_cookie(request)\n\n\nclass InvalidTokenFormat(Exception):\n    def __init__(self, reason):\n        self.reason = reason\n\n\ndef _check_token_format(token):\n    \"\"\"\n    Raise an InvalidTokenFormat error if the token has an invalid length or\n    characters that aren't allowed. The token argument can be a CSRF cookie\n    secret or non-cookie CSRF token, and either masked or unmasked.\n    \"\"\"\n    if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):\n        raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)\n    # Make sure all characters are in CSRF_ALLOWED_CHARS.\n    if invalid_token_chars_re.search(token):\n        raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)",
                "filename": "django/middleware/csrf.py",
                "start_index": 2631,
                "end_index": 5216,
                "start_line": 70,
                "end_line": 139,
                "max_line": 482,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.middleware.csrf import CsrfViewMiddleware, get_token\nfrom django.utils.decorators import decorator_from_middleware\n\ncsrf_protect = decorator_from_middleware(CsrfViewMiddleware)\ncsrf_protect.__name__ = \"csrf_protect\"\ncsrf_protect.__doc__ = \"\"\"\nThis decorator adds CSRF protection in exactly the same way as\nCsrfViewMiddleware, but it can be used on a per view basis.  Using both, or\nusing the decorator multiple times, is harmless and efficient.\n\"\"\"\n\n\nclass _EnsureCsrfToken(CsrfViewMiddleware):\n    # Behave like CsrfViewMiddleware but don't reject requests or log warnings.\n    def _reject(self, request, reason):\n        return None\n\n\nrequires_csrf_token = decorator_from_middleware(_EnsureCsrfToken)\nrequires_csrf_token.__name__ = \"requires_csrf_token\"\nrequires_csrf_token.__doc__ = \"\"\"\nUse this decorator on views that need a correct csrf_token available to\nRequestContext, but without the CSRF protection that csrf_protect\nenforces.\n\"\"\"\n\n\nclass _EnsureCsrfCookie(CsrfViewMiddleware):\n    def _reject(self, request, reason):\n        return None\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        retval = super().process_view(request, callback, callback_args, callback_kwargs)\n        # Force process_response to send the cookie\n        get_token(request)\n        return retval\n\n\nensure_csrf_cookie = decorator_from_middleware(_EnsureCsrfCookie)\nensure_csrf_cookie.__name__ = \"ensure_csrf_cookie\"\nensure_csrf_cookie.__doc__ = \"\"\"\nUse this decorator to ensure that a view sets a CSRF cookie, whether or not it\nuses the csrf_token template tag, or the CsrfViewMiddleware is used.\n\"\"\"\n\n\ndef csrf_exempt(view_func):\n    \"\"\"Mark a view function as being exempt from the CSRF view protection.\"\"\"\n\n    # view_func.csrf_exempt = True would also work, but decorators are nicer\n    # if they don't have side effects, so return a new function.\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            return await view_func(request, *args, **kwargs)\n\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            return view_func(request, *args, **kwargs)\n\n    _view_wrapper.csrf_exempt = True\n\n    return wraps(view_func)(_view_wrapper)",
                "filename": "django/views/decorators/csrf.py",
                "start_index": 0,
                "end_index": 2323,
                "start_line": 1,
                "end_line": 69,
                "max_line": 69,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "def _check_token(self, request):\n        # Access csrf_secret via self._get_secret() as rotate_token() may have\n        # been called by an authentication middleware during the\n        # process_request() phase.\n        try:\n            csrf_secret = self._get_secret(request)\n        except InvalidTokenFormat as exc:\n            raise RejectRequest(f\"CSRF cookie {exc.reason}.\")\n\n        if csrf_secret is None:\n            # No CSRF cookie. For POST requests, we insist on a CSRF cookie,\n            # and in this way we can avoid all CSRF attacks, including login\n            # CSRF.\n            raise RejectRequest(REASON_NO_CSRF_COOKIE)\n\n        # Check non-cookie token for match.\n        request_csrf_token = \"\"\n        if request.method == \"POST\":\n            try:\n                request_csrf_token = request.POST.get(\"csrfmiddlewaretoken\", \"\")\n            except UnreadablePostError:\n                # Handle a broken connection before we've completed reading the\n                # POST data. process_view shouldn't raise any exceptions, so\n                # we'll ignore and serve the user a 403 (assuming they're still\n                # listening, which they probably aren't because of the error).\n                pass\n\n        if request_csrf_token == \"\":\n            # Fall back to X-CSRFToken, to make things easier for AJAX, and\n            # possible for PUT/DELETE.\n            try:\n                # This can have length CSRF_SECRET_LENGTH or CSRF_TOKEN_LENGTH,\n                # depending on whether the client obtained the token from\n                # the DOM or the cookie (and if the cookie, whether the cookie\n                # was masked or unmasked).\n                request_csrf_token = request.META[settings.CSRF_HEADER_NAME]\n            except KeyError:\n                raise RejectRequest(REASON_CSRF_TOKEN_MISSING)\n            token_source = settings.CSRF_HEADER_NAME\n        else:\n            token_source = \"POST\"\n\n        try:\n            _check_token_format(request_csrf_token)\n        except InvalidTokenFormat as exc:\n            reason = self._bad_token_message(exc.reason, token_source)\n            raise RejectRequest(reason)\n\n        if not _does_token_match(request_csrf_token, csrf_secret):\n            reason = self._bad_token_message(\"incorrect\", token_source)\n            raise RejectRequest(reason)\n\n    def process_request(self, request):\n        try:\n            csrf_secret = self._get_secret(request)\n        except InvalidTokenFormat:\n            _add_new_csrf_cookie(request)\n        else:\n            if csrf_secret is not None:\n                # Use the same secret next time. If the secret was originally\n                # masked, this also causes it to be replaced with the unmasked\n                # form, but only in cases where the secret is already getting\n                # saved anyways.\n                request.META[\"CSRF_COOKIE\"] = csrf_secret",
                "filename": "django/middleware/csrf.py",
                "start_index": 13062,
                "end_index": 15971,
                "start_line": 348,
                "end_line": 411,
                "max_line": 482,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "import inspect\n\nfrom django.conf import settings\n\nfrom .. import Error, Tags, Warning, register\n\nW003 = Warning(\n    \"You don't appear to be using Django's built-in \"\n    \"cross-site request forgery protection via the middleware \"\n    \"('django.middleware.csrf.CsrfViewMiddleware' is not in your \"\n    \"MIDDLEWARE). Enabling the middleware is the safest approach \"\n    \"to ensure you don't leave any holes.\",\n    id=\"security.W003\",\n)\n\nW016 = Warning(\n    \"You have 'django.middleware.csrf.CsrfViewMiddleware' in your \"\n    \"MIDDLEWARE, but you have not set CSRF_COOKIE_SECURE to True. \"\n    \"Using a secure-only CSRF cookie makes it more difficult for network \"\n    \"traffic sniffers to steal the CSRF token.\",\n    id=\"security.W016\",\n)\n\n\ndef _csrf_middleware():\n    return \"django.middleware.csrf.CsrfViewMiddleware\" in settings.MIDDLEWARE\n\n\n@register(Tags.security, deploy=True)\ndef check_csrf_middleware(app_configs, **kwargs):\n    passed_check = _csrf_middleware()\n    return [] if passed_check else [W003]\n\n\n@register(Tags.security, deploy=True)\ndef check_csrf_cookie_secure(app_configs, **kwargs):\n    passed_check = (\n        settings.CSRF_USE_SESSIONS\n        or not _csrf_middleware()\n        or settings.CSRF_COOKIE_SECURE is True\n    )\n    return [] if passed_check else [W016]\n\n\n@register(Tags.security)\ndef check_csrf_failure_view(app_configs, **kwargs):\n    from django.middleware.csrf import _get_failure_view\n\n    errors = []\n    try:\n        view = _get_failure_view()\n    except ImportError:\n        msg = (\n            \"The CSRF failure view '%s' could not be imported.\"\n            % settings.CSRF_FAILURE_VIEW\n        )\n        errors.append(Error(msg, id=\"security.E102\"))\n    else:\n        try:\n            inspect.signature(view).bind(None, reason=None)\n        except TypeError:\n            msg = (\n                \"The CSRF failure view '%s' does not take the correct number of \"\n                \"arguments.\" % settings.CSRF_FAILURE_VIEW\n            )\n            errors.append(Error(msg, id=\"security.E101\"))\n    return errors",
                "filename": "django/core/checks/security/csrf.py",
                "start_index": 0,
                "end_index": 2054,
                "start_line": 1,
                "end_line": 67,
                "max_line": 67,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "from django.middleware.csrf import get_token\nfrom django.utils.functional import lazy\nfrom django.utils.html import format_html\nfrom django.utils.safestring import SafeString\n\n\ndef csrf_input(request):\n    return format_html(\n        '<input type=\"hidden\" name=\"csrfmiddlewaretoken\" value=\"{}\">',\n        get_token(request),\n    )\n\n\ncsrf_input_lazy = lazy(csrf_input, SafeString, str)\ncsrf_token_lazy = lazy(get_token, str)",
                "filename": "django/template/backends/utils.py",
                "start_index": 0,
                "end_index": 423,
                "start_line": 1,
                "end_line": 15,
                "max_line": 15,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            },
            {
                "code": "from django.conf import settings\n\nfrom .. import Tags, Warning, register\n\n\ndef add_session_cookie_message(message):\n    return message + (\n        \" Using a secure-only session cookie makes it more difficult for \"\n        \"network traffic sniffers to hijack user sessions.\"\n    )\n\n\nW010 = Warning(\n    add_session_cookie_message(\n        \"You have 'django.contrib.sessions' in your INSTALLED_APPS, \"\n        \"but you have not set SESSION_COOKIE_SECURE to True.\"\n    ),\n    id=\"security.W010\",\n)\n\nW011 = Warning(\n    add_session_cookie_message(\n        \"You have 'django.contrib.sessions.middleware.SessionMiddleware' \"\n        \"in your MIDDLEWARE, but you have not set \"\n        \"SESSION_COOKIE_SECURE to True.\"\n    ),\n    id=\"security.W011\",\n)\n\nW012 = Warning(\n    add_session_cookie_message(\"SESSION_COOKIE_SECURE is not set to True.\"),\n    id=\"security.W012\",\n)\n\n\ndef add_httponly_message(message):\n    return message + (\n        \" Using an HttpOnly session cookie makes it more difficult for \"\n        \"cross-site scripting attacks to hijack user sessions.\"\n    )\n\n\nW013 = Warning(\n    add_httponly_message(\n        \"You have 'django.contrib.sessions' in your INSTALLED_APPS, \"\n        \"but you have not set SESSION_COOKIE_HTTPONLY to True.\",\n    ),\n    id=\"security.W013\",\n)\n\nW014 = Warning(\n    add_httponly_message(\n        \"You have 'django.contrib.sessions.middleware.SessionMiddleware' \"\n        \"in your MIDDLEWARE, but you have not set \"\n        \"SESSION_COOKIE_HTTPONLY to True.\"\n    ),\n    id=\"security.W014\",\n)\n\nW015 = Warning(\n    add_httponly_message(\"SESSION_COOKIE_HTTPONLY is not set to True.\"),\n    id=\"security.W015\",\n)\n\n\n@register(Tags.security, deploy=True)\ndef check_session_cookie_secure(app_configs, **kwargs):\n    if settings.SESSION_COOKIE_SECURE is True:\n        return []\n    errors = []\n    if _session_app():\n        errors.append(W010)\n    if _session_middleware():\n        errors.append(W011)\n    if len(errors) > 1:\n        errors = [W012]\n    return errors\n\n\n@register(Tags.security, deploy=True)\ndef check_session_cookie_httponly(app_configs, **kwargs):\n    if settings.SESSION_COOKIE_HTTPONLY is True:\n        return []\n    errors = []\n    if _session_app():\n        errors.append(W013)\n    if _session_middleware():\n        errors.append(W014)\n    if len(errors) > 1:\n        errors = [W015]\n    return errors\n\n\ndef _session_middleware():\n    return \"django.contrib.sessions.middleware.SessionMiddleware\" in settings.MIDDLEWARE\n\n\ndef _session_app():\n    return \"django.contrib.sessions\" in settings.INSTALLED_APPS",
                "filename": "django/core/checks/security/sessions.py",
                "start_index": 0,
                "end_index": 2553,
                "start_line": 1,
                "end_line": 99,
                "max_line": 99,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.0",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/middleware/csrf.py": [
                {
                    "chunk": {
                        "code": "def _origin_verified(self, request):\n        request_origin = request.META[\"HTTP_ORIGIN\"]\n        try:\n            good_host = request.get_host()\n        except DisallowedHost:\n            pass\n        else:\n            good_origin = \"%s://%s\" % (\n                \"https\" if request.is_secure() else \"http\",\n                good_host,\n            )\n            if request_origin == good_origin:\n                return True\n        if request_origin in self.allowed_origins_exact:\n            return True\n        try:\n            parsed_origin = urlparse(request_origin)\n        except ValueError:\n            return False\n        request_scheme = parsed_origin.scheme\n        request_netloc = parsed_origin.netloc\n        return any(\n            is_same_domain(request_netloc, host)\n            for host in self.allowed_origin_subdomains.get(request_scheme, ())\n        )\n\n    def _check_referer(self, request):\n        referer = request.META.get(\"HTTP_REFERER\")\n        if referer is None:\n            raise RejectRequest(REASON_NO_REFERER)\n\n        try:\n            referer = urlparse(referer)\n        except ValueError:\n            raise RejectRequest(REASON_MALFORMED_REFERER)\n\n        # Make sure we have a valid URL for Referer.\n        if \"\" in (referer.scheme, referer.netloc):\n            raise RejectRequest(REASON_MALFORMED_REFERER)\n\n        # Ensure that our Referer is also secure.\n        if referer.scheme != \"https\":\n            raise RejectRequest(REASON_INSECURE_REFERER)\n\n        if any(\n            is_same_domain(referer.netloc, host)\n            for host in self.csrf_trusted_origins_hosts\n        ):\n            return\n        # Allow matching the configured cookie domain.\n        good_referer = (\n            settings.SESSION_COOKIE_DOMAIN\n            if settings.CSRF_USE_SESSIONS\n            else settings.CSRF_COOKIE_DOMAIN\n        )\n        if good_referer is None:\n            # If no cookie domain is configured, allow matching the current\n            # host:port exactly if it's permitted by ALLOWED_HOSTS.\n            try:\n                # request.get_host() includes the port.\n                good_referer = request.get_host()\n            except DisallowedHost:\n                raise RejectRequest(REASON_BAD_REFERER % referer.geturl())\n        else:\n            server_port = request.get_port()\n            if server_port not in (\"443\", \"80\"):\n                good_referer = \"%s:%s\" % (good_referer, server_port)\n\n        if not is_same_domain(referer.netloc, good_referer):\n            raise RejectRequest(REASON_BAD_REFERER % referer.geturl())\n\n    def _bad_token_message(self, reason, token_source):\n        if token_source != \"POST\":\n            # Assume it is a settings.CSRF_HEADER_NAME value.\n            header_name = HttpHeaders.parse_header_name(token_source)\n            token_source = f\"the {header_name!r} HTTP header\"\n        return f\"CSRF token from {token_source} {reason}.\"",
                        "filename": "django/middleware/csrf.py",
                        "start_index": 10130,
                        "end_index": 13056,
                        "start_line": 270,
                        "end_line": 346,
                        "max_line": 482,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the _bad_token_message method that constructs the CSRF token error message, which is directly related to the issue."
                },
                {
                    "chunk": {
                        "code": "\"\"\"\nCross Site Request Forgery Middleware.\n\nThis module provides a middleware that implements protection\nagainst request forgeries from other sites.\n\"\"\"\nimport logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost, ImproperlyConfigured\nfrom django.http import HttpHeaders, UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare, get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\n\nlogger = logging.getLogger(\"django.security.csrf\")\n# This matches if any character is not in CSRF_ALLOWED_CHARS.\ninvalid_token_chars_re = _lazy_re_compile(\"[^a-zA-Z0-9]\")\n\nREASON_BAD_ORIGIN = \"Origin checking failed - %s does not match any trusted origins.\"\nREASON_NO_REFERER = \"Referer checking failed - no Referer.\"\nREASON_BAD_REFERER = \"Referer checking failed - %s does not match any trusted origins.\"\nREASON_NO_CSRF_COOKIE = \"CSRF cookie not set.\"\nREASON_CSRF_TOKEN_MISSING = \"CSRF token missing.\"\nREASON_MALFORMED_REFERER = \"Referer checking failed - Referer is malformed.\"\nREASON_INSECURE_REFERER = (\n    \"Referer checking failed - Referer is insecure while host is secure.\"\n)\n# The reason strings below are for passing to InvalidTokenFormat. They are\n# phrases without a subject because they can be in reference to either the CSRF\n# cookie or non-cookie token.\nREASON_INCORRECT_LENGTH = \"has incorrect length\"\nREASON_INVALID_CHARACTERS = \"has invalid characters\"\n\nCSRF_SECRET_LENGTH = 32\nCSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH\nCSRF_ALLOWED_CHARS = string.ascii_letters + string.digits\nCSRF_SESSION_KEY = \"_csrftoken\"\n\n\ndef _get_failure_view():\n    \"\"\"Return the view to be used for CSRF rejections.\"\"\"\n    return get_callable(settings.CSRF_FAILURE_VIEW)\n\n\ndef _get_new_csrf_string():\n    return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)\n\n\ndef _mask_cipher_secret(secret):\n    \"\"\"\n    Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a\n    token by adding a mask and applying it to the secret.\n    \"\"\"\n    mask = _get_new_csrf_string()\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))\n    cipher = \"\".join(chars[(x + y) % len(chars)] for x, y in pairs)\n    return mask + cipher",
                        "filename": "django/middleware/csrf.py",
                        "start_index": 0,
                        "end_index": 2628,
                        "start_line": 1,
                        "end_line": 67,
                        "max_line": 482,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the constants for CSRF token error messages, which will need to be updated to include the token source as per the issue."
                },
                {
                    "chunk": {
                        "code": "def _check_token(self, request):\n        # Access csrf_secret via self._get_secret() as rotate_token() may have\n        # been called by an authentication middleware during the\n        # process_request() phase.\n        try:\n            csrf_secret = self._get_secret(request)\n        except InvalidTokenFormat as exc:\n            raise RejectRequest(f\"CSRF cookie {exc.reason}.\")\n\n        if csrf_secret is None:\n            # No CSRF cookie. For POST requests, we insist on a CSRF cookie,\n            # and in this way we can avoid all CSRF attacks, including login\n            # CSRF.\n            raise RejectRequest(REASON_NO_CSRF_COOKIE)\n\n        # Check non-cookie token for match.\n        request_csrf_token = \"\"\n        if request.method == \"POST\":\n            try:\n                request_csrf_token = request.POST.get(\"csrfmiddlewaretoken\", \"\")\n            except UnreadablePostError:\n                # Handle a broken connection before we've completed reading the\n                # POST data. process_view shouldn't raise any exceptions, so\n                # we'll ignore and serve the user a 403 (assuming they're still\n                # listening, which they probably aren't because of the error).\n                pass\n\n        if request_csrf_token == \"\":\n            # Fall back to X-CSRFToken, to make things easier for AJAX, and\n            # possible for PUT/DELETE.\n            try:\n                # This can have length CSRF_SECRET_LENGTH or CSRF_TOKEN_LENGTH,\n                # depending on whether the client obtained the token from\n                # the DOM or the cookie (and if the cookie, whether the cookie\n                # was masked or unmasked).\n                request_csrf_token = request.META[settings.CSRF_HEADER_NAME]\n            except KeyError:\n                raise RejectRequest(REASON_CSRF_TOKEN_MISSING)\n            token_source = settings.CSRF_HEADER_NAME\n        else:\n            token_source = \"POST\"\n\n        try:\n            _check_token_format(request_csrf_token)\n        except InvalidTokenFormat as exc:\n            reason = self._bad_token_message(exc.reason, token_source)\n            raise RejectRequest(reason)\n\n        if not _does_token_match(request_csrf_token, csrf_secret):\n            reason = self._bad_token_message(\"incorrect\", token_source)\n            raise RejectRequest(reason)\n\n    def process_request(self, request):\n        try:\n            csrf_secret = self._get_secret(request)\n        except InvalidTokenFormat:\n            _add_new_csrf_cookie(request)\n        else:\n            if csrf_secret is not None:\n                # Use the same secret next time. If the secret was originally\n                # masked, this also causes it to be replaced with the unmasked\n                # form, but only in cases where the secret is already getting\n                # saved anyways.\n                request.META[\"CSRF_COOKIE\"] = csrf_secret",
                        "filename": "django/middleware/csrf.py",
                        "start_index": 13062,
                        "end_index": 15971,
                        "start_line": 348,
                        "end_line": 411,
                        "max_line": 482,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the _check_token method where the CSRF token is checked and the error message is generated, which will need to be modified to include the token source."
                }
            ]
        },
        "solution_task": "To implement the feature request described in the ticket, you will need to modify the `_bad_token_message` method in the `CsrfViewMiddleware` class to include information about where the CSRF token was obtained from (either POST data or a custom header). Here's how you can do it:\n\n- Locate the `_bad_token_message` method in the `CsrfViewMiddleware` class within the `django/middleware/csrf.py` file.\n- Modify the method to check the `token_source` and include the appropriate message based on whether the token came from POST data or the custom header.\n\nHere's a code snippet that demonstrates the changes:\n\n```python\n# django/middleware/csrf.py\n\nclass CsrfViewMiddleware(MiddlewareMixin):\n    # ... (other methods and properties)\n\n    def _bad_token_message(self, reason, token_source):\n        # Check if the token source is from POST data or from the custom header\n        if token_source == \"POST\":\n            token_source_info = \"from POST\"\n        else:\n            # Assume it is from the custom header specified in settings.CSRF_HEADER_NAME\n            header_name = HttpHeaders.parse_header_name(settings.CSRF_HEADER_NAME)\n            token_source_info = f\"from '{header_name}' header\"\n        \n        # Return the modified message with the token source information\n        return f\"CSRF token ({token_source_info}) {reason}.\"\n\n    # ... (other methods and properties)\n```\n\nMake sure to test the changes thoroughly. You can create unit tests that check for the correct error messages when a bad CSRF token is encountered from either POST data or the custom header. The ticket mentions that the changes to `CsrfViewMiddlewareTestMixin` proposed in #32800 would make these cases easy to test, so you should also review and possibly integrate those test changes.\n\nAfter implementing the feature and testing it, you should follow your project's procedures for code review, documentation, and deployment to integrate the new feature into the software project.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable guide on how to implement the feature request. It specifies the exact location of the code that needs to be modified, offers a detailed code snippet demonstrating the necessary changes, and even includes a conditional check to determine the source of the CSRF token. Additionally, the RESPONSE suggests reviewing and integrating related test changes from a proposed ticket, which is a valuable recommendation for ensuring the feature is properly tested. The inclusion of links to the relevant code snippets in the Django repository is a helpful resource for the developer tasked with implementing this feature. The RESPONSE only lacks a minor detail about handling potential exceptions or edge cases that might arise from the changes, which is why it does not score a perfect 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711722737.384531,
        "result": "To implement the feature request described in the ticket, you will need to modify the `_bad_token_message` method in the `CsrfViewMiddleware` class to include information about where the CSRF token was obtained from (either POST data or a custom header). Here's how you can do it:\n\n- Locate the `_bad_token_message` method in the `CsrfViewMiddleware` class within the `django/middleware/csrf.py` file.\n- Modify the method to check the `token_source` and include the appropriate message based on whether the token came from POST data or the custom header.\n\nHere's a code snippet that demonstrates the changes:\n\n```python\n# django/middleware/csrf.py\n\nclass CsrfViewMiddleware(MiddlewareMixin):\n    # ... (other methods and properties)\n\n    def _bad_token_message(self, reason, token_source):\n        # Check if the token source is from POST data or from the custom header\n        if token_source == \"POST\":\n            token_source_info = \"from POST\"\n        else:\n            # Assume it is from the custom header specified in settings.CSRF_HEADER_NAME\n            header_name = HttpHeaders.parse_header_name(settings.CSRF_HEADER_NAME)\n            token_source_info = f\"from '{header_name}' header\"\n        \n        # Return the modified message with the token source information\n        return f\"CSRF token ({token_source_info}) {reason}.\"\n\n    # ... (other methods and properties)\n```\n\nMake sure to test the changes thoroughly. You can create unit tests that check for the correct error messages when a bad CSRF token is encountered from either POST data or the custom header. The ticket mentions that the changes to `CsrfViewMiddlewareTestMixin` proposed in #32800 would make these cases easy to test, so you should also review and possibly integrate those test changes.\n\nAfter implementing the feature and testing it, you should follow your project's procedures for code review, documentation, and deployment to integrate the new feature into the software project.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.0/tree//django) \u2192 [middleware](https://github.com/testbed/django__django__4.0/tree//django/middleware)- [Lines 270 - 346](https://github.com/testbed/django__django__4.0/blob//django/middleware/csrf.py#L270-L346)\n\n This snippet contains the _bad_token_message method that constructs the CSRF token error message, which is directly related to the issue. \n\n\n   - [Lines 1 - 67](https://github.com/testbed/django__django__4.0/blob//django/middleware/csrf.py#L1-L67)\n\n This snippet defines the constants for CSRF token error messages, which will need to be updated to include the token source as per the issue. \n\n\n   - [Lines 348 - 411](https://github.com/testbed/django__django__4.0/blob//django/middleware/csrf.py#L348-L411)\n\n This snippet includes the _check_token method where the CSRF token is checked and the error message is generated, which will need to be modified to include the token source."
    }
}