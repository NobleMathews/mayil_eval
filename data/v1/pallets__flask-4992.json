{
    "id": "pallets__flask-4992",
    "repo_name": "testbed/pallets__flask__2.3",
    "task_id": 4596713564497563145,
    "title": "Add a file mode parameter to flask.Config.from_file()",
    "body": "Python 3.11 introduced native TOML support with the `tomllib` package. This could work nicely with the `flask.Config.from_file()` method as an easy way to load TOML config files:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", tomllib.load)\r\n```\r\n\r\nHowever, `tomllib.load()` takes an object readable in binary mode, while `flask.Config.from_file()` opens a file in text mode, resulting in this error:\r\n\r\n```\r\nTypeError: File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\r\n```\r\n\r\nWe can get around this with a more verbose expression, like loading from a file opened with the built-in `open()` function and passing the `dict` to `app.Config.from_mapping()`:\r\n\r\n```python\r\n# We have to repeat the path joining that from_file() does\r\nwith open(os.path.join(app.config.root_path, \"config.toml\"), \"rb\") as file:\r\n    app.config.from_mapping(tomllib.load(file))\r\n```\r\n\r\nBut adding a file mode parameter to `flask.Config.from_file()` would enable the use of a simpler expression. E.g.:\r\n\r\n```python\r\napp.config.from_file(\"config.toml\", tomllib.load, mode=\"b\")\r\n```\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pallets__flask__2.3.git",
    "requested_commit": "",
    "mayil_response": "To implement the requested feature, you need to modify the `from_file` method in the `flask.Config` class to accept a new parameter that specifies the file mode. Here's how you can do it:\n\n- Add a new parameter `mode` to the `from_file` method with a default value of `\"t\"` for text mode.\n- Use the `mode` parameter when opening the file.\n- Update the documentation to reflect the new parameter.\n\nHere's the updated `from_file` method:\n\n```python\ndef from_file(\n    self,\n    filename: str | os.PathLike,\n    load: t.Callable[[t.IO[t.Any]], t.Mapping],\n    silent: bool = False,\n    text: bool = True,  # Keep this for backward compatibility\n    mode: str = \"t\",  # New parameter for specifying file mode\n) -> bool:\n    \"\"\"Update the values in the config from a file that is loaded\n    using the ``load`` parameter. The loaded data is passed to the\n    :meth:`from_mapping` method.\n\n    :param filename: The path to the data file. This can be an\n        absolute path or relative to the config root path.\n    :param load: A callable that takes a file handle and returns a\n        mapping of loaded data from the file.\n    :param silent: Ignore the file if it doesn't exist.\n    :param text: Open the file in text or binary mode. Deprecated in favor of 'mode'.\n    :param mode: The mode in which to open the file. Use 't' for text mode (default) and 'b' for binary mode.\n    :return: ``True`` if the file was loaded successfully.\n\n    .. versionchanged:: 2.3\n        The ``text`` parameter was added.\n    .. versionchanged:: Next\n        The ``mode`` parameter was added to specify file mode.\n    \"\"\"\n    filename = os.path.join(self.root_path, filename)\n\n    file_mode = \"r\" + mode  # Combine 'r' with the mode ('t' or 'b')\n\n    try:\n        with open(filename, file_mode) as f:\n            obj = load(f)\n    except OSError as e:\n        if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n            return False\n\n        e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n        raise\n\n    return self.from_mapping(obj)\n```\n\nMake sure to update the documentation and any tests that use the `from_file` method to reflect these changes. Additionally, consider deprecating the `text` parameter in favor of the new `mode` parameter to avoid confusion in the future.\n\n### Code snippets to check\n\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.3/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.3/tree//src/flask)- [Lines 236 - 301](https://github.com/testbed/pallets__flask__2.3/blob//src/flask/config.py#L236-L301)\n\n This snippet contains the 'from_file' method of the 'flask.Config' class, which is directly related to the issue. The 'text' parameter needs to be replaced with a 'mode' parameter to allow binary mode file opening.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000549,
        "snippet_processor": 0.056350000000000004,
        "issue_star_creation": 0.02536,
        "issue_star_solver": 0.060500000000000005,
        "bouncer": 0.028820000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711742750.541882,
        "relevant_snippets": [
            {
                "code": "def from_file(\n        self,\n        filename: str | os.PathLike,\n        load: t.Callable[[t.IO[t.Any]], t.Mapping],\n        silent: bool = False,\n        text: bool = True,\n    ) -> bool:\n        \"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import json\n            app.config.from_file(\"config.json\", load=json.load)\n\n            import tomllib\n            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n        :param text: Open the file in text or binary mode.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionchanged:: 2.3\n            The ``text`` parameter was added.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename, \"r\" if text else \"rb\") as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)\n\n    def from_mapping(\n        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any\n    ) -> bool:\n        \"\"\"Updates the config like :meth:`update` ignoring items with\n        non-upper keys.\n\n        :return: Always returns ``True``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings: dict[str, t.Any] = {}\n        if mapping is not None:\n            mappings.update(mapping)\n        mappings.update(kwargs)\n        for key, value in mappings.items():\n            if key.isupper():\n                self[key] = value\n        return True",
                "filename": "src/flask/config.py",
                "start_index": 8897,
                "end_index": 11146,
                "start_line": 236,
                "end_line": 301,
                "max_line": 347,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "\"\"\"Works exactly like a dict but provides ways to fill it from files\n    or special dictionaries.  There are two common patterns to populate the\n    config.\n\n    Either you can fill the config from a config file::\n\n        app.config.from_pyfile('yourconfig.cfg')\n\n    Or alternatively you can define the configuration options in the\n    module that calls :meth:`from_object` or provide an import path to\n    a module that should be loaded.  It is also possible to tell it to\n    use the same module and with that provide the configuration values\n    just before the call::\n\n        DEBUG = True\n        SECRET_KEY = 'development key'\n        app.config.from_object(__name__)\n\n    In both cases (loading from any Python file or loading from modules),\n    only uppercase keys are added to the config.  This makes it possible to use\n    lowercase values in the config file for temporary values that are not added\n    to the config or to define the config keys in the same file that implements\n    the application.\n\n    Probably the most interesting way to load configurations is from an\n    environment variable pointing to a file::\n\n        app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\n    In this case before launching the application you have to set this\n    environment variable to the file you want to use.  On Linux and OS X\n    use the export statement::\n\n        export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n\n    On windows use `set` instead.\n\n    :param root_path: path to which files are read relative from.  When the\n                      config object is created by the application, this is\n                      the application's :attr:`~flask.Flask.root_path`.\n    :param defaults: an optional dictionary of default values\n    \"\"\"\n\n    def __init__(\n        self, root_path: str | os.PathLike, defaults: dict | None = None\n    ) -> None:\n        super().__init__(defaults or {})\n        self.root_path = root_path\n\n    def from_envvar(self, variable_name: str, silent: bool = False) -> bool:\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                f\"The environment variable {variable_name!r} is not set\"\n                \" and as such configuration could not be loaded. Set\"\n                \" this variable and make it point to a configuration\"\n                \" file\"\n            )\n        return self.from_pyfile(rv, silent=silent)",
                "filename": "src/flask/config.py",
                "start_index": 758,
                "end_index": 3746,
                "start_line": 32,
                "end_line": 103,
                "max_line": 347,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:\n    # If the flag isn't provided, it will default to False. Don't use\n    # that, let debug be set by env in that case.\n    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]\n\n    if source is not None and source in (\n        ParameterSource.DEFAULT,\n        ParameterSource.DEFAULT_MAP,\n    ):\n        return None\n\n    # Set with env var instead of ScriptInfo.load so that it can be\n    # accessed early during a factory function.\n    os.environ[\"FLASK_DEBUG\"] = \"1\" if value else \"0\"\n    return value\n\n\n_debug_option = click.Option(\n    [\"--debug/--no-debug\"],\n    help=\"Set debug mode.\",\n    expose_value=False,\n    callback=_set_debug,\n)\n\n\ndef _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    if value is None:\n        return None\n\n    import importlib\n\n    try:\n        importlib.import_module(\"dotenv\")\n    except ImportError:\n        raise click.BadParameter(\n            \"python-dotenv must be installed to load an env file.\",\n            ctx=ctx,\n            param=param,\n        ) from None\n\n    # Don't check FLASK_SKIP_DOTENV, that only disables automatically\n    # loading .env and .flaskenv files.\n    load_dotenv(value)\n    return value\n\n\n# This option is eager so env vars are loaded as early as possible to be\n# used by other options.\n_env_file_option = click.Option(\n    [\"-e\", \"--env-file\"],\n    type=click.Path(exists=True, dir_okay=False),\n    help=\"Load environment variables from this file. python-dotenv must be installed.\",\n    is_eager=True,\n    expose_value=False,\n    callback=_env_file_callback,\n)",
                "filename": "src/flask/cli.py",
                "start_index": 13423,
                "end_index": 15110,
                "start_line": 422,
                "end_line": 1068,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .ctx import RequestContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nthe current application. To solve this, set up an application context\nwith app.app_context(). See the documentation for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContext = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: Flask = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nThis typically means that you attempted to use functionality that needed\nan active HTTP request. Consult the documentation on testing for\ninformation about how to avoid this problem.\\\n\"\"\"\n_cv_request: ContextVar[RequestContext] = ContextVar(\"flask.request_ctx\")\nrequest_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]\n    _cv_request, unbound_message=_no_req_msg\n)\nrequest: Request = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixin = LocalProxy(  # type: ignore[assignment]\n    _cv_request, \"session\", unbound_message=_no_req_msg\n)",
                "filename": "src/flask/globals.py",
                "start_index": 0,
                "end_index": 1712,
                "start_line": 1,
                "end_line": 51,
                "max_line": 51,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\n\nimport importlib.util\nimport os\nimport sys\nimport typing as t\nfrom datetime import datetime\nfrom functools import lru_cache\nfrom functools import update_wrapper\n\nimport werkzeug.utils\nfrom werkzeug.exceptions import abort as _wz_abort\nfrom werkzeug.utils import redirect as _wz_redirect\n\nfrom .globals import _cv_request\nfrom .globals import current_app\nfrom .globals import request\nfrom .globals import request_ctx\nfrom .globals import session\nfrom .signals import message_flashed\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from werkzeug.wrappers import Response as BaseResponse\n    from .wrappers import Response\n\n\ndef get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})\n\n\ndef get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")",
                "filename": "src/flask/helpers.py",
                "start_index": 0,
                "end_index": 1365,
                "start_line": 1,
                "end_line": 47,
                "max_line": 623,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "def prepare_import(path):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    path = os.path.realpath(path)\n\n    fname, ext = os.path.splitext(path)\n    if ext == \".py\":\n        path = fname\n\n    if os.path.basename(path) == \"__init__\":\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, \"__init__.py\")):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return \".\".join(module_name[::-1])\n\n\ndef locate_app(module_name, app_name, raise_if_not_found=True):\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n\n    flask_version = importlib.metadata.version(\"flask\")\n    werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    click.echo(\n        f\"Python {platform.python_version()}\\n\"\n        f\"Flask {flask_version}\\n\"\n        f\"Werkzeug {werkzeug_version}\",\n        color=ctx.color,\n    )\n    ctx.exit()\n\n\nversion_option = click.Option(\n    [\"--version\"],\n    help=\"Show the Flask version.\",\n    expose_value=False,\n    callback=get_version,\n    is_flag=True,\n    is_eager=True,\n)",
                "filename": "src/flask/cli.py",
                "start_index": 5696,
                "end_index": 7834,
                "start_line": 188,
                "end_line": 1068,
                "max_line": 1068,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\n\nimport typing as t\n\nfrom .blueprints import Blueprint\nfrom .globals import request_ctx\nfrom .sansio.app import App\n\n\nclass UnexpectedUnicodeError(AssertionError, UnicodeError):\n    \"\"\"Raised in places where we want some better error reporting for\n    unexpected unicode or binary data.\n    \"\"\"\n\n\nclass DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError/BadRequest.\n    \"\"\"\n\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = [\n            f\"You tried to access the file {key!r} in the request.files\"\n            \" dictionary but it does not exist. The mimetype for the\"\n            f\" request is {request.mimetype!r} instead of\"\n            \" 'multipart/form-data' which means that no file contents\"\n            \" were transmitted. To fix this error you should provide\"\n            ' enctype=\"multipart/form-data\" in your form.'\n        ]\n        if form_matches:\n            names = \", \".join(repr(x) for x in form_matches)\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                f\"This was submitted: {names}\"\n            )\n        self.msg = \"\".join(buf)\n\n    def __str__(self):\n        return self.msg\n\n\nclass FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised in debug mode if a routing redirect\n    would cause the browser to drop the method or body. This happens\n    when method is not GET, HEAD or OPTIONS and the status code is not\n    307 or 308.\n    \"\"\"\n\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = [\n            f\"A request was sent to '{request.url}', but routing issued\"\n            f\" a redirect to the canonical URL '{exc.new_url}'.\"\n        ]\n\n        if f\"{request.base_url}/\" == exc.new_url.partition(\"?\")[0]:\n            buf.append(\n                \" The URL was defined with a trailing slash. Flask\"\n                \" will redirect to the URL with a trailing slash if it\"\n                \" was accessed without one.\"\n            )\n\n        buf.append(\n            \" Send requests to the canonical URL, or use 307 or 308 for\"\n            \" routing redirects. Otherwise, browsers will drop form\"\n            \" data.\\n\\n\"\n            \"This exception is only raised in debug mode.\"\n        )\n        super().__init__(\"\".join(buf))",
                "filename": "src/flask/debughelpers.py",
                "start_index": 0,
                "end_index": 2489,
                "start_line": 1,
                "end_line": 70,
                "max_line": 160,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "from __future__ import annotations\n\nimport errno\nimport json\nimport os\nimport types\nimport typing as t\n\nfrom werkzeug.utils import import_string\n\n\nclass ConfigAttribute:\n    \"\"\"Makes an attribute forward to the config\"\"\"\n\n    def __init__(self, name: str, get_converter: t.Callable | None = None) -> None:\n        self.__name__ = name\n        self.get_converter = get_converter\n\n    def __get__(self, obj: t.Any, owner: t.Any = None) -> t.Any:\n        if obj is None:\n            return self\n        rv = obj.config[self.__name__]\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n        return rv\n\n    def __set__(self, obj: t.Any, value: t.Any) -> None:\n        obj.config[self.__name__] = value",
                "filename": "src/flask/config.py",
                "start_index": 0,
                "end_index": 731,
                "start_line": 1,
                "end_line": 28,
                "max_line": 347,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "def from_pyfile(self, filename: str | os.PathLike, silent: bool = False) -> bool:\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n        self.from_object(d)\n        return True\n\n    def from_object(self, obj: object | str) -> None:\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)",
                "filename": "src/flask/config.py",
                "start_index": 5968,
                "end_index": 8891,
                "start_line": 169,
                "end_line": 234,
                "max_line": 347,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            },
            {
                "code": "default_config = ImmutableDict(\n        {\n            \"DEBUG\": None,\n            \"TESTING\": False,\n            \"PROPAGATE_EXCEPTIONS\": None,\n            \"SECRET_KEY\": None,\n            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),\n            \"USE_X_SENDFILE\": False,\n            \"SERVER_NAME\": None,\n            \"APPLICATION_ROOT\": \"/\",\n            \"SESSION_COOKIE_NAME\": \"session\",\n            \"SESSION_COOKIE_DOMAIN\": None,\n            \"SESSION_COOKIE_PATH\": None,\n            \"SESSION_COOKIE_HTTPONLY\": True,\n            \"SESSION_COOKIE_SECURE\": False,\n            \"SESSION_COOKIE_SAMESITE\": None,\n            \"SESSION_REFRESH_EACH_REQUEST\": True,\n            \"MAX_CONTENT_LENGTH\": None,\n            \"SEND_FILE_MAX_AGE_DEFAULT\": None,\n            \"TRAP_BAD_REQUEST_ERRORS\": None,\n            \"TRAP_HTTP_EXCEPTIONS\": False,\n            \"EXPLAIN_TEMPLATE_LOADING\": False,\n            \"PREFERRED_URL_SCHEME\": \"http\",\n            \"TEMPLATES_AUTO_RELOAD\": None,\n            \"MAX_COOKIE_SIZE\": 4093,\n        }\n    )\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface: SessionInterface = SecureCookieSessionInterface()",
                "filename": "src/flask/app.py",
                "start_index": 7404,
                "end_index": 8950,
                "start_line": 173,
                "end_line": 213,
                "max_line": 1477,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.3",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "src/flask/config.py": [
                {
                    "chunk": {
                        "code": "def from_file(\n        self,\n        filename: str | os.PathLike,\n        load: t.Callable[[t.IO[t.Any]], t.Mapping],\n        silent: bool = False,\n        text: bool = True,\n    ) -> bool:\n        \"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import json\n            app.config.from_file(\"config.json\", load=json.load)\n\n            import tomllib\n            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n        :param text: Open the file in text or binary mode.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionchanged:: 2.3\n            The ``text`` parameter was added.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename, \"r\" if text else \"rb\") as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)\n\n    def from_mapping(\n        self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any\n    ) -> bool:\n        \"\"\"Updates the config like :meth:`update` ignoring items with\n        non-upper keys.\n\n        :return: Always returns ``True``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings: dict[str, t.Any] = {}\n        if mapping is not None:\n            mappings.update(mapping)\n        mappings.update(kwargs)\n        for key, value in mappings.items():\n            if key.isupper():\n                self[key] = value\n        return True",
                        "filename": "src/flask/config.py",
                        "start_index": 8897,
                        "end_index": 11146,
                        "start_line": 236,
                        "end_line": 301,
                        "max_line": 347,
                        "git_instance": "github",
                        "repo_name": "testbed/pallets__flask__2.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'from_file' method of the 'flask.Config' class, which is directly related to the issue. The 'text' parameter needs to be replaced with a 'mode' parameter to allow binary mode file opening."
                }
            ]
        },
        "solution_task": "To implement the requested feature, you need to modify the `from_file` method in the `flask.Config` class to accept a new parameter that specifies the file mode. Here's how you can do it:\n\n- Add a new parameter `mode` to the `from_file` method with a default value of `\"t\"` for text mode.\n- Use the `mode` parameter when opening the file.\n- Update the documentation to reflect the new parameter.\n\nHere's the updated `from_file` method:\n\n```python\ndef from_file(\n    self,\n    filename: str | os.PathLike,\n    load: t.Callable[[t.IO[t.Any]], t.Mapping],\n    silent: bool = False,\n    text: bool = True,  # Keep this for backward compatibility\n    mode: str = \"t\",  # New parameter for specifying file mode\n) -> bool:\n    \"\"\"Update the values in the config from a file that is loaded\n    using the ``load`` parameter. The loaded data is passed to the\n    :meth:`from_mapping` method.\n\n    :param filename: The path to the data file. This can be an\n        absolute path or relative to the config root path.\n    :param load: A callable that takes a file handle and returns a\n        mapping of loaded data from the file.\n    :param silent: Ignore the file if it doesn't exist.\n    :param text: Open the file in text or binary mode. Deprecated in favor of 'mode'.\n    :param mode: The mode in which to open the file. Use 't' for text mode (default) and 'b' for binary mode.\n    :return: ``True`` if the file was loaded successfully.\n\n    .. versionchanged:: 2.3\n        The ``text`` parameter was added.\n    .. versionchanged:: Next\n        The ``mode`` parameter was added to specify file mode.\n    \"\"\"\n    filename = os.path.join(self.root_path, filename)\n\n    file_mode = \"r\" + mode  # Combine 'r' with the mode ('t' or 'b')\n\n    try:\n        with open(filename, file_mode) as f:\n            obj = load(f)\n    except OSError as e:\n        if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n            return False\n\n        e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n        raise\n\n    return self.from_mapping(obj)\n```\n\nMake sure to update the documentation and any tests that use the `from_file` method to reflect these changes. Additionally, consider deprecating the `text` parameter in favor of the new `mode` parameter to avoid confusion in the future.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the feature request by suggesting modifications to the `from_file` method in the `flask.Config` class. It includes a new parameter for file mode with a default value, ensuring backward compatibility. The RESPONSE also includes an updated method signature and implementation details, which are essential for developers to make the necessary changes. Furthermore, it advises updating the documentation and tests, which is a crucial step in the development process. The RESPONSE also suggests deprecating the old `text` parameter to reduce future confusion, showing foresight in maintaining the codebase. The inclusion of a link to the relevant code snippet in the Flask repository is a valuable addition, providing direct access to the code that needs to be modified. The RESPONSE does not address the potential need for error handling specific to the new file mode parameter, but this is a minor omission and does not significantly detract from the overall utility of the RESPONSE.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711742799.389371,
        "result": "To implement the requested feature, you need to modify the `from_file` method in the `flask.Config` class to accept a new parameter that specifies the file mode. Here's how you can do it:\n\n- Add a new parameter `mode` to the `from_file` method with a default value of `\"t\"` for text mode.\n- Use the `mode` parameter when opening the file.\n- Update the documentation to reflect the new parameter.\n\nHere's the updated `from_file` method:\n\n```python\ndef from_file(\n    self,\n    filename: str | os.PathLike,\n    load: t.Callable[[t.IO[t.Any]], t.Mapping],\n    silent: bool = False,\n    text: bool = True,  # Keep this for backward compatibility\n    mode: str = \"t\",  # New parameter for specifying file mode\n) -> bool:\n    \"\"\"Update the values in the config from a file that is loaded\n    using the ``load`` parameter. The loaded data is passed to the\n    :meth:`from_mapping` method.\n\n    :param filename: The path to the data file. This can be an\n        absolute path or relative to the config root path.\n    :param load: A callable that takes a file handle and returns a\n        mapping of loaded data from the file.\n    :param silent: Ignore the file if it doesn't exist.\n    :param text: Open the file in text or binary mode. Deprecated in favor of 'mode'.\n    :param mode: The mode in which to open the file. Use 't' for text mode (default) and 'b' for binary mode.\n    :return: ``True`` if the file was loaded successfully.\n\n    .. versionchanged:: 2.3\n        The ``text`` parameter was added.\n    .. versionchanged:: Next\n        The ``mode`` parameter was added to specify file mode.\n    \"\"\"\n    filename = os.path.join(self.root_path, filename)\n\n    file_mode = \"r\" + mode  # Combine 'r' with the mode ('t' or 'b')\n\n    try:\n        with open(filename, file_mode) as f:\n            obj = load(f)\n    except OSError as e:\n        if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n            return False\n\n        e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n        raise\n\n    return self.from_mapping(obj)\n```\n\nMake sure to update the documentation and any tests that use the `from_file` method to reflect these changes. Additionally, consider deprecating the `text` parameter in favor of the new `mode` parameter to avoid confusion in the future.\n\n### Code snippets to check\n\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.3/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.3/tree//src/flask)- [Lines 236 - 301](https://github.com/testbed/pallets__flask__2.3/blob//src/flask/config.py#L236-L301)\n\n This snippet contains the 'from_file' method of the 'flask.Config' class, which is directly related to the issue. The 'text' parameter needs to be replaced with a 'mode' parameter to allow binary mode file opening."
    }
}