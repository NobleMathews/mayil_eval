{
    "id": "sympy__sympy-13574",
    "repo_name": "testbed/sympy__sympy__1.1",
    "task_id": 5393255015473801305,
    "title": " randMatrix won't generatte symmetric sparse matrices",
    "body": "When setting the percent parameter to anything else than 100, randMatrix fails to generate symmetric matrices. Consider the following examples:\r\n\r\n' ' ' \r\nIn [1]: import sympy\r\n\r\nIn [2]: from sympy.matrices import randMatrix\r\n\r\nIn [3]: randMatrix(3, symmetric=True, percent=1)\r\nOut[3]: \r\nMatrix([\r\n[13, 61, 13],\r\n[59, 29, 59],\r\n[88, 13, 61]])\r\n\r\nIn [4]: randMatrix(3, symmetric=True, percent=50)\r\nOut[4]: \r\nMatrix([\r\n[90, 60,  0],\r\n[ 0,  0,  0],\r\n[60, 59, 25]])\r\n\r\nIn [7]: randMatrix(3, symmetric=True, percent=99)\r\nOut[7]: \r\nMatrix([\r\n[0, 0, 19],\r\n[0, 0,  0],\r\n[0, 0,  0]])\r\n\r\nIn [9]: randMatrix(3, symmetric=True, percent=0)\r\nOut[9]: \r\nMatrix([\r\n[78, 78, 61],\r\n[68,  8, 61],\r\n[22, 68,  8]])\r\n' ' ' \r\n\r\nAlso, the documentation says `If percent is less than 100 then only approximately the given percentage of elements will be non-zero.`, but the behaviour is the opposite. Setting it to 100 (default) produces the expected behaviour.\r\n\r\nThe problem happens with both the released version from pypi and git master.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sympy__sympy__1.1.git",
    "requested_commit": "",
    "mayil_response": "- The issue is that the `randMatrix` function is not generating symmetric matrices when the `percent` parameter is set to values other than 100.\n- The relevant code snippet is from `sympy/matrices/dense.py` where the `randMatrix` function is defined.\n\nTo fix the issue:\n- Modify the `randMatrix` function in `sympy/matrices/dense.py` to ensure that the symmetry of the matrix is preserved regardless of the `percent` value.\n- Update the algorithm that generates the symmetric matrix to fill both the upper and lower triangular parts of the matrix with the same random values, even when `percent` is less than 100.\n\nHere is the proposed solution:\n\n```python\n# Symmetric case\nif r != c:\n    raise ValueError('For symmetric matrices, r must equal c, but %i != %i' % (r, c))\nm = zeros(r)\nij = [(i, j) for i in range(r) for j in range(i, r)]\nif percent != 100:\n    # Ensure the same elements are chosen for both halves of the matrix\n    prng.shuffle(ij)\n    ij = ij[:int(len(ij)*percent // 100)]\n    ij += [(j, i) for i, j in ij if i != j]  # Add the symmetric elements\n\nfor i, j in ij:\n    value = prng.randint(min, max)\n    m[i, j] = m[j, i] = value\nreturn m\n```\n\n- This change ensures that for each randomly chosen position `(i, j)` in the upper triangle, the corresponding symmetric position `(j, i)` in the lower triangle is also filled with the same random value.\n- The `ij` list is shuffled before selecting a subset based on the `percent` value to ensure randomness.\n- The list comprehension `[(j, i) for i, j in ij if i != j]` adds the symmetric positions for all non-diagonal elements. Diagonal elements are already symmetric and do not need to be duplicated.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.1/tree//sympy) \u2192 [matrices](https://github.com/testbed/sympy__sympy__1.1/tree//sympy/matrices)- [Lines 1184 - 1258](https://github.com/testbed/sympy__sympy__1.1/blob//sympy/matrices/dense.py#L1184-L1258)\n\n This snippet contains the implementation of the randMatrix function, which is directly related to the issue reported. The issue describes a problem with generating symmetric sparse matrices using this function, and the code here handles the symmetric case and the percent parameter.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0034869999999999996,
        "snippet_processor": 0.0604,
        "issue_star_creation": 0.020409999999999998,
        "issue_star_solver": 0.045790000000000004,
        "bouncer": 0.02438
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711749818.863743,
        "relevant_snippets": [
            {
                "code": "def randMatrix(r, c=None, min=0, max=99, seed=None, symmetric=False,\n               percent=100, prng=None):\n    \"\"\"Create random matrix with dimensions ``r`` x ``c``. If ``c`` is omitted\n    the matrix will be square. If ``symmetric`` is True the matrix must be\n    square. If ``percent`` is less than 100 then only approximately the given\n    percentage of elements will be non-zero.\n\n    The pseudo-random number generator used to generate matrix is chosen in the\n    following way.\n\n    * If ``prng`` is supplied, it will be used as random number generator.\n      It should be an instance of ``random.Random``, or at least have\n      ``randint`` and ``shuffle`` methods with same signatures.\n    * if ``prng`` is not supplied but ``seed`` is supplied, then new\n      ``random.Random`` with given ``seed`` will be created;\n    * otherwise, a new ``random.Random`` with default seed will be used.\n\n    Examples\n    ========\n\n    >>> from sympy.matrices import randMatrix\n    >>> randMatrix(3) # doctest:+SKIP\n    [25, 45, 27]\n    [44, 54,  9]\n    [23, 96, 46]\n    >>> randMatrix(3, 2) # doctest:+SKIP\n    [87, 29]\n    [23, 37]\n    [90, 26]\n    >>> randMatrix(3, 3, 0, 2) # doctest:+SKIP\n    [0, 2, 0]\n    [2, 0, 1]\n    [0, 0, 1]\n    >>> randMatrix(3, symmetric=True) # doctest:+SKIP\n    [85, 26, 29]\n    [26, 71, 43]\n    [29, 43, 57]\n    >>> A = randMatrix(3, seed=1)\n    >>> B = randMatrix(3, seed=2)\n    >>> A == B\n    False\n    >>> A == randMatrix(3, seed=1)\n    True\n    >>> randMatrix(3, symmetric=True, percent=50) # doctest:+SKIP\n    [77, 70,  0],\n    [70,  0,  0],\n    [ 0,  0, 88]\n    \"\"\"\n    if c is None:\n        c = r\n    # Note that ``Random()`` is equivalent to ``Random(None)``\n    prng = prng or random.Random(seed)\n\n    if not symmetric:\n        m = Matrix._new(r, c, lambda i, j: prng.randint(min, max))\n        if percent == 100:\n            return m\n        z = int(r*c*(100 - percent) // 100)\n        m._mat[:z] = [S.Zero]*z\n        prng.shuffle(m._mat)\n\n        return m\n\n    # Symmetric case\n    if r != c:\n        raise ValueError('For symmetric matrices, r must equal c, but %i != %i' % (r, c))\n    m = zeros(r)\n    ij = [(i, j) for i in range(r) for j in range(i, r)]\n    if percent != 100:\n        ij = prng.sample(ij, int(len(ij)*percent // 100))\n\n    for i, j in ij:\n        value = prng.randint(min, max)\n        m[i, j] = m[j, i] = value\n    return m",
                "filename": "sympy/matrices/dense.py",
                "start_index": 32191,
                "end_index": 34574,
                "start_line": 1184,
                "end_line": 1258,
                "max_line": 1308,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\n    A sparse matrix (a matrix with a large number of zero elements).\n\n    Examples\n    ========\n\n    >>> from sympy.matrices import SparseMatrix, ones\n    >>> SparseMatrix(2, 2, range(4))\n    Matrix([\n    [0, 1],\n    [2, 3]])\n    >>> SparseMatrix(2, 2, {(1, 1): 2})\n    Matrix([\n    [0, 0],\n    [0, 2]])\n\n    A SparseMatrix can be instantiated from a ragged list of lists:\n\n    >>> SparseMatrix([[1, 2, 3], [1, 2], [1]])\n    Matrix([\n    [1, 2, 3],\n    [1, 2, 0],\n    [1, 0, 0]])\n\n    For safety, one may include the expected size and then an error\n    will be raised if the indices of any element are out of range or\n    (for a flat list) if the total number of elements does not match\n    the expected shape:\n\n    >>> SparseMatrix(2, 2, [1, 2])\n    Traceback (most recent call last):\n    ...\n    ValueError: List length (2) != rows*columns (4)\n\n    Here, an error is not raised because the list is not flat and no\n    element is out of range:\n\n    >>> SparseMatrix(2, 2, [[1, 2]])\n    Matrix([\n    [1, 2],\n    [0, 0]])\n\n    But adding another element to the first (and only) row will cause\n    an error to be raised:\n\n    >>> SparseMatrix(2, 2, [[1, 2, 3]])\n    Traceback (most recent call last):\n    ...\n    ValueError: The location (0, 2) is out of designated range: (1, 1)\n\n    To autosize the matrix, pass None for rows:\n\n    >>> SparseMatrix(None, [[1, 2, 3]])\n    Matrix([[1, 2, 3]])\n    >>> SparseMatrix(None, {(1, 1): 1, (3, 3): 3})\n    Matrix([\n    [0, 0, 0, 0],\n    [0, 1, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 3]])\n\n    Values that are themselves a Matrix are automatically expanded:\n\n    >>> SparseMatrix(4, 4, {(1, 1): ones(2)})\n    Matrix([\n    [0, 0, 0, 0],\n    [0, 1, 1, 0],\n    [0, 1, 1, 0],\n    [0, 0, 0, 0]])\n\n    A ValueError is raised if the expanding matrix tries to overwrite\n    a different element already present:\n\n    >>> SparseMatrix(3, 3, {(0, 0): ones(2), (1, 1): 2})\n    Traceback (most recent call last):\n    ...\n    ValueError: collision at (1, 1)\n\n    See Also\n    ========\n    DenseMatrix\n    MutableSparseMatrix\n    ImmutableSparseMatrix\n    \"\"\"",
                "filename": "sympy/matrices/sparse.py",
                "start_index": 764,
                "end_index": 2852,
                "start_line": 27,
                "end_line": 1135,
                "max_line": 1138,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "class SparseMatrix(MatrixBase):",
                "filename": "sympy/matrices/sparse.py",
                "start_index": 728,
                "end_index": 759,
                "start_line": 26,
                "end_line": 26,
                "max_line": 1138,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "from __future__ import print_function, division\n\nfrom sympy import Basic\nfrom sympy.stats.rv import PSpace, _symbol_converter, RandomMatrixSymbol\n\nclass RandomMatrixPSpace(PSpace):\n    \"\"\"\n    Represents probability space for\n    random matrices. It contains the mechanics\n    for handling the API calls for random matrices.\n    \"\"\"\n    def __new__(cls, sym, model=None):\n        sym = _symbol_converter(sym)\n        return Basic.__new__(cls, sym, model)\n\n    model = property(lambda self: self.args[1])\n\n    def compute_density(self, expr, *args):\n        rms = expr.atoms(RandomMatrixSymbol)\n        if len(rms) > 2 or (not isinstance(expr, RandomMatrixSymbol)):\n            raise NotImplementedError(\"Currently, no algorithm has been \"\n                    \"implemented to handle general expressions containing \"\n                    \"multiple random matrices.\")\n        return self.model.density(expr)",
                "filename": "sympy/stats/random_matrix.py",
                "start_index": 0,
                "end_index": 903,
                "start_line": 1,
                "end_line": 24,
                "max_line": 24,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "def rot_axis1(theta):\n    \"\"\"Returns a rotation matrix for a rotation of theta (in radians) about\n    the 1-axis.\n\n    Examples\n    ========\n\n    >>> from sympy import pi\n    >>> from sympy.matrices import rot_axis1\n\n    A rotation of pi/3 (60 degrees):\n\n    >>> theta = pi/3\n    >>> rot_axis1(theta)\n    Matrix([\n    [1,          0,         0],\n    [0,        1/2, sqrt(3)/2],\n    [0, -sqrt(3)/2,       1/2]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_axis1(pi/2)\n    Matrix([\n    [1,  0, 0],\n    [0,  0, 1],\n    [0, -1, 0]])\n\n    See Also\n    ========\n\n    rot_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis\n    rot_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis\n    \"\"\"\n    ct = cos(theta)\n    st = sin(theta)\n    lil = ((1, 0, 0),\n           (0, ct, st),\n           (0, -st, ct))\n    return Matrix(lil)\n\n\n@doctest_depends_on(modules=('numpy',))\ndef symarray(prefix, shape, **kwargs):  # pragma: no cover\n    r\"\"\"Create a numpy ndarray of symbols (as an object array).\n\n    The created symbols are named ``prefix_i1_i2_``...  You should thus provide a\n    non-empty prefix if you want your symbols to be unique for different output\n    arrays, as SymPy symbols with identical names are the same object.\n\n    Parameters\n    ----------\n\n    prefix : string\n      A prefix prepended to the name of every symbol.\n\n    shape : int or tuple\n      Shape of the created array.  If an int, the array is one-dimensional; for\n      more than one dimension the shape must be a tuple.\n\n    \\*\\*kwargs : dict\n      keyword arguments passed on to Symbol\n\n    Examples\n    ========\n    These doctests require numpy.\n\n    >>> from sympy import symarray\n    >>> symarray('', 3)\n    [_0 _1 _2]\n\n    If you want multiple symarrays to contain distinct symbols, you *must*\n    provide unique prefixes:\n\n    >>> a = symarray('', 3)\n    >>> b = symarray('', 3)\n    >>> a[0] == b[0]\n    True\n    >>> a = symarray('a', 3)\n    >>> b = symarray('b', 3)\n    >>> a[0] == b[0]\n    False\n\n    Creating symarrays with a prefix:\n\n    >>> symarray('a', 3)\n    [a_0 a_1 a_2]\n\n    For more than one dimension, the shape must be given as a tuple:\n\n    >>> symarray('a', (2, 3))\n    [[a_0_0 a_0_1 a_0_2]\n     [a_1_0 a_1_1 a_1_2]]\n    >>> symarray('a', (2, 3, 2))\n    [[[a_0_0_0 a_0_0_1]\n      [a_0_1_0 a_0_1_1]\n      [a_0_2_0 a_0_2_1]]\n    <BLANKLINE>\n     [[a_1_0_0 a_1_0_1]\n      [a_1_1_0 a_1_1_1]\n      [a_1_2_0 a_1_2_1]]]\n\n    For setting assumptions of the underlying Symbols:\n\n    >>> [s.is_real for s in symarray('a', 2, real=True)]\n    [True, True]\n    \"\"\"\n    from numpy import empty, ndindex\n    arr = empty(shape, dtype=object)\n    for index in ndindex(shape):\n        arr[index] = Symbol('%s_%s' % (prefix, '_'.join(map(str, index))),\n                            **kwargs)\n    return arr\n\n\n###############\n# Functions\n###############",
                "filename": "sympy/matrices/dense.py",
                "start_index": 21560,
                "end_index": 24476,
                "start_line": 789,
                "end_line": 907,
                "max_line": 1308,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "import random\n\nfrom sympy.core import SympifyError, Add\nfrom sympy.core.basic import Basic\nfrom sympy.core.compatibility import is_sequence, reduce\nfrom sympy.core.expr import Expr\nfrom sympy.core.singleton import S\nfrom sympy.core.symbol import Symbol\nfrom sympy.core.sympify import sympify\nfrom sympy.functions.elementary.trigonometric import cos, sin\nfrom sympy.matrices.common import \\\n    a2idx, classof, ShapeError\nfrom sympy.matrices.matrices import MatrixBase\nfrom sympy.simplify.simplify import simplify as _simplify\nfrom sympy.utilities.decorator import doctest_depends_on\nfrom sympy.utilities.misc import filldedent\n\nfrom .decompositions import _cholesky, _LDLdecomposition\nfrom .solvers import _lower_triangular_solve, _upper_triangular_solve\n\n\ndef _iszero(x):\n    \"\"\"Returns True if x is zero.\"\"\"\n    return x.is_zero\n\n\ndef _compare_sequence(a, b):\n    \"\"\"Compares the elements of a list/tuple `a`\n    and a list/tuple `b`.  `_compare_sequence((1,2), [1, 2])`\n    is True, whereas `(1,2) == [1, 2]` is False\"\"\"\n    if type(a) is type(b):\n        # if they are the same type, compare directly\n        return a == b\n    # there is no overhead for calling `tuple` on a\n    # tuple\n    return tuple(a) == tuple(b)",
                "filename": "sympy/matrices/dense.py",
                "start_index": 0,
                "end_index": 1222,
                "start_line": 1,
                "end_line": 36,
                "max_line": 1308,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "from sympy import Dict, Dummy, SparseMatrix\n    try:\n        if len(args) not in (1, 2, 3):\n            raise TypeError\n        if not isinstance(args[-1], (dict, Dict)):\n            raise TypeError\n        if len(args) == 1:\n            rows = kwargs.get('rows', None)\n            cols = kwargs.get('cols', None)\n            if rows is not None:\n                rows = as_int(rows)\n            if cols is not None:\n                cols = as_int(cols)\n        elif len(args) == 2:\n            rows = cols = as_int(args[0])\n        else:\n            rows, cols = map(as_int, args[:2])\n        # fails with ValueError if any keys are not ints\n        _ = all(as_int(k) for k in args[-1])\n    except (ValueError, TypeError):\n        raise TypeError(filldedent(\n            '''unrecognized input to banded:\n            expecting [[row,] col,] {int: value}'''))\n    def rc(d):\n        # return row,col coord of diagonal start\n        r = -d if d < 0 else 0\n        c = 0 if r else d\n        return r, c\n    smat = {}\n    undone = []\n    tba = Dummy()\n    # first handle objects with size\n    for d, v in args[-1].items():\n        r, c = rc(d)\n        # note: only list and tuple are recognized since this\n        # will allow other Basic objects like Tuple\n        # into the matrix if so desired\n        if isinstance(v, (list, tuple)):\n            extra = 0\n            for i, vi in enumerate(v):\n                i += extra\n                if is_sequence(vi):\n                    vi = SparseMatrix(vi)\n                    smat[r + i, c + i] = vi\n                    extra += min(vi.shape) - 1\n                else:\n                    smat[r + i, c + i] = vi\n        elif is_sequence(v):\n            v = SparseMatrix(v)\n            rv, cv = v.shape\n            if rows and cols:\n                nr, xr = divmod(rows - r, rv)\n                nc, xc = divmod(cols - c, cv)\n                x = xr or xc\n                do = min(nr, nc)\n            elif rows:\n                do, x = divmod(rows - r, rv)\n            elif cols:\n                do, x = divmod(cols - c, cv)\n            else:\n                do = 1\n                x = 0\n            if x:\n                raise ValueError(filldedent('''\n                    sequence does not fit an integral number of times\n                    in the matrix'''))\n            j = min(v.shape)\n            for i in range(do):\n                smat[r, c] = v\n                r += j\n                c += j\n        elif v:\n            smat[r, c] = tba\n            undone.append((d, v))\n    s = SparseMatrix(None, smat)  # to expand matrices\n    smat = s._smat\n    # check for dim errors here\n    if rows is not None and rows < s.rows:\n        raise ValueError('Designated rows %s < needed %s' % (rows, s.rows))\n    if cols is not None and cols < s.cols:\n        raise ValueError('Designated cols %s < needed %s' % (cols, s.cols))",
                "filename": "sympy/matrices/sparsetools.py",
                "start_index": 5529,
                "end_index": 8393,
                "start_line": 197,
                "end_line": 277,
                "max_line": 300,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "# make sure ImmutableDenseMatrix is aliased as ImmutableMatrix\nImmutableMatrix = ImmutableDenseMatrix\n\n\nclass ImmutableSparseMatrix(SparseMatrix, MatrixExpr):\n    \"\"\"Create an immutable version of a sparse matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import eye\n    >>> from sympy.matrices.immutable import ImmutableSparseMatrix\n    >>> ImmutableSparseMatrix(1, 1, {})\n    Matrix([[0]])\n    >>> ImmutableSparseMatrix(eye(3))\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n    >>> _[0, 0] = 42\n    Traceback (most recent call last):\n    ...\n    TypeError: Cannot set values of ImmutableSparseMatrix\n    >>> _.shape\n    (3, 3)\n    \"\"\"\n    is_Matrix = True\n    _class_priority = 9\n\n    def __new__(cls, *args, **kwargs):\n        return cls._new(*args, **kwargs)\n\n    __hash__ = MatrixExpr.__hash__\n\n    @classmethod\n    def _new(cls, *args, **kwargs):\n        s = MutableSparseMatrix(*args)\n        rows, cols, smat = s.rows, s.cols, s._smat\n        obj = Basic.__new__(cls, Integer(rows), Integer(cols), Dict(smat))\n        obj._rows = rows\n        obj._cols = cols\n        obj._smat = smat\n        return obj\n\n    def __setitem__(self, *args):\n        raise TypeError(\"Cannot set values of ImmutableSparseMatrix\")\n\n    def _entry(self, i, j, **kwargs):\n        return SparseMatrix.__getitem__(self, (i, j))\n\n    _eval_Eq = ImmutableDenseMatrix._eval_Eq\n\n    @property\n    def cols(self):\n        return self._cols\n\n    @property\n    def rows(self):\n        return self._rows\n\n    @property\n    def shape(self):\n        return self._rows, self._cols\n\n    def as_immutable(self):\n        return self\n\n    def is_diagonalizable(self, reals_only=False, **kwargs):\n        return super().is_diagonalizable(\n            reals_only=reals_only, **kwargs)\n    is_diagonalizable.__doc__ = SparseMatrix.is_diagonalizable.__doc__\n    is_diagonalizable = cacheit(is_diagonalizable)",
                "filename": "sympy/matrices/immutable.py",
                "start_index": 4168,
                "end_index": 6057,
                "start_line": 132,
                "end_line": 203,
                "max_line": 203,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "\"\"\"\nBasic methods common to all matrices to be used\nwhen creating more advanced matrices (e.g., matrices over rings,\netc.).\n\"\"\"\n\nfrom sympy.core.logic import FuzzyBool\n\nfrom collections import defaultdict\nfrom inspect import isfunction\n\nfrom sympy.assumptions.refine import refine\nfrom sympy.core import SympifyError, Add\nfrom sympy.core.basic import Atom\nfrom sympy.core.compatibility import (\n    Iterable, as_int, is_sequence, reduce)\nfrom sympy.core.decorators import call_highest_priority\nfrom sympy.core.logic import fuzzy_and\nfrom sympy.core.singleton import S\nfrom sympy.core.symbol import Symbol\nfrom sympy.core.sympify import sympify\nfrom sympy.functions import Abs\nfrom sympy.simplify import simplify as _simplify\nfrom sympy.simplify.simplify import dotprodsimp as _dotprodsimp\nfrom sympy.utilities.exceptions import SymPyDeprecationWarning\nfrom sympy.utilities.iterables import flatten\nfrom sympy.utilities.misc import filldedent\n\nfrom .utilities import _get_intermediate_simp_bool\n\n\nclass MatrixError(Exception):\n    pass\n\n\nclass ShapeError(ValueError, MatrixError):\n    \"\"\"Wrong matrix shape\"\"\"\n    pass\n\n\nclass NonSquareMatrixError(ShapeError):\n    pass\n\n\nclass NonInvertibleMatrixError(ValueError, MatrixError):\n    \"\"\"The matrix in not invertible (division by multidimensional zero error).\"\"\"\n    pass\n\n\nclass NonPositiveDefiniteMatrixError(ValueError, MatrixError):\n    \"\"\"The matrix is not a positive-definite matrix.\"\"\"\n    pass\n\n\nclass MatrixRequired:\n    \"\"\"All subclasses of matrix objects must implement the\n    required matrix properties listed here.\"\"\"\n    rows = None  # type: int\n    cols = None  # type: int\n    _simplify = None\n\n    @classmethod\n    def _new(cls, *args, **kwargs):\n        \"\"\"`_new` must, at minimum, be callable as\n        `_new(rows, cols, mat) where mat is a flat list of the\n        elements of the matrix.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement this.\")\n\n    def __eq__(self, other):\n        raise NotImplementedError(\"Subclasses must implement this.\")\n\n    def __getitem__(self, key):\n        \"\"\"Implementations of __getitem__ should accept ints, in which\n        case the matrix is indexed as a flat list, tuples (i,j) in which\n        case the (i,j) entry is returned, slices, or mixed tuples (a,b)\n        where a and b are any combintion of slices and integers.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement this.\")\n\n    def __len__(self):\n        \"\"\"The total number of entries in the matrix.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement this.\")\n\n    @property\n    def shape(self):\n        raise NotImplementedError(\"Subclasses must implement this.\")",
                "filename": "sympy/matrices/common.py",
                "start_index": 0,
                "end_index": 2669,
                "start_line": 1,
                "end_line": 85,
                "max_line": 2934,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            },
            {
                "code": "def _represent_NumberOp(self, basis, **options):\n        ndim_info = options.get('ndim', 4)\n        format = options.get('format','sympy')\n        matrix = matrix_zeros(ndim_info, ndim_info, **options)\n        for i in range(ndim_info - 1):\n            value = sqrt(i + 1)\n            if format == 'scipy.sparse':\n                value = float(value)\n            matrix[i + 1, i] = value\n        if format == 'scipy.sparse':\n            matrix = matrix.tocsr()\n        return matrix\n\n    #--------------------------------------------------------------------------\n    # Printing Methods\n    #--------------------------------------------------------------------------\n\n    def _print_contents(self, printer, *args):\n        arg0 = printer._print(self.args[0], *args)\n        return '%s(%s)' % (self.__class__.__name__, arg0)\n\n    def _print_contents_pretty(self, printer, *args):\n        from sympy.printing.pretty.stringpict import prettyForm\n        pform = printer._print(self.args[0], *args)\n        pform = pform**prettyForm(u'\\N{DAGGER}')\n        return pform\n\n    def _print_contents_latex(self, printer, *args):\n        arg = printer._print(self.args[0])\n        return '%s^{\\\\dagger}' % arg",
                "filename": "sympy/physics/quantum/sho1d.py",
                "start_index": 4097,
                "end_index": 5295,
                "start_line": 133,
                "end_line": 162,
                "max_line": 678,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.1",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sympy/matrices/dense.py": [
                {
                    "chunk": {
                        "code": "def randMatrix(r, c=None, min=0, max=99, seed=None, symmetric=False,\n               percent=100, prng=None):\n    \"\"\"Create random matrix with dimensions ``r`` x ``c``. If ``c`` is omitted\n    the matrix will be square. If ``symmetric`` is True the matrix must be\n    square. If ``percent`` is less than 100 then only approximately the given\n    percentage of elements will be non-zero.\n\n    The pseudo-random number generator used to generate matrix is chosen in the\n    following way.\n\n    * If ``prng`` is supplied, it will be used as random number generator.\n      It should be an instance of ``random.Random``, or at least have\n      ``randint`` and ``shuffle`` methods with same signatures.\n    * if ``prng`` is not supplied but ``seed`` is supplied, then new\n      ``random.Random`` with given ``seed`` will be created;\n    * otherwise, a new ``random.Random`` with default seed will be used.\n\n    Examples\n    ========\n\n    >>> from sympy.matrices import randMatrix\n    >>> randMatrix(3) # doctest:+SKIP\n    [25, 45, 27]\n    [44, 54,  9]\n    [23, 96, 46]\n    >>> randMatrix(3, 2) # doctest:+SKIP\n    [87, 29]\n    [23, 37]\n    [90, 26]\n    >>> randMatrix(3, 3, 0, 2) # doctest:+SKIP\n    [0, 2, 0]\n    [2, 0, 1]\n    [0, 0, 1]\n    >>> randMatrix(3, symmetric=True) # doctest:+SKIP\n    [85, 26, 29]\n    [26, 71, 43]\n    [29, 43, 57]\n    >>> A = randMatrix(3, seed=1)\n    >>> B = randMatrix(3, seed=2)\n    >>> A == B\n    False\n    >>> A == randMatrix(3, seed=1)\n    True\n    >>> randMatrix(3, symmetric=True, percent=50) # doctest:+SKIP\n    [77, 70,  0],\n    [70,  0,  0],\n    [ 0,  0, 88]\n    \"\"\"\n    if c is None:\n        c = r\n    # Note that ``Random()`` is equivalent to ``Random(None)``\n    prng = prng or random.Random(seed)\n\n    if not symmetric:\n        m = Matrix._new(r, c, lambda i, j: prng.randint(min, max))\n        if percent == 100:\n            return m\n        z = int(r*c*(100 - percent) // 100)\n        m._mat[:z] = [S.Zero]*z\n        prng.shuffle(m._mat)\n\n        return m\n\n    # Symmetric case\n    if r != c:\n        raise ValueError('For symmetric matrices, r must equal c, but %i != %i' % (r, c))\n    m = zeros(r)\n    ij = [(i, j) for i in range(r) for j in range(i, r)]\n    if percent != 100:\n        ij = prng.sample(ij, int(len(ij)*percent // 100))\n\n    for i, j in ij:\n        value = prng.randint(min, max)\n        m[i, j] = m[j, i] = value\n    return m",
                        "filename": "sympy/matrices/dense.py",
                        "start_index": 32191,
                        "end_index": 34574,
                        "start_line": 1184,
                        "end_line": 1258,
                        "max_line": 1308,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of the randMatrix function, which is directly related to the issue reported. The issue describes a problem with generating symmetric sparse matrices using this function, and the code here handles the symmetric case and the percent parameter."
                }
            ]
        },
        "solution_task": "- The issue is that the `randMatrix` function is not generating symmetric matrices when the `percent` parameter is set to values other than 100.\n- The relevant code snippet is from `sympy/matrices/dense.py` where the `randMatrix` function is defined.\n\nTo fix the issue:\n- Modify the `randMatrix` function in `sympy/matrices/dense.py` to ensure that the symmetry of the matrix is preserved regardless of the `percent` value.\n- Update the algorithm that generates the symmetric matrix to fill both the upper and lower triangular parts of the matrix with the same random values, even when `percent` is less than 100.\n\nHere is the proposed solution:\n\n```python\n# Symmetric case\nif r != c:\n    raise ValueError('For symmetric matrices, r must equal c, but %i != %i' % (r, c))\nm = zeros(r)\nij = [(i, j) for i in range(r) for j in range(i, r)]\nif percent != 100:\n    # Ensure the same elements are chosen for both halves of the matrix\n    prng.shuffle(ij)\n    ij = ij[:int(len(ij)*percent // 100)]\n    ij += [(j, i) for i, j in ij if i != j]  # Add the symmetric elements\n\nfor i, j in ij:\n    value = prng.randint(min, max)\n    m[i, j] = m[j, i] = value\nreturn m\n```\n\n- This change ensures that for each randomly chosen position `(i, j)` in the upper triangle, the corresponding symmetric position `(j, i)` in the lower triangle is also filled with the same random value.\n- The `ij` list is shuffled before selecting a subset based on the `percent` value to ensure randomness.\n- The list comprehension `[(j, i) for i, j in ij if i != j]` adds the symmetric positions for all non-diagonal elements. Diagonal elements are already symmetric and do not need to be duplicated.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE accurately identifies the issue with the `randMatrix` function not generating symmetric matrices when the `percent` parameter is set to values other than 100. It provides a detailed and actionable solution by suggesting modifications to the `randMatrix` function in `sympy/matrices/dense.py`. The proposed solution includes a code snippet that ensures symmetry is preserved by filling both the upper and lower triangular parts of the matrix with the same random values, even when `percent` is less than 100. The RESPONSE also correctly points out the need to shuffle the `ij` list before selecting a subset based on the `percent` value to maintain randomness and includes the symmetric positions for non-diagonal elements. The RESPONSE is highly relevant and offers clear guidance for resolving the bug.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711749951.976406,
        "result": "- The issue is that the `randMatrix` function is not generating symmetric matrices when the `percent` parameter is set to values other than 100.\n- The relevant code snippet is from `sympy/matrices/dense.py` where the `randMatrix` function is defined.\n\nTo fix the issue:\n- Modify the `randMatrix` function in `sympy/matrices/dense.py` to ensure that the symmetry of the matrix is preserved regardless of the `percent` value.\n- Update the algorithm that generates the symmetric matrix to fill both the upper and lower triangular parts of the matrix with the same random values, even when `percent` is less than 100.\n\nHere is the proposed solution:\n\n```python\n# Symmetric case\nif r != c:\n    raise ValueError('For symmetric matrices, r must equal c, but %i != %i' % (r, c))\nm = zeros(r)\nij = [(i, j) for i in range(r) for j in range(i, r)]\nif percent != 100:\n    # Ensure the same elements are chosen for both halves of the matrix\n    prng.shuffle(ij)\n    ij = ij[:int(len(ij)*percent // 100)]\n    ij += [(j, i) for i, j in ij if i != j]  # Add the symmetric elements\n\nfor i, j in ij:\n    value = prng.randint(min, max)\n    m[i, j] = m[j, i] = value\nreturn m\n```\n\n- This change ensures that for each randomly chosen position `(i, j)` in the upper triangle, the corresponding symmetric position `(j, i)` in the lower triangle is also filled with the same random value.\n- The `ij` list is shuffled before selecting a subset based on the `percent` value to ensure randomness.\n- The list comprehension `[(j, i) for i, j in ij if i != j]` adds the symmetric positions for all non-diagonal elements. Diagonal elements are already symmetric and do not need to be duplicated.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.1/tree//sympy) \u2192 [matrices](https://github.com/testbed/sympy__sympy__1.1/tree//sympy/matrices)- [Lines 1184 - 1258](https://github.com/testbed/sympy__sympy__1.1/blob//sympy/matrices/dense.py#L1184-L1258)\n\n This snippet contains the implementation of the randMatrix function, which is directly related to the issue reported. The issue describes a problem with generating symmetric sparse matrices using this function, and the code here handles the symmetric case and the percent parameter."
    }
}