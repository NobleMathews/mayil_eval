{
    "id": "sphinx-doc__sphinx-11489",
    "repo_name": "testbed/sphinx-doc__sphinx__7.1",
    "task_id": 696651240824982967,
    "title": "Allow disabling linkcheck anchor checks for specific URLs",
    "body": "**Is your feature request related to a problem? Please describe.**\r\nIt appears GitHub has made the Markdown renderer/file viewer require JavaScript which breaks linkcheck anchor checks. \r\n\r\n**Describe the solution you'd like**\r\n\r\nA config which disables the linkcheck anchors check based on a regex of the entire URL would allow for cases like these to be handled while still validating whether the page itself exists and keep anchor checks enabled for others.\r\n\r\n```python\r\nlinkcheck_anchors_disabled = [\r\n   # Requires JavaScript\r\n   r'https://github.com'\r\n]\r\n```\r\n\r\n**Describe alternatives you've considered**\r\nA clear and concise description of any alternative solutions or features you've considered.\r\n\r\n**Additional context**\r\n\r\nThis is what [the page](https://github.com/NixOS/nix.dev/blob/master/CONTRIBUTING.md#user-content-vision) looks like without JavaScript enabled:\r\n\r\n<img width=\"1007\" alt=\"Capture d\u2019e\u0301cran 2023-07-07 a\u0300 17 00 57\" src=\"https://github.com/sphinx-doc/sphinx/assets/18437312/bed935cb-f044-4cae-9f73-6bba242a3bd8\">\r\n\r\n- Related issue: https://github.com/NixOS/nix.dev/issues/631\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__7.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature that allows disabling linkcheck anchor checks for specific URLs based on a regex of the entire URL, you can follow these steps:\n\n- Add a new configuration option to the Sphinx configuration to specify the URLs for which anchor checks should be disabled.\n- Modify the link checking logic to consult this configuration and skip anchor checks for matching URLs.\n\nHere's a high-level overview of the implementation:\n\n1. Add a new configuration option in `sphinx/builders/linkcheck.py`:\n   ```python\n   app.add_config_value('linkcheck_anchors_disabled', [], False)\n   ```\n\n2. Modify the `HyperlinkAvailabilityChecker` class to include a method that checks if anchor checking should be skipped for a given URL:\n   ```python\n   class HyperlinkAvailabilityChecker:\n       # ... existing code ...\n\n       def is_anchor_check_disabled(self, uri: str) -> bool:\n           return any(re.compile(pattern).match(uri) for pattern in self.config.linkcheck_anchors_disabled)\n   ```\n\n3. Update the `check` method in the `HyperlinkAvailabilityChecker` class to use the new `is_anchor_check_disabled` method:\n   ```python\n   class HyperlinkAvailabilityChecker:\n       # ... existing code ...\n\n       def check(self, hyperlinks: dict[str, Hyperlink]) -> Generator[CheckResult, None, None]:\n           # ... existing code ...\n\n           for hyperlink in hyperlinks.values():\n               if self.is_ignored_uri(hyperlink.uri) or self.is_anchor_check_disabled(hyperlink.uri):\n                   yield CheckResult(hyperlink.uri, hyperlink.docname, hyperlink.lineno, 'ignored', '', 0)\n               else:\n                   # ... existing code ...\n   ```\n\n4. In the `check_uri` function within the `HyperlinkAvailabilityCheckWorker` class, skip the anchor check if `is_anchor_check_disabled` returns `True`:\n   ```python\n   class HyperlinkAvailabilityCheckWorker:\n       # ... existing code ...\n\n       def check_uri(self) -> tuple[str, str, int]:\n           # ... existing code ...\n\n           if anchor and self.config.linkcheck_anchors and not self.is_anchor_check_disabled(req_url):\n               # ... existing anchor check code ...\n           else:\n               # ... existing code for handling non-anchor checks ...\n   ```\n\n5. Update the Sphinx configuration file (usually `conf.py`) to include the new `linkcheck_anchors_disabled` option with the desired regex patterns:\n   ```python\n   linkcheck_anchors_disabled = [\n       r'https://github.com/.*'  # Example pattern to disable anchor checks for GitHub URLs\n   ]\n   ```\n\nThis implementation will allow users to specify patterns for URLs that should skip anchor checks while still performing other link checks. The `is_anchor_check_disabled` method will be used to determine whether a given URL matches any of the user-defined patterns. If a match is found, the anchor check will be skipped for that URL.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__7.1/tree//sphinx) \u2192 [builders](https://github.com/testbed/sphinx-doc__sphinx__7.1/tree//sphinx/builders)- [Lines 156 - 468](https://github.com/testbed/sphinx-doc__sphinx__7.1/blob//sphinx/builders/linkcheck.py#L156-L468)\n\n This snippet contains the logic for checking anchors which is relevant to the issue as the feature request is to disable anchor checks for specific URLs. \n\n\n   - [Lines 1 - 430](https://github.com/testbed/sphinx-doc__sphinx__7.1/blob//sphinx/builders/linkcheck.py#L1-L430)\n\n This snippet defines the CheckExternalLinksBuilder class and may need to be modified to implement the new configuration option to disable anchor checks for specific URLs. \n\n\n   - [Lines 562 - 592](https://github.com/testbed/sphinx-doc__sphinx__7.1/blob//sphinx/builders/linkcheck.py#L562-L592)\n\n This snippet is where new configuration values are added, and the feature request is to add a new configuration option.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002895,
        "snippet_processor": 0.06311,
        "issue_star_creation": 0.022609999999999998,
        "issue_star_solver": 0.07375000000000001,
        "bouncer": 0.0233
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711700978.467873,
        "relevant_snippets": [
            {
                "code": "try:\n                if anchor and self.config.linkcheck_anchors:\n                    # Read the whole document and see if #anchor exists\n                    with requests.get(req_url, stream=True, config=self.config, auth=auth_info,\n                                      **kwargs) as response:\n                        response.raise_for_status()\n                        found = check_anchor(response, unquote(anchor))\n\n                    if not found:\n                        raise Exception(__(\"Anchor '%s' not found\") % anchor)\n                else:\n                    try:\n                        # try a HEAD request first, which should be easier on\n                        # the server and the network\n                        with requests.head(req_url, allow_redirects=True, config=self.config,\n                                           auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n                    # Servers drop the connection on HEAD requests, causing\n                    # ConnectionError.\n                    except (ConnectionError, HTTPError, TooManyRedirects) as err:\n                        if isinstance(err, HTTPError) and err.response.status_code == 429:\n                            raise\n                        # retry with GET request if that fails, some servers\n                        # don't like HEAD requests.\n                        with requests.get(req_url, stream=True, config=self.config,\n                                          auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n            except HTTPError as err:\n                if err.response.status_code == 401:\n                    # We'll take \"Unauthorized\" as working.\n                    return 'working', ' - unauthorized', 0\n                elif err.response.status_code == 429:\n                    next_check = self.limit_rate(err.response)\n                    if next_check is not None:\n                        self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                        return 'rate-limited', '', 0\n                    return 'broken', str(err), 0\n                elif err.response.status_code == 503:\n                    # We'll take \"Service Unavailable\" as ignored.\n                    return 'ignored', str(err), 0\n                else:\n                    return 'broken', str(err), 0\n            except Exception as err:\n                return 'broken', str(err), 0\n            else:\n                netloc = urlparse(req_url).netloc\n                try:\n                    del self.rate_limits[netloc]\n                except KeyError:\n                    pass",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 11520,
                "end_index": 14211,
                "start_line": 156,
                "end_line": 468,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "def allowed_redirect(url: str, new_url: str) -> bool:\n            return any(\n                from_url.match(url) and to_url.match(new_url)\n                for from_url, to_url\n                in self.config.linkcheck_allowed_redirects.items()\n            )\n\n        def check(docname: str) -> tuple[str, str, int]:\n            # check for various conditions without bothering the network\n\n            for doc_matcher in self.documents_exclude:\n                if doc_matcher.match(docname):\n                    info = (\n                        f'{docname} matched {doc_matcher.pattern} from '\n                        'linkcheck_exclude_documents'\n                    )\n                    return 'ignored', info, 0\n\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                if uri_re.match(uri):\n                    # non supported URI schemes (ex. ftp)\n                    return 'unchecked', '', 0\n                else:\n                    srcdir = path.dirname(self.env.doc2path(docname))\n                    if path.exists(path.join(srcdir, uri)):\n                        return 'working', '', 0\n                    else:\n                        return 'broken', '', 0\n\n            # need to actually check the URI\n            for _ in range(self.config.linkcheck_retries):\n                status, info, code = check_uri()\n                if status != \"broken\":\n                    break\n\n            return (status, info, code)\n\n        while True:\n            check_request = self.wqueue.get()\n            next_check, hyperlink = check_request\n            if hyperlink is None:\n                break\n\n            uri, docname, lineno = hyperlink\n\n            if uri is None:\n                break\n            netloc = urlparse(uri).netloc\n            try:\n                # Refresh rate limit.\n                # When there are many links in the queue, workers are all stuck waiting\n                # for responses, but the builder keeps queuing. Links in the queue may\n                # have been queued before rate limits were discovered.\n                next_check = self.rate_limits[netloc].next_check\n            except KeyError:\n                pass\n            if next_check > time.time():\n                # Sleep before putting message back in the queue to avoid\n                # waking up other threads.\n                time.sleep(QUEUE_POLL_SECS)\n                self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                self.wqueue.task_done()\n                continue\n            status, info, code = check(docname)\n            if status == 'rate-limited':\n                logger.info(darkgray('-rate limited-   ') + uri + darkgray(' | sleeping...'))\n            else:\n                self.rqueue.put(CheckResult(uri, docname, lineno, status, info, code))\n            self.wqueue.task_done()",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 14844,
                "end_index": 17804,
                "start_line": 382,
                "end_line": 452,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "class HyperlinkCollector(SphinxPostTransform):\n    builders = ('linkcheck',)\n    default_priority = 800\n\n    def run(self, **kwargs: Any) -> None:\n        builder = cast(CheckExternalLinksBuilder, self.app.builder)\n        hyperlinks = builder.hyperlinks\n\n        def add_uri(uri: str, node: nodes.Element) -> None:\n            newuri = self.app.emit_firstresult('linkcheck-process-uri', uri)\n            if newuri:\n                uri = newuri\n\n            try:\n                lineno = get_node_line(node)\n            except ValueError:\n                lineno = None\n            uri_info = Hyperlink(uri, self.env.docname, lineno)\n            if uri not in hyperlinks:\n                hyperlinks[uri] = uri_info\n\n        # reference nodes\n        for refnode in self.document.findall(nodes.reference):\n            if 'refuri' not in refnode:\n                continue\n            uri = refnode['refuri']\n            add_uri(uri, refnode)\n\n        # image nodes\n        for imgnode in self.document.findall(nodes.image):\n            uri = imgnode['candidates'].get('?')\n            if uri and '://' in uri:\n                add_uri(uri, imgnode)\n\n        # raw nodes\n        for rawnode in self.document.findall(nodes.raw):\n            uri = rawnode.get('source')\n            if uri and '://' in uri:\n                add_uri(uri, rawnode)\n\n\ndef rewrite_github_anchor(app: Sphinx, uri: str) -> str | None:\n    \"\"\"Rewrite anchor name of the hyperlink to github.com\n\n    The hyperlink anchors in github.com are dynamically generated.  This rewrites\n    them before checking and makes them comparable.\n    \"\"\"\n    parsed = urlparse(uri)\n    if parsed.hostname == \"github.com\" and parsed.fragment:\n        prefixed = parsed.fragment.startswith('user-content-')\n        if not prefixed:\n            fragment = f'user-content-{parsed.fragment}'\n            return urlunparse(parsed._replace(fragment=fragment))\n    return None\n\n\ndef compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -> None:\n    \"\"\"Compile patterns in linkcheck_allowed_redirects to the regexp objects.\"\"\"\n    for url, pattern in list(app.config.linkcheck_allowed_redirects.items()):\n        try:\n            app.config.linkcheck_allowed_redirects[re.compile(url)] = re.compile(pattern)\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects: %r %s'),\n                           exc.pattern, exc.msg)\n        finally:\n            # Remove the original regexp-string\n            app.config.linkcheck_allowed_redirects.pop(url)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 19389,
                "end_index": 21951,
                "start_line": 493,
                "end_line": 559,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "# Ref: https://help.github.com/en/github/building-a-strong-community/configuring-issue-templates-for-your-repository#configuring-the-template-chooser\nblank_issues_enabled: false  # default: true\ncontact_links:\n- name: Question\n  url: https://stackoverflow.com/questions/tagged/python-sphinx\n  about: For Q&A purpose, please use Stackoverflow with the tag python-sphinx\n- name: Discussion\n  url: https://groups.google.com/forum/#!forum/sphinx-users\n  about: For general discussion, please use sphinx-users mailing list.",
                "filename": ".github/ISSUE_TEMPLATE/config.yml",
                "start_index": 0,
                "end_index": 518,
                "start_line": 1,
                "end_line": 9,
                "max_line": 9,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "\"\"\"The CheckExternalLinksBuilder class.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport re\nimport socket\nimport time\nfrom copy import deepcopy\nfrom datetime import datetime, timezone\nfrom email.utils import parsedate_to_datetime\nfrom html.parser import HTMLParser\nfrom os import path\nfrom queue import PriorityQueue, Queue\nfrom threading import Thread\nfrom typing import Any, Generator, NamedTuple, Tuple, Union, cast\nfrom urllib.parse import unquote, urlparse, urlunparse\n\nfrom docutils import nodes\nfrom requests import Response\nfrom requests.exceptions import ConnectionError, HTTPError, TooManyRedirects\n\nfrom sphinx.application import Sphinx\nfrom sphinx.builders.dummy import DummyBuilder\nfrom sphinx.config import Config\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import __\nfrom sphinx.transforms.post_transforms import SphinxPostTransform\nfrom sphinx.util import encode_uri, logging, requests\nfrom sphinx.util.console import darkgray, darkgreen, purple, red, turquoise  # type: ignore\nfrom sphinx.util.nodes import get_node_line\n\nlogger = logging.getLogger(__name__)\n\nuri_re = re.compile('([a-z]+:)?//')  # matches to foo:// and // (a protocol relative URL)\n\n\nclass Hyperlink(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int | None\n\n\nclass CheckRequest(NamedTuple):\n    next_check: float\n    hyperlink: Hyperlink | None\n\n\nclass CheckResult(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int\n    status: str\n    message: str\n    code: int\n\n\nclass RateLimit(NamedTuple):\n    delay: float\n    next_check: float\n\n\n# Tuple is old styled CheckRequest\nCheckRequestType = Union[CheckRequest, Tuple[float, str, str, int]]\n\nDEFAULT_REQUEST_HEADERS = {\n    'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',\n}\nCHECK_IMMEDIATELY = 0\nQUEUE_POLL_SECS = 1\nDEFAULT_DELAY = 60.0\n\n\nclass AnchorCheckParser(HTMLParser):\n    \"\"\"Specialized HTML parser that looks for a specific anchor.\"\"\"\n\n    def __init__(self, search_anchor: str) -> None:\n        super().__init__()\n\n        self.search_anchor = search_anchor\n        self.found = False\n\n    def handle_starttag(self, tag: Any, attrs: Any) -> None:\n        for key, value in attrs:\n            if key in ('id', 'name') and value == self.search_anchor:\n                self.found = True\n                break",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 0,
                "end_index": 2310,
                "start_line": 1,
                "end_line": 430,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "\"\"\"Extension to save typing and prevent hard-coding of base URLs in reST files.\n\nThis adds a new config value called ``extlinks`` that is created like this::\n\n   extlinks = {'exmpl': ('https://example.invalid/%s.html', caption), ...}\n\nNow you can use e.g. :exmpl:`foo` in your documents.  This will create a\nlink to ``https://example.invalid/foo.html``.  The link caption depends on\nthe *caption* value given:\n\n- If it is ``None``, the caption will be the full URL.\n- If it is a string, it must contain ``%s`` exactly once.  In this case the\n  caption will be *caption* with the role content substituted for ``%s``.\n\nYou can also give an explicit caption, e.g. :exmpl:`Foo <foo>`.\n\nBoth, the url string and the caption string must escape ``%`` as ``%%``.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any\n\nfrom docutils import nodes, utils\nfrom docutils.nodes import Node, system_message\nfrom docutils.parsers.rst.states import Inliner\n\nimport sphinx\nfrom sphinx.application import Sphinx\nfrom sphinx.locale import __\nfrom sphinx.transforms.post_transforms import SphinxPostTransform\nfrom sphinx.util import logging, rst\nfrom sphinx.util.nodes import split_explicit_title\nfrom sphinx.util.typing import RoleFunction\n\nlogger = logging.getLogger(__name__)\n\n\nclass ExternalLinksChecker(SphinxPostTransform):\n    \"\"\"\n    For each external link, check if it can be replaced by an extlink.\n\n    We treat each ``reference`` node without ``internal`` attribute as an external link.\n    \"\"\"\n\n    default_priority = 500\n\n    def run(self, **kwargs: Any) -> None:\n        if not self.config.extlinks_detect_hardcoded_links:\n            return\n\n        for refnode in self.document.findall(nodes.reference):\n            self.check_uri(refnode)\n\n    def check_uri(self, refnode: nodes.reference) -> None:\n        \"\"\"\n        If the URI in ``refnode`` has a replacement in ``extlinks``,\n        emit a warning with a replacement suggestion.\n        \"\"\"\n        if 'internal' in refnode or 'refuri' not in refnode:\n            return\n\n        uri = refnode['refuri']\n        title = refnode.astext()\n\n        for alias, (base_uri, _caption) in self.app.config.extlinks.items():\n            uri_pattern = re.compile(re.escape(base_uri).replace('%s', '(?P<value>.+)'))\n\n            match = uri_pattern.match(uri)\n            if (\n                match and\n                match.groupdict().get('value') and\n                '/' not in match.groupdict()['value']\n            ):\n                # build a replacement suggestion\n                msg = __('hardcoded link %r could be replaced by an extlink '\n                         '(try using %r instead)')\n                value = match.groupdict().get('value')\n                if uri != title:\n                    replacement = f\":{alias}:`{rst.escape(title)} <{value}>`\"\n                else:\n                    replacement = f\":{alias}:`{value}`\"\n                logger.warning(msg, uri, replacement, location=refnode)",
                "filename": "sphinx/ext/extlinks.py",
                "start_index": 0,
                "end_index": 2976,
                "start_line": 1,
                "end_line": 84,
                "max_line": 120,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "name: Bug report\ndescription: Something is not working correctly.\nlabels: \"bug\"\n\nbody:\n  - type: textarea\n    attributes:\n      label: Describe the bug\n      description: >-\n        A clear and concise description of what the bug is, including the \n        expected behaviour and what has gone wrong.\n        \n        Please include screenshots, if applicable.\n    validations:\n      required: true\n\n  - type: textarea\n    attributes:\n      label: How to Reproduce\n      description: >-\n        Please provide steps to reproduce this bug, with the smallest possible\n        set of source files. For normal bugs this should ideally be one \n        ``index.rst`` file, and for ``sphinx.ext.autodoc`` bugs, this should\n        ideally be a single ``index.rst`` file, and a single example Python \n        module.\n      placeholder: |\n        Minimal method (you can also paste the contents of ``index.rst`` and\n        ``conf.py`` into this report):\n        ```bash\n        $ echo \"Content demonstrating the bug...\" > index.rst\n        $ echo \"\" > conf.py\n        $ sphinx-build -M html . _build\n        $ # open _build/html/index and see bla bla\n        ```\n        \n        ``git clone`` method (this is advised against, to help the Sphinx team):\n        ```bash\n        $ git clone https://github.com/.../some_project\n        $ cd some_project\n        $ pip install -r requirements.txt\n        $ cd docs\n        $ make html SPHINXOPTS=\"-D language=de\"\n        $ # open _build/html/index and see bla bla\n        ```\n    validations:\n      required: true\n\n  - type: markdown\n    attributes:\n      value: |\n        ## Environment info\n\n  - type: textarea\n    attributes:\n      label: Environment Information\n      render: text\n      description: >-\n        Install the latest Sphinx \n        ``pip install -U \"sphinx>=5.3\"``\n        then run ``sphinx-build --bug-report`` or ``python -m sphinx --bug-report``.\n        and paste the output here.\n    validations:\n      required: true\n  - type: textarea\n    attributes:\n      label: Sphinx extensions\n      render: python\n      description: >-\n        Attempt to reproduce your error with the smallest set of extensions possible.\n        This makes it easier to determine where the problem you are encountering is.\n        \n        e.g. ``[\"sphinx.ext.autodoc\", \"recommonmark\"]``\n    validations:\n      required: false\n  - type: textarea\n    attributes:\n      label: Additional context\n      description: >-\n        Add any other context about the problem here, for example:\n        \n        * Any other tools used (Browser, TeX, etc) with versions\n        * Reference to another issue or pull request\n        * URL to some external resource",
                "filename": ".github/ISSUE_TEMPLATE/bug-report.yml",
                "start_index": 0,
                "end_index": 2685,
                "start_line": 1,
                "end_line": 83,
                "max_line": 83,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "class HyperlinkAvailabilityChecker:\n    def __init__(self, env: BuildEnvironment, config: Config) -> None:\n        self.config = config\n        self.env = env\n        self.rate_limits: dict[str, RateLimit] = {}\n        self.rqueue: Queue[CheckResult] = Queue()\n        self.workers: list[Thread] = []\n        self.wqueue: PriorityQueue[CheckRequest] = PriorityQueue()\n\n        self.to_ignore = [re.compile(x) for x in self.config.linkcheck_ignore]\n\n    def invoke_threads(self) -> None:\n        for _i in range(self.config.linkcheck_workers):\n            thread = HyperlinkAvailabilityCheckWorker(self.env, self.config,\n                                                      self.rqueue, self.wqueue,\n                                                      self.rate_limits)\n            thread.start()\n            self.workers.append(thread)\n\n    def shutdown_threads(self) -> None:\n        self.wqueue.join()\n        for _worker in self.workers:\n            self.wqueue.put(CheckRequest(CHECK_IMMEDIATELY, None), False)\n\n    def check(self, hyperlinks: dict[str, Hyperlink]) -> Generator[CheckResult, None, None]:\n        self.invoke_threads()\n\n        total_links = 0\n        for hyperlink in hyperlinks.values():\n            if self.is_ignored_uri(hyperlink.uri):\n                yield CheckResult(hyperlink.uri, hyperlink.docname, hyperlink.lineno,\n                                  'ignored', '', 0)\n            else:\n                self.wqueue.put(CheckRequest(CHECK_IMMEDIATELY, hyperlink), False)\n                total_links += 1\n\n        done = 0\n        while done < total_links:\n            yield self.rqueue.get()\n            done += 1\n\n        self.shutdown_threads()\n\n    def is_ignored_uri(self, uri: str) -> bool:\n        return any(pat.match(uri) for pat in self.to_ignore)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 7221,
                "end_index": 9009,
                "start_line": 201,
                "end_line": 245,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    app.add_builder(CheckExternalLinksBuilder)\n    app.add_post_transform(HyperlinkCollector)\n\n    app.add_config_value('linkcheck_ignore', [], False)\n    app.add_config_value('linkcheck_exclude_documents', [], False)\n    app.add_config_value('linkcheck_allowed_redirects', {}, False)\n    app.add_config_value('linkcheck_auth', [], False)\n    app.add_config_value('linkcheck_request_headers', {}, False)\n    app.add_config_value('linkcheck_retries', 1, False)\n    app.add_config_value('linkcheck_timeout', None, False, [int, float])\n    app.add_config_value('linkcheck_workers', 5, False)\n    app.add_config_value('linkcheck_anchors', True, False)\n    # Anchors starting with ! are ignored since they are\n    # commonly used for dynamic pages\n    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], False)\n    app.add_config_value('linkcheck_rate_limit_timeout', 300.0, False)\n\n    app.add_event('linkcheck-process-uri')\n\n    app.connect('config-inited', compile_linkcheck_allowed_redirects, priority=800)\n\n    # FIXME: Disable URL rewrite handler for github.com temporarily.\n    # ref: https://github.com/sphinx-doc/sphinx/issues/9435\n    # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 21954,
                "end_index": 23325,
                "start_line": 562,
                "end_line": 592,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            },
            {
                "code": "\"\"\"Allow `MathJax`_ to be used to display math in Sphinx's HTML writer.\n\nThis requires the MathJax JavaScript library on your webserver/computer.\n\n.. _MathJax: https://www.mathjax.org/\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom typing import Any, cast\n\nfrom docutils import nodes\n\nimport sphinx\nfrom sphinx.application import Sphinx\nfrom sphinx.domains.math import MathDomain\nfrom sphinx.errors import ExtensionError\nfrom sphinx.locale import _\nfrom sphinx.util.math import get_node_equation_number\nfrom sphinx.writers.html import HTML5Translator\n\n# more information for mathjax secure url is here:\n# https://docs.mathjax.org/en/latest/start.html#secure-access-to-the-cdn\nMATHJAX_URL = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'\n\nlogger = sphinx.util.logging.getLogger(__name__)\n\n\ndef html_visit_math(self: HTML5Translator, node: nodes.math) -> None:\n    self.body.append(self.starttag(node, 'span', '', CLASS='math notranslate nohighlight'))\n    self.body.append(self.builder.config.mathjax_inline[0] +\n                     self.encode(node.astext()) +\n                     self.builder.config.mathjax_inline[1] + '</span>')\n    raise nodes.SkipNode\n\n\ndef html_visit_displaymath(self: HTML5Translator, node: nodes.math_block) -> None:\n    self.body.append(self.starttag(node, 'div', CLASS='math notranslate nohighlight'))\n    if node['nowrap']:\n        self.body.append(self.encode(node.astext()))\n        self.body.append('</div>')\n        raise nodes.SkipNode\n\n    # necessary to e.g. set the id property correctly\n    if node['number']:\n        number = get_node_equation_number(self, node)\n        self.body.append('<span class=\"eqno\">(%s)' % number)\n        self.add_permalink_ref(node, _('Permalink to this equation'))\n        self.body.append('</span>')\n    self.body.append(self.builder.config.mathjax_display[0])\n    parts = [prt for prt in node.astext().split('\\n\\n') if prt.strip()]\n    if len(parts) > 1:  # Add alignment if there are more than 1 equation\n        self.body.append(r' \\begin{align}\\begin{aligned}')\n    for i, part in enumerate(parts):\n        part = self.encode(part)\n        if r'\\\\' in part:\n            self.body.append(r'\\begin{split}' + part + r'\\end{split}')\n        else:\n            self.body.append(part)\n        if i < len(parts) - 1:  # append new line if not the last equation\n            self.body.append(r'\\\\')\n    if len(parts) > 1:  # Add alignment if there are more than 1 equation\n        self.body.append(r'\\end{aligned}\\end{align} ')\n    self.body.append(self.builder.config.mathjax_display[1])\n    self.body.append('</div>\\n')\n    raise nodes.SkipNode",
                "filename": "sphinx/ext/mathjax.py",
                "start_index": 0,
                "end_index": 2636,
                "start_line": 1,
                "end_line": 67,
                "max_line": 122,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                "sha": ""
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "sphinx/builders/linkcheck.py": [
                {
                    "chunk": {
                        "code": "try:\n                if anchor and self.config.linkcheck_anchors:\n                    # Read the whole document and see if #anchor exists\n                    with requests.get(req_url, stream=True, config=self.config, auth=auth_info,\n                                      **kwargs) as response:\n                        response.raise_for_status()\n                        found = check_anchor(response, unquote(anchor))\n\n                    if not found:\n                        raise Exception(__(\"Anchor '%s' not found\") % anchor)\n                else:\n                    try:\n                        # try a HEAD request first, which should be easier on\n                        # the server and the network\n                        with requests.head(req_url, allow_redirects=True, config=self.config,\n                                           auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n                    # Servers drop the connection on HEAD requests, causing\n                    # ConnectionError.\n                    except (ConnectionError, HTTPError, TooManyRedirects) as err:\n                        if isinstance(err, HTTPError) and err.response.status_code == 429:\n                            raise\n                        # retry with GET request if that fails, some servers\n                        # don't like HEAD requests.\n                        with requests.get(req_url, stream=True, config=self.config,\n                                          auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n            except HTTPError as err:\n                if err.response.status_code == 401:\n                    # We'll take \"Unauthorized\" as working.\n                    return 'working', ' - unauthorized', 0\n                elif err.response.status_code == 429:\n                    next_check = self.limit_rate(err.response)\n                    if next_check is not None:\n                        self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                        return 'rate-limited', '', 0\n                    return 'broken', str(err), 0\n                elif err.response.status_code == 503:\n                    # We'll take \"Service Unavailable\" as ignored.\n                    return 'ignored', str(err), 0\n                else:\n                    return 'broken', str(err), 0\n            except Exception as err:\n                return 'broken', str(err), 0\n            else:\n                netloc = urlparse(req_url).netloc\n                try:\n                    del self.rate_limits[netloc]\n                except KeyError:\n                    pass",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 11520,
                        "end_index": 14211,
                        "start_line": 156,
                        "end_line": 468,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the logic for checking anchors which is relevant to the issue as the feature request is to disable anchor checks for specific URLs."
                },
                {
                    "chunk": {
                        "code": "\"\"\"The CheckExternalLinksBuilder class.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport re\nimport socket\nimport time\nfrom copy import deepcopy\nfrom datetime import datetime, timezone\nfrom email.utils import parsedate_to_datetime\nfrom html.parser import HTMLParser\nfrom os import path\nfrom queue import PriorityQueue, Queue\nfrom threading import Thread\nfrom typing import Any, Generator, NamedTuple, Tuple, Union, cast\nfrom urllib.parse import unquote, urlparse, urlunparse\n\nfrom docutils import nodes\nfrom requests import Response\nfrom requests.exceptions import ConnectionError, HTTPError, TooManyRedirects\n\nfrom sphinx.application import Sphinx\nfrom sphinx.builders.dummy import DummyBuilder\nfrom sphinx.config import Config\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import __\nfrom sphinx.transforms.post_transforms import SphinxPostTransform\nfrom sphinx.util import encode_uri, logging, requests\nfrom sphinx.util.console import darkgray, darkgreen, purple, red, turquoise  # type: ignore\nfrom sphinx.util.nodes import get_node_line\n\nlogger = logging.getLogger(__name__)\n\nuri_re = re.compile('([a-z]+:)?//')  # matches to foo:// and // (a protocol relative URL)\n\n\nclass Hyperlink(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int | None\n\n\nclass CheckRequest(NamedTuple):\n    next_check: float\n    hyperlink: Hyperlink | None\n\n\nclass CheckResult(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int\n    status: str\n    message: str\n    code: int\n\n\nclass RateLimit(NamedTuple):\n    delay: float\n    next_check: float\n\n\n# Tuple is old styled CheckRequest\nCheckRequestType = Union[CheckRequest, Tuple[float, str, str, int]]\n\nDEFAULT_REQUEST_HEADERS = {\n    'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',\n}\nCHECK_IMMEDIATELY = 0\nQUEUE_POLL_SECS = 1\nDEFAULT_DELAY = 60.0\n\n\nclass AnchorCheckParser(HTMLParser):\n    \"\"\"Specialized HTML parser that looks for a specific anchor.\"\"\"\n\n    def __init__(self, search_anchor: str) -> None:\n        super().__init__()\n\n        self.search_anchor = search_anchor\n        self.found = False\n\n    def handle_starttag(self, tag: Any, attrs: Any) -> None:\n        for key, value in attrs:\n            if key in ('id', 'name') and value == self.search_anchor:\n                self.found = True\n                break",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 0,
                        "end_index": 2310,
                        "start_line": 1,
                        "end_line": 430,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the CheckExternalLinksBuilder class and may need to be modified to implement the new configuration option to disable anchor checks for specific URLs."
                },
                {
                    "chunk": {
                        "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    app.add_builder(CheckExternalLinksBuilder)\n    app.add_post_transform(HyperlinkCollector)\n\n    app.add_config_value('linkcheck_ignore', [], False)\n    app.add_config_value('linkcheck_exclude_documents', [], False)\n    app.add_config_value('linkcheck_allowed_redirects', {}, False)\n    app.add_config_value('linkcheck_auth', [], False)\n    app.add_config_value('linkcheck_request_headers', {}, False)\n    app.add_config_value('linkcheck_retries', 1, False)\n    app.add_config_value('linkcheck_timeout', None, False, [int, float])\n    app.add_config_value('linkcheck_workers', 5, False)\n    app.add_config_value('linkcheck_anchors', True, False)\n    # Anchors starting with ! are ignored since they are\n    # commonly used for dynamic pages\n    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], False)\n    app.add_config_value('linkcheck_rate_limit_timeout', 300.0, False)\n\n    app.add_event('linkcheck-process-uri')\n\n    app.connect('config-inited', compile_linkcheck_allowed_redirects, priority=800)\n\n    # FIXME: Disable URL rewrite handler for github.com temporarily.\n    # ref: https://github.com/sphinx-doc/sphinx/issues/9435\n    # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 21954,
                        "end_index": 23325,
                        "start_line": 562,
                        "end_line": 592,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__7.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is where new configuration values are added, and the feature request is to add a new configuration option."
                }
            ]
        },
        "solution_task": "To implement the feature that allows disabling linkcheck anchor checks for specific URLs based on a regex of the entire URL, you can follow these steps:\n\n- Add a new configuration option to the Sphinx configuration to specify the URLs for which anchor checks should be disabled.\n- Modify the link checking logic to consult this configuration and skip anchor checks for matching URLs.\n\nHere's a high-level overview of the implementation:\n\n1. Add a new configuration option in `sphinx/builders/linkcheck.py`:\n   ```python\n   app.add_config_value('linkcheck_anchors_disabled', [], False)\n   ```\n\n2. Modify the `HyperlinkAvailabilityChecker` class to include a method that checks if anchor checking should be skipped for a given URL:\n   ```python\n   class HyperlinkAvailabilityChecker:\n       # ... existing code ...\n\n       def is_anchor_check_disabled(self, uri: str) -> bool:\n           return any(re.compile(pattern).match(uri) for pattern in self.config.linkcheck_anchors_disabled)\n   ```\n\n3. Update the `check` method in the `HyperlinkAvailabilityChecker` class to use the new `is_anchor_check_disabled` method:\n   ```python\n   class HyperlinkAvailabilityChecker:\n       # ... existing code ...\n\n       def check(self, hyperlinks: dict[str, Hyperlink]) -> Generator[CheckResult, None, None]:\n           # ... existing code ...\n\n           for hyperlink in hyperlinks.values():\n               if self.is_ignored_uri(hyperlink.uri) or self.is_anchor_check_disabled(hyperlink.uri):\n                   yield CheckResult(hyperlink.uri, hyperlink.docname, hyperlink.lineno, 'ignored', '', 0)\n               else:\n                   # ... existing code ...\n   ```\n\n4. In the `check_uri` function within the `HyperlinkAvailabilityCheckWorker` class, skip the anchor check if `is_anchor_check_disabled` returns `True`:\n   ```python\n   class HyperlinkAvailabilityCheckWorker:\n       # ... existing code ...\n\n       def check_uri(self) -> tuple[str, str, int]:\n           # ... existing code ...\n\n           if anchor and self.config.linkcheck_anchors and not self.is_anchor_check_disabled(req_url):\n               # ... existing anchor check code ...\n           else:\n               # ... existing code for handling non-anchor checks ...\n   ```\n\n5. Update the Sphinx configuration file (usually `conf.py`) to include the new `linkcheck_anchors_disabled` option with the desired regex patterns:\n   ```python\n   linkcheck_anchors_disabled = [\n       r'https://github.com/.*'  # Example pattern to disable anchor checks for GitHub URLs\n   ]\n   ```\n\nThis implementation will allow users to specify patterns for URLs that should skip anchor checks while still performing other link checks. The `is_anchor_check_disabled` method will be used to determine whether a given URL matches any of the user-defined patterns. If a match is found, the anchor check will be skipped for that URL.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable step-by-step guide to implement the feature request of disabling linkcheck anchor checks for specific URLs based on regex patterns. It includes code snippets and modifications to the Sphinx configuration, which are directly relevant to the feature request. The RESPONSE also references specific sections of the codebase where changes need to be made, which is highly useful for developers looking to implement this feature. The only reason it does not score a 10 is that it does not address the alternative solutions or additional context provided in the PROMPT, which could have been acknowledged or integrated into the solution.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711701071.079021,
        "result": "To implement the feature that allows disabling linkcheck anchor checks for specific URLs based on a regex of the entire URL, you can follow these steps:\n\n- Add a new configuration option to the Sphinx configuration to specify the URLs for which anchor checks should be disabled.\n- Modify the link checking logic to consult this configuration and skip anchor checks for matching URLs.\n\nHere's a high-level overview of the implementation:\n\n1. Add a new configuration option in `sphinx/builders/linkcheck.py`:\n   ```python\n   app.add_config_value('linkcheck_anchors_disabled', [], False)\n   ```\n\n2. Modify the `HyperlinkAvailabilityChecker` class to include a method that checks if anchor checking should be skipped for a given URL:\n   ```python\n   class HyperlinkAvailabilityChecker:\n       # ... existing code ...\n\n       def is_anchor_check_disabled(self, uri: str) -> bool:\n           return any(re.compile(pattern).match(uri) for pattern in self.config.linkcheck_anchors_disabled)\n   ```\n\n3. Update the `check` method in the `HyperlinkAvailabilityChecker` class to use the new `is_anchor_check_disabled` method:\n   ```python\n   class HyperlinkAvailabilityChecker:\n       # ... existing code ...\n\n       def check(self, hyperlinks: dict[str, Hyperlink]) -> Generator[CheckResult, None, None]:\n           # ... existing code ...\n\n           for hyperlink in hyperlinks.values():\n               if self.is_ignored_uri(hyperlink.uri) or self.is_anchor_check_disabled(hyperlink.uri):\n                   yield CheckResult(hyperlink.uri, hyperlink.docname, hyperlink.lineno, 'ignored', '', 0)\n               else:\n                   # ... existing code ...\n   ```\n\n4. In the `check_uri` function within the `HyperlinkAvailabilityCheckWorker` class, skip the anchor check if `is_anchor_check_disabled` returns `True`:\n   ```python\n   class HyperlinkAvailabilityCheckWorker:\n       # ... existing code ...\n\n       def check_uri(self) -> tuple[str, str, int]:\n           # ... existing code ...\n\n           if anchor and self.config.linkcheck_anchors and not self.is_anchor_check_disabled(req_url):\n               # ... existing anchor check code ...\n           else:\n               # ... existing code for handling non-anchor checks ...\n   ```\n\n5. Update the Sphinx configuration file (usually `conf.py`) to include the new `linkcheck_anchors_disabled` option with the desired regex patterns:\n   ```python\n   linkcheck_anchors_disabled = [\n       r'https://github.com/.*'  # Example pattern to disable anchor checks for GitHub URLs\n   ]\n   ```\n\nThis implementation will allow users to specify patterns for URLs that should skip anchor checks while still performing other link checks. The `is_anchor_check_disabled` method will be used to determine whether a given URL matches any of the user-defined patterns. If a match is found, the anchor check will be skipped for that URL.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__7.1/tree//sphinx) \u2192 [builders](https://github.com/testbed/sphinx-doc__sphinx__7.1/tree//sphinx/builders)- [Lines 156 - 468](https://github.com/testbed/sphinx-doc__sphinx__7.1/blob//sphinx/builders/linkcheck.py#L156-L468)\n\n This snippet contains the logic for checking anchors which is relevant to the issue as the feature request is to disable anchor checks for specific URLs. \n\n\n   - [Lines 1 - 430](https://github.com/testbed/sphinx-doc__sphinx__7.1/blob//sphinx/builders/linkcheck.py#L1-L430)\n\n This snippet defines the CheckExternalLinksBuilder class and may need to be modified to implement the new configuration option to disable anchor checks for specific URLs. \n\n\n   - [Lines 562 - 592](https://github.com/testbed/sphinx-doc__sphinx__7.1/blob//sphinx/builders/linkcheck.py#L562-L592)\n\n This snippet is where new configuration values are added, and the feature request is to add a new configuration option."
    }
}