{
    "id": "django__django-11666",
    "repo_name": "testbed/django__django__3.0",
    "task_id": 1561734957245824914,
    "title": "Allowing patch_vary_headers() caching utility to handle '*' value.",
    "body": "Description\n\t\nFunction \"patch_vary_headers\", simply appends new headers to list. If view code sets Vary header to asterisk, the resulting header (after applying SessionMiddleware and LocaleMiddleware) looks like this:\nVary: *, Accept-Language, Cookie\nThis is unnecessary and possible violates HTTP spec:\nThe \"Vary\" header field in a response describes what parts of a\n request message, aside from the method, Host header field, and\n request target, might influence the origin server's process for\n selecting and representing this response. The value consists of\n either a single asterisk (\"*\") or a list of header field names\n (case-insensitive).\n\t Vary = \"*\" / 1#field-name\n(from \u200bhttps://tools.ietf.org/html/rfc7231#page-70)\nI am using Django to implement REST API, so I'd like it to speak robust HTTP, that works with all present and future caching libraries, \u2014 even if widely used browsers and Nginx can correctly interpret current form of the header.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.0.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `patch_vary_headers` function in `django/utils/cache.py` to handle the case where the `Vary` header is set to `*` and not append additional fields:\n\n```python\ndef patch_vary_headers(response, newheaders):\n    \"\"\"\n    Add (or update) the \"Vary\" header in the given HttpResponse object.\n    newheaders is a list of header names that should be in \"Vary\". If headers\n    contains an asterisk, then \"Vary\" header will consist of a single asterisk\n    '*'. Otherwise, existing headers in \"Vary\" aren't removed.\n    \"\"\"\n    if response.has_header(\"Vary\"):\n        vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n        if \"*\" in vary_headers:\n            return  # Do not append additional fields if '*' is present\n    else:\n        vary_headers = []\n    # Use .lower() here so we treat headers as case-insensitive.\n    existing_headers = {header.lower() for header in vary_headers}\n    additional_headers = [\n        newheader\n        for newheader in newheaders\n        if newheader.lower() not in existing_headers\n    ]\n    vary_headers += additional_headers\n    response.headers[\"Vary\"] = \", \".join(vary_headers)\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.0/tree//django/utils)- [Lines 298 - 373](https://github.com/testbed/django__django__3.0/blob//django/utils/cache.py#L298-L373)\n\n This snippet contains the 'patch_vary_headers' function which is directly related to the issue of handling the '*' value in the 'Vary' header. \n\n\n   - [Lines 1 - 30](https://github.com/testbed/django__django__3.0/blob//django/utils/cache.py#L1-L30)\n\n This snippet provides context for the 'patch_vary_headers' function and the handling of the 'Vary' header, which is relevant to understanding the issue.\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [views](https://github.com/testbed/django__django__3.0/tree//django/views) \u2192 [decorators](https://github.com/testbed/django__django__3.0/tree//django/views/decorators)- [Lines 1 - 44](https://github.com/testbed/django__django__3.0/blob//django/views/decorators/vary.py#L1-L44)\n\n This snippet uses the 'patch_vary_headers' function within the 'vary_on_headers' decorator, which may need to be reviewed to ensure it handles the '*' value correctly.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000263,
        "snippet_processor": 0.03901,
        "issue_star_creation": 0.01774,
        "issue_star_solver": 0.07738,
        "bouncer": 0.02554
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711728338.5669188,
        "relevant_snippets": [
            {
                "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.utils.cache import patch_vary_headers\n\n\ndef vary_on_headers(*headers):\n    \"\"\"\n    A view decorator that adds the specified headers to the Vary header of the\n    response. Usage:\n\n       @vary_on_headers('Cookie', 'Accept-language')\n       def index(request):\n           ...\n\n    Note that the header names are not case-sensitive.\n    \"\"\"\n\n    def decorator(func):\n        if iscoroutinefunction(func):\n\n            async def _view_wrapper(request, *args, **kwargs):\n                response = await func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n\n        else:\n\n            def _view_wrapper(request, *args, **kwargs):\n                response = func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n\n        return wraps(func)(_view_wrapper)\n\n    return decorator\n\n\nvary_on_cookie = vary_on_headers(\"Cookie\")\nvary_on_cookie.__doc__ = (\n    'A view decorator that adds \"Cookie\" to the Vary header of a response. This '\n    \"indicates that a page's contents depends on cookies.\"\n)",
                "filename": "django/views/decorators/vary.py",
                "start_index": 0,
                "end_index": 1200,
                "start_line": 1,
                "end_line": 44,
                "max_line": 44,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def patch_vary_headers(response, newheaders):\n    \"\"\"\n    Add (or update) the \"Vary\" header in the given HttpResponse object.\n    newheaders is a list of header names that should be in \"Vary\". If headers\n    contains an asterisk, then \"Vary\" header will consist of a single asterisk\n    '*'. Otherwise, existing headers in \"Vary\" aren't removed.\n    \"\"\"\n    # Note that we need to keep the original order intact, because cache\n    # implementations may rely on the order of the Vary contents in, say,\n    # computing an MD5 hash.\n    if response.has_header(\"Vary\"):\n        vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    else:\n        vary_headers = []\n    # Use .lower() here so we treat headers as case-insensitive.\n    existing_headers = {header.lower() for header in vary_headers}\n    additional_headers = [\n        newheader\n        for newheader in newheaders\n        if newheader.lower() not in existing_headers\n    ]\n    vary_headers += additional_headers\n    if \"*\" in vary_headers:\n        response.headers[\"Vary\"] = \"*\"\n    else:\n        response.headers[\"Vary\"] = \", \".join(vary_headers)\n\n\ndef has_vary_header(response, header_query):\n    \"\"\"\n    Check to see if the response has a given header name in its Vary header.\n    \"\"\"\n    if not response.has_header(\"Vary\"):\n        return False\n    vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    existing_headers = {header.lower() for header in vary_headers}\n    return header_query.lower() in existing_headers\n\n\ndef _i18n_cache_key_suffix(request, cache_key):\n    \"\"\"If necessary, add the current locale or time zone to the cache key.\"\"\"\n    if settings.USE_I18N:\n        # first check if LocaleMiddleware or another middleware added\n        # LANGUAGE_CODE to request, then fall back to the active language\n        # which in turn can also fall back to settings.LANGUAGE_CODE\n        cache_key += \".%s\" % getattr(request, \"LANGUAGE_CODE\", get_language())\n    if settings.USE_TZ:\n        cache_key += \".%s\" % get_current_timezone_name()\n    return cache_key\n\n\ndef _generate_cache_key(request, method, headerlist, key_prefix):\n    \"\"\"Return a cache key from the headers given in the header list.\"\"\"\n    ctx = md5(usedforsecurity=False)\n    for header in headerlist:\n        value = request.META.get(header)\n        if value is not None:\n            ctx.update(value.encode())\n    url = md5(request.build_absolute_uri().encode(\"ascii\"), usedforsecurity=False)\n    cache_key = \"views.decorators.cache.cache_page.%s.%s.%s.%s\" % (\n        key_prefix,\n        method,\n        url.hexdigest(),\n        ctx.hexdigest(),\n    )\n    return _i18n_cache_key_suffix(request, cache_key)",
                "filename": "django/utils/cache.py",
                "start_index": 10415,
                "end_index": 13075,
                "start_line": 298,
                "end_line": 373,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\nThis module contains helper functions for controlling caching. It does so by\nmanaging the \"Vary\" header of responses. It includes functions to patch the\nheader of response objects directly and decorators that change functions to do\nthat header-patching themselves.\n\nFor information on the Vary header, see RFC 9110 Section 12.5.5.\n\nEssentially, the \"Vary\" HTTP header defines which headers a cache should take\ninto account when building its cache key. Requests with the same path but\ndifferent header content for headers named in \"Vary\" need to get different\ncache keys to prevent delivery of wrong content.\n\nAn example: i18n middleware would need to distinguish caches by the\n\"Accept-language\" header.\n\"\"\"\nimport time\nfrom collections import defaultdict\nfrom hashlib import md5\n\nfrom django.conf import settings\nfrom django.core.cache import caches\nfrom django.http import HttpResponse, HttpResponseNotModified\nfrom django.utils.http import http_date, parse_etags, parse_http_date_safe, quote_etag\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_current_timezone_name\nfrom django.utils.translation import get_language\n\ncc_delim_re = _lazy_re_compile(r\"\\s*,\\s*\")",
                "filename": "django/utils/cache.py",
                "start_index": 0,
                "end_index": 1253,
                "start_line": 1,
                "end_line": 30,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "from django.utils.cache import patch_vary_headers\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.text import compress_sequence, compress_string\n\nre_accepts_gzip = _lazy_re_compile(r\"\\bgzip\\b\")\n\n\nclass GZipMiddleware(MiddlewareMixin):\n    \"\"\"\n    Compress content if the browser allows gzip compression.\n    Set the Vary header accordingly, so that caches will base their storage\n    on the Accept-Encoding header.\n    \"\"\"\n\n    max_random_bytes = 100\n\n    def process_response(self, request, response):\n        # It's not worth attempting to compress really short responses.\n        if not response.streaming and len(response.content) < 200:\n            return response\n\n        # Avoid gzipping if we've already got a content-encoding.\n        if response.has_header(\"Content-Encoding\"):\n            return response\n\n        patch_vary_headers(response, (\"Accept-Encoding\",))\n\n        ae = request.META.get(\"HTTP_ACCEPT_ENCODING\", \"\")\n        if not re_accepts_gzip.search(ae):\n            return response\n\n        if response.streaming:\n            if response.is_async:\n                # pull to lexical scope to capture fixed reference in case\n                # streaming_content is set again later.\n                orignal_iterator = response.streaming_content\n\n                async def gzip_wrapper():\n                    async for chunk in orignal_iterator:\n                        yield compress_string(\n                            chunk,\n                            max_random_bytes=self.max_random_bytes,\n                        )\n\n                response.streaming_content = gzip_wrapper()\n            else:\n                response.streaming_content = compress_sequence(\n                    response.streaming_content,\n                    max_random_bytes=self.max_random_bytes,\n                )\n            # Delete the `Content-Length` header for streaming content, because\n            # we won't know the compressed size until we stream it.\n            del response.headers[\"Content-Length\"]\n        else:\n            # Return the compressed content only if it's actually shorter.\n            compressed_content = compress_string(\n                response.content,\n                max_random_bytes=self.max_random_bytes,\n            )\n            if len(compressed_content) >= len(response.content):\n                return response\n            response.content = compressed_content\n            response.headers[\"Content-Length\"] = str(len(response.content))\n\n        # If there is a strong ETag, make it weak to fulfill the requirements\n        # of RFC 9110 Section 8.8.1 while also allowing conditional request\n        # matches on ETags.\n        etag = response.get(\"ETag\")\n        if etag and etag.startswith('\"'):\n            response.headers[\"ETag\"] = \"W/\" + etag\n        response.headers[\"Content-Encoding\"] = \"gzip\"\n\n        return response",
                "filename": "django/middleware/gzip.py",
                "start_index": 0,
                "end_index": 2944,
                "start_line": 1,
                "end_line": 74,
                "max_line": 74,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def _if_none_match_passes(target_etag, etags):\n    \"\"\"\n    Test the If-None-Match comparison as defined in RFC 9110 Section 13.1.2.\n    \"\"\"\n    if not target_etag:\n        # If there isn't an ETag, then there isn't a match.\n        return True\n    elif etags == [\"*\"]:\n        # The existence of an ETag means that there is \"a current\n        # representation for the target resource\", so there is a match to '*'.\n        return False\n    else:\n        # The comparison should be weak, so look for a match after stripping\n        # off any weak indicators.\n        target_etag = target_etag.strip(\"W/\")\n        etags = (etag.strip(\"W/\") for etag in etags)\n        return target_etag not in etags\n\n\ndef _if_modified_since_passes(last_modified, if_modified_since):\n    \"\"\"\n    Test the If-Modified-Since comparison as defined in RFC 9110 Section\n    13.1.3.\n    \"\"\"\n    return not last_modified or last_modified > if_modified_since\n\n\ndef patch_response_headers(response, cache_timeout=None):\n    \"\"\"\n    Add HTTP caching headers to the given HttpResponse: Expires and\n    Cache-Control.\n\n    Each header is only added if it isn't already set.\n\n    cache_timeout is in seconds. The CACHE_MIDDLEWARE_SECONDS setting is used\n    by default.\n    \"\"\"\n    if cache_timeout is None:\n        cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n    if cache_timeout < 0:\n        cache_timeout = 0  # Can't have max-age negative\n    if not response.has_header(\"Expires\"):\n        response.headers[\"Expires\"] = http_date(time.time() + cache_timeout)\n    patch_cache_control(response, max_age=cache_timeout)\n\n\ndef add_never_cache_headers(response):\n    \"\"\"\n    Add headers to a response to indicate that a page should never be cached.\n    \"\"\"\n    patch_response_headers(response, cache_timeout=-1)\n    patch_cache_control(\n        response, no_cache=True, no_store=True, must_revalidate=True, private=True\n    )",
                "filename": "django/utils/cache.py",
                "start_index": 8517,
                "end_index": 10412,
                "start_line": 242,
                "end_line": 372,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def patch_cache_control(response, **kwargs):\n    \"\"\"\n    Patch the Cache-Control header by adding all keyword arguments to it.\n    The transformation is as follows:\n\n    * All keyword parameter names are turned to lowercase, and underscores\n      are converted to hyphens.\n    * If the value of a parameter is True (exactly True, not just a\n      true value), only the parameter name is added to the header.\n    * All other parameters are added with their value, after applying\n      str() to it.\n    \"\"\"\n\n    def dictitem(s):\n        t = s.split(\"=\", 1)\n        if len(t) > 1:\n            return (t[0].lower(), t[1])\n        else:\n            return (t[0].lower(), True)\n\n    def dictvalue(*t):\n        if t[1] is True:\n            return t[0]\n        else:\n            return \"%s=%s\" % (t[0], t[1])\n\n    cc = defaultdict(set)\n    if response.get(\"Cache-Control\"):\n        for field in cc_delim_re.split(response.headers[\"Cache-Control\"]):\n            directive, value = dictitem(field)\n            if directive == \"no-cache\":\n                # no-cache supports multiple field names.\n                cc[directive].add(value)\n            else:\n                cc[directive] = value\n\n    # If there's already a max-age header but we're being asked to set a new\n    # max-age, use the minimum of the two ages. In practice this happens when\n    # a decorator and a piece of middleware both operate on a given view.\n    if \"max-age\" in cc and \"max_age\" in kwargs:\n        kwargs[\"max_age\"] = min(int(cc[\"max-age\"]), kwargs[\"max_age\"])\n\n    # Allow overriding private caching and vice versa\n    if \"private\" in cc and \"public\" in kwargs:\n        del cc[\"private\"]\n    elif \"public\" in cc and \"private\" in kwargs:\n        del cc[\"public\"]\n\n    for k, v in kwargs.items():\n        directive = k.replace(\"_\", \"-\")\n        if directive == \"no-cache\":\n            # no-cache supports multiple field names.\n            cc[directive].add(v)\n        else:\n            cc[directive] = v\n\n    directives = []\n    for directive, values in cc.items():\n        if isinstance(values, set):\n            if True in values:\n                # True takes precedence.\n                values = {True}\n            directives.extend([dictvalue(directive, value) for value in values])\n        else:\n            directives.append(dictvalue(directive, values))\n    cc = \", \".join(directives)\n    response.headers[\"Cache-Control\"] = cc\n\n\ndef get_max_age(response):\n    \"\"\"\n    Return the max-age from the response Cache-Control header as an integer,\n    or None if it wasn't found or wasn't an integer.\n    \"\"\"\n    if not response.has_header(\"Cache-Control\"):\n        return\n    cc = dict(\n        _to_tuple(el) for el in cc_delim_re.split(response.headers[\"Cache-Control\"])\n    )\n    try:\n        return int(cc[\"max-age\"])\n    except (ValueError, TypeError, KeyError):\n        pass",
                "filename": "django/utils/cache.py",
                "start_index": 1256,
                "end_index": 4107,
                "start_line": 33,
                "end_line": 115,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "def learn_cache_key(request, response, cache_timeout=None, key_prefix=None, cache=None):\n    \"\"\"\n    Learn what headers to take into account for some request URL from the\n    response object. Store those headers in a global URL registry so that\n    later access to that URL will know what headers to take into account\n    without building the response object itself. The headers are named in the\n    Vary header of the response, but we want to prevent response generation.\n\n    The list of headers to use for cache key generation is stored in the same\n    cache as the pages themselves. If the cache ages some data out of the\n    cache, this just means that we have to build the response once to get at\n    the Vary header and so at the list of headers to use for the cache key.\n    \"\"\"\n    if key_prefix is None:\n        key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n    if cache_timeout is None:\n        cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n    cache_key = _generate_cache_header_key(key_prefix, request)\n    if cache is None:\n        cache = caches[settings.CACHE_MIDDLEWARE_ALIAS]\n    if response.has_header(\"Vary\"):\n        is_accept_language_redundant = settings.USE_I18N\n        # If i18n is used, the generated cache key will be suffixed with the\n        # current locale. Adding the raw value of Accept-Language is redundant\n        # in that case and would result in storing the same content under\n        # multiple keys in the cache. See #18191 for details.\n        headerlist = []\n        for header in cc_delim_re.split(response.headers[\"Vary\"]):\n            header = header.upper().replace(\"-\", \"_\")\n            if header != \"ACCEPT_LANGUAGE\" or not is_accept_language_redundant:\n                headerlist.append(\"HTTP_\" + header)\n        headerlist.sort()\n        cache.set(cache_key, headerlist, cache_timeout)\n        return _generate_cache_key(request, request.method, headerlist, key_prefix)\n    else:\n        # if there is no Vary header, we still need a cache key\n        # for the request.build_absolute_uri()\n        cache.set(cache_key, [], cache_timeout)\n        return _generate_cache_key(request, request.method, [], key_prefix)\n\n\ndef _to_tuple(s):\n    t = s.split(\"=\", 1)\n    if len(t) == 2:\n        return t[0].lower(), t[1]\n    return t[0].lower(), True",
                "filename": "django/utils/cache.py",
                "start_index": 14279,
                "end_index": 16581,
                "start_line": 398,
                "end_line": 443,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "\"\"\"\nDecorators for views based on HTTP headers.\n\"\"\"\nimport datetime\nfrom functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.http import HttpResponseNotAllowed\nfrom django.middleware.http import ConditionalGetMiddleware\nfrom django.utils import timezone\nfrom django.utils.cache import get_conditional_response\nfrom django.utils.decorators import decorator_from_middleware\nfrom django.utils.http import http_date, quote_etag\nfrom django.utils.log import log_response\n\nconditional_page = decorator_from_middleware(ConditionalGetMiddleware)\n\n\ndef require_http_methods(request_method_list):\n    \"\"\"\n    Decorator to make a view only accept particular request methods.  Usage::\n\n        @require_http_methods([\"GET\", \"POST\"])\n        def my_view(request):\n            # I can assume now that only GET or POST requests make it this far\n            # ...\n\n    Note that request methods should be in uppercase.\n    \"\"\"\n\n    def decorator(func):\n        if iscoroutinefunction(func):\n\n            @wraps(func)\n            async def inner(request, *args, **kwargs):\n                if request.method not in request_method_list:\n                    response = HttpResponseNotAllowed(request_method_list)\n                    log_response(\n                        \"Method Not Allowed (%s): %s\",\n                        request.method,\n                        request.path,\n                        response=response,\n                        request=request,\n                    )\n                    return response\n                return await func(request, *args, **kwargs)\n\n        else:\n\n            @wraps(func)\n            def inner(request, *args, **kwargs):\n                if request.method not in request_method_list:\n                    response = HttpResponseNotAllowed(request_method_list)\n                    log_response(\n                        \"Method Not Allowed (%s): %s\",\n                        request.method,\n                        request.path,\n                        response=response,\n                        request=request,\n                    )\n                    return response\n                return func(request, *args, **kwargs)\n\n        return inner\n\n    return decorator\n\n\nrequire_GET = require_http_methods([\"GET\"])\nrequire_GET.__doc__ = \"Decorator to require that a view only accepts the GET method.\"\n\nrequire_POST = require_http_methods([\"POST\"])\nrequire_POST.__doc__ = \"Decorator to require that a view only accepts the POST method.\"\n\nrequire_safe = require_http_methods([\"GET\", \"HEAD\"])\nrequire_safe.__doc__ = (\n    \"Decorator to require that a view only accepts safe methods: GET and HEAD.\"\n)",
                "filename": "django/views/decorators/http.py",
                "start_index": 0,
                "end_index": 2653,
                "start_line": 1,
                "end_line": 168,
                "max_line": 168,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\n\ndef xframe_options_deny(view_func):\n    \"\"\"\n    Modify a view function so its response has the X-Frame-Options HTTP\n    header set to 'DENY' as long as the response doesn't already have that\n    header set. Usage:\n\n    @xframe_options_deny\n    def some_view(request):\n        ...\n    \"\"\"\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(*args, **kwargs):\n            response = await view_func(*args, **kwargs)\n            if response.get(\"X-Frame-Options\") is None:\n                response[\"X-Frame-Options\"] = \"DENY\"\n            return response\n\n    else:\n\n        def _view_wrapper(*args, **kwargs):\n            response = view_func(*args, **kwargs)\n            if response.get(\"X-Frame-Options\") is None:\n                response[\"X-Frame-Options\"] = \"DENY\"\n            return response\n\n    return wraps(view_func)(_view_wrapper)\n\n\ndef xframe_options_sameorigin(view_func):\n    \"\"\"\n    Modify a view function so its response has the X-Frame-Options HTTP\n    header set to 'SAMEORIGIN' as long as the response doesn't already have\n    that header set. Usage:\n\n    @xframe_options_sameorigin\n    def some_view(request):\n        ...\n    \"\"\"\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(*args, **kwargs):\n            response = await view_func(*args, **kwargs)\n            if response.get(\"X-Frame-Options\") is None:\n                response[\"X-Frame-Options\"] = \"SAMEORIGIN\"\n            return response\n\n    else:\n\n        def _view_wrapper(*args, **kwargs):\n            response = view_func(*args, **kwargs)\n            if response.get(\"X-Frame-Options\") is None:\n                response[\"X-Frame-Options\"] = \"SAMEORIGIN\"\n            return response\n\n    return wraps(view_func)(_view_wrapper)\n\n\ndef xframe_options_exempt(view_func):\n    \"\"\"\n    Modify a view function by setting a response variable that instructs\n    XFrameOptionsMiddleware to NOT set the X-Frame-Options HTTP header. Usage:\n\n    @xframe_options_exempt\n    def some_view(request):\n        ...\n    \"\"\"\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(*args, **kwargs):\n            response = await view_func(*args, **kwargs)\n            response.xframe_options_exempt = True\n            return response\n\n    else:\n\n        def _view_wrapper(*args, **kwargs):\n            response = view_func(*args, **kwargs)\n            response.xframe_options_exempt = True\n            return response\n\n    return wraps(view_func)(_view_wrapper)",
                "filename": "django/views/decorators/clickjacking.py",
                "start_index": 0,
                "end_index": 2554,
                "start_line": 1,
                "end_line": 90,
                "max_line": 90,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            },
            {
                "code": "from django.utils.cache import cc_delim_re, get_conditional_response, set_response_etag\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.http import parse_http_date_safe\n\n\nclass ConditionalGetMiddleware(MiddlewareMixin):\n    \"\"\"\n    Handle conditional GET operations. If the response has an ETag or\n    Last-Modified header and the request has If-None-Match or If-Modified-Since,\n    replace the response with HttpNotModified. Add an ETag header if needed.\n    \"\"\"\n\n    def process_response(self, request, response):\n        # It's too late to prevent an unsafe request with a 412 response, and\n        # for a HEAD request, the response body is always empty so computing\n        # an accurate ETag isn't possible.\n        if request.method != \"GET\":\n            return response\n\n        if self.needs_etag(response) and not response.has_header(\"ETag\"):\n            set_response_etag(response)\n\n        etag = response.get(\"ETag\")\n        last_modified = response.get(\"Last-Modified\")\n        last_modified = last_modified and parse_http_date_safe(last_modified)\n\n        if etag or last_modified:\n            return get_conditional_response(\n                request,\n                etag=etag,\n                last_modified=last_modified,\n                response=response,\n            )\n\n        return response\n\n    def needs_etag(self, response):\n        \"\"\"Return True if an ETag header should be added to response.\"\"\"\n        cache_control_headers = cc_delim_re.split(response.get(\"Cache-Control\", \"\"))\n        return all(header.lower() != \"no-store\" for header in cache_control_headers)",
                "filename": "django/middleware/http.py",
                "start_index": 0,
                "end_index": 1615,
                "start_line": 1,
                "end_line": 40,
                "max_line": 40,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.0",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/utils/cache.py": [
                {
                    "chunk": {
                        "code": "def patch_vary_headers(response, newheaders):\n    \"\"\"\n    Add (or update) the \"Vary\" header in the given HttpResponse object.\n    newheaders is a list of header names that should be in \"Vary\". If headers\n    contains an asterisk, then \"Vary\" header will consist of a single asterisk\n    '*'. Otherwise, existing headers in \"Vary\" aren't removed.\n    \"\"\"\n    # Note that we need to keep the original order intact, because cache\n    # implementations may rely on the order of the Vary contents in, say,\n    # computing an MD5 hash.\n    if response.has_header(\"Vary\"):\n        vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    else:\n        vary_headers = []\n    # Use .lower() here so we treat headers as case-insensitive.\n    existing_headers = {header.lower() for header in vary_headers}\n    additional_headers = [\n        newheader\n        for newheader in newheaders\n        if newheader.lower() not in existing_headers\n    ]\n    vary_headers += additional_headers\n    if \"*\" in vary_headers:\n        response.headers[\"Vary\"] = \"*\"\n    else:\n        response.headers[\"Vary\"] = \", \".join(vary_headers)\n\n\ndef has_vary_header(response, header_query):\n    \"\"\"\n    Check to see if the response has a given header name in its Vary header.\n    \"\"\"\n    if not response.has_header(\"Vary\"):\n        return False\n    vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n    existing_headers = {header.lower() for header in vary_headers}\n    return header_query.lower() in existing_headers\n\n\ndef _i18n_cache_key_suffix(request, cache_key):\n    \"\"\"If necessary, add the current locale or time zone to the cache key.\"\"\"\n    if settings.USE_I18N:\n        # first check if LocaleMiddleware or another middleware added\n        # LANGUAGE_CODE to request, then fall back to the active language\n        # which in turn can also fall back to settings.LANGUAGE_CODE\n        cache_key += \".%s\" % getattr(request, \"LANGUAGE_CODE\", get_language())\n    if settings.USE_TZ:\n        cache_key += \".%s\" % get_current_timezone_name()\n    return cache_key\n\n\ndef _generate_cache_key(request, method, headerlist, key_prefix):\n    \"\"\"Return a cache key from the headers given in the header list.\"\"\"\n    ctx = md5(usedforsecurity=False)\n    for header in headerlist:\n        value = request.META.get(header)\n        if value is not None:\n            ctx.update(value.encode())\n    url = md5(request.build_absolute_uri().encode(\"ascii\"), usedforsecurity=False)\n    cache_key = \"views.decorators.cache.cache_page.%s.%s.%s.%s\" % (\n        key_prefix,\n        method,\n        url.hexdigest(),\n        ctx.hexdigest(),\n    )\n    return _i18n_cache_key_suffix(request, cache_key)",
                        "filename": "django/utils/cache.py",
                        "start_index": 10415,
                        "end_index": 13075,
                        "start_line": 298,
                        "end_line": 373,
                        "max_line": 443,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'patch_vary_headers' function which is directly related to the issue of handling the '*' value in the 'Vary' header."
                },
                {
                    "chunk": {
                        "code": "\"\"\"\nThis module contains helper functions for controlling caching. It does so by\nmanaging the \"Vary\" header of responses. It includes functions to patch the\nheader of response objects directly and decorators that change functions to do\nthat header-patching themselves.\n\nFor information on the Vary header, see RFC 9110 Section 12.5.5.\n\nEssentially, the \"Vary\" HTTP header defines which headers a cache should take\ninto account when building its cache key. Requests with the same path but\ndifferent header content for headers named in \"Vary\" need to get different\ncache keys to prevent delivery of wrong content.\n\nAn example: i18n middleware would need to distinguish caches by the\n\"Accept-language\" header.\n\"\"\"\nimport time\nfrom collections import defaultdict\nfrom hashlib import md5\n\nfrom django.conf import settings\nfrom django.core.cache import caches\nfrom django.http import HttpResponse, HttpResponseNotModified\nfrom django.utils.http import http_date, parse_etags, parse_http_date_safe, quote_etag\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_current_timezone_name\nfrom django.utils.translation import get_language\n\ncc_delim_re = _lazy_re_compile(r\"\\s*,\\s*\")",
                        "filename": "django/utils/cache.py",
                        "start_index": 0,
                        "end_index": 1253,
                        "start_line": 1,
                        "end_line": 30,
                        "max_line": 443,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet provides context for the 'patch_vary_headers' function and the handling of the 'Vary' header, which is relevant to understanding the issue."
                }
            ],
            "django/views/decorators/vary.py": [
                {
                    "chunk": {
                        "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.utils.cache import patch_vary_headers\n\n\ndef vary_on_headers(*headers):\n    \"\"\"\n    A view decorator that adds the specified headers to the Vary header of the\n    response. Usage:\n\n       @vary_on_headers('Cookie', 'Accept-language')\n       def index(request):\n           ...\n\n    Note that the header names are not case-sensitive.\n    \"\"\"\n\n    def decorator(func):\n        if iscoroutinefunction(func):\n\n            async def _view_wrapper(request, *args, **kwargs):\n                response = await func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n\n        else:\n\n            def _view_wrapper(request, *args, **kwargs):\n                response = func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n\n        return wraps(func)(_view_wrapper)\n\n    return decorator\n\n\nvary_on_cookie = vary_on_headers(\"Cookie\")\nvary_on_cookie.__doc__ = (\n    'A view decorator that adds \"Cookie\" to the Vary header of a response. This '\n    \"indicates that a page's contents depends on cookies.\"\n)",
                        "filename": "django/views/decorators/vary.py",
                        "start_index": 0,
                        "end_index": 1200,
                        "start_line": 1,
                        "end_line": 44,
                        "max_line": 44,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet uses the 'patch_vary_headers' function within the 'vary_on_headers' decorator, which may need to be reviewed to ensure it handles the '*' value correctly."
                }
            ]
        },
        "solution_task": "- Modify the `patch_vary_headers` function in `django/utils/cache.py` to handle the case where the `Vary` header is set to `*` and not append additional fields:\n\n```python\ndef patch_vary_headers(response, newheaders):\n    \"\"\"\n    Add (or update) the \"Vary\" header in the given HttpResponse object.\n    newheaders is a list of header names that should be in \"Vary\". If headers\n    contains an asterisk, then \"Vary\" header will consist of a single asterisk\n    '*'. Otherwise, existing headers in \"Vary\" aren't removed.\n    \"\"\"\n    if response.has_header(\"Vary\"):\n        vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n        if \"*\" in vary_headers:\n            return  # Do not append additional fields if '*' is present\n    else:\n        vary_headers = []\n    # Use .lower() here so we treat headers as case-insensitive.\n    existing_headers = {header.lower() for header in vary_headers}\n    additional_headers = [\n        newheader\n        for newheader in newheaders\n        if newheader.lower() not in existing_headers\n    ]\n    vary_headers += additional_headers\n    response.headers[\"Vary\"] = \", \".join(vary_headers)\n```",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT. It suggests modifying the 'patch_vary_headers' function to handle the case where the 'Vary' header is set to '*', which is the core issue described. The provided code snippet is directly relevant and addresses the problem by checking for the presence of '*' in the 'Vary' header and returning early if it is found, thus preventing the addition of any other headers. This aligns with the HTTP specification mentioned in the PROMPT. Additionally, the RESPONSE includes references to the relevant code snippets in the Django repository, which is helpful for locating the function that needs to be modified. The RESPONSE does not address all aspects of the described bug, such as testing the change or considering the impact on other parts of the Django framework that may rely on the 'patch_vary_headers' function, which is why it does not receive a perfect score.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711728547.856888,
        "result": "- Modify the `patch_vary_headers` function in `django/utils/cache.py` to handle the case where the `Vary` header is set to `*` and not append additional fields:\n\n```python\ndef patch_vary_headers(response, newheaders):\n    \"\"\"\n    Add (or update) the \"Vary\" header in the given HttpResponse object.\n    newheaders is a list of header names that should be in \"Vary\". If headers\n    contains an asterisk, then \"Vary\" header will consist of a single asterisk\n    '*'. Otherwise, existing headers in \"Vary\" aren't removed.\n    \"\"\"\n    if response.has_header(\"Vary\"):\n        vary_headers = cc_delim_re.split(response.headers[\"Vary\"])\n        if \"*\" in vary_headers:\n            return  # Do not append additional fields if '*' is present\n    else:\n        vary_headers = []\n    # Use .lower() here so we treat headers as case-insensitive.\n    existing_headers = {header.lower() for header in vary_headers}\n    additional_headers = [\n        newheader\n        for newheader in newheaders\n        if newheader.lower() not in existing_headers\n    ]\n    vary_headers += additional_headers\n    response.headers[\"Vary\"] = \", \".join(vary_headers)\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.0/tree//django/utils)- [Lines 298 - 373](https://github.com/testbed/django__django__3.0/blob//django/utils/cache.py#L298-L373)\n\n This snippet contains the 'patch_vary_headers' function which is directly related to the issue of handling the '*' value in the 'Vary' header. \n\n\n   - [Lines 1 - 30](https://github.com/testbed/django__django__3.0/blob//django/utils/cache.py#L1-L30)\n\n This snippet provides context for the 'patch_vary_headers' function and the handling of the 'Vary' header, which is relevant to understanding the issue.\n-  \u2192 [django](https://github.com/testbed/django__django__3.0/tree//django) \u2192 [views](https://github.com/testbed/django__django__3.0/tree//django/views) \u2192 [decorators](https://github.com/testbed/django__django__3.0/tree//django/views/decorators)- [Lines 1 - 44](https://github.com/testbed/django__django__3.0/blob//django/views/decorators/vary.py#L1-L44)\n\n This snippet uses the 'patch_vary_headers' function within the 'vary_on_headers' decorator, which may need to be reviewed to ensure it handles the '*' value correctly."
    }
}