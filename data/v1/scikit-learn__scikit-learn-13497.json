{
    "id": "scikit-learn__scikit-learn-13497",
    "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
    "task_id": 3510962037560634596,
    "title": "Comparing string to array in _estimate_mi",
    "body": "In ``_estimate_mi`` there is ``discrete_features == 'auto'`` but discrete features can be an array of indices or a boolean mask.\r\nThis will error in future versions of numpy.\r\nAlso this means we never test this function with discrete features != 'auto', it seems?\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__0.21.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `_estimate_mi` function to handle `discrete_features` correctly when it is not `'auto'`. Ensure that the comparison with `'auto'` is done in a way that will not raise an error in future numpy versions.\n- Add test cases for `_estimate_mi` with `discrete_features` set to an array of indices and a boolean mask to ensure proper functionality.\n- Update the type checking or conversion of `discrete_features` before the comparison to handle both array-like and boolean mask inputs.\n- Ensure that the function can handle `discrete_features` being a boolean array without raising a FutureWarning or error due to numpy version changes. Use `isinstance(discrete_features, str)` to check if `discrete_features` is a string before comparing it to `'auto'`.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn) \u2192 [feature_selection](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn/feature_selection)- [Lines 201 - 415](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L201-L415)\n\n This snippet defines the _estimate_mi function where the issue with comparing string to array or boolean mask occurs. \n\n\n   - [Lines 399 - 399](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L399-L399)\n\n This snippet shows a call to _estimate_mi which may need to be reviewed to ensure proper handling of the discrete_features parameter. \n\n\n   - [Lines 489 - 490](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L489-L490)\n\n This snippet shows another call to _estimate_mi with the discrete_features parameter, indicating where the issue might manifest. \n\n\n   - [Lines 282 - 309](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L282-L309)\n\n This snippet is part of the _estimate_mi function and may need to be reviewed if changes to handling of discrete_features affect the internal logic.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0008225,
        "snippet_processor": 0.051160000000000004,
        "issue_star_creation": 0.035809999999999995,
        "issue_star_solver": 0.07194,
        "bouncer": 0.02488
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711740446.634634,
        "relevant_snippets": [
            {
                "code": "return _estimate_mi(X, y, discrete_features, False, n_neighbors, copy, random_state)",
                "filename": "sklearn/feature_selection/_mutual_info.py",
                "start_index": 13490,
                "end_index": 13574,
                "start_line": 399,
                "end_line": 399,
                "max_line": 490,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "def _estimate_mi(\n    X,\n    y,\n    discrete_features=\"auto\",\n    discrete_target=False,\n    n_neighbors=3,\n    copy=True,\n    random_state=None,\n):",
                "filename": "sklearn/feature_selection/_mutual_info.py",
                "start_index": 5792,
                "end_index": 5940,
                "start_line": 201,
                "end_line": 415,
                "max_line": 490,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "check_classification_targets(y)\n    return _estimate_mi(X, y, discrete_features, True, n_neighbors, copy, random_state)",
                "filename": "sklearn/feature_selection/_mutual_info.py",
                "start_index": 17292,
                "end_index": 17411,
                "start_line": 489,
                "end_line": 490,
                "max_line": 490,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "@ignore_warnings\ndef check_fit2d_1feature(name, estimator_orig):\n    # check fitting a 2d array with only 1 feature either works or returns\n    # informative message\n    rnd = np.random.RandomState(0)\n    X = 3 * rnd.uniform(size=(10, 1))\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    y = X[:, 0].astype(int)\n    estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if hasattr(estimator, \"n_components\"):\n        estimator.n_components = 1\n    if hasattr(estimator, \"n_clusters\"):\n        estimator.n_clusters = 1\n    # ensure two labels in subsample for RandomizedLogisticRegression\n    if name == \"RandomizedLogisticRegression\":\n        estimator.sample_fraction = 1\n    # ensure non skipped trials for RANSACRegressor\n    if name == \"RANSACRegressor\":\n        estimator.residual_threshold = 0.5\n\n    y = _enforce_estimator_tags_y(estimator, y)\n    set_random_state(estimator, 1)\n\n    msgs = [r\"1 feature\\(s\\)\", \"n_features = 1\", \"n_features=1\"]\n\n    with raises(ValueError, match=msgs, may_pass=True):\n        estimator.fit(X, y)\n\n\n@ignore_warnings\ndef check_fit1d(name, estimator_orig):\n    # check fitting 1d X array raises a ValueError\n    rnd = np.random.RandomState(0)\n    X = 3 * rnd.uniform(size=(20))\n    y = X.astype(int)\n    estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if hasattr(estimator, \"n_components\"):\n        estimator.n_components = 1\n    if hasattr(estimator, \"n_clusters\"):\n        estimator.n_clusters = 1\n\n    set_random_state(estimator, 1)\n    with raises(ValueError):\n        estimator.fit(X, y)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_transformer_general(name, transformer, readonly_memmap=False):\n    X, y = make_blobs(\n        n_samples=30,\n        centers=[[0, 0, 0], [1, 1, 1]],\n        random_state=0,\n        n_features=2,\n        cluster_std=0.1,\n    )\n    X = StandardScaler().fit_transform(X)\n    X = _enforce_estimator_tags_X(transformer, X)\n\n    if readonly_memmap:\n        X, y = create_memmap_backed_data([X, y])\n\n    _check_transformer(name, transformer, X, y)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_transformer_data_not_an_array(name, transformer):\n    X, y = make_blobs(\n        n_samples=30,\n        centers=[[0, 0, 0], [1, 1, 1]],\n        random_state=0,\n        n_features=2,\n        cluster_std=0.1,\n    )\n    X = StandardScaler().fit_transform(X)\n    X = _enforce_estimator_tags_X(transformer, X)\n    this_X = _NotAnArray(X)\n    this_y = _NotAnArray(np.asarray(y))\n    _check_transformer(name, transformer, this_X, this_y)\n    # try the same with some list\n    _check_transformer(name, transformer, X.tolist(), y.tolist())",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 55999,
                "end_index": 58685,
                "start_line": 181,
                "end_line": 1729,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "@ignore_warnings(category=FutureWarning)\ndef check_estimators_partial_fit_n_features(name, estimator_orig):\n    # check if number of features changes between calls to partial_fit.\n    if not hasattr(estimator_orig, \"partial_fit\"):\n        return\n    estimator = clone(estimator_orig)\n    X, y = make_blobs(n_samples=50, random_state=1)\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    y = _enforce_estimator_tags_y(estimator_orig, y)\n\n    try:\n        if is_classifier(estimator):\n            classes = np.unique(y)\n            estimator.partial_fit(X, y, classes=classes)\n        else:\n            estimator.partial_fit(X, y)\n    except NotImplementedError:\n        return\n\n    with raises(\n        ValueError,\n        err_msg=(\n            f\"The estimator {name} does not raise an error when the \"\n            \"number of features changes between calls to partial_fit.\"\n        ),\n    ):\n        estimator.partial_fit(X[:, :-1], y)",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 72345,
                "end_index": 73285,
                "start_line": 181,
                "end_line": 2142,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "\"\"\"Check that the estimator can work consistently with the Array API\n\n    By default, this just checks that the types and shapes of the arrays are\n    consistent with calling the same estimator with numpy arrays.\n\n    When check_values is True, it also checks that calling the estimator on the\n    array_api Array gives the same results as ndarrays.\n    \"\"\"\n    xp, device, dtype = _array_api_for_tests(array_namespace, device, dtype)\n\n    X, y = make_classification(random_state=42)\n    X = X.astype(dtype, copy=False)\n\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    y = _enforce_estimator_tags_y(estimator_orig, y)\n\n    est = clone(estimator_orig)\n\n    X_xp = xp.asarray(X, device=device)\n    y_xp = xp.asarray(y, device=device)\n\n    est.fit(X, y)\n\n    array_attributes = {\n        key: value for key, value in vars(est).items() if isinstance(value, np.ndarray)\n    }\n\n    est_xp = clone(est)\n    with config_context(array_api_dispatch=True):\n        est_xp.fit(X_xp, y_xp)\n        input_ns = get_namespace(X_xp)[0].__name__\n\n    # Fitted attributes which are arrays must have the same\n    # namespace as the one of the training data.\n    for key, attribute in array_attributes.items():\n        est_xp_param = getattr(est_xp, key)\n        with config_context(array_api_dispatch=True):\n            attribute_ns = get_namespace(est_xp_param)[0].__name__\n        assert attribute_ns == input_ns, (\n            f\"'{key}' attribute is in wrong namespace, expected {input_ns} \"\n            f\"got {attribute_ns}\"\n        )\n\n        assert array_device(est_xp_param) == array_device(X_xp)\n\n        est_xp_param_np = _convert_to_numpy(est_xp_param, xp=xp)\n        if check_values:\n            assert_allclose(\n                attribute,\n                est_xp_param_np,\n                err_msg=f\"{key} not the same\",\n                atol=np.finfo(X.dtype).eps * 100,\n            )\n        else:\n            assert attribute.shape == est_xp_param_np.shape\n            assert attribute.dtype == est_xp_param_np.dtype\n\n    # Check estimator methods, if supported, give the same results\n    methods = (\n        \"score\",\n        \"score_samples\",\n        \"decision_function\",\n        \"predict\",\n        \"predict_log_proba\",\n        \"predict_proba\",\n        \"transform\",\n    )",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 31006,
                "end_index": 33278,
                "start_line": 890,
                "end_line": 4639,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "if np.any(continuous_mask):\n        X = X.astype(np.float64, copy=copy)\n        X[:, continuous_mask] = scale(\n            X[:, continuous_mask], with_mean=False, copy=False\n        )\n\n        # Add small noise to continuous features as advised in Kraskov et. al.\n        means = np.maximum(1, np.mean(np.abs(X[:, continuous_mask]), axis=0))\n        X[:, continuous_mask] += (\n            1e-10\n            * means\n            * rng.standard_normal(size=(n_samples, np.sum(continuous_mask)))\n        )\n\n    if not discrete_target:\n        y = scale(y, with_mean=False)\n        y += (\n            1e-10\n            * np.maximum(1, np.mean(np.abs(y)))\n            * rng.standard_normal(size=n_samples)\n        )\n\n    mi = [\n        _compute_mi(x, y, discrete_feature, discrete_target, n_neighbors)\n        for x, discrete_feature in zip(_iterate_columns(X), discrete_mask)\n    ]\n\n    return np.array(mi)",
                "filename": "sklearn/feature_selection/_mutual_info.py",
                "start_index": 8868,
                "end_index": 9769,
                "start_line": 282,
                "end_line": 309,
                "max_line": 490,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "def check_array_api_input(\n    name,\n    estimator_orig,\n    array_namespace,\n    device=None,\n    dtype=\"float64\",\n    check_values=False,\n):",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 30859,
                "end_index": 31001,
                "start_line": 882,
                "end_line": 4627,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "@ignore_warnings(category=FutureWarning)\ndef check_regressor_data_not_an_array(name, estimator_orig):\n    X, y = _regression_dataset()\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    y = _enforce_estimator_tags_y(estimator_orig, y)\n    for obj_type in [\"NotAnArray\", \"PandasDataframe\"]:\n        check_estimators_data_not_an_array(name, estimator_orig, X, y, obj_type)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_estimators_data_not_an_array(name, estimator_orig, X, y, obj_type):\n    if name in CROSS_DECOMPOSITION:\n        raise SkipTest(\n            \"Skipping check_estimators_data_not_an_array \"\n            \"for cross decomposition module as estimators \"\n            \"are not deterministic.\"\n        )\n    # separate estimators to control random seeds\n    estimator_1 = clone(estimator_orig)\n    estimator_2 = clone(estimator_orig)\n    set_random_state(estimator_1)\n    set_random_state(estimator_2)\n\n    if obj_type not in [\"NotAnArray\", \"PandasDataframe\"]:\n        raise ValueError(\"Data type {0} not supported\".format(obj_type))\n\n    if obj_type == \"NotAnArray\":\n        y_ = _NotAnArray(np.asarray(y))\n        X_ = _NotAnArray(np.asarray(X))\n    else:\n        # Here pandas objects (Series and DataFrame) are tested explicitly\n        # because some estimators may handle them (especially their indexing)\n        # specially.\n        try:\n            import pandas as pd\n\n            y_ = np.asarray(y)\n            if y_.ndim == 1:\n                y_ = pd.Series(y_, copy=False)\n            else:\n                y_ = pd.DataFrame(y_, copy=False)\n            X_ = pd.DataFrame(np.asarray(X), copy=False)\n\n        except ImportError:\n            raise SkipTest(\n                \"pandas is not installed: not checking estimators for pandas objects.\"\n            )\n\n    # fit\n    estimator_1.fit(X_, y_)\n    pred1 = estimator_1.predict(X_)\n    estimator_2.fit(X, y)\n    pred2 = estimator_2.predict(X)\n    assert_allclose(pred1, pred2, atol=1e-2, err_msg=name)",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 118586,
                "end_index": 120568,
                "start_line": 181,
                "end_line": 3430,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            },
            {
                "code": "def check_array_api_input_and_values(\n    name,\n    estimator_orig,\n    array_namespace,\n    device=None,\n    dtype=\"float64\",\n):\n    return check_array_api_input(\n        name,\n        estimator_orig,\n        array_namespace=array_namespace,\n        device=device,\n        dtype=dtype,\n        check_values=True,\n    )\n\n\ndef check_estimator_sparse_data(name, estimator_orig):\n    rng = np.random.RandomState(0)\n    X = rng.uniform(size=(40, 3))\n    X[X < 0.8] = 0\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    X_csr = sparse.csr_matrix(X)\n    y = (4 * rng.uniform(size=40)).astype(int)\n    # catch deprecation warnings\n    with ignore_warnings(category=FutureWarning):\n        estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n    tags = _safe_tags(estimator_orig)\n    for matrix_format, X in _generate_sparse_matrix(X_csr):\n        # catch deprecation warnings\n        with ignore_warnings(category=FutureWarning):\n            estimator = clone(estimator_orig)\n            if name in [\"Scaler\", \"StandardScaler\"]:\n                estimator.set_params(with_mean=False)\n        # fit and predict\n        if \"64\" in matrix_format:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to support {matrix_format} \"\n                \"matrix, and is not failing gracefully, e.g. by using \"\n                \"check_array(X, accept_large_sparse=False)\"\n            )\n        else:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to fail gracefully on sparse \"\n                \"data: error message should state explicitly that sparse \"\n                \"input is not supported if this is not the case.\"\n            )\n        with raises(\n            (TypeError, ValueError),\n            match=[\"sparse\", \"Sparse\"],\n            may_pass=True,\n            err_msg=err_msg,\n        ):\n            with ignore_warnings(category=FutureWarning):\n                estimator.fit(X, y)\n            if hasattr(estimator, \"predict\"):\n                pred = estimator.predict(X)\n                if tags[\"multioutput_only\"]:\n                    assert pred.shape == (X.shape[0], 1)\n                else:\n                    assert pred.shape == (X.shape[0],)\n            if hasattr(estimator, \"predict_proba\"):\n                probs = estimator.predict_proba(X)\n                if tags[\"binary_only\"]:\n                    expected_probs_shape = (X.shape[0], 2)\n                else:\n                    expected_probs_shape = (X.shape[0], 4)\n                assert probs.shape == expected_probs_shape",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 36016,
                "end_index": 38577,
                "start_line": 1025,
                "end_line": 1093,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sklearn/feature_selection/_mutual_info.py": [
                {
                    "chunk": {
                        "code": "def _estimate_mi(\n    X,\n    y,\n    discrete_features=\"auto\",\n    discrete_target=False,\n    n_neighbors=3,\n    copy=True,\n    random_state=None,\n):",
                        "filename": "sklearn/feature_selection/_mutual_info.py",
                        "start_index": 5792,
                        "end_index": 5940,
                        "start_line": 201,
                        "end_line": 415,
                        "max_line": 490,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the _estimate_mi function where the issue with comparing string to array or boolean mask occurs."
                },
                {
                    "chunk": {
                        "code": "return _estimate_mi(X, y, discrete_features, False, n_neighbors, copy, random_state)",
                        "filename": "sklearn/feature_selection/_mutual_info.py",
                        "start_index": 13490,
                        "end_index": 13574,
                        "start_line": 399,
                        "end_line": 399,
                        "max_line": 490,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows a call to _estimate_mi which may need to be reviewed to ensure proper handling of the discrete_features parameter."
                },
                {
                    "chunk": {
                        "code": "check_classification_targets(y)\n    return _estimate_mi(X, y, discrete_features, True, n_neighbors, copy, random_state)",
                        "filename": "sklearn/feature_selection/_mutual_info.py",
                        "start_index": 17292,
                        "end_index": 17411,
                        "start_line": 489,
                        "end_line": 490,
                        "max_line": 490,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows another call to _estimate_mi with the discrete_features parameter, indicating where the issue might manifest."
                },
                {
                    "chunk": {
                        "code": "if np.any(continuous_mask):\n        X = X.astype(np.float64, copy=copy)\n        X[:, continuous_mask] = scale(\n            X[:, continuous_mask], with_mean=False, copy=False\n        )\n\n        # Add small noise to continuous features as advised in Kraskov et. al.\n        means = np.maximum(1, np.mean(np.abs(X[:, continuous_mask]), axis=0))\n        X[:, continuous_mask] += (\n            1e-10\n            * means\n            * rng.standard_normal(size=(n_samples, np.sum(continuous_mask)))\n        )\n\n    if not discrete_target:\n        y = scale(y, with_mean=False)\n        y += (\n            1e-10\n            * np.maximum(1, np.mean(np.abs(y)))\n            * rng.standard_normal(size=n_samples)\n        )\n\n    mi = [\n        _compute_mi(x, y, discrete_feature, discrete_target, n_neighbors)\n        for x, discrete_feature in zip(_iterate_columns(X), discrete_mask)\n    ]\n\n    return np.array(mi)",
                        "filename": "sklearn/feature_selection/_mutual_info.py",
                        "start_index": 8868,
                        "end_index": 9769,
                        "start_line": 282,
                        "end_line": 309,
                        "max_line": 490,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.21",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the _estimate_mi function and may need to be reviewed if changes to handling of discrete_features affect the internal logic."
                }
            ]
        },
        "solution_task": "- Modify the `_estimate_mi` function to handle `discrete_features` correctly when it is not `'auto'`. Ensure that the comparison with `'auto'` is done in a way that will not raise an error in future numpy versions.\n- Add test cases for `_estimate_mi` with `discrete_features` set to an array of indices and a boolean mask to ensure proper functionality.\n- Update the type checking or conversion of `discrete_features` before the comparison to handle both array-like and boolean mask inputs.\n- Ensure that the function can handle `discrete_features` being a boolean array without raising a FutureWarning or error due to numpy version changes. Use `isinstance(discrete_features, str)` to check if `discrete_features` is a string before comparing it to `'auto'`.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable set of steps to address the issue described in the PROMPT. It suggests modifying the '_estimate_mi' function to handle different types of 'discrete_features' input, adding test cases for different input scenarios, and updating type checking or conversion before comparison. The advice to use 'isinstance(discrete_features, str)' to prevent future errors with numpy is particularly relevant and actionable. The RESPONSE also directly references the code snippets where the issue occurs and where the changes need to be made, which is highly valuable for debugging and fixing the issue. The only reason it does not score a 10 is that it does not provide the exact code changes needed, but it gives enough guidance for a developer to implement the solution.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711740585.397158,
        "result": "- Modify the `_estimate_mi` function to handle `discrete_features` correctly when it is not `'auto'`. Ensure that the comparison with `'auto'` is done in a way that will not raise an error in future numpy versions.\n- Add test cases for `_estimate_mi` with `discrete_features` set to an array of indices and a boolean mask to ensure proper functionality.\n- Update the type checking or conversion of `discrete_features` before the comparison to handle both array-like and boolean mask inputs.\n- Ensure that the function can handle `discrete_features` being a boolean array without raising a FutureWarning or error due to numpy version changes. Use `isinstance(discrete_features, str)` to check if `discrete_features` is a string before comparing it to `'auto'`.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn) \u2192 [feature_selection](https://github.com/testbed/scikit-learn__scikit-learn__0.21/tree//sklearn/feature_selection)- [Lines 201 - 415](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L201-L415)\n\n This snippet defines the _estimate_mi function where the issue with comparing string to array or boolean mask occurs. \n\n\n   - [Lines 399 - 399](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L399-L399)\n\n This snippet shows a call to _estimate_mi which may need to be reviewed to ensure proper handling of the discrete_features parameter. \n\n\n   - [Lines 489 - 490](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L489-L490)\n\n This snippet shows another call to _estimate_mi with the discrete_features parameter, indicating where the issue might manifest. \n\n\n   - [Lines 282 - 309](https://github.com/testbed/scikit-learn__scikit-learn__0.21/blob//sklearn/feature_selection/_mutual_info.py#L282-L309)\n\n This snippet is part of the _estimate_mi function and may need to be reviewed if changes to handling of discrete_features affect the internal logic."
    }
}