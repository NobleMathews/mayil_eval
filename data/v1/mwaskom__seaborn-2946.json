{
    "id": "mwaskom__seaborn-2946",
    "repo_name": "testbed/mwaskom__seaborn__0.12",
    "task_id": 5231046002242688459,
    "title": "Regression: `pointplot` and `barplot` raise when using a custom estimator",
    "body": "This may be related to #2866 . According to `pointplot` (and `barplot`) documentation, the `estimator` can be any callable that maps vector to scalar. However, the following example raises with `'0.12.0.dev0'` on my Windows and Mac machines (and doesn't raise with `'0.11.2'`):\r\n```python\r\nimport seaborn as sns\r\nimport numpy as np\r\ntips = sns.load_dataset(\"tips\")\r\n\r\ndef custom_min(x):\r\n    return float(np.asarray(x).min())\r\n\r\nax = sns.pointplot(x=\"day\", y=\"tip\", data=tips, estimator=custom_min)\r\n```\r\n\r\n<details><summary>Exception</summary>\r\n\r\n```\r\nC:\\Users\\admin\\seaborn\\seaborn\\categorical.py:1491: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\r\n  self.statistic = np.array(statistic)\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\admin\\miniconda3\\lib\\site-packages\\pandas\\core\\series.py\", line 191, in wrapper\r\n    raise TypeError(f\"cannot convert the series to {converter}\")\r\nTypeError: cannot convert the series to <class 'float'>\r\n```\r\n\r\n</details>\r\n\r\nIt does work, however, when changing the `custom_min` function to use the builtin `min` func:\r\n```python\r\nimport seaborn as sns\r\nimport numpy as np\r\ntips = sns.load_dataset(\"tips\")\r\n\r\ndef custom_min(x):\r\n    return float(min(x))\r\n\r\nax = sns.pointplot(x=\"day\", y=\"tip\", data=tips, estimator=custom_min)\r\n```\r\n\r\nThe same error is raised when changing the example code to use `barplot`, or when using a different numpy aggregator within the custom function.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/mwaskom__seaborn__0.12.git",
    "requested_commit": "",
    "mayil_response": "- Ensure that the `custom_min` function returns a scalar value when passed a pandas Series object.\n- Modify the `custom_min` function to handle pandas Series correctly by using `np.min` or `pd.Series.min` instead of `np.asarray(x).min()`.\n- If `custom_min` is intended to be used as an estimator, it should have the signature `custom_min(x: pd.Series) -> float` and ensure it returns a float.\n- Check for any changes in the `EstimateAggregator` class between versions `'0.12.0.dev0'` and `'0.11.2'` that could affect how the estimator is called or how the results are processed.\n- If the issue is due to a change in seaborn's internal handling of estimators, consider reverting to the previous behavior or adjusting the `EstimateAggregator` to be compatible with custom estimator functions like `custom_min`.\n- If the issue persists, provide a minimal reproducible example to the seaborn development team for further investigation.\n\n### Code snippets to check\n\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn)- [Lines 2442 - 2662](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/categorical.py#L2442-L2662)\n\n This snippet defines the 'pointplot' function, which is directly related to the issue as it handles the estimator parameter. \n\n\n   - [Lines 2302 - 2662](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/categorical.py#L2302-L2662)\n\n This snippet defines the 'barplot' function, which is also directly related to the issue as it handles the estimator parameter similar to 'pointplot'.\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn)- [Lines 456 - 518](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/_statistics.py#L456-L518)\n\n This snippet contains the 'EstimateAggregator' class which is instantiated with the estimator parameter and is likely where the TypeError is occurring.\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn) \u2192 [_stats](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn/_stats)- [Lines 15 - 118](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/_stats/aggregation.py#L15-L118)\n\n This snippet contains the 'Est' class which processes the estimator and errorbar parameters and may be involved in the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005124999999999999,
        "snippet_processor": 0.050390000000000004,
        "issue_star_creation": 0.03585,
        "issue_star_solver": 0.055110000000000006,
        "bouncer": 0.03034
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711735764.182027,
        "relevant_snippets": [
            {
                "code": "def pointplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n    color=None, palette=None, hue_norm=None, markers=default, linestyles=default,\n    dodge=False, native_scale=False, orient=None, capsize=0,\n    formatter=None, legend=\"auto\", err_kws=None,\n    ci=deprecated, errwidth=deprecated, join=deprecated, scale=deprecated,\n    ax=None,\n    **kwargs,\n):\n\n    errorbar = utils._deprecate_ci(errorbar, ci)\n\n    p = _CategoricalAggPlotter(\n        data=data,\n        variables=_CategoricalAggPlotter.get_semantics(locals()),\n        order=order,\n        orient=orient,\n        require_numeric=False,\n        legend=legend,\n    )\n\n    if ax is None:\n        ax = plt.gca()\n\n    if p.plot_data.empty:\n        return ax\n\n    if p.var_types.get(p.orient) == \"categorical\" or not native_scale:\n        p.scale_categorical(p.orient, order=order, formatter=formatter)\n\n    p._attach(ax)\n\n    # Deprecations to remove in v0.14.0.\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    color = _default_color(ax.plot, hue, color, kwargs)\n\n    aggregator = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)\n    err_kws = {} if err_kws is None else _normalize_kwargs(err_kws, mpl.lines.Line2D)\n\n    # Deprecations to remove in v0.15.0.\n    p._point_kwargs_backcompat(scale, join, kwargs)\n    err_kws, capsize = p._err_kws_backcompat(err_kws, None, errwidth, capsize)\n\n    p.plot_points(\n        aggregator=aggregator,\n        markers=markers,\n        linestyles=linestyles,\n        dodge=dodge,\n        color=color,\n        capsize=capsize,\n        err_kws=err_kws,\n        plot_kws=kwargs,\n    )\n\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.orient)\n\n    return ax",
                "filename": "seaborn/categorical.py",
                "start_index": 87289,
                "end_index": 89234,
                "start_line": 2442,
                "end_line": 2662,
                "max_line": 3409,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "if self.estimator is not None and self.errorbar is not None:\n\n                # TODO handling of orientation will need to happen here\n\n                if self.err_style == \"band\":\n\n                    func = {\"x\": ax.fill_between, \"y\": ax.fill_betweenx}[orient]\n                    func(\n                        sub_data[orient],\n                        sub_data[f\"{other}min\"], sub_data[f\"{other}max\"],\n                        color=line_color, **err_kws\n                    )\n\n                elif self.err_style == \"bars\":\n\n                    error_param = {\n                        f\"{other}err\": (\n                            sub_data[other] - sub_data[f\"{other}min\"],\n                            sub_data[f\"{other}max\"] - sub_data[other],\n                        )\n                    }\n                    ebars = ax.errorbar(\n                        sub_data[\"x\"], sub_data[\"y\"], **error_param,\n                        linestyle=\"\", color=line_color, alpha=line_alpha,\n                        **err_kws\n                    )\n\n                    # Set the capstyle properly on the error bars\n                    for obj in ebars.get_children():\n                        if isinstance(obj, mpl.collections.LineCollection):\n                            obj.set_capstyle(line_capstyle)",
                "filename": "seaborn/relational.py",
                "start_index": 17091,
                "end_index": 18380,
                "start_line": 450,
                "end_line": 480,
                "max_line": 1044,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "elif kind == \"point\":\n\n        aggregator = EstimateAggregator(\n            estimator, errorbar, n_boot=n_boot, seed=seed\n        )\n\n        markers = kwargs.pop(\"markers\", default)\n        linestyles = kwargs.pop(\"linestyles\", default)\n\n        # Deprecations to remove in v0.15.0.\n        # TODO Uncomment when removing deprecation backcompat\n        # capsize = kwargs.pop(\"capsize\", 0)\n        # err_kws = _normalize_kwargs(kwargs.pop(\"err_kws\", {}), mpl.lines.Line2D)\n        p._point_kwargs_backcompat(\n            kwargs.pop(\"scale\", deprecated),\n            kwargs.pop(\"join\", deprecated),\n            kwargs\n        )\n        err_kws, capsize = p._err_kws_backcompat(\n            _normalize_kwargs(kwargs.pop(\"err_kws\", {}), mpl.lines.Line2D),\n            None,\n            errwidth=kwargs.pop(\"errwidth\", deprecated),\n            capsize=kwargs.pop(\"capsize\", 0),\n        )\n\n        p.plot_points(\n            aggregator=aggregator,\n            markers=markers,\n            linestyles=linestyles,\n            dodge=dodge,\n            color=color,\n            capsize=capsize,\n            err_kws=err_kws,\n            plot_kws=kwargs,\n        )\n\n    elif kind == \"bar\":\n\n        aggregator = EstimateAggregator(\n            estimator, errorbar, n_boot=n_boot, seed=seed\n        )\n        err_kws, capsize = p._err_kws_backcompat(\n            _normalize_kwargs(kwargs.pop(\"err_kws\", {}), mpl.lines.Line2D),\n            errcolor=kwargs.pop(\"errcolor\", deprecated),\n            errwidth=kwargs.pop(\"errwidth\", deprecated),\n            capsize=kwargs.pop(\"capsize\", 0),\n        )\n        gap = kwargs.pop(\"gap\", 0)\n        fill = kwargs.pop(\"fill\", True)\n\n        p.plot_bars(\n            aggregator=aggregator,\n            dodge=dodge,\n            width=width,\n            gap=gap,\n            color=color,\n            fill=fill,\n            capsize=capsize,\n            err_kws=err_kws,\n            plot_kws=kwargs,\n        )\n\n    elif kind == \"count\":\n\n        aggregator = EstimateAggregator(\"sum\", errorbar=None)\n\n        count_axis = {\"x\": \"y\", \"y\": \"x\"}[p.orient]\n        p.plot_data[count_axis] = 1\n\n        stat_options = [\"count\", \"percent\", \"probability\", \"proportion\"]\n        stat = _check_argument(\"stat\", stat_options, kwargs.pop(\"stat\", \"count\"))\n        p.variables[count_axis] = stat\n        if stat != \"count\":\n            denom = 100 if stat == \"percent\" else 1\n            p.plot_data[count_axis] /= len(p.plot_data) / denom\n\n        gap = kwargs.pop(\"gap\", 0)\n        fill = kwargs.pop(\"fill\", True)\n\n        p.plot_bars(\n            aggregator=aggregator,\n            dodge=dodge,\n            width=width,\n            gap=gap,\n            color=color,\n            fill=fill,\n            capsize=0,\n            err_kws={},\n            plot_kws=kwargs,\n        )\n\n    else:\n        msg = (\n            f\"Invalid `kind`: {kind!r}. Options are 'strip', 'swarm', \"\n            \"'box', 'boxen', 'violin', 'bar', 'count', and 'point'.\"\n        )\n        raise ValueError(msg)",
                "filename": "seaborn/categorical.py",
                "start_index": 104091,
                "end_index": 107087,
                "start_line": 2975,
                "end_line": 3071,
                "max_line": 3409,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "def barplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n    orient=None, color=None, palette=None, saturation=.75, fill=True, hue_norm=None,\n    width=.8, dodge=\"auto\", gap=0, native_scale=False, formatter=None, legend=\"auto\",\n    capsize=0, err_kws=None, ci=deprecated, errcolor=deprecated, errwidth=deprecated,\n    ax=None, **kwargs,\n):\n\n    errorbar = utils._deprecate_ci(errorbar, ci)\n\n    # Be backwards compatible with len passed directly, which\n    # does not work in Series.agg (maybe a pandas bug?)\n    if estimator is len:\n        estimator = \"size\"\n\n    p = _CategoricalAggPlotter(\n        data=data,\n        variables=_CategoricalAggPlotter.get_semantics(locals()),\n        order=order,\n        orient=orient,\n        require_numeric=False,\n        legend=legend,\n    )\n\n    if ax is None:\n        ax = plt.gca()\n\n    if p.plot_data.empty:\n        return ax\n\n    if dodge == \"auto\":\n        # Needs to be before scale_categorical changes the coordinate series dtype\n        dodge = p._dodge_needed()\n\n    if p.var_types.get(p.orient) == \"categorical\" or not native_scale:\n        p.scale_categorical(p.orient, order=order, formatter=formatter)\n\n    p._attach(ax)\n\n    # Deprecations to remove in v0.14.0.\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n\n    saturation = saturation if fill else 1\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)\n    color = _default_color(ax.bar, hue, color, kwargs, saturation=saturation)\n\n    aggregator = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)\n    err_kws = {} if err_kws is None else _normalize_kwargs(err_kws, mpl.lines.Line2D)\n\n    # Deprecations to remove in v0.15.0.\n    err_kws, capsize = p._err_kws_backcompat(err_kws, errcolor, errwidth, capsize)\n\n    p.plot_bars(\n        aggregator=aggregator,\n        dodge=dodge,\n        width=width,\n        gap=gap,\n        color=color,\n        fill=fill,\n        capsize=capsize,\n        err_kws=err_kws,\n        plot_kws=kwargs,\n    )\n\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.orient)\n\n    return ax",
                "filename": "seaborn/categorical.py",
                "start_index": 83337,
                "end_index": 85618,
                "start_line": 2302,
                "end_line": 2662,
                "max_line": 3409,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "@dataclass\nclass Est(Stat):\n    \"\"\"\n    Calculate a point estimate and error bar interval.\n\n    For additional information about the various `errorbar` choices, see\n    the :doc:`errorbar tutorial </tutorial/error_bars>`.\n\n    Parameters\n    ----------\n    func : str or callable\n        Name of a :class:`numpy.ndarray` method or a vector -> scalar function.\n    errorbar : str, (str, float) tuple, or callable\n        Name of errorbar method (one of \"ci\", \"pi\", \"se\" or \"sd\"), or a tuple\n        with a method name ane a level parameter, or a function that maps from a\n        vector to a (min, max) interval.\n    n_boot : int\n       Number of bootstrap samples to draw for \"ci\" errorbars.\n    seed : int\n        Seed for the PRNG used to draw bootstrap samples.\n\n    Examples\n    --------\n    .. include:: ../docstrings/objects.Est.rst\n\n    \"\"\"\n    func: str | Callable[[Vector], float] = \"mean\"\n    errorbar: str | tuple[str, float] = (\"ci\", 95)\n    n_boot: int = 1000\n    seed: int | None = None\n\n    group_by_orient: ClassVar[bool] = True\n\n    def _process(\n        self, data: DataFrame, var: str, estimator: EstimateAggregator\n    ) -> DataFrame:\n        # Needed because GroupBy.apply assumes func is DataFrame -> DataFrame\n        # which we could probably make more general to allow Series return\n        res = estimator(data, var)\n        return pd.DataFrame([res])\n\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        boot_kws = {\"n_boot\": self.n_boot, \"seed\": self.seed}\n        engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)\n\n        var = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        res = (\n            groupby\n            .apply(data, self._process, var, engine)\n            .dropna(subset=[var])\n            .reset_index(drop=True)\n        )\n\n        res = res.fillna({f\"{var}min\": res[var], f\"{var}max\": res[var]})\n\n        return res\n\n\n@dataclass\nclass Rolling(Stat):\n    ...\n\n    def __call__(self, data, groupby, orient, scales):\n        ...",
                "filename": "seaborn/_stats/aggregation.py",
                "start_index": 1208,
                "end_index": 3266,
                "start_line": 15,
                "end_line": 118,
                "max_line": 118,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "pointplot.__doc__ = dedent(\"\"\"\\\n    Show point estimates and errors using lines with markers.\n\n    A point plot represents an estimate of central tendency for a numeric\n    variable by the position of the dot and provides some indication of the\n    uncertainty around that estimate using error bars.\n\n    Point plots can be more useful than bar plots for focusing comparisons\n    between different levels of one or more categorical variables. They are\n    particularly adept at showing interactions: how the relationship between\n    levels of one categorical variable changes across levels of a second\n    categorical variable. The lines that join each point from the same `hue`\n    level allow interactions to be judged by differences in slope, which is\n    easier for the eyes than comparing the heights of several groups of points\n    or bars.\n\n    {categorical_narrative}\n\n    Parameters\n    ----------\n    {categorical_data}\n    {input_params}\n    {order_vars}\n    {stat_api_params}\n    {color}\n    {palette}\n    markers : string or list of strings\n        Markers to use for each of the `hue` levels.\n    linestyles : string or list of strings\n        Line styles to use for each of the `hue` levels.\n    dodge : bool or float\n        Amount to separate the points for each level of the `hue` variable along\n        the categorical axis. Setting to `True` will apply a small default.\n    {native_scale}\n    {orient}\n    {capsize}\n    {formatter}\n    {legend}\n    {err_kws}\n    {ci}\n    {errwidth}\n    join : bool\n        If `True`, connect point estimates with a line.\n\n        .. deprecated:: v0.13.0\n            Set `linestyle=\"none\"` to remove the lines between the points.\n    scale : float\n        Scale factor for the plot elements.\n\n        .. deprecated:: v0.13.0\n            Control element sizes with :class:`matplotlib.lines.Line2D` parameters.\n    {ax_in}\n    kwargs : key, value mappings\n        Other parameters are passed through to :class:`matplotlib.lines.Line2D`.\n\n        .. versionadded:: v0.13.0\n\n    Returns\n    -------\n    {ax_out}\n\n    See Also\n    --------\n    {barplot}\n    {catplot}\n\n    Notes\n    -----\n    It is important to keep in mind that a point plot shows only the mean (or\n    other estimator) value, but in many cases it may be more informative to\n    show the distribution of values at each level of the categorical variables.\n    In that case, other approaches such as a box or violin plot may be more\n    appropriate.\n\n    Examples\n    --------\n    .. include:: ../docstrings/pointplot.rst\n\n    \"\"\").format(**_categorical_docs)",
                "filename": "seaborn/categorical.py",
                "start_index": 89237,
                "end_index": 91810,
                "start_line": 2506,
                "end_line": 3167,
                "max_line": 3409,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "class EstimateAggregator:\n\n    def __init__(self, estimator, errorbar=None, **boot_kws):\n        \"\"\"\n        Data aggregator that produces an estimate and error bar interval.\n\n        Parameters\n        ----------\n        estimator : callable or string\n            Function (or method name) that maps a vector to a scalar.\n        errorbar : string, (string, number) tuple, or callable\n            Name of errorbar method (either \"ci\", \"pi\", \"se\", or \"sd\"), or a tuple\n            with a method name and a level parameter, or a function that maps from a\n            vector to a (min, max) interval.\n        boot_kws\n            Additional keywords are passed to bootstrap when error_method is \"ci\".\n\n        \"\"\"\n        self.estimator = estimator\n\n        method, level = _validate_errorbar_arg(errorbar)\n        self.error_method = method\n        self.error_level = level\n\n        self.boot_kws = boot_kws\n\n    def __call__(self, data, var):\n        \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"\n        vals = data[var]\n        if callable(self.estimator):\n            # You would think we could pass to vals.agg, and yet:\n            # https://github.com/mwaskom/seaborn/issues/2943\n            estimate = self.estimator(vals)\n        else:\n            estimate = vals.agg(self.estimator)\n\n        # Options that produce no error bars\n        if self.error_method is None:\n            err_min = err_max = np.nan\n        elif len(data) <= 1:\n            err_min = err_max = np.nan\n\n        # Generic errorbars from user-supplied function\n        elif callable(self.error_method):\n            err_min, err_max = self.error_method(vals)\n\n        # Parametric options\n        elif self.error_method == \"sd\":\n            half_interval = vals.std() * self.error_level\n            err_min, err_max = estimate - half_interval, estimate + half_interval\n        elif self.error_method == \"se\":\n            half_interval = vals.sem() * self.error_level\n            err_min, err_max = estimate - half_interval, estimate + half_interval\n\n        # Nonparametric options\n        elif self.error_method == \"pi\":\n            err_min, err_max = _percentile_interval(vals, self.error_level)\n        elif self.error_method == \"ci\":\n            units = data.get(\"units\", None)\n            boots = bootstrap(vals, units=units, func=self.estimator, **self.boot_kws)\n            err_min, err_max = _percentile_interval(boots, self.error_level)\n\n        return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})",
                "filename": "seaborn/_statistics.py",
                "start_index": 15926,
                "end_index": 18468,
                "start_line": 456,
                "end_line": 518,
                "max_line": 639,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "(\n\n    model_api=dedent(\"\"\"\\\n    There are a number of mutually exclusive options for estimating the\n    regression model. See the :ref:`tutorial <regression_tutorial>` for more\n    information.\\\n    \"\"\"),\n    regplot_vs_lmplot=dedent(\"\"\"\\\n    The :func:`regplot` and :func:`lmplot` functions are closely related, but\n    the former is an axes-level function while the latter is a figure-level\n    function that combines :func:`regplot` and :class:`FacetGrid`.\\\n    \"\"\"),\n    x_estimator=dedent(\"\"\"\\\n    x_estimator : callable that maps vector -> scalar, optional\n        Apply this function to each unique value of ``x`` and plot the\n        resulting estimate. This is useful when ``x`` is a discrete variable.\n        If ``x_ci`` is given, this estimate will be bootstrapped and a\n        confidence interval will be drawn.\\\n    \"\"\"),\n    x_bins=dedent(\"\"\"\\\n    x_bins : int or vector, optional\n        Bin the ``x`` variable into discrete bins and then estimate the central\n        tendency and a confidence interval. This binning only influences how\n        the scatterplot is drawn; the regression is still fit to the original\n        data.  This parameter is interpreted either as the number of\n        evenly-sized (not necessary spaced) bins or the positions of the bin\n        centers. When this parameter is used, it implies that the default of\n        ``x_estimator`` is ``numpy.mean``.\\\n    \"\"\"),\n    x_ci=dedent(\"\"\"\\\n    x_ci : \"ci\", \"sd\", int in [0, 100] or None, optional\n        Size of the confidence interval used when plotting a central tendency\n        for discrete values of ``x``. If ``\"ci\"``, defer to the value of the\n        ``ci`` parameter. If ``\"sd\"``, skip bootstrapping and show the\n        standard deviation of the observations in each bin.\\\n    \"\"\"),\n    scatter=dedent(\"\"\"\\\n    scatter : bool, optional\n        If ``True``, draw a scatterplot with the underlying observations (or\n        the ``x_estimator`` values).\\\n    \"\"\"),\n    fit_reg=dedent(\"\"\"\\\n    fit_reg : bool, optional\n        If ``True``, estimate and plot a regression model relating the ``x``\n        and ``y`` variables.\\\n    \"\"\"),\n    ci=dedent(\"\"\"\\\n    ci : int in [0, 100] or None, optional\n        Size of the confidence interval for the regression estimate. This will\n        be drawn using translucent bands around the regression line. The\n        confidence interval is estimated using a bootstrap; for large\n        datasets, it may be advisable to avoid that computation by setting\n        this parameter to None.\\\n    \"\"\"),\n    n_boot=dedent(\"\"\"\\\n    n_boot : int, optional\n        Number of bootstrap resamples used to estimate the ``ci``. The default\n        value attempts to balance time and stability; you may want to increase\n        this value for \"final\" versions of plots.\\\n    \"\"\"),",
                "filename": "seaborn/regression.py",
                "start_index": 15560,
                "end_index": 18363,
                "start_line": 1,
                "end_line": 561,
                "max_line": 930,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "\"\"\"Plotter for numeric independent variables with regression model.\n\n    This does the computations and drawing for the `regplot` function, and\n    is thus also used indirectly by `lmplot`.\n    \"\"\"\n    def __init__(self, x, y, data=None, x_estimator=None, x_bins=None,\n                 x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,\n                 units=None, seed=None, order=1, logistic=False, lowess=False,\n                 robust=False, logx=False, x_partial=None, y_partial=None,\n                 truncate=False, dropna=True, x_jitter=None, y_jitter=None,\n                 color=None, label=None):\n\n        # Set member attributes\n        self.x_estimator = x_estimator\n        self.ci = ci\n        self.x_ci = ci if x_ci == \"ci\" else x_ci\n        self.n_boot = n_boot\n        self.seed = seed\n        self.scatter = scatter\n        self.fit_reg = fit_reg\n        self.order = order\n        self.logistic = logistic\n        self.lowess = lowess\n        self.robust = robust\n        self.logx = logx\n        self.truncate = truncate\n        self.x_jitter = x_jitter\n        self.y_jitter = y_jitter\n        self.color = color\n        self.label = label\n\n        # Validate the regression options:\n        if sum((order > 1, logistic, robust, lowess, logx)) > 1:\n            raise ValueError(\"Mutually exclusive regression options.\")\n\n        # Extract the data vals from the arguments or passed dataframe\n        self.establish_variables(data, x=x, y=y, units=units,\n                                 x_partial=x_partial, y_partial=y_partial)\n\n        # Drop null observations\n        if dropna:\n            self.dropna(\"x\", \"y\", \"units\", \"x_partial\", \"y_partial\")\n\n        # Regress nuisance variables out of the data\n        if self.x_partial is not None:\n            self.x = self.regress_out(self.x, self.x_partial)\n        if self.y_partial is not None:\n            self.y = self.regress_out(self.y, self.y_partial)\n\n        # Possibly bin the predictor variable, which implies a point estimate\n        if x_bins is not None:\n            self.x_estimator = np.mean if x_estimator is None else x_estimator\n            x_discrete, x_bins = self.bin_predictor(x_bins)\n            self.x_discrete = x_discrete\n        else:\n            self.x_discrete = self.x\n\n        # Disable regression in case of singleton inputs\n        if len(self.x) <= 1:\n            self.fit_reg = False\n\n        # Save the range of the x variable for the grid later\n        if self.fit_reg:\n            self.x_range = self.x.min(), self.x.max()\n\n    @property\n    def scatter_data(self):\n        \"\"\"Data where each observation is a point.\"\"\"\n        x_j = self.x_jitter\n        if x_j is None:\n            x = self.x\n        else:\n            x = self.x + np.random.uniform(-x_j, x_j, len(self.x))\n\n        y_j = self.y_jitter\n        if y_j is None:\n            y = self.y\n        else:\n            y = self.y + np.random.uniform(-y_j, y_j, len(self.y))\n\n        return x, y",
                "filename": "seaborn/regression.py",
                "start_index": 2116,
                "end_index": 5087,
                "start_line": 71,
                "end_line": 151,
                "max_line": 930,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            },
            {
                "code": "if sub_data.empty:\n                continue\n\n            # Do the histogram computation\n            heights, (x_edges, y_edges) = estimator(\n                sub_data[\"x\"],\n                sub_data[\"y\"],\n                weights=sub_data.get(\"weights\", None),\n            )\n\n            # Get the axes for this plot\n            ax = self._get_axes(sub_vars)\n\n            # Invert the scale for the edges\n            _, inv_x = _get_transform_functions(ax, \"x\")\n            _, inv_y = _get_transform_functions(ax, \"y\")\n            x_edges = inv_x(x_edges)\n            y_edges = inv_y(y_edges)\n\n            # Apply scaling to normalize across groups\n            if estimator.stat != \"count\" and common_norm:\n                heights *= len(sub_data) / len(all_data)\n\n            # Define the specific kwargs for this artist\n            artist_kws = plot_kws.copy()\n            if \"hue\" in self.variables:\n                color = self._hue_map(sub_vars[\"hue\"])\n                cmap = self._cmap_from_color(color)\n                artist_kws[\"cmap\"] = cmap\n            else:\n                cmap = artist_kws.pop(\"cmap\", None)\n                if isinstance(cmap, str):\n                    cmap = color_palette(cmap, as_cmap=True)\n                elif cmap is None:\n                    cmap = self._cmap_from_color(color)\n                artist_kws[\"cmap\"] = cmap\n\n            # Set the upper norm on the colormap\n            if not common_color_norm and pmax is not None:\n                vmax = self._quantile_to_level(heights, pmax)\n            if vmax is not None:\n                artist_kws[\"vmax\"] = vmax\n\n            # Make cells at or below the threshold transparent\n            if not common_color_norm and pthresh:\n                thresh = self._quantile_to_level(heights, pthresh)\n            if thresh is not None:\n                heights = np.ma.masked_less_equal(heights, thresh)\n\n            # pcolormesh is going to turn the grid off, but we want to keep it\n            # I'm not sure if there's a better way to get the grid state\n            x_grid = any([l.get_visible() for l in ax.xaxis.get_gridlines()])\n            y_grid = any([l.get_visible() for l in ax.yaxis.get_gridlines()])\n\n            mesh = ax.pcolormesh(\n                x_edges,\n                y_edges,\n                heights.T,\n                **artist_kws,\n            )\n\n            # pcolormesh sets sticky edges, but we only want them if not thresholding\n            if thresh is not None:\n                mesh.sticky_edges.x[:] = []\n                mesh.sticky_edges.y[:] = []\n\n            # Add an optional colorbar\n            # Note, we want to improve this. When hue is used, it will stack\n            # multiple colorbars with redundant ticks in an ugly way.\n            # But it's going to take some work to have multiple colorbars that\n            # share ticks nicely.\n            if cbar:\n                ax.figure.colorbar(mesh, cbar_ax, ax, **cbar_kws)\n\n            # Reset the grid state",
                "filename": "seaborn/distributions.py",
                "start_index": 29166,
                "end_index": 32147,
                "start_line": 801,
                "end_line": 875,
                "max_line": 2541,
                "git_instance": "github",
                "repo_name": "testbed/mwaskom__seaborn__0.12",
                "sha": ""
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "seaborn/categorical.py": [
                {
                    "chunk": {
                        "code": "def pointplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n    color=None, palette=None, hue_norm=None, markers=default, linestyles=default,\n    dodge=False, native_scale=False, orient=None, capsize=0,\n    formatter=None, legend=\"auto\", err_kws=None,\n    ci=deprecated, errwidth=deprecated, join=deprecated, scale=deprecated,\n    ax=None,\n    **kwargs,\n):\n\n    errorbar = utils._deprecate_ci(errorbar, ci)\n\n    p = _CategoricalAggPlotter(\n        data=data,\n        variables=_CategoricalAggPlotter.get_semantics(locals()),\n        order=order,\n        orient=orient,\n        require_numeric=False,\n        legend=legend,\n    )\n\n    if ax is None:\n        ax = plt.gca()\n\n    if p.plot_data.empty:\n        return ax\n\n    if p.var_types.get(p.orient) == \"categorical\" or not native_scale:\n        p.scale_categorical(p.orient, order=order, formatter=formatter)\n\n    p._attach(ax)\n\n    # Deprecations to remove in v0.14.0.\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    color = _default_color(ax.plot, hue, color, kwargs)\n\n    aggregator = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)\n    err_kws = {} if err_kws is None else _normalize_kwargs(err_kws, mpl.lines.Line2D)\n\n    # Deprecations to remove in v0.15.0.\n    p._point_kwargs_backcompat(scale, join, kwargs)\n    err_kws, capsize = p._err_kws_backcompat(err_kws, None, errwidth, capsize)\n\n    p.plot_points(\n        aggregator=aggregator,\n        markers=markers,\n        linestyles=linestyles,\n        dodge=dodge,\n        color=color,\n        capsize=capsize,\n        err_kws=err_kws,\n        plot_kws=kwargs,\n    )\n\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.orient)\n\n    return ax",
                        "filename": "seaborn/categorical.py",
                        "start_index": 87289,
                        "end_index": 89234,
                        "start_line": 2442,
                        "end_line": 2662,
                        "max_line": 3409,
                        "git_instance": "github",
                        "repo_name": "testbed/mwaskom__seaborn__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the 'pointplot' function, which is directly related to the issue as it handles the estimator parameter."
                },
                {
                    "chunk": {
                        "code": "def barplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n    orient=None, color=None, palette=None, saturation=.75, fill=True, hue_norm=None,\n    width=.8, dodge=\"auto\", gap=0, native_scale=False, formatter=None, legend=\"auto\",\n    capsize=0, err_kws=None, ci=deprecated, errcolor=deprecated, errwidth=deprecated,\n    ax=None, **kwargs,\n):\n\n    errorbar = utils._deprecate_ci(errorbar, ci)\n\n    # Be backwards compatible with len passed directly, which\n    # does not work in Series.agg (maybe a pandas bug?)\n    if estimator is len:\n        estimator = \"size\"\n\n    p = _CategoricalAggPlotter(\n        data=data,\n        variables=_CategoricalAggPlotter.get_semantics(locals()),\n        order=order,\n        orient=orient,\n        require_numeric=False,\n        legend=legend,\n    )\n\n    if ax is None:\n        ax = plt.gca()\n\n    if p.plot_data.empty:\n        return ax\n\n    if dodge == \"auto\":\n        # Needs to be before scale_categorical changes the coordinate series dtype\n        dodge = p._dodge_needed()\n\n    if p.var_types.get(p.orient) == \"categorical\" or not native_scale:\n        p.scale_categorical(p.orient, order=order, formatter=formatter)\n\n    p._attach(ax)\n\n    # Deprecations to remove in v0.14.0.\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n\n    saturation = saturation if fill else 1\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)\n    color = _default_color(ax.bar, hue, color, kwargs, saturation=saturation)\n\n    aggregator = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)\n    err_kws = {} if err_kws is None else _normalize_kwargs(err_kws, mpl.lines.Line2D)\n\n    # Deprecations to remove in v0.15.0.\n    err_kws, capsize = p._err_kws_backcompat(err_kws, errcolor, errwidth, capsize)\n\n    p.plot_bars(\n        aggregator=aggregator,\n        dodge=dodge,\n        width=width,\n        gap=gap,\n        color=color,\n        fill=fill,\n        capsize=capsize,\n        err_kws=err_kws,\n        plot_kws=kwargs,\n    )\n\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.orient)\n\n    return ax",
                        "filename": "seaborn/categorical.py",
                        "start_index": 83337,
                        "end_index": 85618,
                        "start_line": 2302,
                        "end_line": 2662,
                        "max_line": 3409,
                        "git_instance": "github",
                        "repo_name": "testbed/mwaskom__seaborn__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the 'barplot' function, which is also directly related to the issue as it handles the estimator parameter similar to 'pointplot'."
                }
            ],
            "seaborn/_statistics.py": [
                {
                    "chunk": {
                        "code": "class EstimateAggregator:\n\n    def __init__(self, estimator, errorbar=None, **boot_kws):\n        \"\"\"\n        Data aggregator that produces an estimate and error bar interval.\n\n        Parameters\n        ----------\n        estimator : callable or string\n            Function (or method name) that maps a vector to a scalar.\n        errorbar : string, (string, number) tuple, or callable\n            Name of errorbar method (either \"ci\", \"pi\", \"se\", or \"sd\"), or a tuple\n            with a method name and a level parameter, or a function that maps from a\n            vector to a (min, max) interval.\n        boot_kws\n            Additional keywords are passed to bootstrap when error_method is \"ci\".\n\n        \"\"\"\n        self.estimator = estimator\n\n        method, level = _validate_errorbar_arg(errorbar)\n        self.error_method = method\n        self.error_level = level\n\n        self.boot_kws = boot_kws\n\n    def __call__(self, data, var):\n        \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"\n        vals = data[var]\n        if callable(self.estimator):\n            # You would think we could pass to vals.agg, and yet:\n            # https://github.com/mwaskom/seaborn/issues/2943\n            estimate = self.estimator(vals)\n        else:\n            estimate = vals.agg(self.estimator)\n\n        # Options that produce no error bars\n        if self.error_method is None:\n            err_min = err_max = np.nan\n        elif len(data) <= 1:\n            err_min = err_max = np.nan\n\n        # Generic errorbars from user-supplied function\n        elif callable(self.error_method):\n            err_min, err_max = self.error_method(vals)\n\n        # Parametric options\n        elif self.error_method == \"sd\":\n            half_interval = vals.std() * self.error_level\n            err_min, err_max = estimate - half_interval, estimate + half_interval\n        elif self.error_method == \"se\":\n            half_interval = vals.sem() * self.error_level\n            err_min, err_max = estimate - half_interval, estimate + half_interval\n\n        # Nonparametric options\n        elif self.error_method == \"pi\":\n            err_min, err_max = _percentile_interval(vals, self.error_level)\n        elif self.error_method == \"ci\":\n            units = data.get(\"units\", None)\n            boots = bootstrap(vals, units=units, func=self.estimator, **self.boot_kws)\n            err_min, err_max = _percentile_interval(boots, self.error_level)\n\n        return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})",
                        "filename": "seaborn/_statistics.py",
                        "start_index": 15926,
                        "end_index": 18468,
                        "start_line": 456,
                        "end_line": 518,
                        "max_line": 639,
                        "git_instance": "github",
                        "repo_name": "testbed/mwaskom__seaborn__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'EstimateAggregator' class which is instantiated with the estimator parameter and is likely where the TypeError is occurring."
                }
            ],
            "seaborn/_stats/aggregation.py": [
                {
                    "chunk": {
                        "code": "@dataclass\nclass Est(Stat):\n    \"\"\"\n    Calculate a point estimate and error bar interval.\n\n    For additional information about the various `errorbar` choices, see\n    the :doc:`errorbar tutorial </tutorial/error_bars>`.\n\n    Parameters\n    ----------\n    func : str or callable\n        Name of a :class:`numpy.ndarray` method or a vector -> scalar function.\n    errorbar : str, (str, float) tuple, or callable\n        Name of errorbar method (one of \"ci\", \"pi\", \"se\" or \"sd\"), or a tuple\n        with a method name ane a level parameter, or a function that maps from a\n        vector to a (min, max) interval.\n    n_boot : int\n       Number of bootstrap samples to draw for \"ci\" errorbars.\n    seed : int\n        Seed for the PRNG used to draw bootstrap samples.\n\n    Examples\n    --------\n    .. include:: ../docstrings/objects.Est.rst\n\n    \"\"\"\n    func: str | Callable[[Vector], float] = \"mean\"\n    errorbar: str | tuple[str, float] = (\"ci\", 95)\n    n_boot: int = 1000\n    seed: int | None = None\n\n    group_by_orient: ClassVar[bool] = True\n\n    def _process(\n        self, data: DataFrame, var: str, estimator: EstimateAggregator\n    ) -> DataFrame:\n        # Needed because GroupBy.apply assumes func is DataFrame -> DataFrame\n        # which we could probably make more general to allow Series return\n        res = estimator(data, var)\n        return pd.DataFrame([res])\n\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        boot_kws = {\"n_boot\": self.n_boot, \"seed\": self.seed}\n        engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)\n\n        var = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        res = (\n            groupby\n            .apply(data, self._process, var, engine)\n            .dropna(subset=[var])\n            .reset_index(drop=True)\n        )\n\n        res = res.fillna({f\"{var}min\": res[var], f\"{var}max\": res[var]})\n\n        return res\n\n\n@dataclass\nclass Rolling(Stat):\n    ...\n\n    def __call__(self, data, groupby, orient, scales):\n        ...",
                        "filename": "seaborn/_stats/aggregation.py",
                        "start_index": 1208,
                        "end_index": 3266,
                        "start_line": 15,
                        "end_line": 118,
                        "max_line": 118,
                        "git_instance": "github",
                        "repo_name": "testbed/mwaskom__seaborn__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'Est' class which processes the estimator and errorbar parameters and may be involved in the issue."
                }
            ]
        },
        "solution_task": "- Ensure that the `custom_min` function returns a scalar value when passed a pandas Series object.\n- Modify the `custom_min` function to handle pandas Series correctly by using `np.min` or `pd.Series.min` instead of `np.asarray(x).min()`.\n- If `custom_min` is intended to be used as an estimator, it should have the signature `custom_min(x: pd.Series) -> float` and ensure it returns a float.\n- Check for any changes in the `EstimateAggregator` class between versions `'0.12.0.dev0'` and `'0.11.2'` that could affect how the estimator is called or how the results are processed.\n- If the issue is due to a change in seaborn's internal handling of estimators, consider reverting to the previous behavior or adjusting the `EstimateAggregator` to be compatible with custom estimator functions like `custom_min`.\n- If the issue persists, provide a minimal reproducible example to the seaborn development team for further investigation.",
        "bouncer_response": {
            "score": 7,
            "criteria": "RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides several actionable recommendations that are relevant to the described bug. It suggests ensuring that the custom_min function returns a scalar value when passed a pandas Series object, which is directly related to the TypeError mentioned in the PROMPT. The RESPONSE also recommends modifying the custom_min function to handle pandas Series correctly, which is a practical and relevant suggestion. Additionally, it advises checking for changes in the EstimateAggregator class between versions, which could lead to identifying the root cause of the regression. The RESPONSE also includes the suggestion to provide a minimal reproducible example to the seaborn development team if the issue persists, which is a standard practice in software development for bug tracking. Lastly, the RESPONSE provides specific code snippets to check, which could help in pinpointing the exact location of the bug within the seaborn library. However, the RESPONSE does not address the VisibleDeprecationWarning, which is also part of the exception message and could be related to the issue. This omission prevents the RESPONSE from scoring higher.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711735906.3620129,
        "result": "- Ensure that the `custom_min` function returns a scalar value when passed a pandas Series object.\n- Modify the `custom_min` function to handle pandas Series correctly by using `np.min` or `pd.Series.min` instead of `np.asarray(x).min()`.\n- If `custom_min` is intended to be used as an estimator, it should have the signature `custom_min(x: pd.Series) -> float` and ensure it returns a float.\n- Check for any changes in the `EstimateAggregator` class between versions `'0.12.0.dev0'` and `'0.11.2'` that could affect how the estimator is called or how the results are processed.\n- If the issue is due to a change in seaborn's internal handling of estimators, consider reverting to the previous behavior or adjusting the `EstimateAggregator` to be compatible with custom estimator functions like `custom_min`.\n- If the issue persists, provide a minimal reproducible example to the seaborn development team for further investigation.\n\n### Code snippets to check\n\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn)- [Lines 2442 - 2662](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/categorical.py#L2442-L2662)\n\n This snippet defines the 'pointplot' function, which is directly related to the issue as it handles the estimator parameter. \n\n\n   - [Lines 2302 - 2662](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/categorical.py#L2302-L2662)\n\n This snippet defines the 'barplot' function, which is also directly related to the issue as it handles the estimator parameter similar to 'pointplot'.\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn)- [Lines 456 - 518](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/_statistics.py#L456-L518)\n\n This snippet contains the 'EstimateAggregator' class which is instantiated with the estimator parameter and is likely where the TypeError is occurring.\n-  \u2192 [seaborn](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn) \u2192 [_stats](https://github.com/testbed/mwaskom__seaborn__0.12/tree//seaborn/_stats)- [Lines 15 - 118](https://github.com/testbed/mwaskom__seaborn__0.12/blob//seaborn/_stats/aggregation.py#L15-L118)\n\n This snippet contains the 'Est' class which processes the estimator and errorbar parameters and may be involved in the issue."
    }
}