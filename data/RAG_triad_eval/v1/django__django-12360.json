{
    "id": "django__django-12360",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 3105830771451982630,
    "title": "Add system check for the length of auth permissions codenames.",
    "body": "Description\n\t\nI stumbled across this while performing some migrations on models with rather... descriptive names (my original model was dynamically created).\nAnyway, it looks like in cases where a model name is just under the 100 character limit, and contrib.auth is used, the codenames generated for the default permissions (ie. add_*, change_*, delete_*, view_*) can exceed the maximum 100 characters on the Permission model.\nAs an example, the model below having a 98 character name allows migrations to be generated, but upon running the migration, a database error is raised when it tries to create permissions with codenames above 100 characters.\nThe model:\nclass SomeExcessivelyDescriptiveModelWithAnAbsolutelyRidiculousNameThatCouldntEverNeedToBeNearlyThisLong(models.Model):\n\tfield1 = models.CharField(max_length=25)\nThe error:\ndjango.db.utils.DataError: value too long for type character varying(100)\nWhile I'm aware that you can override the default permissions by setting Meta.default_permissions on the model (this is how I fixed my app), and that the majority of people would never need model names this long, I figured it might be worth adding validation for this case since it uses contrib.auth's default behaviour. Also, the error message originally came up while using a flush command, which seemed counterintuitive.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature request to add a system check for the length of auth permissions codenames, you can follow these steps:\n\n- Update the `django/contrib/auth/checks.py` file to include a new check function that validates the length of the generated permission codenames for each model.\n- Use the existing `permission_codename_max_length` variable to determine the maximum allowed length for permission codenames.\n- For each model, generate the default permission codenames (`add_<model_name>`, `change_<model_name>`, `delete_<model_name>`, `view_<model_name>`) and check if any exceed the `permission_codename_max_length`.\n- If a codename exceeds the maximum length, append an error to the `errors` list with a suitable error message and error code (e.g., `auth.E013`).\n- Add this new check function to the list of system checks that are run by Django.\n\nHere is a pseudo-code snippet to illustrate the implementation:\n\n```python\nfrom django.core import checks\nfrom django.contrib.auth.models import Permission\n\ndef check_permission_codenames_length(app_configs=None, **kwargs):\n    if app_configs is None:\n        models = apps.get_models()\n    else:\n        models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n\n    Permission = apps.get_model(\"auth\", \"Permission\")\n    permission_codename_max_length = Permission._meta.get_field(\"codename\").max_length\n    errors = []\n\n    for model in models:\n        opts = model._meta\n        default_codenames = [\n            f\"add_{opts.model_name}\",\n            f\"change_{opts.model_name}\",\n            f\"delete_{opts.model_name}\",\n            f\"view_{opts.model_name}\",\n        ]\n        for codename in default_codenames:\n            if len(codename) > permission_codename_max_length:\n                errors.append(\n                    checks.Error(\n                        f\"The permission codename '{codename}' for model '{opts.label}' is longer than {permission_codename_max_length} characters.\",\n                        obj=model,\n                        id=\"auth.E013\",\n                    )\n                )\n    return errors\n\n# Register the check\nchecks.register(check_permission_codenames_length, checks.Tags.models)\n```\n\nRemember to add this new check function to the list of checks that Django performs during the system check phase. This can be done by registering the check function with the `checks.register()` function, as shown in the pseudo-code.\n\nThis implementation will ensure that before running migrations, the system will check if the generated permission codenames will fit within the database constraints, and if not, it will provide a clear error message to the developer.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [contrib](https://github.com/testbed/django__django__3.1/tree//django/contrib) \u2192 [auth](https://github.com/testbed/django__django__3.1/tree//django/contrib/auth)- [Lines 121 - 167](https://github.com/testbed/django__django__3.1/blob//django/contrib/auth/checks.py#L121-L167)\n\n This snippet contains checks for the length of built-in permission names and codenames, which is directly related to the issue of permission codenames exceeding the maximum length. \n\n\n   - [Lines 168 - 218](https://github.com/testbed/django__django__3.1/blob//django/contrib/auth/checks.py#L168-L218)\n\n This snippet includes checks for custom permission names and codenames length, which is relevant to ensure that the issue of codenames exceeding the maximum length is not present in custom permissions as well. \n\n\n   - [Lines 12 - 118](https://github.com/testbed/django__django__3.1/blob//django/contrib/auth/checks.py#L12-L118)\n\n This snippet is where the maximum lengths for permission names and codenames are retrieved from the Permission model, which is necessary to understand the constraints that are being exceeded in the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.001254,
        "snippet_processor": 0.06692000000000001,
        "issue_star_creation": 0.02413,
        "issue_star_solver": 0.057440000000000005,
        "bouncer": 0.02357
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711731668.332031,
        "relevant_snippets": [
            {
                "code": "opts = model._meta\n        builtin_permissions = dict(_get_builtin_permissions(opts))\n        # Check builtin permission name length.\n        max_builtin_permission_name_length = (\n            max(len(name) for name in builtin_permissions.values())\n            if builtin_permissions\n            else 0\n        )\n        if max_builtin_permission_name_length > permission_name_max_length:\n            verbose_name_max_length = permission_name_max_length - (\n                max_builtin_permission_name_length - len(opts.verbose_name_raw)\n            )\n            errors.append(\n                checks.Error(\n                    \"The verbose_name of model '%s' must be at most %d \"\n                    \"characters for its builtin permission names to be at \"\n                    \"most %d characters.\"\n                    % (opts.label, verbose_name_max_length, permission_name_max_length),\n                    obj=model,\n                    id=\"auth.E007\",\n                )\n            )\n        # Check builtin permission codename length.\n        max_builtin_permission_codename_length = (\n            max(len(codename) for codename in builtin_permissions.keys())\n            if builtin_permissions\n            else 0\n        )\n        if max_builtin_permission_codename_length > permission_codename_max_length:\n            model_name_max_length = permission_codename_max_length - (\n                max_builtin_permission_codename_length - len(opts.model_name)\n            )\n            errors.append(\n                checks.Error(\n                    \"The name of model '%s' must be at most %d characters \"\n                    \"for its builtin permission codenames to be at most %d \"\n                    \"characters.\"\n                    % (\n                        opts.label,\n                        model_name_max_length,\n                        permission_codename_max_length,\n                    ),\n                    obj=model,\n                    id=\"auth.E011\",\n                )\n            )\n        codenames = set()",
                "filename": "django/contrib/auth/checks.py",
                "start_index": 4292,
                "end_index": 6322,
                "start_line": 121,
                "end_line": 167,
                "max_line": 220,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "for codename, name in opts.permissions:\n            # Check custom permission name length.\n            if len(name) > permission_name_max_length:\n                errors.append(\n                    checks.Error(\n                        \"The permission named '%s' of model '%s' is longer \"\n                        \"than %d characters.\"\n                        % (\n                            name,\n                            opts.label,\n                            permission_name_max_length,\n                        ),\n                        obj=model,\n                        id=\"auth.E008\",\n                    )\n                )\n            # Check custom permission codename length.\n            if len(codename) > permission_codename_max_length:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' of model '%s' is \"\n                        \"longer than %d characters.\"\n                        % (\n                            codename,\n                            opts.label,\n                            permission_codename_max_length,\n                        ),\n                        obj=model,\n                        id=\"auth.E012\",\n                    )\n                )\n            # Check custom permissions codename clashing.\n            if codename in builtin_permissions:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' clashes with a builtin \"\n                        \"permission for model '%s'.\" % (codename, opts.label),\n                        obj=model,\n                        id=\"auth.E005\",\n                    )\n                )\n            elif codename in codenames:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' is duplicated for \"\n                        \"model '%s'.\" % (codename, opts.label),\n                        obj=model,\n                        id=\"auth.E006\",\n                    )\n                )\n            codenames.add(codename)",
                "filename": "django/contrib/auth/checks.py",
                "start_index": 6331,
                "end_index": 8422,
                "start_line": 168,
                "end_line": 218,
                "max_line": 220,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "for f in cls._meta.local_many_to_many:\n            # Skip nonexistent models.\n            if isinstance(f.remote_field.through, str):\n                continue\n\n            # Check if auto-generated name for the M2M field is too long\n            # for the database.\n            for m2m in f.remote_field.through._meta.local_fields:\n                _, rel_name = m2m.get_attname_column()\n                if (\n                    m2m.db_column is None\n                    and rel_name is not None\n                    and len(rel_name) > allowed_len\n                ):\n                    errors.append(\n                        checks.Error(\n                            \"Autogenerated column name too long for M2M field \"\n                            '\"%s\". Maximum length is \"%s\" for database \"%s\".'\n                            % (rel_name, allowed_len, db_alias),\n                            hint=(\n                                \"Use 'through' to create a separate model for \"\n                                \"M2M and then set column_name using 'db_column'.\"\n                            ),\n                            obj=cls,\n                            id=\"models.E019\",\n                        )\n                    )\n\n        return errors",
                "filename": "django/db/models/base.py",
                "start_index": 90213,
                "end_index": 91455,
                "start_line": 2293,
                "end_line": 2553,
                "max_line": 2607,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n        Check that any auto-generated column names are shorter than the limits\n        for each database in which the model will be created.\n        \"\"\"\n        if not databases:\n            return []\n        errors = []\n        allowed_len = None\n        db_alias = None\n\n        # Find the minimum max allowed length among all specified db_aliases.\n        for db in databases:\n            # skip databases where the model won't be created\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            max_name_length = connection.ops.max_name_length()\n            if max_name_length is None or connection.features.truncates_names:\n                continue\n            else:\n                if allowed_len is None:\n                    allowed_len = max_name_length\n                    db_alias = db\n                elif max_name_length < allowed_len:\n                    allowed_len = max_name_length\n                    db_alias = db\n\n        if allowed_len is None:\n            return errors\n\n        for f in cls._meta.local_fields:\n            _, column_name = f.get_attname_column()\n\n            # Check if auto-generated name for the field is too long\n            # for the database.\n            if (\n                f.db_column is None\n                and column_name is not None\n                and len(column_name) > allowed_len\n            ):\n                errors.append(\n                    checks.Error(\n                        'Autogenerated column name too long for field \"%s\". '\n                        'Maximum length is \"%s\" for database \"%s\".'\n                        % (column_name, allowed_len, db_alias),\n                        hint=\"Set the column name manually using 'db_column'.\",\n                        obj=cls,\n                        id=\"models.E018\",\n                    )\n                )",
                "filename": "django/db/models/base.py",
                "start_index": 88303,
                "end_index": 90203,
                "start_line": 70,
                "end_line": 2551,
                "max_line": 2607,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "from django.contrib.auth import validators\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0003_alter_user_email_max_length\"),\n    ]\n\n    # No database changes; modifies validators and error_messages (#13147).\n    operations = [\n        migrations.AlterField(\n            model_name=\"user\",\n            name=\"username\",\n            field=models.CharField(\n                error_messages={\"unique\": \"A user with that username already exists.\"},\n                max_length=30,\n                validators=[validators.UnicodeUsernameValidator()],\n                help_text=(\n                    \"Required. 30 characters or fewer. Letters, digits and @/./+/-/_ \"\n                    \"only.\"\n                ),\n                unique=True,\n                verbose_name=\"username\",\n            ),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0004_alter_user_username_opts.py",
                "start_index": 0,
                "end_index": 879,
                "start_line": 1,
                "end_line": 27,
                "max_line": 27,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from django.contrib.auth import validators\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0007_alter_validators_add_error_messages\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"user\",\n            name=\"username\",\n            field=models.CharField(\n                error_messages={\"unique\": \"A user with that username already exists.\"},\n                help_text=(\n                    \"Required. 150 characters or fewer. Letters, digits and @/./+/-/_ \"\n                    \"only.\"\n                ),\n                max_length=150,\n                unique=True,\n                validators=[validators.UnicodeUsernameValidator()],\n                verbose_name=\"username\",\n            ),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0008_alter_user_username_max_length.py",
                "start_index": 0,
                "end_index": 813,
                "start_line": 1,
                "end_line": 26,
                "max_line": 26,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from itertools import chain\n\nfrom django.apps import apps\nfrom django.core.checks import Error\n\n\ndef check_generic_foreign_keys(app_configs=None, **kwargs):\n    from .fields import GenericForeignKey\n\n    if app_configs is None:\n        models = apps.get_models()\n    else:\n        models = chain.from_iterable(\n            app_config.get_models() for app_config in app_configs\n        )\n    errors = []\n    fields = (\n        obj\n        for model in models\n        for obj in vars(model).values()\n        if isinstance(obj, GenericForeignKey)\n    )\n    for field in fields:\n        errors.extend(field.check())\n    return errors\n\n\ndef check_model_name_lengths(app_configs=None, **kwargs):\n    if app_configs is None:\n        models = apps.get_models()\n    else:\n        models = chain.from_iterable(\n            app_config.get_models() for app_config in app_configs\n        )\n    errors = []\n    for model in models:\n        if len(model._meta.model_name) > 100:\n            errors.append(\n                Error(\n                    \"Model names must be at most 100 characters (got %d).\"\n                    % (len(model._meta.model_name),),\n                    obj=model,\n                    id=\"contenttypes.E005\",\n                )\n            )\n    return errors",
                "filename": "django/contrib/contenttypes/checks.py",
                "start_index": 0,
                "end_index": 1267,
                "start_line": 1,
                "end_line": 46,
                "max_line": 46,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "from django.contrib.auth import validators\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0006_require_contenttypes_0002\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"user\",\n            name=\"username\",\n            field=models.CharField(\n                error_messages={\"unique\": \"A user with that username already exists.\"},\n                help_text=(\n                    \"Required. 30 characters or fewer. Letters, digits and @/./+/-/_ \"\n                    \"only.\"\n                ),\n                max_length=30,\n                unique=True,\n                validators=[validators.UnicodeUsernameValidator()],\n                verbose_name=\"username\",\n            ),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0007_alter_validators_add_error_messages.py",
                "start_index": 0,
                "end_index": 801,
                "start_line": 1,
                "end_line": 26,
                "max_line": 26,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if app_configs is None:\n        models = apps.get_models()\n    else:\n        models = chain.from_iterable(\n            app_config.get_models() for app_config in app_configs\n        )\n\n    Permission = apps.get_model(\"auth\", \"Permission\")\n    permission_name_max_length = Permission._meta.get_field(\"name\").max_length\n    permission_codename_max_length = Permission._meta.get_field(\"codename\").max_length\n    errors = []",
                "filename": "django/contrib/auth/checks.py",
                "start_index": 3838,
                "end_index": 4257,
                "start_line": 12,
                "end_line": 118,
                "max_line": 220,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"auth\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name=\"permission\",\n            name=\"name\",\n            field=models.CharField(max_length=255, verbose_name=\"name\"),\n        ),\n    ]",
                "filename": "django/contrib/auth/migrations/0002_alter_permission_name_max_length.py",
                "start_index": 0,
                "end_index": 345,
                "start_line": 1,
                "end_line": 15,
                "max_line": 15,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 1.0
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/contrib/auth/checks.py": [
                {
                    "chunk": {
                        "code": "opts = model._meta\n        builtin_permissions = dict(_get_builtin_permissions(opts))\n        # Check builtin permission name length.\n        max_builtin_permission_name_length = (\n            max(len(name) for name in builtin_permissions.values())\n            if builtin_permissions\n            else 0\n        )\n        if max_builtin_permission_name_length > permission_name_max_length:\n            verbose_name_max_length = permission_name_max_length - (\n                max_builtin_permission_name_length - len(opts.verbose_name_raw)\n            )\n            errors.append(\n                checks.Error(\n                    \"The verbose_name of model '%s' must be at most %d \"\n                    \"characters for its builtin permission names to be at \"\n                    \"most %d characters.\"\n                    % (opts.label, verbose_name_max_length, permission_name_max_length),\n                    obj=model,\n                    id=\"auth.E007\",\n                )\n            )\n        # Check builtin permission codename length.\n        max_builtin_permission_codename_length = (\n            max(len(codename) for codename in builtin_permissions.keys())\n            if builtin_permissions\n            else 0\n        )\n        if max_builtin_permission_codename_length > permission_codename_max_length:\n            model_name_max_length = permission_codename_max_length - (\n                max_builtin_permission_codename_length - len(opts.model_name)\n            )\n            errors.append(\n                checks.Error(\n                    \"The name of model '%s' must be at most %d characters \"\n                    \"for its builtin permission codenames to be at most %d \"\n                    \"characters.\"\n                    % (\n                        opts.label,\n                        model_name_max_length,\n                        permission_codename_max_length,\n                    ),\n                    obj=model,\n                    id=\"auth.E011\",\n                )\n            )\n        codenames = set()",
                        "filename": "django/contrib/auth/checks.py",
                        "start_index": 4292,
                        "end_index": 6322,
                        "start_line": 121,
                        "end_line": 167,
                        "max_line": 220,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains checks for the length of built-in permission names and codenames, which is directly related to the issue of permission codenames exceeding the maximum length."
                },
                {
                    "chunk": {
                        "code": "for codename, name in opts.permissions:\n            # Check custom permission name length.\n            if len(name) > permission_name_max_length:\n                errors.append(\n                    checks.Error(\n                        \"The permission named '%s' of model '%s' is longer \"\n                        \"than %d characters.\"\n                        % (\n                            name,\n                            opts.label,\n                            permission_name_max_length,\n                        ),\n                        obj=model,\n                        id=\"auth.E008\",\n                    )\n                )\n            # Check custom permission codename length.\n            if len(codename) > permission_codename_max_length:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' of model '%s' is \"\n                        \"longer than %d characters.\"\n                        % (\n                            codename,\n                            opts.label,\n                            permission_codename_max_length,\n                        ),\n                        obj=model,\n                        id=\"auth.E012\",\n                    )\n                )\n            # Check custom permissions codename clashing.\n            if codename in builtin_permissions:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' clashes with a builtin \"\n                        \"permission for model '%s'.\" % (codename, opts.label),\n                        obj=model,\n                        id=\"auth.E005\",\n                    )\n                )\n            elif codename in codenames:\n                errors.append(\n                    checks.Error(\n                        \"The permission codenamed '%s' is duplicated for \"\n                        \"model '%s'.\" % (codename, opts.label),\n                        obj=model,\n                        id=\"auth.E006\",\n                    )\n                )\n            codenames.add(codename)",
                        "filename": "django/contrib/auth/checks.py",
                        "start_index": 6331,
                        "end_index": 8422,
                        "start_line": 168,
                        "end_line": 218,
                        "max_line": 220,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes checks for custom permission names and codenames length, which is relevant to ensure that the issue of codenames exceeding the maximum length is not present in custom permissions as well."
                },
                {
                    "chunk": {
                        "code": "if app_configs is None:\n        models = apps.get_models()\n    else:\n        models = chain.from_iterable(\n            app_config.get_models() for app_config in app_configs\n        )\n\n    Permission = apps.get_model(\"auth\", \"Permission\")\n    permission_name_max_length = Permission._meta.get_field(\"name\").max_length\n    permission_codename_max_length = Permission._meta.get_field(\"codename\").max_length\n    errors = []",
                        "filename": "django/contrib/auth/checks.py",
                        "start_index": 3838,
                        "end_index": 4257,
                        "start_line": 12,
                        "end_line": 118,
                        "max_line": 220,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is where the maximum lengths for permission names and codenames are retrieved from the Permission model, which is necessary to understand the constraints that are being exceeded in the issue."
                }
            ]
        },
        "solution_task": "To implement the feature request to add a system check for the length of auth permissions codenames, you can follow these steps:\n\n- Update the `django/contrib/auth/checks.py` file to include a new check function that validates the length of the generated permission codenames for each model.\n- Use the existing `permission_codename_max_length` variable to determine the maximum allowed length for permission codenames.\n- For each model, generate the default permission codenames (`add_<model_name>`, `change_<model_name>`, `delete_<model_name>`, `view_<model_name>`) and check if any exceed the `permission_codename_max_length`.\n- If a codename exceeds the maximum length, append an error to the `errors` list with a suitable error message and error code (e.g., `auth.E013`).\n- Add this new check function to the list of system checks that are run by Django.\n\nHere is a pseudo-code snippet to illustrate the implementation:\n\n```python\nfrom django.core import checks\nfrom django.contrib.auth.models import Permission\n\ndef check_permission_codenames_length(app_configs=None, **kwargs):\n    if app_configs is None:\n        models = apps.get_models()\n    else:\n        models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n\n    Permission = apps.get_model(\"auth\", \"Permission\")\n    permission_codename_max_length = Permission._meta.get_field(\"codename\").max_length\n    errors = []\n\n    for model in models:\n        opts = model._meta\n        default_codenames = [\n            f\"add_{opts.model_name}\",\n            f\"change_{opts.model_name}\",\n            f\"delete_{opts.model_name}\",\n            f\"view_{opts.model_name}\",\n        ]\n        for codename in default_codenames:\n            if len(codename) > permission_codename_max_length:\n                errors.append(\n                    checks.Error(\n                        f\"The permission codename '{codename}' for model '{opts.label}' is longer than {permission_codename_max_length} characters.\",\n                        obj=model,\n                        id=\"auth.E013\",\n                    )\n                )\n    return errors\n\n# Register the check\nchecks.register(check_permission_codenames_length, checks.Tags.models)\n```\n\nRemember to add this new check function to the list of checks that Django performs during the system check phase. This can be done by registering the check function with the `checks.register()` function, as shown in the pseudo-code.\n\nThis implementation will ensure that before running migrations, the system will check if the generated permission codenames will fit within the database constraints, and if not, it will provide a clear error message to the developer.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable step-by-step guide to implement a system check for the length of auth permissions codenames, which directly addresses the feature request described in the PROMPT. It includes a clear explanation of where to add the new check function, how to use existing variables to determine the maximum allowed length, and how to generate and validate the default permission codenames. The RESPONSE also includes a pseudo-code snippet that illustrates the implementation, which is highly relevant and useful for the developer. Additionally, the RESPONSE provides guidance on how to register the new check function with Django's system checks. The inclusion of code snippets to check further adds value by pointing the developer to relevant sections of the Django codebase. The RESPONSE only misses a perfect score because it does not explicitly mention the need to handle edge cases or provide guidance on testing the new check function, which would be necessary for a comprehensive implementation.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711731827.215434,
        "result": "To implement the feature request to add a system check for the length of auth permissions codenames, you can follow these steps:\n\n- Update the `django/contrib/auth/checks.py` file to include a new check function that validates the length of the generated permission codenames for each model.\n- Use the existing `permission_codename_max_length` variable to determine the maximum allowed length for permission codenames.\n- For each model, generate the default permission codenames (`add_<model_name>`, `change_<model_name>`, `delete_<model_name>`, `view_<model_name>`) and check if any exceed the `permission_codename_max_length`.\n- If a codename exceeds the maximum length, append an error to the `errors` list with a suitable error message and error code (e.g., `auth.E013`).\n- Add this new check function to the list of system checks that are run by Django.\n\nHere is a pseudo-code snippet to illustrate the implementation:\n\n```python\nfrom django.core import checks\nfrom django.contrib.auth.models import Permission\n\ndef check_permission_codenames_length(app_configs=None, **kwargs):\n    if app_configs is None:\n        models = apps.get_models()\n    else:\n        models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n\n    Permission = apps.get_model(\"auth\", \"Permission\")\n    permission_codename_max_length = Permission._meta.get_field(\"codename\").max_length\n    errors = []\n\n    for model in models:\n        opts = model._meta\n        default_codenames = [\n            f\"add_{opts.model_name}\",\n            f\"change_{opts.model_name}\",\n            f\"delete_{opts.model_name}\",\n            f\"view_{opts.model_name}\",\n        ]\n        for codename in default_codenames:\n            if len(codename) > permission_codename_max_length:\n                errors.append(\n                    checks.Error(\n                        f\"The permission codename '{codename}' for model '{opts.label}' is longer than {permission_codename_max_length} characters.\",\n                        obj=model,\n                        id=\"auth.E013\",\n                    )\n                )\n    return errors\n\n# Register the check\nchecks.register(check_permission_codenames_length, checks.Tags.models)\n```\n\nRemember to add this new check function to the list of checks that Django performs during the system check phase. This can be done by registering the check function with the `checks.register()` function, as shown in the pseudo-code.\n\nThis implementation will ensure that before running migrations, the system will check if the generated permission codenames will fit within the database constraints, and if not, it will provide a clear error message to the developer.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [contrib](https://github.com/testbed/django__django__3.1/tree//django/contrib) \u2192 [auth](https://github.com/testbed/django__django__3.1/tree//django/contrib/auth)- [Lines 121 - 167](https://github.com/testbed/django__django__3.1/blob//django/contrib/auth/checks.py#L121-L167)\n\n This snippet contains checks for the length of built-in permission names and codenames, which is directly related to the issue of permission codenames exceeding the maximum length. \n\n\n   - [Lines 168 - 218](https://github.com/testbed/django__django__3.1/blob//django/contrib/auth/checks.py#L168-L218)\n\n This snippet includes checks for custom permission names and codenames length, which is relevant to ensure that the issue of codenames exceeding the maximum length is not present in custom permissions as well. \n\n\n   - [Lines 12 - 118](https://github.com/testbed/django__django__3.1/blob//django/contrib/auth/checks.py#L12-L118)\n\n This snippet is where the maximum lengths for permission names and codenames are retrieved from the Permission model, which is necessary to understand the constraints that are being exceeded in the issue.",
        "context_relevance": 0.5399999999999999,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant and answers the entire PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation and steps to implement a system check for the length of auth permissions codenames, which is the exact issue described in the PROMPT. It addresses the problem of permission codenames exceeding the maximum length and offers a solution with pseudo-code that is directly related to the described issue. The RESPONSE also includes references to specific lines of code in the Django repository that are relevant to the problem, showing a clear understanding of the context and the technical aspects involved. The RESPONSE fulfills all parts of the PROMPT, providing a complete and relevant answer."
        },
        "qa_relevance": 1.0
    }
}