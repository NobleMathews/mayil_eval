{
    "id": "matplotlib__matplotlib-19763",
    "repo_name": "testbed/matplotlib__matplotlib__3.3",
    "task_id": 471466209764715356,
    "title": "Multicursor disappears when not moving on nbagg with useblit=False + burns CPU",
    "body": "<!--To help us understand and resolve your issue, please fill out the form to the best of your ability.-->\r\n<!--You can feel free to delete the sections that do not apply.-->\r\n\r\n### Bug report\r\n\r\n**Bug summary**\r\nWhen on the nbagg backend if you stop moving the mouse the multicursor will disappear. The same example works fine on the qt backend.\r\n\r\nAdditionally I noticed that when I add the multicursor my cpu usage jumps and the kernel busy indicator constantly flashes on and off. \r\n\r\nShowing the plot without the multicursor:\r\n![image](https://user-images.githubusercontent.com/10111092/109886513-28e01700-7c4e-11eb-8aac-d8a18832f787.png)\r\nand with the multicursor (just displaying, not interacting with the plot):\r\n\r\n![image](https://user-images.githubusercontent.com/10111092/109886579-490fd600-7c4e-11eb-94d8-ce4d9425559f.png)\r\nThat usage is pretty stable and my laptop's fan goes wild.\r\n\r\nThe issue with the dissappearing was originally noticed by @ipcoder in https://github.com/matplotlib/ipympl/issues/306\r\n\r\n**Code for reproduction**\r\n\r\n<!--A minimum code snippet required to reproduce the bug.\r\nPlease make sure to minimize the number of dependencies required, and provide\r\nany necessary plotted data.\r\nAvoid using threads, as Matplotlib is (explicitly) not thread-safe.-->\r\n\r\n```python\r\n%matplotlib nbagg\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.widgets import MultiCursor\r\n\r\nt = np.arange(0.0, 2.0, 0.01)\r\ns1 = np.sin(2*np.pi*t)\r\ns2 = np.sin(4*np.pi*t)\r\n\r\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\r\nax1.plot(t, s1)\r\nax2.plot(t, s2)\r\n\r\nmulti = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1, useblit=False)\r\nplt.show()\r\n```\r\n\r\n**Actual outcome**\r\n\r\n![Peek 2021-03-03 18-12](https://user-images.githubusercontent.com/10111092/109885329-54fa9880-7c4c-11eb-9caa-f765dda6f729.gif)\r\n\r\nand the high CPU usage\r\n\r\n\r\n**Expected outcome**\r\nRed line doesn't disappear + my CPU doesn't get crushed.\r\n\r\n\r\n<!--A description of the expected outcome from the code snippet-->\r\n<!--If this used to work in an earlier version of Matplotlib, please note the version it used to work on-->\r\n\r\n**Matplotlib version**\r\n<!--Please specify your platform and versions of the relevant libraries you are using:-->\r\n  * Operating system: Ubuntu\r\n  * Matplotlib version (`import matplotlib; print(matplotlib.__version__)`): '3.3.4.post2456+gfd23bb238'\r\n  * Matplotlib backend (`print(matplotlib.get_backend())`): nbagg\r\n  * Python version: '3.9.1 | packaged by conda-forge | (default, Jan 26 2021, 01:34:10) \\n[GCC 9.3.0]'\r\n  * Jupyter version (if applicable): Notebook 6.2.0 - IPython 7.20.0\r\n\r\ndev instlal of maptlotlib + conda-forge for the others \r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.3.git",
    "requested_commit": "",
    "mayil_response": "To address the issue of the multicursor disappearing when not moving and the high CPU usage with the `nbagg` backend when `useblit=False`, consider the following solution:\n\n- Modify the `MultiCursor` class to ensure it is compatible with the `nbagg` backend when `useblit` is set to `False`. This may involve checking and updating the event loop handling for the `nbagg` backend to prevent high CPU usage and ensure the multicursor remains visible.\n- Implement a mechanism to force a redraw of the multicursor when the mouse is not moving. This could be done by setting a timer that triggers a redraw at regular intervals or by redrawing the cursor in response to other events that indicate the figure is still being displayed.\n- Investigate the kernel busy indicator flashing issue to ensure that the event loop or the drawing logic does not inadvertently trigger unnecessary computations or communications with the Jupyter kernel.\n\nHere is a hypothetical code snippet that could be added or modified in the `MultiCursor` class to address the issue:\n\n```python\nclass MultiCursor(Widget):\n    def __init__(self, canvas, axes, color='r', lw=1, useblit=False):\n        # ... existing code ...\n\n        # Add a timer to force redraw the cursor when idle if using nbagg backend\n        if matplotlib.get_backend() == 'nbagg':\n            self.timer = self.canvas.new_timer(interval=100)  # interval in milliseconds\n            self.timer.add_callback(self.redraw_idle_cursor)\n            self.timer.start()\n\n    def redraw_idle_cursor(self):\n        # Redraw the cursor if it's visible and the mouse is not moving\n        if self.visible and not self.mouse_moving:\n            self.canvas.draw_idle()\n\n    def on_mouse_move(self, event):\n        # ... existing code ...\n        self.mouse_moving = True\n        # ... existing code ...\n\n    def on_mouse_stop(self, event):\n        # Event handler for when the mouse stops moving\n        self.mouse_moving = False\n\n    # ... existing code ...\n```\n\nIn this hypothetical solution:\n- A timer is added to the `MultiCursor` class that calls `redraw_idle_cursor` at a regular interval when using the `nbagg` backend.\n- The `redraw_idle_cursor` method forces a redraw of the cursor if it is visible and the mouse is not moving.\n- The `on_mouse_move` method is updated to set a flag when the mouse is moving.\n- An additional event handler `on_mouse_stop` could be implemented to detect when the mouse stops moving.\n\nPlease note that the actual implementation may vary based on the existing codebase and the specific details of the `nbagg` backend. The provided code is a conceptual example and may require adaptation to fit into the actual Matplotlib codebase.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.3/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.3/tree//lib/matplotlib)- [Lines 2042 - 2042](https://github.com/testbed/matplotlib__matplotlib__3.3/blob//lib/matplotlib/widgets.py#L2042-L2042)\n\n This snippet points to the definition of the MultiCursor class in the widgets.py file, which is directly related to the issue reported.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00056,
        "snippet_processor": 0.07283,
        "issue_star_creation": 0.03674,
        "issue_star_solver": 0.07214000000000001,
        "bouncer": 0.02909
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711698969.8153212,
        "relevant_snippets": [
            {
                "code": "\"\"\"\n===========\nMulticursor\n===========\n\nShowing a cursor on multiple plots simultaneously.\n\nThis example generates three axes split over two different figures.  On\nhovering the cursor over data in one subplot, the values of that datapoint are\nshown in all axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import MultiCursor\n\nt = np.arange(0.0, 2.0, 0.01)\ns1 = np.sin(2*np.pi*t)\ns2 = np.sin(3*np.pi*t)\ns3 = np.sin(4*np.pi*t)\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nax1.plot(t, s1)\nax2.plot(t, s2)\nfig, ax3 = plt.subplots()\nax3.plot(t, s3)\n\nmulti = MultiCursor(None, (ax1, ax2, ax3), color='r', lw=1)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.MultiCursor`",
                "filename": "galleries/examples/widgets/multicursor.py",
                "start_index": 0,
                "end_index": 838,
                "start_line": 1,
                "end_line": 39,
                "max_line": 39,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n=================\nCross-hair cursor\n=================\n\nThis example adds a cross-hair as a data cursor.  The cross-hair is\nimplemented as regular line objects that are updated on mouse move.\n\nWe show three implementations:\n\n1) A simple cursor implementation that redraws the figure on every mouse move.\n   This is a bit slow, and you may notice some lag of the cross-hair movement.\n2) A cursor that uses blitting for speedup of the rendering.\n3) A cursor that snaps to data points.\n\nFaster cursoring is possible using native GUI drawing, as in\n:doc:`/gallery/user_interfaces/wxcursor_demo_sgskip`.\n\nThe mpldatacursor__ and mplcursors__ third-party packages can be used to\nachieve a similar effect.\n\n__ https://github.com/joferkington/mpldatacursor\n__ https://github.com/anntzer/mplcursors\n\n.. redirect-from:: /gallery/misc/cursor_demo\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseEvent\n\n\nclass Cursor:\n    \"\"\"\n    A cross hair cursor.\n    \"\"\"\n    def __init__(self, ax):\n        self.ax = ax\n        self.horizontal_line = ax.axhline(color='k', lw=0.8, ls='--')\n        self.vertical_line = ax.axvline(color='k', lw=0.8, ls='--')\n        # text location in axes coordinates\n        self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def on_mouse_move(self, event):\n        if not event.inaxes:\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.draw()\n        else:\n            self.set_cross_hair_visible(True)\n            x, y = event.xdata, event.ydata\n            # update the line positions\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f'x={x:1.2f}, y={y:1.2f}')\n            self.ax.figure.canvas.draw()\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title('Simple cursor')\nax.plot(x, y, 'o')\ncursor = Cursor(ax)\nfig.canvas.mpl_connect('motion_notify_event', cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n\n# %%\n# Faster redrawing using blitting\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n# This technique stores the rendered plot as a background image. Only the\n# changed artists (cross-hair lines and text) are rendered anew. They are\n# combined with the background using blitting.\n#\n# This technique is significantly faster. It requires a bit more setup because\n# the background has to be stored without the cross-hair lines (see",
                "filename": "galleries/examples/event_handling/cursor_demo.py",
                "start_index": 0,
                "end_index": 2929,
                "start_line": 1,
                "end_line": 90,
                "max_line": 242,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.4
            },
            {
                "code": "\"\"\"\n============\nMouse Cursor\n============\n\nThis example sets an alternative cursor on a figure canvas.\n\nNote, this is an interactive example, and must be run to see the effect.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.backend_tools import Cursors\n\nfig, axs = plt.subplots(len(Cursors), figsize=(6, len(Cursors) + 0.5),\n                        gridspec_kw={'hspace': 0})\nfig.suptitle('Hover over an Axes to see alternate Cursors')\n\nfor cursor, ax in zip(Cursors, axs):\n    ax.cursor_to_use = cursor\n    ax.text(0.5, 0.5, cursor.name,\n            horizontalalignment='center', verticalalignment='center')\n    ax.set(xticks=[], yticks=[])\n\n\ndef hover(event):\n    if fig.canvas.widgetlock.locked():\n        # Don't do anything if the zoom/pan tools have been enabled.\n        return\n\n    fig.canvas.set_cursor(\n        event.inaxes.cursor_to_use if event.inaxes else Cursors.POINTER)\n\n\nfig.canvas.mpl_connect('motion_notify_event', hover)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.backend_bases.FigureCanvasBase.set_cursor`",
                "filename": "galleries/examples/widgets/mouse_cursor.py",
                "start_index": 0,
                "end_index": 1164,
                "start_line": 1,
                "end_line": 46,
                "max_line": 46,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "fig, ax = plt.subplots(figsize=(8, 6))\nax.set_title(\"Cursor Tracking x Position\")\n\nx = np.linspace(-5, 5, 1000)\ny = x**2\n\nline, = ax.plot(x, y)\nax.set_xlim(-5, 5)\nax.set_ylim(0, 25)\n\n# A minimum call\n# Set useblit=True on most backends for enhanced performance\n# and pass the ax parameter to the Cursor base class.\n# cursor = AnnotatedCursor(line=lin[0], ax=ax, useblit=True)\n\n# A more advanced call. Properties for text and lines are passed.\n# Watch the passed color names and the color of cursor line and text, to\n# relate the passed options to graphical elements.\n# The dataaxis parameter is still the default.\ncursor = AnnotatedCursor(\n    line=line,\n    numberformat=\"{0:.2f}\\n{1:.2f}\",\n    dataaxis='x', offset=[10, 10],\n    textprops={'color': 'blue', 'fontweight': 'bold'},\n    ax=ax,\n    useblit=True,\n    color='red',\n    linewidth=2)\n\n# Simulate a mouse move to (-2, 10), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((-2, 10))\n)._process()\n\nplt.show()\n\n# %%\n# Trouble with non-biunique functions\n# -----------------------------------\n# A call demonstrating problems with the *dataaxis=y* parameter.\n# The text now looks up the matching x value for the current cursor y position\n# instead of vice versa. Hover your cursor to y=4. There are two x values\n# producing this y value: -2 and 2. The function is only unique,\n# but not biunique. Only one value is shown in the text.\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.set_title(\"Cursor Tracking y Position\")\n\nline, = ax.plot(x, y)\nax.set_xlim(-5, 5)\nax.set_ylim(0, 25)\n\ncursor = AnnotatedCursor(\n    line=line,\n    numberformat=\"{0:.2f}\\n{1:.2f}\",\n    dataaxis='y', offset=[10, 10],\n    textprops={'color': 'blue', 'fontweight': 'bold'},\n    ax=ax,\n    useblit=True,\n    color='red', linewidth=2)\n\n# Simulate a mouse move to (-2, 10), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((-2, 10))\n)._process()\n\nplt.show()",
                "filename": "galleries/examples/widgets/annotated_cursor.py",
                "start_index": 11326,
                "end_index": 13330,
                "start_line": 288,
                "end_line": 356,
                "max_line": 356,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "class MultiCursor(Widget):",
                "filename": "lib/matplotlib/widgets.py",
                "start_index": 73653,
                "end_index": 73679,
                "start_line": 2042,
                "end_line": 2042,
                "max_line": 4245,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# ``create_new_background()``). Additionally, a new background has to be\n# created whenever the figure changes. This is achieved by connecting to the\n# ``'draw_event'``.\n\n\nclass BlittedCursor:\n    \"\"\"\n    A cross-hair cursor using blitting for faster redraw.\n    \"\"\"\n    def __init__(self, ax):\n        self.ax = ax\n        self.background = None\n        self.horizontal_line = ax.axhline(color='k', lw=0.8, ls='--')\n        self.vertical_line = ax.axvline(color='k', lw=0.8, ls='--')\n        # text location in axes coordinates\n        self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)\n        self._creating_background = False\n        ax.figure.canvas.mpl_connect('draw_event', self.on_draw)\n\n    def on_draw(self, event):\n        self.create_new_background()\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def create_new_background(self):\n        if self._creating_background:\n            # discard calls triggered from within this function\n            return\n        self._creating_background = True\n        self.set_cross_hair_visible(False)\n        self.ax.figure.canvas.draw()\n        self.background = self.ax.figure.canvas.copy_from_bbox(self.ax.bbox)\n        self.set_cross_hair_visible(True)\n        self._creating_background = False\n\n    def on_mouse_move(self, event):\n        if self.background is None:\n            self.create_new_background()\n        if not event.inaxes:\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.restore_region(self.background)\n                self.ax.figure.canvas.blit(self.ax.bbox)\n        else:\n            self.set_cross_hair_visible(True)\n            # update the line positions\n            x, y = event.xdata, event.ydata\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f'x={x:1.2f}, y={y:1.2f}')\n\n            self.ax.figure.canvas.restore_region(self.background)\n            self.ax.draw_artist(self.horizontal_line)\n            self.ax.draw_artist(self.vertical_line)\n            self.ax.draw_artist(self.text)\n            self.ax.figure.canvas.blit(self.ax.bbox)\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title('Blitted cursor')\nax.plot(x, y, 'o')\nblitted_cursor = BlittedCursor(ax)\nfig.canvas.mpl_connect('motion_notify_event', blitted_cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n\n# %%\n# Snapping to data points\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n# The following cursor snaps its position to the data points of a `.Line2D`\n# object.\n#",
                "filename": "galleries/examples/event_handling/cursor_demo.py",
                "start_index": 2930,
                "end_index": 5911,
                "start_line": 91,
                "end_line": 236,
                "max_line": 242,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n.. redirect-from:: /tutorials/advanced/blitting\n\n.. _blitting:\n\n==================================\nFaster rendering by using blitting\n==================================\n\n*Blitting* is a `standard technique\n<https://en.wikipedia.org/wiki/Bit_blit>`__ in raster graphics that,\nin the context of Matplotlib, can be used to (drastically) improve\nperformance of interactive figures. For example, the\n:mod:`.animation` and :mod:`.widgets` modules use blitting\ninternally. Here, we demonstrate how to implement your own blitting, outside\nof these classes.\n\nBlitting speeds up repetitive drawing by rendering all non-changing\ngraphic elements into a background image once. Then, for every draw, only the\nchanging elements need to be drawn onto this background. For example,\nif the limits of an Axes have not changed, we can render the empty Axes\nincluding all ticks and labels once, and only draw the changing data later.\n\nThe strategy is\n\n- Prepare the constant background:\n\n  - Draw the figure, but exclude all artists that you want to animate by\n    marking them as *animated* (see `.Artist.set_animated`).\n  - Save a copy of the RBGA buffer.\n\n- Render the individual images:\n\n  - Restore the copy of the RGBA buffer.\n  - Redraw the animated artists using `.Axes.draw_artist` /\n    `.Figure.draw_artist`.\n  - Show the resulting image on the screen.\n\nOne consequence of this procedure is that your animated artists are always\ndrawn on top of the static artists.\n\nNot all backends support blitting.  You can check if a given canvas does via\nthe `.FigureCanvasBase.supports_blit` property.\n\n.. warning::\n\n   This code does not work with the OSX backend (but does work with other\n   GUI backends on Mac).\n\nMinimal example\n---------------\n\nWe can use the `.FigureCanvasAgg` methods\n`~.FigureCanvasAgg.copy_from_bbox` and\n`~.FigureCanvasAgg.restore_region` in conjunction with setting\n``animated=True`` on our artist to implement a minimal example that\nuses blitting to accelerate rendering\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 2 * np.pi, 100)\n\nfig, ax = plt.subplots()\n\n# animated=True tells matplotlib to only draw the artist when we\n# explicitly request it\n(ln,) = ax.plot(x, np.sin(x), animated=True)\n\n# make sure the window is raised, but the script keeps going\nplt.show(block=False)\n\n# stop to admire our empty window axes and ensure it is rendered at\n# least once.\n#\n# We need to fully draw the figure at its final size on the screen\n# before we continue on so that :\n#  a) we have the correctly sized and drawn background to grab\n#  b) we have a cached renderer so that ``ax.draw_artist`` works\n# so we spin the event loop to let the backend process any pending operations\nplt.pause(0.1)\n\n# get copy of entire figure (everything inside fig.bbox) sans animated artist\nbg = fig.canvas.copy_from_bbox(fig.bbox)\n# draw the animated artist, this uses a cached renderer\nax.draw_artist(ln)\n# show the result to the screen, this pushes the updated RGBA buffer from the",
                "filename": "galleries/users_explain/animations/blitting.py",
                "start_index": 0,
                "end_index": 3001,
                "start_line": 1,
                "end_line": 89,
                "max_line": 232,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n=====================\nAdding a cursor in WX\n=====================\n\nExample to draw a cursor and report the data coords in wx.\n\"\"\"\n\nimport wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wx import NavigationToolbar2Wx\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self, ):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2*np.pi*t)\n\n        self.axes.plot(t, s)\n        self.axes.set_xlabel('t')\n        self.axes.set_ylabel('sin(t)')\n        self.figure_canvas = FigureCanvas(self, -1, self.figure)\n\n        # Note that event is a MplEvent\n        self.figure_canvas.mpl_connect(\n            'motion_notify_event', self.UpdateStatusBar)\n        self.figure_canvas.Bind(wx.EVT_ENTER_WINDOW, self.ChangeCursor)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.figure_canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.statusBar = wx.StatusBar(self, -1)\n        self.SetStatusBar(self.statusBar)\n\n        self.toolbar = NavigationToolbar2Wx(self.figure_canvas)\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.toolbar.Show()\n\n    def ChangeCursor(self, event):\n        self.figure_canvas.SetCursor(wx.Cursor(wx.CURSOR_BULLSEYE))\n\n    def UpdateStatusBar(self, event):\n        if event.inaxes:\n            self.statusBar.SetStatusText(f\"x={event.xdata}  y={event.ydata}\")\n\n\nclass App(wx.App):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        frame = CanvasFrame()\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == '__main__':\n    app = App()\n    app.MainLoop()",
                "filename": "galleries/examples/user_interfaces/wxcursor_demo_sgskip.py",
                "start_index": 0,
                "end_index": 1940,
                "start_line": 1,
                "end_line": 68,
                "max_line": 68,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "name: Bug Report\ndescription: Report a bug or issue with Matplotlib.\ntitle: \"[Bug]: \"\nbody:\n  - type: textarea\n    id: summary\n    attributes:\n      label: Bug summary\n      description:  Describe the bug in 1-2 short sentences\n      placeholder:\n      value:\n    validations:\n      required: true\n  - type: textarea\n    id: reproduction\n    attributes:\n      label: Code for reproduction\n      description: |\n        If possible, please provide a minimum self-contained example.\n      placeholder: Paste your code here. This field is automatically formatted as Python code.\n      render: python\n    validations:\n      required: true\n  - type: textarea\n    id: actual\n    attributes:\n      label: Actual outcome\n      description: |\n        Paste the output produced by the code provided above, e.g.\n        console output, images/videos produced by the code, any relevant screenshots/screencasts, etc.\n    validations:\n      required: true\n  - type: textarea\n    id: expected\n    attributes:\n      label: Expected outcome\n      description: Describe (or provide a visual example of) the expected outcome from the code snippet.\n    validations:\n      required: true\n  - type: textarea\n    id: details\n    attributes:\n      label: Additional information\n      description: |\n        - What are the conditions under which this bug happens? input parameters, edge cases, etc?\n        - Has this worked in earlier versions?\n        - Do you know why this bug is happening?\n        - Do you maybe even know a fix?\n  - type: input\n    id: operating-system\n    attributes:\n      label: Operating system\n      description: Windows, OS/X, Arch, Debian, Ubuntu, etc.\n  - type: input\n    id: matplotlib-version\n    attributes:\n      label: Matplotlib Version\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.__version__)`\"\n    validations:\n      required: true\n  - type: input\n    id: matplotlib-backend\n    attributes:\n      label: Matplotlib Backend\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.get_backend())`\"\n  - type: input\n    id: python-version\n    attributes:\n      label: Python version\n      description: \"In console: `python --version`\"\n  - type: input\n    id: jupyter-version\n    attributes:\n      label: Jupyter version\n      description: \"In console: `jupyter notebook --version` or `jupyter lab --version`\"\n  - type: dropdown\n    id: install\n    attributes:\n      label: Installation\n      description: How did you install matplotlib?\n      options:\n        - pip\n        - conda\n        - Linux package manager\n        - from source (.tar.gz)\n        - git checkout",
                "filename": ".github/ISSUE_TEMPLATE/bug_report.yml",
                "start_index": 0,
                "end_index": 2631,
                "start_line": 1,
                "end_line": 86,
                "max_line": 86,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.9
            },
            {
                "code": "import numpy as np\n\nfrom .. import cbook\nfrom . import backend_agg, backend_gtk4\nfrom .backend_gtk4 import Gtk, _BackendGTK4\n\nimport cairo  # Presence of cairo is already checked by _backend_gtk.\n\n\nclass FigureCanvasGTK4Agg(backend_agg.FigureCanvasAgg,\n                          backend_gtk4.FigureCanvasGTK4):\n\n    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n\n        Gtk.render_background(\n            self.get_style_context(), ctx,\n            allocation.x, allocation.y,\n            allocation.width, allocation.height)\n\n        buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n            np.asarray(self.get_renderer().buffer_rgba()))\n        height, width, _ = buf.shape\n        image = cairo.ImageSurface.create_for_data(\n            buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n        image.set_device_scale(scale, scale)\n        ctx.set_source_surface(image, 0, 0)\n        ctx.paint()\n\n        return False\n\n\n@_BackendGTK4.export\nclass _BackendGTK4Agg(_BackendGTK4):\n    FigureCanvas = FigureCanvasGTK4Agg",
                "filename": "lib/matplotlib/backends/backend_gtk4agg.py",
                "start_index": 0,
                "end_index": 1113,
                "start_line": 1,
                "end_line": 36,
                "max_line": 36,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.3",
                "sha": "",
                "context_relevance": 0.0
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "lib/matplotlib/widgets.py": [
                {
                    "chunk": {
                        "code": "class MultiCursor(Widget):",
                        "filename": "lib/matplotlib/widgets.py",
                        "start_index": 73653,
                        "end_index": 73679,
                        "start_line": 2042,
                        "end_line": 2042,
                        "max_line": 4245,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet points to the definition of the MultiCursor class in the widgets.py file, which is directly related to the issue reported."
                }
            ]
        },
        "solution_task": "To address the issue of the multicursor disappearing when not moving and the high CPU usage with the `nbagg` backend when `useblit=False`, consider the following solution:\n\n- Modify the `MultiCursor` class to ensure it is compatible with the `nbagg` backend when `useblit` is set to `False`. This may involve checking and updating the event loop handling for the `nbagg` backend to prevent high CPU usage and ensure the multicursor remains visible.\n- Implement a mechanism to force a redraw of the multicursor when the mouse is not moving. This could be done by setting a timer that triggers a redraw at regular intervals or by redrawing the cursor in response to other events that indicate the figure is still being displayed.\n- Investigate the kernel busy indicator flashing issue to ensure that the event loop or the drawing logic does not inadvertently trigger unnecessary computations or communications with the Jupyter kernel.\n\nHere is a hypothetical code snippet that could be added or modified in the `MultiCursor` class to address the issue:\n\n```python\nclass MultiCursor(Widget):\n    def __init__(self, canvas, axes, color='r', lw=1, useblit=False):\n        # ... existing code ...\n\n        # Add a timer to force redraw the cursor when idle if using nbagg backend\n        if matplotlib.get_backend() == 'nbagg':\n            self.timer = self.canvas.new_timer(interval=100)  # interval in milliseconds\n            self.timer.add_callback(self.redraw_idle_cursor)\n            self.timer.start()\n\n    def redraw_idle_cursor(self):\n        # Redraw the cursor if it's visible and the mouse is not moving\n        if self.visible and not self.mouse_moving:\n            self.canvas.draw_idle()\n\n    def on_mouse_move(self, event):\n        # ... existing code ...\n        self.mouse_moving = True\n        # ... existing code ...\n\n    def on_mouse_stop(self, event):\n        # Event handler for when the mouse stops moving\n        self.mouse_moving = False\n\n    # ... existing code ...\n```\n\nIn this hypothetical solution:\n- A timer is added to the `MultiCursor` class that calls `redraw_idle_cursor` at a regular interval when using the `nbagg` backend.\n- The `redraw_idle_cursor` method forces a redraw of the cursor if it is visible and the mouse is not moving.\n- The `on_mouse_move` method is updated to set a flag when the mouse is moving.\n- An additional event handler `on_mouse_stop` could be implemented to detect when the mouse stops moving.\n\nPlease note that the actual implementation may vary based on the existing codebase and the specific details of the `nbagg` backend. The provided code is a conceptual example and may require adaptation to fit into the actual Matplotlib codebase.",
        "bouncer_response": {
            "score": 7,
            "criteria": "RESPONSES that are highly relevant, offering clear and comprehensive guidance or solutions for the described bug, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a detailed and relevant solution to the issue of the multicursor disappearing and the high CPU usage with the `nbagg` backend. It suggests modifying the `MultiCursor` class to be compatible with the `nbagg` backend when `useblit` is set to `False` and provides a hypothetical code snippet that could be added to the `MultiCursor` class to address the issue. The RESPONSE also addresses the kernel busy indicator flashing issue by suggesting an investigation into the event loop or drawing logic. The RESPONSE is actionable and directly addresses the main issues outlined in the PROMPT, providing a clear direction for a potential fix. However, it does not fully guarantee a resolution without further testing and integration into the actual codebase, which is why it does not score a perfect 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711699132.4188359,
        "result": "To address the issue of the multicursor disappearing when not moving and the high CPU usage with the `nbagg` backend when `useblit=False`, consider the following solution:\n\n- Modify the `MultiCursor` class to ensure it is compatible with the `nbagg` backend when `useblit` is set to `False`. This may involve checking and updating the event loop handling for the `nbagg` backend to prevent high CPU usage and ensure the multicursor remains visible.\n- Implement a mechanism to force a redraw of the multicursor when the mouse is not moving. This could be done by setting a timer that triggers a redraw at regular intervals or by redrawing the cursor in response to other events that indicate the figure is still being displayed.\n- Investigate the kernel busy indicator flashing issue to ensure that the event loop or the drawing logic does not inadvertently trigger unnecessary computations or communications with the Jupyter kernel.\n\nHere is a hypothetical code snippet that could be added or modified in the `MultiCursor` class to address the issue:\n\n```python\nclass MultiCursor(Widget):\n    def __init__(self, canvas, axes, color='r', lw=1, useblit=False):\n        # ... existing code ...\n\n        # Add a timer to force redraw the cursor when idle if using nbagg backend\n        if matplotlib.get_backend() == 'nbagg':\n            self.timer = self.canvas.new_timer(interval=100)  # interval in milliseconds\n            self.timer.add_callback(self.redraw_idle_cursor)\n            self.timer.start()\n\n    def redraw_idle_cursor(self):\n        # Redraw the cursor if it's visible and the mouse is not moving\n        if self.visible and not self.mouse_moving:\n            self.canvas.draw_idle()\n\n    def on_mouse_move(self, event):\n        # ... existing code ...\n        self.mouse_moving = True\n        # ... existing code ...\n\n    def on_mouse_stop(self, event):\n        # Event handler for when the mouse stops moving\n        self.mouse_moving = False\n\n    # ... existing code ...\n```\n\nIn this hypothetical solution:\n- A timer is added to the `MultiCursor` class that calls `redraw_idle_cursor` at a regular interval when using the `nbagg` backend.\n- The `redraw_idle_cursor` method forces a redraw of the cursor if it is visible and the mouse is not moving.\n- The `on_mouse_move` method is updated to set a flag when the mouse is moving.\n- An additional event handler `on_mouse_stop` could be implemented to detect when the mouse stops moving.\n\nPlease note that the actual implementation may vary based on the existing codebase and the specific details of the `nbagg` backend. The provided code is a conceptual example and may require adaptation to fit into the actual Matplotlib codebase.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.3/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.3/tree//lib/matplotlib)- [Lines 2042 - 2042](https://github.com/testbed/matplotlib__matplotlib__3.3/blob//lib/matplotlib/widgets.py#L2042-L2042)\n\n This snippet points to the definition of the MultiCursor class in the widgets.py file, which is directly related to the issue reported.",
        "context_relevance": 0.26,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE provides a solution to the issue described in the PROMPT, but it does not address the specific bug report template or the request for information about the Matplotlib version, backend, and Python version.\nSupporting Evidence: The RESPONSE offers a hypothetical solution to the problem of the multicursor disappearing and high CPU usage, which is relevant to the bug summary. However, it does not acknowledge or provide information about the Matplotlib version, backend, Python version, or the Jupyter version, which are all requested in the bug report template. The RESPONSE also includes a code snippet that is not directly related to the actual code in the Matplotlib repository, which does not fully address the \"Code for reproduction\" or \"Expected outcome\" sections of the PROMPT."
        },
        "qa_relevance": 0.2
    }
}