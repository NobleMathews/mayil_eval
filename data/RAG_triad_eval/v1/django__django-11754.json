{
    "id": "django__django-11754",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 2633515995715170690,
    "title": "Allow using ExceptionReporter subclass in django.views.debug.technical_500_response",
    "body": "Description\n\t \n\t\t(last modified by Carlton Gibson)\n\t \n#29714 allows using an ExceptionReporter subclass with AdminEmailHandler. \nIdeally we'd make the similar available for the 500 debug error view. \n\u200bCurrently the use of `ExceptionReporter` is hardcoded. \n* Move this to a parameter\n* Provide an example of using, e.g., functools.partial to configure a subclass when specifying handler500.\nUpdated for comment:5\nAdd ExceptionReporter to the documentation, explaining the relation between the exception reporter class and the filter it uses, and showing a simple override of get_traceback_data(). \nAdd a DEFAULT_EXCEPTION_REPORTER setting to allow specifying this. \n(At that point we could review deprecating DEFAULT_EXCEPTION_REPORTER_FILTER, as was discussed on #25167 \u2014\u00a0but maybe that's unnecessary. Thoughts?)\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature requested in the ticket, follow these steps:\n\n- Add a new setting in Django's settings module to specify the default `ExceptionReporter` class.\n  ```python\n  # In django/conf/global_settings.py\n  DEFAULT_EXCEPTION_REPORTER = 'django.views.debug.ExceptionReporter'\n  ```\n\n- Modify the `technical_500_response` function to use the `ExceptionReporter` class specified in the settings.\n  ```python\n  # In django/views/debug.py\n  def technical_500_response(request, exc_type, exc_value, tb, status_code=500):\n      exception_reporter_class = import_string(settings.DEFAULT_EXCEPTION_REPORTER)\n      reporter = exception_reporter_class(request, exc_type, exc_value, tb)\n      # ... rest of the function remains the same\n  ```\n\n- Update the `AdminEmailHandler` class to use the new setting if `reporter_class` is not provided.\n  ```python\n  # In django/utils/log.py\n  class AdminEmailHandler(logging.Handler):\n      def __init__(self, include_html=False, email_backend=None, reporter_class=None):\n          # ...\n          self.reporter_class = import_string(\n              reporter_class or settings.DEFAULT_EXCEPTION_REPORTER\n          )\n          # ...\n  ```\n\n- Add documentation for the `ExceptionReporter` class, explaining how to subclass it and override `get_traceback_data()`.\n  - This would involve updating the documentation files, typically found in the `docs/` directory of the Django project.\n\n- Provide an example of how to use `functools.partial` to configure a subclass of `ExceptionReporter` when specifying `handler500`.\n  ```python\n  # Example usage in a Django project's urls.py\n  from django.conf.urls import handler500\n  from django.views.debug import ExceptionReporter, technical_500_response\n  from functools import partial\n\n  class CustomExceptionReporter(ExceptionReporter):\n      # Custom implementation\n\n  handler500 = partial(technical_500_response, reporter_class=CustomExceptionReporter)\n  ```\n\n- Consider adding a deprecation path for `DEFAULT_EXCEPTION_REPORTER_FILTER` if it's decided to be unnecessary after the review.\n\n- Ensure that tests are written or updated to cover the new functionality and that existing tests pass.\n\n- Update the `ExceptionReporter` class documentation to reflect the new setting and usage.\n\n- Submit the changes for review according to the project's contribution guidelines.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [views](https://github.com/testbed/django__django__3.1/tree//django/views)- [Lines 1 - 86](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L1-L86)\n\n This snippet contains the 'technical_500_response' function where 'ExceptionReporter' is hardcoded. The issue requires moving this to a parameter, so this snippet is directly relevant to the issue. \n\n\n   - [Lines 311 - 629](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L311-L629)\n\n This snippet defines the 'ExceptionReporter' class, which is central to the issue. Modifications may be needed here to allow subclassing and customization as described in the issue. \n\n\n   - [Lines 424 - 489](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L424-L489)\n\n This snippet contains methods 'get_traceback_html' and 'get_traceback_text' of the 'ExceptionReporter' class, which may need to be overridden in a subclass as suggested in the issue. \n\n\n   - [Lines 491 - 528](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L491-L528)\n\n This snippet contains the 'get_traceback_frames' method of the 'ExceptionReporter' class, which is part of the traceback reporting mechanism and may be relevant if the traceback data needs to be customized in a subclass.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 79 - 168](https://github.com/testbed/django__django__3.1/blob//django/utils/log.py#L79-L168)\n\n This snippet from 'django/utils/log.py' shows how 'ExceptionReporter' is used in the 'AdminEmailHandler' class. It may provide insight into how to implement a similar mechanism for the 'technical_500_response' function.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [handlers](https://github.com/testbed/django__django__3.1/tree//django/core/handlers)- [Lines 161 - 185](https://github.com/testbed/django__django__3.1/blob//django/core/handlers/exception.py#L161-L185)\n\n This snippet from 'django/core/handlers/exception.py' shows how the 'technical_500_response' is used in the context of handling uncaught exceptions. It may need to be reviewed to ensure consistency with the changes made to 'technical_500_response'.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00033,
        "snippet_processor": 0.050890000000000005,
        "issue_star_creation": 0.023889999999999998,
        "issue_star_solver": 0.04168000000000001,
        "bouncer": 0.02727
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711732771.393179,
        "relevant_snippets": [
            {
                "code": "import functools\nimport inspect\nimport itertools\nimport re\nimport sys\nimport types\nimport warnings\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.http import Http404, HttpResponse, HttpResponseNotFound\nfrom django.template import Context, Engine, TemplateDoesNotExist\nfrom django.template.defaultfilters import pprint\nfrom django.urls import resolve\nfrom django.utils import timezone\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import force_str\nfrom django.utils.module_loading import import_string\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.version import PY311, get_docs_version\nfrom django.views.decorators.debug import coroutine_functions_to_sensitive_variables\n\n# Minimal Django templates engine to render the error templates\n# regardless of the project's TEMPLATES setting. Templates are\n# read directly from the filesystem so that the error handler\n# works even if the template loader is broken.\nDEBUG_ENGINE = Engine(\n    debug=True,\n    libraries={\"i18n\": \"django.templatetags.i18n\"},\n)\n\n\ndef builtin_template_path(name):\n    \"\"\"\n    Return a path to a builtin template.\n\n    Avoid calling this function at the module level or in a class-definition\n    because __file__ may not exist, e.g. in frozen environments.\n    \"\"\"\n    return Path(__file__).parent / \"templates\" / name\n\n\nclass ExceptionCycleWarning(UserWarning):\n    pass\n\n\nclass CallableSettingWrapper:\n    \"\"\"\n    Object to wrap callable appearing in settings.\n    * Not to call in the debug page (#21345).\n    * Not to break the debug page if the callable forbidding to set attributes\n      (#23070).\n    \"\"\"\n\n    def __init__(self, callable_setting):\n        self._wrapped = callable_setting\n\n    def __repr__(self):\n        return repr(self._wrapped)\n\n\ndef technical_500_response(request, exc_type, exc_value, tb, status_code=500):\n    \"\"\"\n    Create a technical server error response. The last three arguments are\n    the values returned from sys.exc_info() and friends.\n    \"\"\"\n    reporter = get_exception_reporter_class(request)(request, exc_type, exc_value, tb)\n    if request.accepts(\"text/html\"):\n        html = reporter.get_traceback_html()\n        return HttpResponse(html, status=status_code)\n    else:\n        text = reporter.get_traceback_text()\n        return HttpResponse(\n            text, status=status_code, content_type=\"text/plain; charset=utf-8\"\n        )\n\n\n@functools.lru_cache\ndef get_default_exception_reporter_filter():\n    # Instantiate the default filter for the first time and cache it.\n    return import_string(settings.DEFAULT_EXCEPTION_REPORTER_FILTER)()\n\n\ndef get_exception_reporter_filter(request):\n    default_filter = get_default_exception_reporter_filter()\n    return getattr(request, \"exception_reporter_filter\", default_filter)",
                "filename": "django/views/debug.py",
                "start_index": 0,
                "end_index": 2827,
                "start_line": 1,
                "end_line": 86,
                "max_line": 665,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "class ExceptionReporter:",
                "filename": "django/views/debug.py",
                "start_index": 11709,
                "end_index": 11733,
                "start_line": 310,
                "end_line": 310,
                "max_line": 665,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Organize and coordinate reporting on exceptions.\"\"\"\n\n    @property\n    def html_template_path(self):\n        return builtin_template_path(\"technical_500.html\")\n\n    @property\n    def text_template_path(self):\n        return builtin_template_path(\"technical_500.txt\")\n\n    def __init__(self, request, exc_type, exc_value, tb, is_email=False):\n        self.request = request\n        self.filter = get_exception_reporter_filter(self.request)\n        self.exc_type = exc_type\n        self.exc_value = exc_value\n        self.tb = tb\n        self.is_email = is_email\n\n        self.template_info = getattr(self.exc_value, \"template_debug\", None)\n        self.template_does_not_exist = False\n        self.postmortem = None\n\n    def _get_raw_insecure_uri(self):\n        \"\"\"\n        Return an absolute URI from variables available in this request. Skip\n        allowed hosts protection, so may return insecure URI.\n        \"\"\"\n        return \"{scheme}://{host}{path}\".format(\n            scheme=self.request.scheme,\n            host=self.request._get_raw_host(),\n            path=self.request.get_full_path(),\n        )",
                "filename": "django/views/debug.py",
                "start_index": 11738,
                "end_index": 12850,
                "start_line": 311,
                "end_line": 629,
                "max_line": 665,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "class AdminEmailHandler(logging.Handler):\n    \"\"\"An exception log handler that emails log entries to site admins.\n\n    If the request is passed as the first argument to the log record,\n    request data will be provided in the email report.\n    \"\"\"\n\n    def __init__(self, include_html=False, email_backend=None, reporter_class=None):\n        super().__init__()\n        self.include_html = include_html\n        self.email_backend = email_backend\n        self.reporter_class = import_string(\n            reporter_class or settings.DEFAULT_EXCEPTION_REPORTER\n        )\n\n    def emit(self, record):\n        try:\n            request = record.request\n            subject = \"%s (%s IP): %s\" % (\n                record.levelname,\n                (\n                    \"internal\"\n                    if request.META.get(\"REMOTE_ADDR\") in settings.INTERNAL_IPS\n                    else \"EXTERNAL\"\n                ),\n                record.getMessage(),\n            )\n        except Exception:\n            subject = \"%s: %s\" % (record.levelname, record.getMessage())\n            request = None\n        subject = self.format_subject(subject)\n\n        # Since we add a nicely formatted traceback on our own, create a copy\n        # of the log record without the exception data.\n        no_exc_record = copy(record)\n        no_exc_record.exc_info = None\n        no_exc_record.exc_text = None\n\n        if record.exc_info:\n            exc_info = record.exc_info\n        else:\n            exc_info = (None, record.getMessage(), None)\n\n        reporter = self.reporter_class(request, is_email=True, *exc_info)\n        message = \"%s\\n\\n%s\" % (\n            self.format(no_exc_record),\n            reporter.get_traceback_text(),\n        )\n        html_message = reporter.get_traceback_html() if self.include_html else None\n        self.send_mail(subject, message, fail_silently=True, html_message=html_message)\n\n    def send_mail(self, subject, message, *args, **kwargs):\n        mail.mail_admins(\n            subject, message, *args, connection=self.connection(), **kwargs\n        )\n\n    def connection(self):\n        return get_connection(backend=self.email_backend, fail_silently=True)\n\n    def format_subject(self, subject):\n        \"\"\"\n        Escape CR and LF characters.\n        \"\"\"\n        return subject.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")\n\n\nclass CallbackFilter(logging.Filter):\n    \"\"\"\n    A logging filter that checks the return value of a given callable (which\n    takes the record-to-be-logged as its only parameter) to decide whether to\n    log a record.\n    \"\"\"\n\n    def __init__(self, callback):\n        self.callback = callback\n\n    def filter(self, record):\n        if self.callback(record):\n            return 1\n        return 0\n\n\nclass RequireDebugFalse(logging.Filter):\n    def filter(self, record):\n        return not settings.DEBUG\n\n\nclass RequireDebugTrue(logging.Filter):\n    def filter(self, record):\n        return settings.DEBUG",
                "filename": "django/utils/log.py",
                "start_index": 2414,
                "end_index": 5356,
                "start_line": 79,
                "end_line": 168,
                "max_line": 250,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "class SafeExceptionReporterFilter:",
                "filename": "django/views/debug.py",
                "start_index": 3361,
                "end_index": 3395,
                "start_line": 108,
                "end_line": 108,
                "max_line": 665,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def get_traceback_html(self):\n        \"\"\"Return HTML version of debug 500 HTTP error page.\"\"\"\n        with self.html_template_path.open(encoding=\"utf-8\") as fh:\n            t = DEBUG_ENGINE.from_string(fh.read())\n        c = Context(self.get_traceback_data(), use_l10n=False)\n        return t.render(c)\n\n    def get_traceback_text(self):\n        \"\"\"Return plain text version of debug 500 HTTP error page.\"\"\"\n        with self.text_template_path.open(encoding=\"utf-8\") as fh:\n            t = DEBUG_ENGINE.from_string(fh.read())\n        c = Context(self.get_traceback_data(), autoescape=False, use_l10n=False)\n        return t.render(c)\n\n    def _get_source(self, filename, loader, module_name):\n        source = None\n        if hasattr(loader, \"get_source\"):\n            try:\n                source = loader.get_source(module_name)\n            except ImportError:\n                pass\n            if source is not None:\n                source = source.splitlines()\n        if source is None:\n            try:\n                with open(filename, \"rb\") as fp:\n                    source = fp.read().splitlines()\n            except OSError:\n                pass\n        return source\n\n    def _get_lines_from_file(\n        self, filename, lineno, context_lines, loader=None, module_name=None\n    ):\n        \"\"\"\n        Return context_lines before and after lineno from file.\n        Return (pre_context_lineno, pre_context, context_line, post_context).\n        \"\"\"\n        source = self._get_source(filename, loader, module_name)\n        if source is None:\n            return None, [], None, []\n\n        # If we just read the source from a file, or if the loader did not\n        # apply tokenize.detect_encoding to decode the source into a\n        # string, then we should do that ourselves.\n        if isinstance(source[0], bytes):\n            encoding = \"ascii\"\n            for line in source[:2]:\n                # File coding may be specified. Match pattern from PEP-263\n                # (https://www.python.org/dev/peps/pep-0263/)\n                match = re.search(rb\"coding[:=]\\s*([-\\w.]+)\", line)\n                if match:\n                    encoding = match[1].decode(\"ascii\")\n                    break\n            source = [str(sline, encoding, \"replace\") for sline in source]\n\n        lower_bound = max(0, lineno - context_lines)\n        upper_bound = lineno + context_lines\n\n        try:\n            pre_context = source[lower_bound:lineno]\n            context_line = source[lineno]\n            post_context = source[lineno + 1 : upper_bound]\n        except IndexError:\n            return None, [], None, []\n        return lower_bound, pre_context, context_line, post_context",
                "filename": "django/views/debug.py",
                "start_index": 16289,
                "end_index": 18973,
                "start_line": 424,
                "end_line": 489,
                "max_line": 665,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def get_exception_response(request, resolver, status_code, exception):\n    try:\n        callback = resolver.resolve_error_handler(status_code)\n        response = callback(request, exception=exception)\n    except Exception:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(request, resolver, sys.exc_info())\n\n    return response\n\n\ndef handle_uncaught_exception(request, resolver, exc_info):\n    \"\"\"\n    Processing for any otherwise uncaught exceptions (those that will\n    generate HTTP 500 responses).\n    \"\"\"\n    if settings.DEBUG_PROPAGATE_EXCEPTIONS:\n        raise\n\n    if settings.DEBUG:\n        return debug.technical_500_response(request, *exc_info)\n\n    # Return an HttpResponse that displays a friendly error message.\n    callback = resolver.resolve_error_handler(500)\n    return callback(request)",
                "filename": "django/core/handlers/exception.py",
                "start_index": 5047,
                "end_index": 5921,
                "start_line": 161,
                "end_line": 185,
                "max_line": 185,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _get_explicit_or_implicit_cause(self, exc_value):\n        explicit = getattr(exc_value, \"__cause__\", None)\n        suppress_context = getattr(exc_value, \"__suppress_context__\", None)\n        implicit = getattr(exc_value, \"__context__\", None)\n        return explicit or (None if suppress_context else implicit)\n\n    def get_traceback_frames(self):\n        # Get the exception and all its causes\n        exceptions = []\n        exc_value = self.exc_value\n        while exc_value:\n            exceptions.append(exc_value)\n            exc_value = self._get_explicit_or_implicit_cause(exc_value)\n            if exc_value in exceptions:\n                warnings.warn(\n                    \"Cycle in the exception chain detected: exception '%s' \"\n                    \"encountered again.\" % exc_value,\n                    ExceptionCycleWarning,\n                )\n                # Avoid infinite loop if there's a cyclic reference (#29393).\n                break\n\n        frames = []\n        # No exceptions were supplied to ExceptionReporter\n        if not exceptions:\n            return frames\n\n        # In case there's just one exception, take the traceback from self.tb\n        exc_value = exceptions.pop()\n        tb = self.tb if not exceptions else exc_value.__traceback__\n        while True:\n            frames.extend(self.get_exception_traceback_frames(exc_value, tb))\n            try:\n                exc_value = exceptions.pop()\n            except IndexError:\n                break\n            tb = exc_value.__traceback__\n        return frames",
                "filename": "django/views/debug.py",
                "start_index": 18979,
                "end_index": 20529,
                "start_line": 491,
                "end_line": 528,
                "max_line": 665,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if isinstance(exc, Http404):\n        if settings.DEBUG:\n            response = debug.technical_404_response(request, exc)\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 404, exc\n            )\n\n    elif isinstance(exc, PermissionDenied):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 403, exc\n        )\n        log_response(\n            \"Forbidden (Permission denied): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    elif isinstance(exc, MultiPartParserError):\n        response = get_exception_response(\n            request, get_resolver(get_urlconf()), 400, exc\n        )\n        log_response(\n            \"Bad request (Unable to parse request body): %s\",\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    elif isinstance(exc, BadRequest):\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n        log_response(\n            \"%s: %s\",\n            str(exc),\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n    elif isinstance(exc, SuspiciousOperation):\n        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent, TooManyFilesSent)):\n            # POST data can't be accessed again, otherwise the original\n            # exception would be raised.\n            request._mark_post_parse_error()\n\n        # The request logger receives events for any problematic request\n        # The security logger receives events for all SuspiciousOperations\n        security_logger = logging.getLogger(\n            \"django.security.%s\" % exc.__class__.__name__\n        )\n        security_logger.error(\n            str(exc),\n            exc_info=exc,\n            extra={\"status_code\": 400, \"request\": request},\n        )\n        if settings.DEBUG:\n            response = debug.technical_500_response(\n                request, *sys.exc_info(), status_code=400\n            )\n        else:\n            response = get_exception_response(\n                request, get_resolver(get_urlconf()), 400, exc\n            )\n\n    else:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(\n            request, get_resolver(get_urlconf()), sys.exc_info()\n        )\n        log_response(\n            \"%s: %s\",\n            response.reason_phrase,\n            request.path,\n            response=response,\n            request=request,\n            exception=exc,\n        )\n\n    # Force a TemplateResponse to be rendered.",
                "filename": "django/core/handlers/exception.py",
                "start_index": 1929,
                "end_index": 4873,
                "start_line": 64,
                "end_line": 152,
                "max_line": 185,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "from django.urls import include\nfrom django.views import defaults\n\n__all__ = [\"handler400\", \"handler403\", \"handler404\", \"handler500\", \"include\"]\n\nhandler400 = defaults.bad_request\nhandler403 = defaults.permission_denied\nhandler404 = defaults.page_not_found\nhandler500 = defaults.server_error",
                "filename": "django/conf/urls/__init__.py",
                "start_index": 0,
                "end_index": 291,
                "start_line": 1,
                "end_line": 9,
                "max_line": 9,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/views/debug.py": [
                {
                    "chunk": {
                        "code": "import functools\nimport inspect\nimport itertools\nimport re\nimport sys\nimport types\nimport warnings\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.http import Http404, HttpResponse, HttpResponseNotFound\nfrom django.template import Context, Engine, TemplateDoesNotExist\nfrom django.template.defaultfilters import pprint\nfrom django.urls import resolve\nfrom django.utils import timezone\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import force_str\nfrom django.utils.module_loading import import_string\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.version import PY311, get_docs_version\nfrom django.views.decorators.debug import coroutine_functions_to_sensitive_variables\n\n# Minimal Django templates engine to render the error templates\n# regardless of the project's TEMPLATES setting. Templates are\n# read directly from the filesystem so that the error handler\n# works even if the template loader is broken.\nDEBUG_ENGINE = Engine(\n    debug=True,\n    libraries={\"i18n\": \"django.templatetags.i18n\"},\n)\n\n\ndef builtin_template_path(name):\n    \"\"\"\n    Return a path to a builtin template.\n\n    Avoid calling this function at the module level or in a class-definition\n    because __file__ may not exist, e.g. in frozen environments.\n    \"\"\"\n    return Path(__file__).parent / \"templates\" / name\n\n\nclass ExceptionCycleWarning(UserWarning):\n    pass\n\n\nclass CallableSettingWrapper:\n    \"\"\"\n    Object to wrap callable appearing in settings.\n    * Not to call in the debug page (#21345).\n    * Not to break the debug page if the callable forbidding to set attributes\n      (#23070).\n    \"\"\"\n\n    def __init__(self, callable_setting):\n        self._wrapped = callable_setting\n\n    def __repr__(self):\n        return repr(self._wrapped)\n\n\ndef technical_500_response(request, exc_type, exc_value, tb, status_code=500):\n    \"\"\"\n    Create a technical server error response. The last three arguments are\n    the values returned from sys.exc_info() and friends.\n    \"\"\"\n    reporter = get_exception_reporter_class(request)(request, exc_type, exc_value, tb)\n    if request.accepts(\"text/html\"):\n        html = reporter.get_traceback_html()\n        return HttpResponse(html, status=status_code)\n    else:\n        text = reporter.get_traceback_text()\n        return HttpResponse(\n            text, status=status_code, content_type=\"text/plain; charset=utf-8\"\n        )\n\n\n@functools.lru_cache\ndef get_default_exception_reporter_filter():\n    # Instantiate the default filter for the first time and cache it.\n    return import_string(settings.DEFAULT_EXCEPTION_REPORTER_FILTER)()\n\n\ndef get_exception_reporter_filter(request):\n    default_filter = get_default_exception_reporter_filter()\n    return getattr(request, \"exception_reporter_filter\", default_filter)",
                        "filename": "django/views/debug.py",
                        "start_index": 0,
                        "end_index": 2827,
                        "start_line": 1,
                        "end_line": 86,
                        "max_line": 665,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'technical_500_response' function where 'ExceptionReporter' is hardcoded. The issue requires moving this to a parameter, so this snippet is directly relevant to the issue."
                },
                {
                    "chunk": {
                        "code": "\"\"\"Organize and coordinate reporting on exceptions.\"\"\"\n\n    @property\n    def html_template_path(self):\n        return builtin_template_path(\"technical_500.html\")\n\n    @property\n    def text_template_path(self):\n        return builtin_template_path(\"technical_500.txt\")\n\n    def __init__(self, request, exc_type, exc_value, tb, is_email=False):\n        self.request = request\n        self.filter = get_exception_reporter_filter(self.request)\n        self.exc_type = exc_type\n        self.exc_value = exc_value\n        self.tb = tb\n        self.is_email = is_email\n\n        self.template_info = getattr(self.exc_value, \"template_debug\", None)\n        self.template_does_not_exist = False\n        self.postmortem = None\n\n    def _get_raw_insecure_uri(self):\n        \"\"\"\n        Return an absolute URI from variables available in this request. Skip\n        allowed hosts protection, so may return insecure URI.\n        \"\"\"\n        return \"{scheme}://{host}{path}\".format(\n            scheme=self.request.scheme,\n            host=self.request._get_raw_host(),\n            path=self.request.get_full_path(),\n        )",
                        "filename": "django/views/debug.py",
                        "start_index": 11738,
                        "end_index": 12850,
                        "start_line": 311,
                        "end_line": 629,
                        "max_line": 665,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the 'ExceptionReporter' class, which is central to the issue. Modifications may be needed here to allow subclassing and customization as described in the issue."
                },
                {
                    "chunk": {
                        "code": "def get_traceback_html(self):\n        \"\"\"Return HTML version of debug 500 HTTP error page.\"\"\"\n        with self.html_template_path.open(encoding=\"utf-8\") as fh:\n            t = DEBUG_ENGINE.from_string(fh.read())\n        c = Context(self.get_traceback_data(), use_l10n=False)\n        return t.render(c)\n\n    def get_traceback_text(self):\n        \"\"\"Return plain text version of debug 500 HTTP error page.\"\"\"\n        with self.text_template_path.open(encoding=\"utf-8\") as fh:\n            t = DEBUG_ENGINE.from_string(fh.read())\n        c = Context(self.get_traceback_data(), autoescape=False, use_l10n=False)\n        return t.render(c)\n\n    def _get_source(self, filename, loader, module_name):\n        source = None\n        if hasattr(loader, \"get_source\"):\n            try:\n                source = loader.get_source(module_name)\n            except ImportError:\n                pass\n            if source is not None:\n                source = source.splitlines()\n        if source is None:\n            try:\n                with open(filename, \"rb\") as fp:\n                    source = fp.read().splitlines()\n            except OSError:\n                pass\n        return source\n\n    def _get_lines_from_file(\n        self, filename, lineno, context_lines, loader=None, module_name=None\n    ):\n        \"\"\"\n        Return context_lines before and after lineno from file.\n        Return (pre_context_lineno, pre_context, context_line, post_context).\n        \"\"\"\n        source = self._get_source(filename, loader, module_name)\n        if source is None:\n            return None, [], None, []\n\n        # If we just read the source from a file, or if the loader did not\n        # apply tokenize.detect_encoding to decode the source into a\n        # string, then we should do that ourselves.\n        if isinstance(source[0], bytes):\n            encoding = \"ascii\"\n            for line in source[:2]:\n                # File coding may be specified. Match pattern from PEP-263\n                # (https://www.python.org/dev/peps/pep-0263/)\n                match = re.search(rb\"coding[:=]\\s*([-\\w.]+)\", line)\n                if match:\n                    encoding = match[1].decode(\"ascii\")\n                    break\n            source = [str(sline, encoding, \"replace\") for sline in source]\n\n        lower_bound = max(0, lineno - context_lines)\n        upper_bound = lineno + context_lines\n\n        try:\n            pre_context = source[lower_bound:lineno]\n            context_line = source[lineno]\n            post_context = source[lineno + 1 : upper_bound]\n        except IndexError:\n            return None, [], None, []\n        return lower_bound, pre_context, context_line, post_context",
                        "filename": "django/views/debug.py",
                        "start_index": 16289,
                        "end_index": 18973,
                        "start_line": 424,
                        "end_line": 489,
                        "max_line": 665,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains methods 'get_traceback_html' and 'get_traceback_text' of the 'ExceptionReporter' class, which may need to be overridden in a subclass as suggested in the issue."
                },
                {
                    "chunk": {
                        "code": "def _get_explicit_or_implicit_cause(self, exc_value):\n        explicit = getattr(exc_value, \"__cause__\", None)\n        suppress_context = getattr(exc_value, \"__suppress_context__\", None)\n        implicit = getattr(exc_value, \"__context__\", None)\n        return explicit or (None if suppress_context else implicit)\n\n    def get_traceback_frames(self):\n        # Get the exception and all its causes\n        exceptions = []\n        exc_value = self.exc_value\n        while exc_value:\n            exceptions.append(exc_value)\n            exc_value = self._get_explicit_or_implicit_cause(exc_value)\n            if exc_value in exceptions:\n                warnings.warn(\n                    \"Cycle in the exception chain detected: exception '%s' \"\n                    \"encountered again.\" % exc_value,\n                    ExceptionCycleWarning,\n                )\n                # Avoid infinite loop if there's a cyclic reference (#29393).\n                break\n\n        frames = []\n        # No exceptions were supplied to ExceptionReporter\n        if not exceptions:\n            return frames\n\n        # In case there's just one exception, take the traceback from self.tb\n        exc_value = exceptions.pop()\n        tb = self.tb if not exceptions else exc_value.__traceback__\n        while True:\n            frames.extend(self.get_exception_traceback_frames(exc_value, tb))\n            try:\n                exc_value = exceptions.pop()\n            except IndexError:\n                break\n            tb = exc_value.__traceback__\n        return frames",
                        "filename": "django/views/debug.py",
                        "start_index": 18979,
                        "end_index": 20529,
                        "start_line": 491,
                        "end_line": 528,
                        "max_line": 665,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'get_traceback_frames' method of the 'ExceptionReporter' class, which is part of the traceback reporting mechanism and may be relevant if the traceback data needs to be customized in a subclass."
                }
            ],
            "django/utils/log.py": [
                {
                    "chunk": {
                        "code": "class AdminEmailHandler(logging.Handler):\n    \"\"\"An exception log handler that emails log entries to site admins.\n\n    If the request is passed as the first argument to the log record,\n    request data will be provided in the email report.\n    \"\"\"\n\n    def __init__(self, include_html=False, email_backend=None, reporter_class=None):\n        super().__init__()\n        self.include_html = include_html\n        self.email_backend = email_backend\n        self.reporter_class = import_string(\n            reporter_class or settings.DEFAULT_EXCEPTION_REPORTER\n        )\n\n    def emit(self, record):\n        try:\n            request = record.request\n            subject = \"%s (%s IP): %s\" % (\n                record.levelname,\n                (\n                    \"internal\"\n                    if request.META.get(\"REMOTE_ADDR\") in settings.INTERNAL_IPS\n                    else \"EXTERNAL\"\n                ),\n                record.getMessage(),\n            )\n        except Exception:\n            subject = \"%s: %s\" % (record.levelname, record.getMessage())\n            request = None\n        subject = self.format_subject(subject)\n\n        # Since we add a nicely formatted traceback on our own, create a copy\n        # of the log record without the exception data.\n        no_exc_record = copy(record)\n        no_exc_record.exc_info = None\n        no_exc_record.exc_text = None\n\n        if record.exc_info:\n            exc_info = record.exc_info\n        else:\n            exc_info = (None, record.getMessage(), None)\n\n        reporter = self.reporter_class(request, is_email=True, *exc_info)\n        message = \"%s\\n\\n%s\" % (\n            self.format(no_exc_record),\n            reporter.get_traceback_text(),\n        )\n        html_message = reporter.get_traceback_html() if self.include_html else None\n        self.send_mail(subject, message, fail_silently=True, html_message=html_message)\n\n    def send_mail(self, subject, message, *args, **kwargs):\n        mail.mail_admins(\n            subject, message, *args, connection=self.connection(), **kwargs\n        )\n\n    def connection(self):\n        return get_connection(backend=self.email_backend, fail_silently=True)\n\n    def format_subject(self, subject):\n        \"\"\"\n        Escape CR and LF characters.\n        \"\"\"\n        return subject.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")\n\n\nclass CallbackFilter(logging.Filter):\n    \"\"\"\n    A logging filter that checks the return value of a given callable (which\n    takes the record-to-be-logged as its only parameter) to decide whether to\n    log a record.\n    \"\"\"\n\n    def __init__(self, callback):\n        self.callback = callback\n\n    def filter(self, record):\n        if self.callback(record):\n            return 1\n        return 0\n\n\nclass RequireDebugFalse(logging.Filter):\n    def filter(self, record):\n        return not settings.DEBUG\n\n\nclass RequireDebugTrue(logging.Filter):\n    def filter(self, record):\n        return settings.DEBUG",
                        "filename": "django/utils/log.py",
                        "start_index": 2414,
                        "end_index": 5356,
                        "start_line": 79,
                        "end_line": 168,
                        "max_line": 250,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from 'django/utils/log.py' shows how 'ExceptionReporter' is used in the 'AdminEmailHandler' class. It may provide insight into how to implement a similar mechanism for the 'technical_500_response' function."
                }
            ],
            "django/core/handlers/exception.py": [
                {
                    "chunk": {
                        "code": "def get_exception_response(request, resolver, status_code, exception):\n    try:\n        callback = resolver.resolve_error_handler(status_code)\n        response = callback(request, exception=exception)\n    except Exception:\n        signals.got_request_exception.send(sender=None, request=request)\n        response = handle_uncaught_exception(request, resolver, sys.exc_info())\n\n    return response\n\n\ndef handle_uncaught_exception(request, resolver, exc_info):\n    \"\"\"\n    Processing for any otherwise uncaught exceptions (those that will\n    generate HTTP 500 responses).\n    \"\"\"\n    if settings.DEBUG_PROPAGATE_EXCEPTIONS:\n        raise\n\n    if settings.DEBUG:\n        return debug.technical_500_response(request, *exc_info)\n\n    # Return an HttpResponse that displays a friendly error message.\n    callback = resolver.resolve_error_handler(500)\n    return callback(request)",
                        "filename": "django/core/handlers/exception.py",
                        "start_index": 5047,
                        "end_index": 5921,
                        "start_line": 161,
                        "end_line": 185,
                        "max_line": 185,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from 'django/core/handlers/exception.py' shows how the 'technical_500_response' is used in the context of handling uncaught exceptions. It may need to be reviewed to ensure consistency with the changes made to 'technical_500_response'."
                }
            ]
        },
        "solution_task": "To implement the feature requested in the ticket, follow these steps:\n\n- Add a new setting in Django's settings module to specify the default `ExceptionReporter` class.\n  ```python\n  # In django/conf/global_settings.py\n  DEFAULT_EXCEPTION_REPORTER = 'django.views.debug.ExceptionReporter'\n  ```\n\n- Modify the `technical_500_response` function to use the `ExceptionReporter` class specified in the settings.\n  ```python\n  # In django/views/debug.py\n  def technical_500_response(request, exc_type, exc_value, tb, status_code=500):\n      exception_reporter_class = import_string(settings.DEFAULT_EXCEPTION_REPORTER)\n      reporter = exception_reporter_class(request, exc_type, exc_value, tb)\n      # ... rest of the function remains the same\n  ```\n\n- Update the `AdminEmailHandler` class to use the new setting if `reporter_class` is not provided.\n  ```python\n  # In django/utils/log.py\n  class AdminEmailHandler(logging.Handler):\n      def __init__(self, include_html=False, email_backend=None, reporter_class=None):\n          # ...\n          self.reporter_class = import_string(\n              reporter_class or settings.DEFAULT_EXCEPTION_REPORTER\n          )\n          # ...\n  ```\n\n- Add documentation for the `ExceptionReporter` class, explaining how to subclass it and override `get_traceback_data()`.\n  - This would involve updating the documentation files, typically found in the `docs/` directory of the Django project.\n\n- Provide an example of how to use `functools.partial` to configure a subclass of `ExceptionReporter` when specifying `handler500`.\n  ```python\n  # Example usage in a Django project's urls.py\n  from django.conf.urls import handler500\n  from django.views.debug import ExceptionReporter, technical_500_response\n  from functools import partial\n\n  class CustomExceptionReporter(ExceptionReporter):\n      # Custom implementation\n\n  handler500 = partial(technical_500_response, reporter_class=CustomExceptionReporter)\n  ```\n\n- Consider adding a deprecation path for `DEFAULT_EXCEPTION_REPORTER_FILTER` if it's decided to be unnecessary after the review.\n\n- Ensure that tests are written or updated to cover the new functionality and that existing tests pass.\n\n- Update the `ExceptionReporter` class documentation to reflect the new setting and usage.\n\n- Submit the changes for review according to the project's contribution guidelines.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant suggestions that can directly lead to the successful implementation or improvement of the requested feature.",
            "supporting_evidence": "The RESPONSE provides a comprehensive and detailed plan to implement the feature request, including code snippets and explanations for each step. It addresses the need to make the use of `ExceptionReporter` customizable in the `technical_500_response` function by introducing a new setting and modifying the function to use this setting. It also suggests updating the `AdminEmailHandler` to use the new setting, adding documentation, and providing an example using `functools.partial`. The RESPONSE also considers the potential deprecation of `DEFAULT_EXCEPTION_REPORTER_FILTER` and emphasizes the importance of testing and documentation updates. The RESPONSE is well-structured and directly addresses the prompt's requirements, making it highly valuable for the feature's development.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711732996.38045,
        "result": "To implement the feature requested in the ticket, follow these steps:\n\n- Add a new setting in Django's settings module to specify the default `ExceptionReporter` class.\n  ```python\n  # In django/conf/global_settings.py\n  DEFAULT_EXCEPTION_REPORTER = 'django.views.debug.ExceptionReporter'\n  ```\n\n- Modify the `technical_500_response` function to use the `ExceptionReporter` class specified in the settings.\n  ```python\n  # In django/views/debug.py\n  def technical_500_response(request, exc_type, exc_value, tb, status_code=500):\n      exception_reporter_class = import_string(settings.DEFAULT_EXCEPTION_REPORTER)\n      reporter = exception_reporter_class(request, exc_type, exc_value, tb)\n      # ... rest of the function remains the same\n  ```\n\n- Update the `AdminEmailHandler` class to use the new setting if `reporter_class` is not provided.\n  ```python\n  # In django/utils/log.py\n  class AdminEmailHandler(logging.Handler):\n      def __init__(self, include_html=False, email_backend=None, reporter_class=None):\n          # ...\n          self.reporter_class = import_string(\n              reporter_class or settings.DEFAULT_EXCEPTION_REPORTER\n          )\n          # ...\n  ```\n\n- Add documentation for the `ExceptionReporter` class, explaining how to subclass it and override `get_traceback_data()`.\n  - This would involve updating the documentation files, typically found in the `docs/` directory of the Django project.\n\n- Provide an example of how to use `functools.partial` to configure a subclass of `ExceptionReporter` when specifying `handler500`.\n  ```python\n  # Example usage in a Django project's urls.py\n  from django.conf.urls import handler500\n  from django.views.debug import ExceptionReporter, technical_500_response\n  from functools import partial\n\n  class CustomExceptionReporter(ExceptionReporter):\n      # Custom implementation\n\n  handler500 = partial(technical_500_response, reporter_class=CustomExceptionReporter)\n  ```\n\n- Consider adding a deprecation path for `DEFAULT_EXCEPTION_REPORTER_FILTER` if it's decided to be unnecessary after the review.\n\n- Ensure that tests are written or updated to cover the new functionality and that existing tests pass.\n\n- Update the `ExceptionReporter` class documentation to reflect the new setting and usage.\n\n- Submit the changes for review according to the project's contribution guidelines.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [views](https://github.com/testbed/django__django__3.1/tree//django/views)- [Lines 1 - 86](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L1-L86)\n\n This snippet contains the 'technical_500_response' function where 'ExceptionReporter' is hardcoded. The issue requires moving this to a parameter, so this snippet is directly relevant to the issue. \n\n\n   - [Lines 311 - 629](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L311-L629)\n\n This snippet defines the 'ExceptionReporter' class, which is central to the issue. Modifications may be needed here to allow subclassing and customization as described in the issue. \n\n\n   - [Lines 424 - 489](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L424-L489)\n\n This snippet contains methods 'get_traceback_html' and 'get_traceback_text' of the 'ExceptionReporter' class, which may need to be overridden in a subclass as suggested in the issue. \n\n\n   - [Lines 491 - 528](https://github.com/testbed/django__django__3.1/blob//django/views/debug.py#L491-L528)\n\n This snippet contains the 'get_traceback_frames' method of the 'ExceptionReporter' class, which is part of the traceback reporting mechanism and may be relevant if the traceback data needs to be customized in a subclass.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 79 - 168](https://github.com/testbed/django__django__3.1/blob//django/utils/log.py#L79-L168)\n\n This snippet from 'django/utils/log.py' shows how 'ExceptionReporter' is used in the 'AdminEmailHandler' class. It may provide insight into how to implement a similar mechanism for the 'technical_500_response' function.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [handlers](https://github.com/testbed/django__django__3.1/tree//django/core/handlers)- [Lines 161 - 185](https://github.com/testbed/django__django__3.1/blob//django/core/handlers/exception.py#L161-L185)\n\n This snippet from 'django/core/handlers/exception.py' shows how the 'technical_500_response' is used in the context of handling uncaught exceptions. It may need to be reviewed to ensure consistency with the changes made to 'technical_500_response'.",
        "context_relevance": 0.45,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT to get a score of 9 or 10. The RESPONSE that is RELEVANT and answers the entire PROMPT completely should get a score of 10.\nSupporting Evidence: The RESPONSE provides a detailed step-by-step guide on how to implement the feature requested in the Django ticket, addressing each point mentioned in the PROMPT. It includes code snippets, documentation updates, and considerations for deprecation paths, which are all relevant to the PROMPT's request for allowing the use of an `ExceptionReporter` subclass in `django.views.debug.technical_500_response`. The RESPONSE also includes relevant links to code snippets that would be affected by the changes, directly addressing the \"Code snippets to check\" section of the PROMPT."
        },
        "qa_relevance": 1.0
    }
}