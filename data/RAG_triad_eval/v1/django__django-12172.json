{
    "id": "django__django-12172",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 116009462463163901,
    "title": "Add ability to override \"async unsafe\" checks.",
    "body": "Description\n\t\nIt's been reported that Jupyter, at least, executes apparently-synchronous code in an async environment (\u200bhttps://forum.djangoproject.com/t/is-there-a-way-to-disable-the-synchronousonlyoperation-check-when-using-the-orm-in-a-jupyter-notebook/548/3) and we're going to have people running headlong into this soon.\nThe \"right\" way of wrapping code in sync_to_async works, but is an undue burden on notebook authors as it would have to be in every cell, so it's suggested that we add a flag that disables the async-unsafe check. Either a setting or an environment variable could work; I slightly prefer an environment variable (as it's hard to forget about) provided this works well with Jupyter.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature of allowing users to override \"async unsafe\" checks, you can follow these steps:\n\n- Modify the `async_unsafe` decorator in `django/utils/asyncio.py` to check for an environment variable that allows bypassing the async-unsafe check.\n- Add documentation and warnings to inform users about the implications of disabling async safety checks.\n\nHere's a step-by-step guide:\n\n1. Modify the `async_unsafe` decorator to check for an environment variable, such as `DJANGO_ALLOW_ASYNC_UNSAFE`. If this variable is set, the decorator should not raise `SynchronousOnlyOperation`.\n\n```python\ndef async_unsafe(message):\n    def decorator(func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            try:\n                get_running_loop()\n            except RuntimeError:\n                pass\n            else:\n                if not os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n                    raise SynchronousOnlyOperation(message)\n            return func(*args, **kwargs)\n        return inner\n    if callable(message):\n        func = message\n        message = \"You cannot call this from an async context - use a thread or sync_to_async.\"\n        return decorator(func)\n    else:\n        return decorator\n```\n\n2. In `django/core/checks/async_checks.py`, you may want to add a system check that warns users if they have the `DJANGO_ALLOW_ASYNC_UNSAFE` environment variable set in a production environment.\n\n```python\n@register(Tags.async_support, deploy=True)\ndef check_async_unsafe(app_configs, **kwargs):\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        return [E001]\n    return []\n```\n\n3. Update the documentation to explain the new environment variable and its intended use case. Emphasize that it should not be used in production environments as it disables important safety checks.\n\n4. Optionally, you can add logging or warnings when the environment variable is used, to alert developers that they are bypassing safety checks.\n\n```python\nelse:\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        warnings.warn(\n            \"The DJANGO_ALLOW_ASYNC_UNSAFE environment variable is set. \"\n            \"Async safety checks are bypassed, which can lead to data corruption \"\n            \"and other issues. This should not be used in production.\",\n            RuntimeWarning\n        )\n```\n\n5. Ensure that tests are added to cover the new functionality and that existing tests still pass with the changes.\n\nRemember to follow the project's contribution guidelines for naming conventions, coding style, and testing requirements.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 1 - 39](https://github.com/testbed/django__django__3.1/blob//django/utils/asyncio.py#L1-L39)\n\n This snippet contains the async_unsafe decorator which raises SynchronousOnlyOperation if the DJANGO_ALLOW_ASYNC_UNSAFE environment variable is not set. Modifying this check or the environment variable handling is directly related to the issue.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [checks](https://github.com/testbed/django__django__3.1/tree//django/core/checks)- [Lines 1 - 16](https://github.com/testbed/django__django__3.1/blob//django/core/checks/async_checks.py#L1-L16)\n\n This snippet contains a check for the DJANGO_ALLOW_ASYNC_UNSAFE environment variable and raises an error if it is set in deployment. This is relevant because the issue discusses adding a flag or environment variable to control async-unsafe checks.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00020449999999999998,
        "snippet_processor": 0.04630000000000001,
        "issue_star_creation": 0.022739999999999996,
        "issue_star_solver": 0.07763,
        "bouncer": 0.04344
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711731919.270101,
        "relevant_snippets": [
            {
                "code": "import os\nfrom asyncio import get_running_loop\nfrom functools import wraps\n\nfrom django.core.exceptions import SynchronousOnlyOperation\n\n\ndef async_unsafe(message):\n    \"\"\"\n    Decorator to mark functions as async-unsafe. Someone trying to access\n    the function while in an async context will get an error message.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            # Detect a running event loop in this thread.\n            try:\n                get_running_loop()\n            except RuntimeError:\n                pass\n            else:\n                if not os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n                    raise SynchronousOnlyOperation(message)\n            # Pass onward.\n            return func(*args, **kwargs)\n\n        return inner\n\n    # If the message is actually a function, then be a no-arguments decorator.\n    if callable(message):\n        func = message\n        message = (\n            \"You cannot call this from an async context - use a thread or \"\n            \"sync_to_async.\"\n        )\n        return decorator(func)\n    else:\n        return decorator",
                "filename": "django/utils/asyncio.py",
                "start_index": 0,
                "end_index": 1137,
                "start_line": 1,
                "end_line": 39,
                "max_line": 39,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "import os\n\nfrom . import Error, Tags, register\n\nE001 = Error(\n    \"You should not set the DJANGO_ALLOW_ASYNC_UNSAFE environment variable in \"\n    \"deployment. This disables async safety protection.\",\n    id=\"async.E001\",\n)\n\n\n@register(Tags.async_support, deploy=True)\ndef check_async_unsafe(app_configs, **kwargs):\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        return [E001]\n    return []",
                "filename": "django/core/checks/async_checks.py",
                "start_index": 0,
                "end_index": 402,
                "start_line": 1,
                "end_line": 16,
                "max_line": 16,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "class DeprecationInstanceCheck(type):\n    def __instancecheck__(self, instance):\n        warnings.warn(\n            \"`%s` is deprecated, use `%s` instead.\" % (self.__name__, self.alternative),\n            self.deprecation_warning,\n            2,\n        )\n        return super().__instancecheck__(instance)\n\n\nclass MiddlewareMixin:\n    sync_capable = True\n    async_capable = True\n\n    def __init__(self, get_response):\n        if get_response is None:\n            raise ValueError(\"get_response must be provided.\")\n        self.get_response = get_response\n        self._async_check()\n        super().__init__()\n\n    def __repr__(self):\n        return \"<%s get_response=%s>\" % (\n            self.__class__.__qualname__,\n            getattr(\n                self.get_response,\n                \"__qualname__\",\n                self.get_response.__class__.__name__,\n            ),\n        )\n\n    def _async_check(self):\n        \"\"\"\n        If get_response is a coroutine function, turns us into async mode so\n        a thread is not consumed during a whole request.\n        \"\"\"\n        if iscoroutinefunction(self.get_response):\n            # Mark the class as async-capable, but do the actual switch\n            # inside __call__ to avoid swapping out dunder methods\n            markcoroutinefunction(self)\n\n    def __call__(self, request):\n        # Exit out to async mode, if needed\n        if iscoroutinefunction(self):\n            return self.__acall__(request)\n        response = None\n        if hasattr(self, \"process_request\"):\n            response = self.process_request(request)\n        response = response or self.get_response(request)\n        if hasattr(self, \"process_response\"):\n            response = self.process_response(request, response)\n        return response\n\n    async def __acall__(self, request):\n        \"\"\"\n        Async version of __call__ that is swapped in when an async request\n        is running.\n        \"\"\"\n        response = None\n        if hasattr(self, \"process_request\"):\n            response = await sync_to_async(\n                self.process_request,\n                thread_sensitive=True,\n            )(request)\n        response = response or await self.get_response(request)\n        if hasattr(self, \"process_response\"):\n            response = await sync_to_async(\n                self.process_response,\n                thread_sensitive=True,\n            )(request, response)\n        return response",
                "filename": "django/utils/deprecation.py",
                "start_index": 2790,
                "end_index": 5228,
                "start_line": 86,
                "end_line": 156,
                "max_line": 156,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import _thread\nimport copy\nimport datetime\nimport logging\nimport threading\nimport time\nimport warnings\nimport zoneinfo\nfrom collections import deque\nfrom contextlib import contextmanager\n\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import DEFAULT_DB_ALIAS, DatabaseError, NotSupportedError\nfrom django.db.backends import utils\nfrom django.db.backends.base.validation import BaseDatabaseValidation\nfrom django.db.backends.signals import connection_created\nfrom django.db.backends.utils import debug_transaction\nfrom django.db.transaction import TransactionManagementError\nfrom django.db.utils import DatabaseErrorWrapper\nfrom django.utils.asyncio import async_unsafe\nfrom django.utils.functional import cached_property\n\nNO_DB_ALIAS = \"__no_db__\"\nRAN_DB_VERSION_CHECK = set()\n\nlogger = logging.getLogger(\"django.db.backends.base\")",
                "filename": "django/db/backends/base/base.py",
                "start_index": 0,
                "end_index": 888,
                "start_line": 1,
                "end_line": 27,
                "max_line": 788,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import asyncio\nimport logging\nimport sys\nimport tempfile\nimport traceback\nfrom contextlib import aclosing\n\nfrom asgiref.sync import ThreadSensitiveContext, sync_to_async\n\nfrom django.conf import settings\nfrom django.core import signals\nfrom django.core.exceptions import RequestAborted, RequestDataTooBig\nfrom django.core.handlers import base\nfrom django.http import (\n    FileResponse,\n    HttpRequest,\n    HttpResponse,\n    HttpResponseBadRequest,\n    HttpResponseServerError,\n    QueryDict,\n    parse_cookie,\n)\nfrom django.urls import set_script_prefix\nfrom django.utils.functional import cached_property\n\nlogger = logging.getLogger(\"django.request\")\n\n\ndef get_script_prefix(scope):\n    \"\"\"\n    Return the script prefix to use from either the scope or a setting.\n    \"\"\"\n    if settings.FORCE_SCRIPT_NAME:\n        return settings.FORCE_SCRIPT_NAME\n    return scope.get(\"root_path\", \"\") or \"\"",
                "filename": "django/core/handlers/asgi.py",
                "start_index": 0,
                "end_index": 894,
                "start_line": 1,
                "end_line": 35,
                "max_line": 355,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@contextmanager\n    def constraint_checks_disabled(self):\n        \"\"\"\n        Disable foreign key constraint checking.\n        \"\"\"\n        disabled = self.disable_constraint_checking()\n        try:\n            yield\n        finally:\n            if disabled:\n                self.enable_constraint_checking()\n\n    def disable_constraint_checking(self):\n        \"\"\"\n        Backends can implement as needed to temporarily disable foreign key\n        constraint checking. Should return True if the constraints were\n        disabled and will need to be reenabled.\n        \"\"\"\n        return False\n\n    def enable_constraint_checking(self):\n        \"\"\"\n        Backends can implement as needed to re-enable foreign key constraint\n        checking.\n        \"\"\"\n        pass\n\n    def check_constraints(self, table_names=None):\n        \"\"\"\n        Backends can override this method if they can apply constraint\n        checking (e.g. via \"SET CONSTRAINTS ALL IMMEDIATE\"). Should raise an\n        IntegrityError if any invalid foreign key references are encountered.\n        \"\"\"\n        pass\n\n    # ##### Connection termination handling #####\n\n    def is_usable(self):\n        \"\"\"\n        Test if the database connection is usable.\n\n        This method may assume that self.connection is not None.\n\n        Actual implementations should take care not to raise exceptions\n        as that may prevent Django from recycling unusable connections.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of BaseDatabaseWrapper may require an is_usable() method\"\n        )\n\n    def close_if_health_check_failed(self):\n        \"\"\"Close existing connection if it fails a health check.\"\"\"\n        if (\n            self.connection is None\n            or not self.health_check_enabled\n            or self.health_check_done\n        ):\n            return\n\n        if not self.is_usable():\n            self.close()\n        self.health_check_done = True",
                "filename": "django/db/backends/base/base.py",
                "start_index": 19043,
                "end_index": 20987,
                "start_line": 524,
                "end_line": 605,
                "max_line": 788,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import functools\nimport itertools\nfrom collections import defaultdict\n\nfrom asgiref.sync import sync_to_async\n\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core import checks\nfrom django.core.exceptions import FieldDoesNotExist, ObjectDoesNotExist\nfrom django.db import DEFAULT_DB_ALIAS, models, router, transaction\nfrom django.db.models import DO_NOTHING, ForeignObject, ForeignObjectRel\nfrom django.db.models.base import ModelBase, make_foreign_order_accessors\nfrom django.db.models.fields.mixins import FieldCacheMixin\nfrom django.db.models.fields.related import (\n    ReverseManyToOneDescriptor,\n    lazy_related_operation,\n)\nfrom django.db.models.query_utils import PathInfo\nfrom django.db.models.sql import AND\nfrom django.db.models.sql.where import WhereNode\nfrom django.db.models.utils import AltersData\nfrom django.utils.functional import cached_property",
                "filename": "django/contrib/contenttypes/fields.py",
                "start_index": 0,
                "end_index": 889,
                "start_line": 1,
                "end_line": 22,
                "max_line": 803,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def make_middleware_decorator(middleware_class):\n    def _make_decorator(*m_args, **m_kwargs):\n        def _decorator(view_func):\n            middleware = middleware_class(view_func, *m_args, **m_kwargs)\n\n            @wraps(view_func)\n            def _wrapper_view(request, *args, **kwargs):\n                if hasattr(middleware, \"process_request\"):\n                    result = middleware.process_request(request)\n                    if result is not None:\n                        return result\n                if hasattr(middleware, \"process_view\"):\n                    result = middleware.process_view(request, view_func, args, kwargs)\n                    if result is not None:\n                        return result\n                try:\n                    response = view_func(request, *args, **kwargs)\n                except Exception as e:\n                    if hasattr(middleware, \"process_exception\"):\n                        result = middleware.process_exception(request, e)\n                        if result is not None:\n                            return result\n                    raise\n                if hasattr(response, \"render\") and callable(response.render):\n                    if hasattr(middleware, \"process_template_response\"):\n                        response = middleware.process_template_response(\n                            request, response\n                        )\n                    # Defer running of process_response until after the template\n                    # has been rendered:\n                    if hasattr(middleware, \"process_response\"):\n\n                        def callback(response):\n                            return middleware.process_response(request, response)\n\n                        response.add_post_render_callback(callback)\n                else:\n                    if hasattr(middleware, \"process_response\"):\n                        return middleware.process_response(request, response)\n                return response\n\n            return _wrapper_view\n\n        return _decorator\n\n    return _make_decorator\n\n\ndef sync_and_async_middleware(func):\n    \"\"\"\n    Mark a middleware factory as returning a hybrid middleware supporting both\n    types of request.\n    \"\"\"\n    func.sync_capable = True\n    func.async_capable = True\n    return func\n\n\ndef sync_only_middleware(func):\n    \"\"\"\n    Mark a middleware factory as returning a sync middleware.\n    This is the default.\n    \"\"\"\n    func.sync_capable = True\n    func.async_capable = False\n    return func\n\n\ndef async_only_middleware(func):\n    \"\"\"Mark a middleware factory as returning an async middleware.\"\"\"\n    func.sync_capable = False\n    func.async_capable = True\n    return func",
                "filename": "django/utils/decorators.py",
                "start_index": 4246,
                "end_index": 6939,
                "start_line": 118,
                "end_line": 190,
                "max_line": 190,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import copy\nimport inspect\nimport warnings\nfrom functools import partialmethod\nfrom itertools import chain\n\nfrom asgiref.sync import sync_to_async\n\nimport django\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.core import checks\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS,\n    FieldDoesNotExist,\n    FieldError,\n    MultipleObjectsReturned,\n    ObjectDoesNotExist,\n    ValidationError,\n)\nfrom django.db import (\n    DJANGO_VERSION_PICKLE_KEY,\n    DatabaseError,\n    connection,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import NOT_PROVIDED, ExpressionWrapper, IntegerField, Max, Value\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.constraints import CheckConstraint, UniqueConstraint\nfrom django.db.models.deletion import CASCADE, Collector\nfrom django.db.models.expressions import RawSQL\nfrom django.db.models.fields.related import (\n    ForeignObjectRel,\n    OneToOneField,\n    lazy_related_operation,\n    resolve_relation,\n)\nfrom django.db.models.functions import Coalesce\nfrom django.db.models.manager import Manager\nfrom django.db.models.options import Options\nfrom django.db.models.query import F, Q\nfrom django.db.models.signals import (\n    class_prepared,\n    post_init,\n    post_save,\n    pre_init,\n    pre_save,\n)\nfrom django.db.models.utils import AltersData, make_model_tuple\nfrom django.utils.encoding import force_str\nfrom django.utils.hashable import make_hashable\nfrom django.utils.text import capfirst, get_text_list\nfrom django.utils.translation import gettext_lazy as _\n\n\nclass Deferred:\n    def __repr__(self):\n        return \"<Deferred field>\"\n\n    def __str__(self):\n        return \"<Deferred field>\"\n\n\nDEFERRED = Deferred()\n\n\ndef subclass_exception(name, bases, module, attached_to):\n    \"\"\"\n    Create exception subclass. Used by ModelBase below.\n\n    The exception is created in a way that allows it to be pickled, assuming\n    that the returned exception class will be added as an attribute to the\n    'attached_to' class.\n    \"\"\"\n    return type(\n        name,\n        bases,\n        {\n            \"__module__\": module,\n            \"__qualname__\": \"%s.%s\" % (attached_to.__qualname__, name),\n        },\n    )\n\n\ndef _has_contribute_to_class(value):\n    # Only call contribute_to_class() if it's bound.\n    return not inspect.isclass(value) and hasattr(value, \"contribute_to_class\")",
                "filename": "django/db/models/base.py",
                "start_index": 0,
                "end_index": 2403,
                "start_line": 1,
                "end_line": 89,
                "max_line": 2607,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.middleware.csrf import CsrfViewMiddleware, get_token\nfrom django.utils.decorators import decorator_from_middleware\n\ncsrf_protect = decorator_from_middleware(CsrfViewMiddleware)\ncsrf_protect.__name__ = \"csrf_protect\"\ncsrf_protect.__doc__ = \"\"\"\nThis decorator adds CSRF protection in exactly the same way as\nCsrfViewMiddleware, but it can be used on a per view basis.  Using both, or\nusing the decorator multiple times, is harmless and efficient.\n\"\"\"\n\n\nclass _EnsureCsrfToken(CsrfViewMiddleware):\n    # Behave like CsrfViewMiddleware but don't reject requests or log warnings.\n    def _reject(self, request, reason):\n        return None\n\n\nrequires_csrf_token = decorator_from_middleware(_EnsureCsrfToken)\nrequires_csrf_token.__name__ = \"requires_csrf_token\"\nrequires_csrf_token.__doc__ = \"\"\"\nUse this decorator on views that need a correct csrf_token available to\nRequestContext, but without the CSRF protection that csrf_protect\nenforces.\n\"\"\"\n\n\nclass _EnsureCsrfCookie(CsrfViewMiddleware):\n    def _reject(self, request, reason):\n        return None\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        retval = super().process_view(request, callback, callback_args, callback_kwargs)\n        # Force process_response to send the cookie\n        get_token(request)\n        return retval\n\n\nensure_csrf_cookie = decorator_from_middleware(_EnsureCsrfCookie)\nensure_csrf_cookie.__name__ = \"ensure_csrf_cookie\"\nensure_csrf_cookie.__doc__ = \"\"\"\nUse this decorator to ensure that a view sets a CSRF cookie, whether or not it\nuses the csrf_token template tag, or the CsrfViewMiddleware is used.\n\"\"\"\n\n\ndef csrf_exempt(view_func):\n    \"\"\"Mark a view function as being exempt from the CSRF view protection.\"\"\"\n\n    # view_func.csrf_exempt = True would also work, but decorators are nicer\n    # if they don't have side effects, so return a new function.\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            return await view_func(request, *args, **kwargs)\n\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            return view_func(request, *args, **kwargs)\n\n    _view_wrapper.csrf_exempt = True\n\n    return wraps(view_func)(_view_wrapper)",
                "filename": "django/views/decorators/csrf.py",
                "start_index": 0,
                "end_index": 2323,
                "start_line": 1,
                "end_line": 69,
                "max_line": 69,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/utils/asyncio.py": [
                {
                    "chunk": {
                        "code": "import os\nfrom asyncio import get_running_loop\nfrom functools import wraps\n\nfrom django.core.exceptions import SynchronousOnlyOperation\n\n\ndef async_unsafe(message):\n    \"\"\"\n    Decorator to mark functions as async-unsafe. Someone trying to access\n    the function while in an async context will get an error message.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            # Detect a running event loop in this thread.\n            try:\n                get_running_loop()\n            except RuntimeError:\n                pass\n            else:\n                if not os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n                    raise SynchronousOnlyOperation(message)\n            # Pass onward.\n            return func(*args, **kwargs)\n\n        return inner\n\n    # If the message is actually a function, then be a no-arguments decorator.\n    if callable(message):\n        func = message\n        message = (\n            \"You cannot call this from an async context - use a thread or \"\n            \"sync_to_async.\"\n        )\n        return decorator(func)\n    else:\n        return decorator",
                        "filename": "django/utils/asyncio.py",
                        "start_index": 0,
                        "end_index": 1137,
                        "start_line": 1,
                        "end_line": 39,
                        "max_line": 39,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the async_unsafe decorator which raises SynchronousOnlyOperation if the DJANGO_ALLOW_ASYNC_UNSAFE environment variable is not set. Modifying this check or the environment variable handling is directly related to the issue."
                }
            ],
            "django/core/checks/async_checks.py": [
                {
                    "chunk": {
                        "code": "import os\n\nfrom . import Error, Tags, register\n\nE001 = Error(\n    \"You should not set the DJANGO_ALLOW_ASYNC_UNSAFE environment variable in \"\n    \"deployment. This disables async safety protection.\",\n    id=\"async.E001\",\n)\n\n\n@register(Tags.async_support, deploy=True)\ndef check_async_unsafe(app_configs, **kwargs):\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        return [E001]\n    return []",
                        "filename": "django/core/checks/async_checks.py",
                        "start_index": 0,
                        "end_index": 402,
                        "start_line": 1,
                        "end_line": 16,
                        "max_line": 16,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains a check for the DJANGO_ALLOW_ASYNC_UNSAFE environment variable and raises an error if it is set in deployment. This is relevant because the issue discusses adding a flag or environment variable to control async-unsafe checks."
                }
            ]
        },
        "solution_task": "To implement the feature of allowing users to override \"async unsafe\" checks, you can follow these steps:\n\n- Modify the `async_unsafe` decorator in `django/utils/asyncio.py` to check for an environment variable that allows bypassing the async-unsafe check.\n- Add documentation and warnings to inform users about the implications of disabling async safety checks.\n\nHere's a step-by-step guide:\n\n1. Modify the `async_unsafe` decorator to check for an environment variable, such as `DJANGO_ALLOW_ASYNC_UNSAFE`. If this variable is set, the decorator should not raise `SynchronousOnlyOperation`.\n\n```python\ndef async_unsafe(message):\n    def decorator(func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            try:\n                get_running_loop()\n            except RuntimeError:\n                pass\n            else:\n                if not os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n                    raise SynchronousOnlyOperation(message)\n            return func(*args, **kwargs)\n        return inner\n    if callable(message):\n        func = message\n        message = \"You cannot call this from an async context - use a thread or sync_to_async.\"\n        return decorator(func)\n    else:\n        return decorator\n```\n\n2. In `django/core/checks/async_checks.py`, you may want to add a system check that warns users if they have the `DJANGO_ALLOW_ASYNC_UNSAFE` environment variable set in a production environment.\n\n```python\n@register(Tags.async_support, deploy=True)\ndef check_async_unsafe(app_configs, **kwargs):\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        return [E001]\n    return []\n```\n\n3. Update the documentation to explain the new environment variable and its intended use case. Emphasize that it should not be used in production environments as it disables important safety checks.\n\n4. Optionally, you can add logging or warnings when the environment variable is used, to alert developers that they are bypassing safety checks.\n\n```python\nelse:\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        warnings.warn(\n            \"The DJANGO_ALLOW_ASYNC_UNSAFE environment variable is set. \"\n            \"Async safety checks are bypassed, which can lead to data corruption \"\n            \"and other issues. This should not be used in production.\",\n            RuntimeWarning\n        )\n```\n\n5. Ensure that tests are added to cover the new functionality and that existing tests still pass with the changes.\n\nRemember to follow the project's contribution guidelines for naming conventions, coding style, and testing requirements.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a comprehensive and actionable plan for implementing the feature to override \"async unsafe\" checks. It includes specific steps to modify the `async_unsafe` decorator, add a system check, update documentation, and add logging or warnings. The RESPONSE also includes code snippets and emphasizes the importance of not using the override in production environments. The RESPONSE addresses the feature request by suggesting the use of an environment variable, which aligns with the preference mentioned in the PROMPT. The only reason it does not score a 10 is that it does not explicitly mention how to ensure compatibility with Jupyter, which was a part of the initial concern in the PROMPT. However, the RESPONSE implicitly suggests that setting the environment variable would work well with Jupyter, as it would bypass the checks globally, which would likely resolve the issue in Jupyter notebooks.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711731995.326525,
        "result": "To implement the feature of allowing users to override \"async unsafe\" checks, you can follow these steps:\n\n- Modify the `async_unsafe` decorator in `django/utils/asyncio.py` to check for an environment variable that allows bypassing the async-unsafe check.\n- Add documentation and warnings to inform users about the implications of disabling async safety checks.\n\nHere's a step-by-step guide:\n\n1. Modify the `async_unsafe` decorator to check for an environment variable, such as `DJANGO_ALLOW_ASYNC_UNSAFE`. If this variable is set, the decorator should not raise `SynchronousOnlyOperation`.\n\n```python\ndef async_unsafe(message):\n    def decorator(func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            try:\n                get_running_loop()\n            except RuntimeError:\n                pass\n            else:\n                if not os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n                    raise SynchronousOnlyOperation(message)\n            return func(*args, **kwargs)\n        return inner\n    if callable(message):\n        func = message\n        message = \"You cannot call this from an async context - use a thread or sync_to_async.\"\n        return decorator(func)\n    else:\n        return decorator\n```\n\n2. In `django/core/checks/async_checks.py`, you may want to add a system check that warns users if they have the `DJANGO_ALLOW_ASYNC_UNSAFE` environment variable set in a production environment.\n\n```python\n@register(Tags.async_support, deploy=True)\ndef check_async_unsafe(app_configs, **kwargs):\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        return [E001]\n    return []\n```\n\n3. Update the documentation to explain the new environment variable and its intended use case. Emphasize that it should not be used in production environments as it disables important safety checks.\n\n4. Optionally, you can add logging or warnings when the environment variable is used, to alert developers that they are bypassing safety checks.\n\n```python\nelse:\n    if os.environ.get(\"DJANGO_ALLOW_ASYNC_UNSAFE\"):\n        warnings.warn(\n            \"The DJANGO_ALLOW_ASYNC_UNSAFE environment variable is set. \"\n            \"Async safety checks are bypassed, which can lead to data corruption \"\n            \"and other issues. This should not be used in production.\",\n            RuntimeWarning\n        )\n```\n\n5. Ensure that tests are added to cover the new functionality and that existing tests still pass with the changes.\n\nRemember to follow the project's contribution guidelines for naming conventions, coding style, and testing requirements.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [utils](https://github.com/testbed/django__django__3.1/tree//django/utils)- [Lines 1 - 39](https://github.com/testbed/django__django__3.1/blob//django/utils/asyncio.py#L1-L39)\n\n This snippet contains the async_unsafe decorator which raises SynchronousOnlyOperation if the DJANGO_ALLOW_ASYNC_UNSAFE environment variable is not set. Modifying this check or the environment variable handling is directly related to the issue.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [checks](https://github.com/testbed/django__django__3.1/tree//django/core/checks)- [Lines 1 - 16](https://github.com/testbed/django__django__3.1/blob//django/core/checks/async_checks.py#L1-L16)\n\n This snippet contains a check for the DJANGO_ALLOW_ASYNC_UNSAFE environment variable and raises an error if it is set in deployment. This is relevant because the issue discusses adding a flag or environment variable to control async-unsafe checks.",
        "context_relevance": 0.36000000000000004,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT and answer it completely to get a score of 10.\nSupporting Evidence: The RESPONSE provides a detailed explanation and step-by-step guide on how to implement the feature to override \"async unsafe\" checks, which is exactly what the PROMPT is requesting. It addresses the issue of Jupyter executing synchronous code in an async environment and suggests a solution that involves setting an environment variable, which aligns with the preference mentioned in the PROMPT. The RESPONSE also includes code snippets and a link to the relevant sections of the Django codebase, which directly relates to the issue at hand. Additionally, it covers the need for documentation and warnings, which is an important aspect of the PROMPT's description. The RESPONSE is comprehensive and fully answers the entire PROMPT."
        },
        "qa_relevance": 1.0
    }
}