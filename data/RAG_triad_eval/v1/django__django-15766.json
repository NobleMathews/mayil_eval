{
    "id": "django__django-15766",
    "repo_name": "testbed/django__django__4.2",
    "task_id": 7617083517877171003,
    "title": "Supporting robust on_commit handlers.",
    "body": "Description\n\t \n\t\t(last modified by Josh Smeaton)\n\t \nI recently tracked down an issue in my application where some on_commit handlers didn't execute because one of the previous handlers raised an exception. There appears to be no way to execute on_commit handlers *robustly* as you're able to do with signals [0] using send_robust.\nI could sprinkle try/catches around the place, but I'd like to avoid doing so because not all functions that are used as handlers should always swallow exceptions, but could do so when run as on_commit handlers.\nTargeting which handlers can be robust or not would be really useful, for example:\ndef update_search(user):\n\t# if updating search fails, it's fine, we'll bulk update later anyway\n\ttransaction.on_commit(lambda: search.update(user), robust=True)\ndef trigger_background_task_one(user):\n\t# if this task fails, we want to crash\n\ttransaction.on_commit(lambda: mytask.delay(user_id=user.id))\nHere if search fails to update it doesn't prevent the background task from being scheduled.\nI'm proposing to add a robust kwarg that defaults to False, for backward compatibility, but allows a user to tag specific handlers as such.\n[0] \u200bhttps://docs.djangoproject.com/en/4.0/topics/signals/#sending-signals\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__4.2.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature of supporting robust `on_commit` handlers, you can follow these steps:\n\n- Modify the `on_commit` function in `django/db/transaction.py` to accept a new keyword argument `robust` with a default value of `False`.\n- Update the `on_commit` method in `django/db/backends/base/base.py` to handle the `robust` flag. When `robust` is `True`, wrap the function call in a `try-except` block to catch and log exceptions without re-raising them.\n- Ensure that the `run_and_clear_commit_hooks` method in `django/db/backends/base/base.py` also respects the `robust` flag when executing the stored `on_commit` functions after a transaction is committed.\n- Update the documentation and tests to reflect the new feature.\n\nHere is the modified code snippet for `django/db/backends/base/base.py`:\n\n```python\ndef on_commit(self, func, robust=False):\n    if not callable(func):\n        raise TypeError(\"on_commit()'s callback must be a callable.\")\n    if self.in_atomic_block:\n        # Transaction in progress; save for execution on commit.\n        self.run_on_commit.append((set(self.savepoint_ids), func, robust))\n    elif not self.get_autocommit():\n        raise TransactionManagementError(\n            \"on_commit() cannot be used in manual transaction management\"\n        )\n    else:\n        # No transaction in progress and in autocommit mode; execute immediately.\n        if robust:\n            try:\n                func()\n            except Exception as e:\n                logger.error(\n                    f\"Error calling {func.__qualname__} in on_commit() (%s).\",\n                    e,\n                    exc_info=True,\n                )\n        else:\n            func()\n\ndef run_and_clear_commit_hooks(self):\n    self.validate_no_atomic_block()\n    current_run_on_commit = self.run_on_commit\n    self.run_on_commit = []\n    while current_run_on_commit:\n        _, func, robust = current_run_on_commit.pop(0)\n        if robust:\n            try:\n                func()\n            except Exception as e:\n                logger.error(\n                    f\"Error calling {func.__qualname__} in on_commit() during \"\n                    f\"transaction (%s).\",\n                    e,\n                    exc_info=True,\n                )\n        else:\n            func()\n```\n\nAnd the modified `on_commit` function in `django/db/transaction.py`:\n\n```python\ndef on_commit(func, using=None, robust=False):\n    \"\"\"\n    Register `func` to be called when the current transaction is committed.\n    If the current transaction is rolled back, `func` will not be called.\n    \"\"\"\n    get_connection(using).on_commit(func, robust)\n```\n\nRemember to add unit tests to verify that:\n- Functions registered with `robust=True` do not cause the transaction to fail if they raise an exception.\n- Functions registered with `robust=False` (default behavior) behave as before, without swallowing exceptions.\n\nAlso, update the documentation to describe the new `robust` parameter for the `on_commit` function.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [backends](https://github.com/testbed/django__django__4.2/tree//django/db/backends) \u2192 [base](https://github.com/testbed/django__django__4.2/tree//django/db/backends/base)- [Lines 723 - 788](https://github.com/testbed/django__django__4.2/blob//django/db/backends/base/base.py#L723-L788)\n\n This snippet contains the implementation of the on_commit method with the robust parameter and the run_and_clear_commit_hooks method which handles the execution of the on_commit callbacks. It is directly related to the issue of adding robustness to on_commit handlers.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db)- [Lines 100 - 139](https://github.com/testbed/django__django__4.2/blob//django/db/transaction.py#L100-L139)\n\n This snippet shows the definition of the on_commit method in the transaction module, which is where the new robust parameter would be added according to the issue description.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00029299999999999997,
        "snippet_processor": 0.05661,
        "issue_star_solver": 0.05147000000000001,
        "issue_star_creation": 0.0343,
        "bouncer": 0.02192
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711716080.542807,
        "relevant_snippets": [
            {
                "code": "@contextmanager\ndef mark_for_rollback_on_error(using=None):\n    \"\"\"\n    Internal low-level utility to mark a transaction as \"needs rollback\" when\n    an exception is raised while not enforcing the enclosed block to be in a\n    transaction. This is needed by Model.save() and friends to avoid starting a\n    transaction when in autocommit mode and a single query is executed.\n\n    It's equivalent to:\n\n        connection = get_connection(using)\n        if connection.get_autocommit():\n            yield\n        else:\n            with transaction.atomic(using=using, savepoint=False):\n                yield\n\n    but it uses low-level utilities to avoid performance overhead.\n    \"\"\"\n    try:\n        yield\n    except Exception as exc:\n        connection = get_connection(using)\n        if connection.in_atomic_block:\n            connection.needs_rollback = True\n            connection.rollback_exc = exc\n        raise\n\n\ndef on_commit(func, using=None, robust=False):\n    \"\"\"\n    Register `func` to be called when the current transaction is committed.\n    If the current transaction is rolled back, `func` will not be called.\n    \"\"\"\n    get_connection(using).on_commit(func, robust)\n\n\n#################################\n# Decorators / context managers #\n#################################",
                "filename": "django/db/transaction.py",
                "start_index": 2672,
                "end_index": 3956,
                "start_line": 100,
                "end_line": 139,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def on_commit(self, func, robust=False):\n        if not callable(func):\n            raise TypeError(\"on_commit()'s callback must be a callable.\")\n        if self.in_atomic_block:\n            # Transaction in progress; save for execution on commit.\n            self.run_on_commit.append((set(self.savepoint_ids), func, robust))\n        elif not self.get_autocommit():\n            raise TransactionManagementError(\n                \"on_commit() cannot be used in manual transaction management\"\n            )\n        else:\n            # No transaction in progress and in autocommit mode; execute\n            # immediately.\n            if robust:\n                try:\n                    func()\n                except Exception as e:\n                    logger.error(\n                        f\"Error calling {func.__qualname__} in on_commit() (%s).\",\n                        e,\n                        exc_info=True,\n                    )\n            else:\n                func()\n\n    def run_and_clear_commit_hooks(self):\n        self.validate_no_atomic_block()\n        current_run_on_commit = self.run_on_commit\n        self.run_on_commit = []\n        while current_run_on_commit:\n            _, func, robust = current_run_on_commit.pop(0)\n            if robust:\n                try:\n                    func()\n                except Exception as e:\n                    logger.error(\n                        f\"Error calling {func.__qualname__} in on_commit() during \"\n                        f\"transaction (%s).\",\n                        e,\n                        exc_info=True,\n                    )\n            else:\n                func()\n\n    @contextmanager\n    def execute_wrapper(self, wrapper):\n        \"\"\"\n        Return a context manager under which the wrapper is applied to suitable\n        database query executions.\n        \"\"\"\n        self.execute_wrappers.append(wrapper)\n        try:\n            yield\n        finally:\n            self.execute_wrappers.pop()\n\n    def copy(self, alias=None):\n        \"\"\"\n        Return a copy of this connection.\n\n        For tests that require two connections to the same database.\n        \"\"\"\n        settings_dict = copy.deepcopy(self.settings_dict)\n        if alias is None:\n            alias = self.alias\n        return type(self)(settings_dict, alias)",
                "filename": "django/db/backends/base/base.py",
                "start_index": 26082,
                "end_index": 28387,
                "start_line": 723,
                "end_line": 788,
                "max_line": 788,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "def save_base(\n        self,\n        raw=False,\n        force_insert=False,\n        force_update=False,\n        using=None,\n        update_fields=None,\n    ):\n        \"\"\"\n        Handle the parts of saving which should be done only once per save,\n        yet need to be done in raw saves, too. This includes some sanity\n        checks and signal sending.\n\n        The 'raw' argument is telling save_base not to save any parent\n        models and not to do any changes to the values before save. This\n        is used by fixture loading.\n        \"\"\"\n        using = using or router.db_for_write(self.__class__, instance=self)\n        assert not (force_insert and (force_update or update_fields))\n        assert update_fields is None or update_fields\n        cls = origin = self.__class__\n        # Skip proxies, but keep the origin as the proxy model.\n        if cls._meta.proxy:\n            cls = cls._meta.concrete_model\n        meta = cls._meta\n        if not meta.auto_created:\n            pre_save.send(\n                sender=origin,\n                instance=self,\n                raw=raw,\n                using=using,\n                update_fields=update_fields,\n            )\n        # A transaction isn't needed if one query is issued.\n        if meta.parents:\n            context_manager = transaction.atomic(using=using, savepoint=False)\n        else:\n            context_manager = transaction.mark_for_rollback_on_error(using=using)\n        with context_manager:\n            parent_inserted = False\n            if not raw:\n                # Validate force insert only when parents are inserted.\n                force_insert = self._validate_force_insert(force_insert)\n                parent_inserted = self._save_parents(\n                    cls, using, update_fields, force_insert\n                )\n            updated = self._save_table(\n                raw,\n                cls,\n                force_insert or parent_inserted,\n                force_update,\n                using,\n                update_fields,\n            )\n        # Store the database on which the object was saved\n        self._state.db = using\n        # Once saved, this is no longer a to-be-added instance.\n        self._state.adding = False\n\n        # Signal that the save is complete\n        if not meta.auto_created:\n            post_save.send(\n                sender=origin,\n                instance=self,\n                created=(not updated),\n                update_fields=update_fields,\n                raw=raw,\n                using=using,\n            )\n\n    save_base.alters_data = True",
                "filename": "django/db/models/base.py",
                "start_index": 33401,
                "end_index": 35982,
                "start_line": 855,
                "end_line": 925,
                "max_line": 2607,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from collections import Counter, defaultdict\nfrom functools import partial, reduce\nfrom itertools import chain\nfrom operator import attrgetter, or_\n\nfrom django.db import IntegrityError, connections, models, transaction\nfrom django.db.models import query_utils, signals, sql\n\n\nclass ProtectedError(IntegrityError):\n    def __init__(self, msg, protected_objects):\n        self.protected_objects = protected_objects\n        super().__init__(msg, protected_objects)\n\n\nclass RestrictedError(IntegrityError):\n    def __init__(self, msg, restricted_objects):\n        self.restricted_objects = restricted_objects\n        super().__init__(msg, restricted_objects)\n\n\ndef CASCADE(collector, field, sub_objs, using):\n    collector.collect(\n        sub_objs,\n        source=field.remote_field.model,\n        source_attr=field.name,\n        nullable=field.null,\n        fail_on_restricted=False,\n    )\n    if field.null and not connections[using].features.can_defer_constraint_checks:\n        collector.add_field_update(field, None, sub_objs)\n\n\ndef PROTECT(collector, field, sub_objs, using):\n    raise ProtectedError(\n        \"Cannot delete some instances of model '%s' because they are \"\n        \"referenced through a protected foreign key: '%s.%s'\"\n        % (\n            field.remote_field.model.__name__,\n            sub_objs[0].__class__.__name__,\n            field.name,\n        ),\n        sub_objs,\n    )\n\n\ndef RESTRICT(collector, field, sub_objs, using):\n    collector.add_restricted_objects(field, sub_objs)\n    collector.add_dependency(field.remote_field.model, field.model)\n\n\ndef SET(value):\n    if callable(value):\n\n        def set_on_delete(collector, field, sub_objs, using):\n            collector.add_field_update(field, value(), sub_objs)\n\n    else:\n\n        def set_on_delete(collector, field, sub_objs, using):\n            collector.add_field_update(field, value, sub_objs)\n\n    set_on_delete.deconstruct = lambda: (\"django.db.models.SET\", (value,), {})\n    set_on_delete.lazy_sub_objs = True\n    return set_on_delete\n\n\ndef SET_NULL(collector, field, sub_objs, using):\n    collector.add_field_update(field, None, sub_objs)\n\n\nSET_NULL.lazy_sub_objs = True\n\n\ndef SET_DEFAULT(collector, field, sub_objs, using):\n    collector.add_field_update(field, field.get_default(), sub_objs)\n\n\nSET_DEFAULT.lazy_sub_objs = True\n\n\ndef DO_NOTHING(collector, field, sub_objs, using):\n    pass\n\n\ndef get_candidate_relations_to_delete(opts):\n    # The candidate relations are the ones that come from N-1 and 1-1 relations.\n    # N-N  (i.e., many-to-many) relations aren't candidates for deletion.\n    return (\n        f\n        for f in opts.get_fields(include_hidden=True)\n        if f.auto_created and not f.concrete and (f.one_to_one or f.one_to_many)\n    )",
                "filename": "django/db/models/deletion.py",
                "start_index": 0,
                "end_index": 2747,
                "start_line": 1,
                "end_line": 517,
                "max_line": 522,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "else:\n                # This flag will be set to True again if there isn't a savepoint\n                # allowing to perform the rollback at this level.\n                connection.needs_rollback = False\n                if connection.in_atomic_block:\n                    # Roll back to savepoint if there is one, mark for rollback\n                    # otherwise.\n                    if sid is None:\n                        connection.needs_rollback = True\n                    else:\n                        try:\n                            connection.savepoint_rollback(sid)\n                            # The savepoint won't be reused. Release it to\n                            # minimize overhead for the database server.\n                            connection.savepoint_commit(sid)\n                        except Error:\n                            # If rolling back to a savepoint fails, mark for\n                            # rollback at a higher level and avoid shadowing\n                            # the original exception.\n                            connection.needs_rollback = True\n                else:\n                    # Roll back transaction\n                    try:\n                        connection.rollback()\n                    except Error:\n                        # An error during rollback means that something\n                        # went wrong with the connection. Drop it.\n                        connection.close()",
                "filename": "django/db/transaction.py",
                "start_index": 9581,
                "end_index": 11023,
                "start_line": 113,
                "end_line": 299,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@cached_property\n    def supports_transactions(self):\n        \"\"\"Confirm support for transactions.\"\"\"\n        with self.connection.cursor() as cursor:\n            cursor.execute(\"CREATE TABLE ROLLBACK_TEST (X INT)\")\n            self.connection.set_autocommit(False)\n            cursor.execute(\"INSERT INTO ROLLBACK_TEST (X) VALUES (8)\")\n            self.connection.rollback()\n            self.connection.set_autocommit(True)\n            cursor.execute(\"SELECT COUNT(X) FROM ROLLBACK_TEST\")\n            (count,) = cursor.fetchone()\n            cursor.execute(\"DROP TABLE ROLLBACK_TEST\")\n        return count == 0\n\n    def allows_group_by_selected_pks_on_model(self, model):\n        if not self.allows_group_by_selected_pks:\n            return False\n        return model._meta.managed",
                "filename": "django/db/backends/base/features.py",
                "start_index": 14932,
                "end_index": 15714,
                "start_line": 391,
                "end_line": 413,
                "max_line": 413,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _savepoint_rollback(self, sid):\n        with self.cursor() as cursor:\n            cursor.execute(self.ops.savepoint_rollback_sql(sid))\n\n    def _savepoint_commit(self, sid):\n        with self.cursor() as cursor:\n            cursor.execute(self.ops.savepoint_commit_sql(sid))\n\n    def _savepoint_allowed(self):\n        # Savepoints cannot be created outside a transaction\n        return self.features.uses_savepoints and not self.get_autocommit()\n\n    # ##### Generic savepoint management methods #####\n\n    @async_unsafe\n    def savepoint(self):\n        \"\"\"\n        Create a savepoint inside the current transaction. Return an\n        identifier for the savepoint that will be used for the subsequent\n        rollback or commit. Do nothing if savepoints are not supported.\n        \"\"\"\n        if not self._savepoint_allowed():\n            return\n\n        thread_ident = _thread.get_ident()\n        tid = str(thread_ident).replace(\"-\", \"\")\n\n        self.savepoint_state += 1\n        sid = \"s%s_x%d\" % (tid, self.savepoint_state)\n\n        self.validate_thread_sharing()\n        self._savepoint(sid)\n\n        return sid\n\n    @async_unsafe\n    def savepoint_rollback(self, sid):\n        \"\"\"\n        Roll back to a savepoint. Do nothing if savepoints are not supported.\n        \"\"\"\n        if not self._savepoint_allowed():\n            return\n\n        self.validate_thread_sharing()\n        self._savepoint_rollback(sid)\n\n        # Remove any callbacks registered while this savepoint was active.\n        self.run_on_commit = [\n            (sids, func, robust)\n            for (sids, func, robust) in self.run_on_commit\n            if sid not in sids\n        ]\n\n    @async_unsafe\n    def savepoint_commit(self, sid):\n        \"\"\"\n        Release a savepoint. Do nothing if savepoints are not supported.\n        \"\"\"\n        if not self._savepoint_allowed():\n            return\n\n        self.validate_thread_sharing()\n        self._savepoint_commit(sid)\n\n    @async_unsafe\n    def clean_savepoints(self):\n        \"\"\"\n        Reset the counter used to generate unique savepoint ids in this thread.\n        \"\"\"\n        self.savepoint_state = 0\n\n    # ##### Backend-specific transaction management methods #####\n\n    def _set_autocommit(self, autocommit):\n        \"\"\"\n        Backend-specific implementation to enable or disable autocommit.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of BaseDatabaseWrapper may require a _set_autocommit() method\"\n        )\n\n    # ##### Generic transaction management methods #####\n\n    def get_autocommit(self):\n        \"\"\"Get the autocommit state.\"\"\"\n        self.ensure_connection()\n        return self.autocommit",
                "filename": "django/db/backends/base/base.py",
                "start_index": 13619,
                "end_index": 16289,
                "start_line": 365,
                "end_line": 451,
                "max_line": 788,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "async def asend_robust(self, sender, **named):\n        \"\"\"\n        Send signal from sender to all connected receivers catching errors.\n\n        If any receivers are synchronous, they are grouped and called behind a\n        sync_to_async() adaption before executing any asynchronous receivers.\n\n        If any receivers are asynchronous, they are grouped and executed\n        concurrently with asyncio.gather.\n\n        Arguments:\n\n            sender\n                The sender of the signal. Can be any Python object (normally one\n                registered with a connect if you actually want something to\n                occur).\n\n            named\n                Named arguments which will be passed to receivers.\n\n        Return a list of tuple pairs [(receiver, response), ... ].\n\n        If any receiver raises an error (specifically any subclass of\n        Exception), return the error instance as the result for that receiver.\n        \"\"\"\n        if (\n            not self.receivers\n            or self.sender_receivers_cache.get(sender) is NO_RECEIVERS\n        ):\n            return []\n\n        # Call each receiver with whatever arguments it can accept.\n        # Return a list of tuple pairs [(receiver, response), ... ].\n        sync_receivers, async_receivers = self._live_receivers(sender)\n\n        if sync_receivers:\n\n            @sync_to_async\n            def sync_send():\n                responses = []\n                for receiver in sync_receivers:\n                    try:\n                        response = receiver(signal=self, sender=sender, **named)\n                    except Exception as err:\n                        self._log_robust_failure(receiver, err)\n                        responses.append((receiver, err))\n                    else:\n                        responses.append((receiver, response))\n                return responses\n\n        else:\n            sync_send = list\n\n        async def asend_and_wrap_exception(receiver):\n            try:\n                response = await receiver(signal=self, sender=sender, **named)\n            except Exception as err:\n                self._log_robust_failure(receiver, err)\n                return err\n            return response\n\n        responses, async_responses = await asyncio.gather(\n            sync_send(),\n            asyncio.gather(\n                *(asend_and_wrap_exception(receiver) for receiver in async_receivers),\n            ),\n        )\n        responses.extend(zip(async_receivers, async_responses))\n        return responses\n\n    def _clear_dead_receivers(self):\n        # Note: caller is assumed to hold self.lock.\n        if self._dead_receivers:\n            self._dead_receivers = False\n            self.receivers = [\n                r\n                for r in self.receivers\n                if not (isinstance(r[1], weakref.ReferenceType) and r[1]() is None)\n            ]",
                "filename": "django/dispatch/dispatcher.py",
                "start_index": 11575,
                "end_index": 14445,
                "start_line": 332,
                "end_line": 410,
                "max_line": 490,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def send_robust(self, sender, **named):\n        \"\"\"\n        Send signal from sender to all connected receivers catching errors.\n\n        If any receivers are asynchronous, they are called after all the\n        synchronous receivers via a single call to async_to_sync(). They are\n        also executed concurrently with asyncio.gather().\n\n        Arguments:\n\n            sender\n                The sender of the signal. Can be any Python object (normally one\n                registered with a connect if you actually want something to\n                occur).\n\n            named\n                Named arguments which will be passed to receivers.\n\n        Return a list of tuple pairs [(receiver, response), ... ].\n\n        If any receiver raises an error (specifically any subclass of\n        Exception), return the error instance as the result for that receiver.\n        \"\"\"\n        if (\n            not self.receivers\n            or self.sender_receivers_cache.get(sender) is NO_RECEIVERS\n        ):\n            return []\n\n        # Call each receiver with whatever arguments it can accept.\n        # Return a list of tuple pairs [(receiver, response), ... ].\n        responses = []\n        sync_receivers, async_receivers = self._live_receivers(sender)\n        for receiver in sync_receivers:\n            try:\n                response = receiver(signal=self, sender=sender, **named)\n            except Exception as err:\n                self._log_robust_failure(receiver, err)\n                responses.append((receiver, err))\n            else:\n                responses.append((receiver, response))\n        if async_receivers:\n\n            async def asend_and_wrap_exception(receiver):\n                try:\n                    response = await receiver(signal=self, sender=sender, **named)\n                except Exception as err:\n                    self._log_robust_failure(receiver, err)\n                    return err\n                return response\n\n            async def asend():\n                async_responses = await asyncio.gather(\n                    *(\n                        asend_and_wrap_exception(receiver)\n                        for receiver in async_receivers\n                    )\n                )\n                return zip(async_receivers, async_responses)\n\n            responses.extend(async_to_sync(asend)())\n        return responses",
                "filename": "django/dispatch/dispatcher.py",
                "start_index": 9209,
                "end_index": 11569,
                "start_line": 269,
                "end_line": 400,
                "max_line": 490,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if connection.closed_in_transaction:\n                # The database will perform a rollback by itself.\n                # Wait until we exit the outermost block.\n                pass\n\n            elif exc_type is None and not connection.needs_rollback:\n                if connection.in_atomic_block:\n                    # Release savepoint if there is one\n                    if sid is not None:\n                        try:\n                            connection.savepoint_commit(sid)\n                        except DatabaseError:\n                            try:\n                                connection.savepoint_rollback(sid)\n                                # The savepoint won't be reused. Release it to\n                                # minimize overhead for the database server.\n                                connection.savepoint_commit(sid)\n                            except Error:\n                                # If rolling back to a savepoint fails, mark for\n                                # rollback at a higher level and avoid shadowing\n                                # the original exception.\n                                connection.needs_rollback = True\n                            raise\n                else:\n                    # Commit transaction\n                    try:\n                        connection.commit()\n                    except DatabaseError:\n                        try:\n                            connection.rollback()\n                        except Error:\n                            # An error during rollback means that something\n                            # went wrong with the connection. Drop it.\n                            connection.close()\n                        raise",
                "filename": "django/db/transaction.py",
                "start_index": 7841,
                "end_index": 9568,
                "start_line": 237,
                "end_line": 271,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/db/backends/base/base.py": [
                {
                    "chunk": {
                        "code": "def on_commit(self, func, robust=False):\n        if not callable(func):\n            raise TypeError(\"on_commit()'s callback must be a callable.\")\n        if self.in_atomic_block:\n            # Transaction in progress; save for execution on commit.\n            self.run_on_commit.append((set(self.savepoint_ids), func, robust))\n        elif not self.get_autocommit():\n            raise TransactionManagementError(\n                \"on_commit() cannot be used in manual transaction management\"\n            )\n        else:\n            # No transaction in progress and in autocommit mode; execute\n            # immediately.\n            if robust:\n                try:\n                    func()\n                except Exception as e:\n                    logger.error(\n                        f\"Error calling {func.__qualname__} in on_commit() (%s).\",\n                        e,\n                        exc_info=True,\n                    )\n            else:\n                func()\n\n    def run_and_clear_commit_hooks(self):\n        self.validate_no_atomic_block()\n        current_run_on_commit = self.run_on_commit\n        self.run_on_commit = []\n        while current_run_on_commit:\n            _, func, robust = current_run_on_commit.pop(0)\n            if robust:\n                try:\n                    func()\n                except Exception as e:\n                    logger.error(\n                        f\"Error calling {func.__qualname__} in on_commit() during \"\n                        f\"transaction (%s).\",\n                        e,\n                        exc_info=True,\n                    )\n            else:\n                func()\n\n    @contextmanager\n    def execute_wrapper(self, wrapper):\n        \"\"\"\n        Return a context manager under which the wrapper is applied to suitable\n        database query executions.\n        \"\"\"\n        self.execute_wrappers.append(wrapper)\n        try:\n            yield\n        finally:\n            self.execute_wrappers.pop()\n\n    def copy(self, alias=None):\n        \"\"\"\n        Return a copy of this connection.\n\n        For tests that require two connections to the same database.\n        \"\"\"\n        settings_dict = copy.deepcopy(self.settings_dict)\n        if alias is None:\n            alias = self.alias\n        return type(self)(settings_dict, alias)",
                        "filename": "django/db/backends/base/base.py",
                        "start_index": 26082,
                        "end_index": 28387,
                        "start_line": 723,
                        "end_line": 788,
                        "max_line": 788,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the implementation of the on_commit method with the robust parameter and the run_and_clear_commit_hooks method which handles the execution of the on_commit callbacks. It is directly related to the issue of adding robustness to on_commit handlers."
                }
            ],
            "django/db/transaction.py": [
                {
                    "chunk": {
                        "code": "@contextmanager\ndef mark_for_rollback_on_error(using=None):\n    \"\"\"\n    Internal low-level utility to mark a transaction as \"needs rollback\" when\n    an exception is raised while not enforcing the enclosed block to be in a\n    transaction. This is needed by Model.save() and friends to avoid starting a\n    transaction when in autocommit mode and a single query is executed.\n\n    It's equivalent to:\n\n        connection = get_connection(using)\n        if connection.get_autocommit():\n            yield\n        else:\n            with transaction.atomic(using=using, savepoint=False):\n                yield\n\n    but it uses low-level utilities to avoid performance overhead.\n    \"\"\"\n    try:\n        yield\n    except Exception as exc:\n        connection = get_connection(using)\n        if connection.in_atomic_block:\n            connection.needs_rollback = True\n            connection.rollback_exc = exc\n        raise\n\n\ndef on_commit(func, using=None, robust=False):\n    \"\"\"\n    Register `func` to be called when the current transaction is committed.\n    If the current transaction is rolled back, `func` will not be called.\n    \"\"\"\n    get_connection(using).on_commit(func, robust)\n\n\n#################################\n# Decorators / context managers #\n#################################",
                        "filename": "django/db/transaction.py",
                        "start_index": 2672,
                        "end_index": 3956,
                        "start_line": 100,
                        "end_line": 139,
                        "max_line": 340,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the definition of the on_commit method in the transaction module, which is where the new robust parameter would be added according to the issue description."
                }
            ]
        },
        "solution_task": "To implement the feature of supporting robust `on_commit` handlers, you can follow these steps:\n\n- Modify the `on_commit` function in `django/db/transaction.py` to accept a new keyword argument `robust` with a default value of `False`.\n- Update the `on_commit` method in `django/db/backends/base/base.py` to handle the `robust` flag. When `robust` is `True`, wrap the function call in a `try-except` block to catch and log exceptions without re-raising them.\n- Ensure that the `run_and_clear_commit_hooks` method in `django/db/backends/base/base.py` also respects the `robust` flag when executing the stored `on_commit` functions after a transaction is committed.\n- Update the documentation and tests to reflect the new feature.\n\nHere is the modified code snippet for `django/db/backends/base/base.py`:\n\n```python\ndef on_commit(self, func, robust=False):\n    if not callable(func):\n        raise TypeError(\"on_commit()'s callback must be a callable.\")\n    if self.in_atomic_block:\n        # Transaction in progress; save for execution on commit.\n        self.run_on_commit.append((set(self.savepoint_ids), func, robust))\n    elif not self.get_autocommit():\n        raise TransactionManagementError(\n            \"on_commit() cannot be used in manual transaction management\"\n        )\n    else:\n        # No transaction in progress and in autocommit mode; execute immediately.\n        if robust:\n            try:\n                func()\n            except Exception as e:\n                logger.error(\n                    f\"Error calling {func.__qualname__} in on_commit() (%s).\",\n                    e,\n                    exc_info=True,\n                )\n        else:\n            func()\n\ndef run_and_clear_commit_hooks(self):\n    self.validate_no_atomic_block()\n    current_run_on_commit = self.run_on_commit\n    self.run_on_commit = []\n    while current_run_on_commit:\n        _, func, robust = current_run_on_commit.pop(0)\n        if robust:\n            try:\n                func()\n            except Exception as e:\n                logger.error(\n                    f\"Error calling {func.__qualname__} in on_commit() during \"\n                    f\"transaction (%s).\",\n                    e,\n                    exc_info=True,\n                )\n        else:\n            func()\n```\n\nAnd the modified `on_commit` function in `django/db/transaction.py`:\n\n```python\ndef on_commit(func, using=None, robust=False):\n    \"\"\"\n    Register `func` to be called when the current transaction is committed.\n    If the current transaction is rolled back, `func` will not be called.\n    \"\"\"\n    get_connection(using).on_commit(func, robust)\n```\n\nRemember to add unit tests to verify that:\n- Functions registered with `robust=True` do not cause the transaction to fail if they raise an exception.\n- Functions registered with `robust=False` (default behavior) behave as before, without swallowing exceptions.\n\nAlso, update the documentation to describe the new `robust` parameter for the `on_commit` function.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable plan for implementing the feature of robust `on_commit` handlers. It includes specific steps to modify the `on_commit` function and the `run_and_clear_commit_hooks` method, as well as code snippets that demonstrate how to handle the new `robust` keyword argument. The RESPONSE also advises updating documentation and tests, which is essential for the feature's integration and future maintenance. The only minor aspect not covered is the explicit mention of how to handle the logging of exceptions, which is implied but not detailed. However, this does not significantly detract from the overall utility of the RESPONSE.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711716205.993515,
        "result": "To implement the feature of supporting robust `on_commit` handlers, you can follow these steps:\n\n- Modify the `on_commit` function in `django/db/transaction.py` to accept a new keyword argument `robust` with a default value of `False`.\n- Update the `on_commit` method in `django/db/backends/base/base.py` to handle the `robust` flag. When `robust` is `True`, wrap the function call in a `try-except` block to catch and log exceptions without re-raising them.\n- Ensure that the `run_and_clear_commit_hooks` method in `django/db/backends/base/base.py` also respects the `robust` flag when executing the stored `on_commit` functions after a transaction is committed.\n- Update the documentation and tests to reflect the new feature.\n\nHere is the modified code snippet for `django/db/backends/base/base.py`:\n\n```python\ndef on_commit(self, func, robust=False):\n    if not callable(func):\n        raise TypeError(\"on_commit()'s callback must be a callable.\")\n    if self.in_atomic_block:\n        # Transaction in progress; save for execution on commit.\n        self.run_on_commit.append((set(self.savepoint_ids), func, robust))\n    elif not self.get_autocommit():\n        raise TransactionManagementError(\n            \"on_commit() cannot be used in manual transaction management\"\n        )\n    else:\n        # No transaction in progress and in autocommit mode; execute immediately.\n        if robust:\n            try:\n                func()\n            except Exception as e:\n                logger.error(\n                    f\"Error calling {func.__qualname__} in on_commit() (%s).\",\n                    e,\n                    exc_info=True,\n                )\n        else:\n            func()\n\ndef run_and_clear_commit_hooks(self):\n    self.validate_no_atomic_block()\n    current_run_on_commit = self.run_on_commit\n    self.run_on_commit = []\n    while current_run_on_commit:\n        _, func, robust = current_run_on_commit.pop(0)\n        if robust:\n            try:\n                func()\n            except Exception as e:\n                logger.error(\n                    f\"Error calling {func.__qualname__} in on_commit() during \"\n                    f\"transaction (%s).\",\n                    e,\n                    exc_info=True,\n                )\n        else:\n            func()\n```\n\nAnd the modified `on_commit` function in `django/db/transaction.py`:\n\n```python\ndef on_commit(func, using=None, robust=False):\n    \"\"\"\n    Register `func` to be called when the current transaction is committed.\n    If the current transaction is rolled back, `func` will not be called.\n    \"\"\"\n    get_connection(using).on_commit(func, robust)\n```\n\nRemember to add unit tests to verify that:\n- Functions registered with `robust=True` do not cause the transaction to fail if they raise an exception.\n- Functions registered with `robust=False` (default behavior) behave as before, without swallowing exceptions.\n\nAlso, update the documentation to describe the new `robust` parameter for the `on_commit` function.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [backends](https://github.com/testbed/django__django__4.2/tree//django/db/backends) \u2192 [base](https://github.com/testbed/django__django__4.2/tree//django/db/backends/base)- [Lines 723 - 788](https://github.com/testbed/django__django__4.2/blob//django/db/backends/base/base.py#L723-L788)\n\n This snippet contains the implementation of the on_commit method with the robust parameter and the run_and_clear_commit_hooks method which handles the execution of the on_commit callbacks. It is directly related to the issue of adding robustness to on_commit handlers.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db)- [Lines 100 - 139](https://github.com/testbed/django__django__4.2/blob//django/db/transaction.py#L100-L139)\n\n This snippet shows the definition of the on_commit method in the transaction module, which is where the new robust parameter would be added according to the issue description.",
        "context_relevance": 0.2800000000000001,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT and answer it completely to get a score of 10.\nSupporting Evidence: The RESPONSE provides a detailed explanation and steps on how to implement robust `on_commit` handlers, which is exactly what the PROMPT is asking for. It includes code modifications and the rationale behind them, aligning with the proposed feature in the PROMPT. The RESPONSE also addresses the need for documentation and testing, which is part of a complete answer to the PROMPT's request. Additionally, it provides relevant code snippets and their locations, which directly relate to the implementation details discussed in the PROMPT. The RESPONSE is comprehensive and fully addresses all aspects of the PROMPT."
        },
        "qa_relevance": 1.0
    }
}