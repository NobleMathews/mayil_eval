{
    "id": "pydata__xarray-5233",
    "repo_name": "testbed/pydata__xarray__0.12",
    "task_id": 5431719787462818517,
    "title": "Calendar utilities",
    "body": "**Is your feature request related to a problem? Please describe.**\r\nHandling cftime and numpy time coordinates can sometimes be exhausting. Here I am thinking of the following common problems:\r\n\r\n1. Querying the calendar type from a time coordinate.\r\n2. Converting a _dataset_ from a calendar type to another.\r\n3. Generating a time coordinate in the correct calendar. \r\n\r\n**Describe the solution you'd like**\r\n\r\n1. `ds.time.dt.calendar` would be magic.\r\n2.  `xr.convert_calendar(ds, \"new_cal\")` could be nice?\r\n3. `xr.date_range(start, stop, calendar=cal)`, same as pandas' (see context below).\r\n\r\n**Describe alternatives you've considered**\r\nWe have implemented all this in (xclim)[https://xclim.readthedocs.io/en/stable/api.html#calendar-handling-utilities] (and more). But it seems to make sense that some of the simplest things there could move to xarray? We had this discussion in xarray-contrib/cf-xarray#193  and suggestion was made to see what fits here before implementing this there.\r\n\r\n**Additional context**\r\nAt xclim, to differentiate numpy datetime64 from cftime types, we call the former \"default\". This way a time coordinate using cftime's \"proleptic_gregorian\" calendar is distinct from one using numpy's datetime64.\r\n\r\n1. is easy ([xclim function](https://xclim.readthedocs.io/en/stable/api.html#xclim.core.calendar.get_calendar)). If the datatype is numpy return \"default\", if cftime, look into the first non-null value and get the calendar.\r\n2. [xclim function](https://xclim.readthedocs.io/en/stable/api.html#xclim.core.calendar.convert_calendar) The calendar type of each time element is transformed to the new calendar. Our way is to _drop_ any dates that do not exist in the new calendar (like Feb 29th when going to \"noleap\"). In the other direction, there is an option to either fill with some fill value of simply _not_ include them. It can't be a DataArray method, but could be a Dataset one, or simply a top-level function.  Related to #5107.\r\n\r\nWe also have an [`interp_calendar`](https://xclim.readthedocs.io/en/stable/api.html#xclim.core.calendar.interp_calendar) function that reinterps data on a yearly basis. This is a bit narrower, because it only makes sense on daily data (or coarser).\r\n\r\n3. With the definition of a \"default\" calendar, [`date_range`](https://xclim.readthedocs.io/en/stable/api.html#xclim.core.calendar.date_range) and `date_range_like` simply chose between `pd.date_range` and `xr.cftime_range` according to the target calendar.\r\n\r\n\r\nWhat do you think? I have time to move whatever code makes sense to move.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pydata__xarray__0.12.git",
    "requested_commit": "",
    "mayil_response": "To implement the requested calendar utilities in the xarray project, you can follow these steps:\n\n1. **Querying the calendar type from a time coordinate:**\n   - Implement a property in the `DatetimeAccessor` class in `xarray/core/accessor_dt.py` to return the calendar type.\n   - Use the `infer_calendar_name` function from `xarray/coding/times.py` to determine the calendar type.\n\n```python\n# In xarray/core/accessor_dt.py\nclass DatetimeAccessor:\n    # ... existing code ...\n\n    @property\n    def calendar(self):\n        return infer_calendar_name(self._obj.data)\n```\n\n2. **Converting a dataset from one calendar type to another:**\n   - Implement a top-level function `convert_calendar` in `xarray/core/dataset.py` or a new module if appropriate.\n   - Use the existing logic from the `convert_calendar` function in `xarray/coding/calendar_ops.py` as a reference.\n\n```python\n# In xarray/core/dataset.py or a new module\ndef convert_calendar(ds, new_calendar):\n    # ... use logic from xarray/coding/calendar_ops.py ...\n    return converted_ds\n```\n\n3. **Generating a time coordinate in the correct calendar:**\n   - Implement a function `date_range` in `xarray/coding/cftime_offsets.py` or a new module if appropriate.\n   - Use the `date_range_like` function as a reference, which chooses between `pd.date_range` and `xr.cftime_range` based on the calendar.\n\n```python\n# In xarray/coding/cftime_offsets.py or a new module\ndef date_range(start, end, calendar='standard', freq='D', use_cftime=None):\n    # ... use logic from date_range_like ...\n    return date_range\n```\n\nFor each of these features, you should also include appropriate unit tests to ensure correctness and handle edge cases. The existing functions in `xarray/coding/calendar_ops.py` and `xarray/coding/cftime_offsets.py` can serve as a reference for handling different calendar types and the nuances of date conversion.\n\nRemember to handle dependencies correctly, such as importing necessary modules and handling cases where the `cftime` module might not be available.\n\nFinally, ensure that the new features are documented in the API documentation, including examples of how to use them.\n\n### Code snippets to check\n\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [core](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/core)- [Lines 1 - 140](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/core/accessor_dt.py#L1-L140)\n\n This snippet contains the datetime accessor implementations which would be relevant for adding new calendar utility functions such as 'ds.time.dt.calendar'.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 1 - 122](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/times.py#L1-L122)\n\n This snippet includes functions related to time units and calendars, which are essential for handling conversions between different calendar types. \n\n\n   - [Lines 345 - 405](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/times.py#L345-L405)\n\n This snippet includes functions for inferring calendar names and datetime units, which could be useful for querying the calendar type from a time coordinate.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 1 - 32](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/calendar_ops.py#L1-L32)\n\n This snippet contains calendar operations and could be relevant for implementing new calendar conversion functions. \n\n\n   - [Lines 147 - 343](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/calendar_ops.py#L147-L343)\n\n This snippet is part of the calendar operations file and includes logic for converting a dataset from one calendar type to another, which is directly related to the issue.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 1244 - 1311](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L1244-L1311)\n\n This snippet is about generating a datetime array in a different calendar, which is relevant for the issue's third point about generating a time coordinate in the correct calendar.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005495,
        "snippet_processor": 0.06112,
        "issue_star_creation": 0.025959999999999997,
        "issue_star_solver": 0.08023,
        "bouncer": 0.027180000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711759330.65728,
        "relevant_snippets": [
            {
                "code": "from __future__ import annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING, Generic\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.times import infer_calendar_name\nfrom xarray.core.common import (\n    _contains_datetime_like_objects,\n    is_np_datetime_like,\n    is_np_timedelta_like,\n)\nfrom xarray.core.pycompat import is_duck_dask_array\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.variable import IndexVariable\n\nif TYPE_CHECKING:\n    from numpy.typing import DTypeLike\n\n    from xarray.core.dataarray import DataArray\n    from xarray.core.dataset import Dataset\n    from xarray.core.types import CFCalendar\n\n\ndef _season_from_months(months):\n    \"\"\"Compute season (DJF, MAM, JJA, SON) from month ordinal\"\"\"\n    # TODO: Move \"season\" accessor upstream into pandas\n    seasons = np.array([\"DJF\", \"MAM\", \"JJA\", \"SON\", \"nan\"])\n    months = np.asarray(months)\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", message=\"invalid value encountered in floor_divide\"\n        )\n        warnings.filterwarnings(\n            \"ignore\", message=\"invalid value encountered in remainder\"\n        )\n        idx = (months // 3) % 4\n\n    idx[np.isnan(idx)] = 4\n    return seasons[idx.astype(int)]\n\n\ndef _access_through_cftimeindex(values, name):\n    \"\"\"Coerce an array of datetime-like values to a CFTimeIndex\n    and access requested datetime component\n    \"\"\"\n    from xarray.coding.cftimeindex import CFTimeIndex\n\n    if not isinstance(values, CFTimeIndex):\n        values_as_cftimeindex = CFTimeIndex(values.ravel())\n    else:\n        values_as_cftimeindex = values\n    if name == \"season\":\n        months = values_as_cftimeindex.month\n        field_values = _season_from_months(months)\n    elif name == \"date\":\n        raise AttributeError(\n            \"'CFTimeIndex' object has no attribute `date`. Consider using the floor method instead, for instance: `.time.dt.floor('D')`.\"\n        )\n    else:\n        field_values = getattr(values_as_cftimeindex, name)\n    return field_values.reshape(values.shape)\n\n\ndef _access_through_series(values, name):\n    \"\"\"Coerce an array of datetime-like values to a pandas Series and\n    access requested datetime component\n    \"\"\"\n    values_as_series = pd.Series(values.ravel(), copy=False)\n    if name == \"season\":\n        months = values_as_series.dt.month.values\n        field_values = _season_from_months(months)\n    elif name == \"isocalendar\":\n        # isocalendar returns iso- year, week, and weekday -> reshape\n        field_values = np.array(values_as_series.dt.isocalendar(), dtype=np.int64)\n        return field_values.T.reshape(3, *values.shape)\n    else:\n        field_values = getattr(values_as_series.dt, name).values\n    return field_values.reshape(values.shape)",
                "filename": "xarray/core/accessor_dt.py",
                "start_index": 0,
                "end_index": 2782,
                "start_line": 1,
                "end_line": 140,
                "max_line": 599,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from __future__ import annotations\n\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime, timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING, Callable, Union\n\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime, OutOfBoundsTimedelta\n\nfrom xarray.coding.variables import (\n    SerializationWarning,\n    VariableCoder,\n    lazy_elemwise_func,\n    pop_to,\n    safe_setitem,\n    unpack_for_decoding,\n    unpack_for_encoding,\n)\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes, is_np_datetime_like\nfrom xarray.core.formatting import first_n_items, format_timestamp, last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.pycompat import is_duck_dask_array\nfrom xarray.core.variable import Variable\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\nif TYPE_CHECKING:\n    from xarray.core.types import CFCalendar\n\n    T_Name = Union[Hashable, None]\n\n# standard calendars recognized by cftime\n_STANDARD_CALENDARS = {\"standard\", \"gregorian\", \"proleptic_gregorian\"}\n\n_NS_PER_TIME_DELTA = {\n    \"ns\": 1,\n    \"us\": int(1e3),\n    \"ms\": int(1e6),\n    \"s\": int(1e9),\n    \"m\": int(1e9) * 60,\n    \"h\": int(1e9) * 60 * 60,\n    \"D\": int(1e9) * 60 * 60 * 24,\n}\n\n_US_PER_TIME_DELTA = {\n    \"microseconds\": 1,\n    \"milliseconds\": 1_000,\n    \"seconds\": 1_000_000,\n    \"minutes\": 60 * 1_000_000,\n    \"hours\": 60 * 60 * 1_000_000,\n    \"days\": 24 * 60 * 60 * 1_000_000,\n}\n\n_NETCDF_TIME_UNITS_CFTIME = [\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"milliseconds\",\n    \"microseconds\",\n]\n\n_NETCDF_TIME_UNITS_NUMPY = _NETCDF_TIME_UNITS_CFTIME + [\"nanoseconds\"]\n\nTIME_UNITS = frozenset(\n    [\n        \"days\",\n        \"hours\",\n        \"minutes\",\n        \"seconds\",\n        \"milliseconds\",\n        \"microseconds\",\n        \"nanoseconds\",\n    ]\n)\n\n\ndef _is_standard_calendar(calendar: str) -> bool:\n    return calendar.lower() in _STANDARD_CALENDARS\n\n\ndef _is_numpy_compatible_time_range(times):\n    if is_np_datetime_like(times.dtype):\n        return True\n    # times array contains cftime objects\n    times = np.asarray(times)\n    tmin = times.min()\n    tmax = times.max()\n    try:\n        convert_time_or_go_back(tmin, pd.Timestamp)\n        convert_time_or_go_back(tmax, pd.Timestamp)\n    except pd.errors.OutOfBoundsDatetime:\n        return False\n    except ValueError as err:\n        if err.args[0] == \"year 0 is out of range\":\n            return False\n        raise\n    else:\n        return True\n\n\ndef _netcdf_to_numpy_timeunit(units: str) -> str:\n    units = units.lower()\n    if not units.endswith(\"s\"):\n        units = f\"{units}s\"\n    return {\n        \"nanoseconds\": \"ns\",\n        \"microseconds\": \"us\",\n        \"milliseconds\": \"ms\",\n        \"seconds\": \"s\",\n        \"minutes\": \"m\",\n        \"hours\": \"h\",\n        \"days\": \"D\",\n    }[units]",
                "filename": "xarray/coding/times.py",
                "start_index": 0,
                "end_index": 2910,
                "start_line": 1,
                "end_line": 122,
                "max_line": 762,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import numpy as np\n\nimport xarray as xr\n\nfrom . import parameterized\n\nNTIME = 365 * 30\n\n\n@parameterized([\"calendar\"], [(\"standard\", \"noleap\")])\nclass DateTimeAccessor:\n    def setup(self, calendar):\n        np.random.randn(NTIME)\n        time = xr.date_range(\"2000\", periods=30 * 365, calendar=calendar)\n        data = np.ones((NTIME,))\n        self.da = xr.DataArray(data, dims=\"time\", coords={\"time\": time})\n\n    def time_dayofyear(self, calendar):\n        self.da.time.dt.dayofyear\n\n    def time_year(self, calendar):\n        self.da.time.dt.year\n\n    def time_floor(self, calendar):\n        self.da.time.dt.floor(\"D\")",
                "filename": "asv_bench/benchmarks/accessors.py",
                "start_index": 0,
                "end_index": 621,
                "start_line": 1,
                "end_line": 25,
                "max_line": 25,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "name: \ud83d\udca1 Feature Request\ndescription: Suggest an idea for xarray\nlabels: [enhancement]\nbody:\n  - type: textarea\n    id: description\n    attributes:\n      label: Is your feature request related to a problem?\n      description: |\n        Please do a quick search of existing issues to make sure that this has not been asked before.\n        Please provide a clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\n    validations:\n      required: true\n  - type: textarea\n    id: solution\n    attributes:\n      label: Describe the solution you'd like\n      description: |\n        A clear and concise description of what you want to happen.\n  - type: textarea\n    id: alternatives\n    attributes:\n      label: Describe alternatives you've considered\n      description: |\n        A clear and concise description of any alternative solutions or features you've considered.\n    validations:\n      required: false\n  - type: textarea\n    id: additional-context\n    attributes:\n      label: Additional context\n      description: |\n        Add any other context about the feature request here.\n    validations:\n      required: false",
                "filename": ".github/ISSUE_TEMPLATE/newfeature.yml",
                "start_index": 0,
                "end_index": 1154,
                "start_line": 1,
                "end_line": 35,
                "max_line": 35,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "from __future__ import annotations\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.cftime_offsets import date_range_like, get_date_type\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.coding.times import _should_cftime_be_used, convert_times\nfrom xarray.core.common import _contains_datetime_like_objects, is_np_datetime_like\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\n\n_CALENDARS_WITHOUT_YEAR_ZERO = [\n    \"gregorian\",\n    \"proleptic_gregorian\",\n    \"julian\",\n    \"standard\",\n]\n\n\ndef _days_in_year(year, calendar, use_cftime=True):\n    \"\"\"Return the number of days in the input year according to the input calendar.\"\"\"\n    date_type = get_date_type(calendar, use_cftime=use_cftime)\n    if year == -1 and calendar in _CALENDARS_WITHOUT_YEAR_ZERO:\n        difference = date_type(year + 2, 1, 1) - date_type(year, 1, 1)\n    else:\n        difference = date_type(year + 1, 1, 1) - date_type(year, 1, 1)\n    return difference.days",
                "filename": "xarray/coding/calendar_ops.py",
                "start_index": 0,
                "end_index": 971,
                "start_line": 1,
                "end_line": 32,
                "max_line": 343,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from xarray.core.dataarray import DataArray\n\n    time = obj[dim]\n    if not _contains_datetime_like_objects(time.variable):\n        raise ValueError(f\"Coordinate {dim} must contain datetime objects.\")\n\n    use_cftime = _should_cftime_be_used(time, calendar, use_cftime)\n\n    source_calendar = time.dt.calendar\n    # Do nothing if request calendar is the same as the source\n    # AND source is np XOR use_cftime\n    if source_calendar == calendar and is_np_datetime_like(time.dtype) ^ use_cftime:\n        return obj\n\n    if (time.dt.year == 0).any() and calendar in _CALENDARS_WITHOUT_YEAR_ZERO:\n        raise ValueError(\n            f\"Source time coordinate contains dates with year 0, which is not supported by target calendar {calendar}.\"\n        )\n\n    if (source_calendar == \"360_day\" or calendar == \"360_day\") and align_on is None:\n        raise ValueError(\n            \"Argument `align_on` must be specified with either 'date' or \"\n            \"'year' when converting to or from a '360_day' calendar.\"\n        )\n\n    if source_calendar != \"360_day\" and calendar != \"360_day\":\n        align_on = \"date\"\n\n    out = obj.copy()\n\n    if align_on == \"year\":\n        # Special case for conversion involving 360_day calendar\n        # Instead of translating dates directly, this tries to keep the position within a year similar.\n\n        new_doy = time.groupby(f\"{dim}.year\").map(\n            _interpolate_day_of_year, target_calendar=calendar, use_cftime=use_cftime\n        )\n\n        # Convert the source datetimes, but override the day of year with our new day of years.\n        out[dim] = DataArray(\n            [\n                _convert_to_new_calendar_with_new_day_of_year(\n                    date, newdoy, calendar, use_cftime\n                )\n                for date, newdoy in zip(time.variable._data.array, new_doy)\n            ],\n            dims=(dim,),\n            name=dim,\n        )\n        # Remove duplicate timestamps, happens when reducing the number of days\n        out = out.isel({dim: np.unique(out[dim], return_index=True)[1]})\n    elif align_on == \"date\":\n        new_times = convert_times(\n            time.data,\n            get_date_type(calendar, use_cftime=use_cftime),\n            raise_on_invalid=False,\n        )\n        out[dim] = new_times\n\n        # Remove NaN that where put on invalid dates in target calendar\n        out = out.where(out[dim].notnull(), drop=True)\n\n    if missing is not None:\n        time_target = date_range_like(time, calendar=calendar, use_cftime=use_cftime)\n        out = out.reindex({dim: time_target}, fill_value=missing)\n\n    # Copy attrs but remove `calendar` if still present.\n    out[dim].attrs.update(time.attrs)\n    out[dim].attrs.pop(\"calendar\", None)\n    return out",
                "filename": "xarray/coding/calendar_ops.py",
                "start_index": 6525,
                "end_index": 9260,
                "start_line": 147,
                "end_line": 343,
                "max_line": 343,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "def _unit_timedelta_numpy(units: str) -> np.timedelta64:\n    numpy_units = _netcdf_to_numpy_timeunit(units)\n    return np.timedelta64(_NS_PER_TIME_DELTA[numpy_units], \"ns\")\n\n\ndef _infer_time_units_from_diff(unique_timedeltas) -> str:\n    unit_timedelta: Callable[[str], timedelta] | Callable[[str], np.timedelta64]\n    zero_timedelta: timedelta | np.timedelta64\n    if unique_timedeltas.dtype == np.dtype(\"O\"):\n        time_units = _NETCDF_TIME_UNITS_CFTIME\n        unit_timedelta = _unit_timedelta_cftime\n        zero_timedelta = timedelta(microseconds=0)\n    else:\n        time_units = _NETCDF_TIME_UNITS_NUMPY\n        unit_timedelta = _unit_timedelta_numpy\n        zero_timedelta = np.timedelta64(0, \"ns\")\n    for time_unit in time_units:\n        if np.all(unique_timedeltas % unit_timedelta(time_unit) == zero_timedelta):\n            return time_unit\n    return \"seconds\"\n\n\ndef infer_calendar_name(dates) -> CFCalendar:\n    \"\"\"Given an array of datetimes, infer the CF calendar name\"\"\"\n    if is_np_datetime_like(dates.dtype):\n        return \"proleptic_gregorian\"\n    elif dates.dtype == np.dtype(\"O\") and dates.size > 0:\n        # Logic copied from core.common.contains_cftime_datetimes.\n        if cftime is not None:\n            sample = np.asarray(dates).flat[0]\n            if is_duck_dask_array(sample):\n                sample = sample.compute()\n                if isinstance(sample, np.ndarray):\n                    sample = sample.item()\n            if isinstance(sample, cftime.datetime):\n                return sample.calendar\n\n    # Error raise if dtype is neither datetime or \"O\", if cftime is not importable, and if element of 'O' dtype is not cftime.\n    raise ValueError(\"Array does not contain datetime objects.\")\n\n\ndef infer_datetime_units(dates) -> str:\n    \"\"\"Given an array of datetimes, returns a CF compatible time-unit string of\n    the form \"{time_unit} since {date[0]}\", where `time_unit` is 'days',\n    'hours', 'minutes' or 'seconds' (the first one that can evenly divide all\n    unique time deltas in `dates`)\n    \"\"\"\n    dates = np.asarray(dates).ravel()\n    if np.asarray(dates).dtype == \"datetime64[ns]\":\n        dates = to_datetime_unboxed(dates)\n        dates = dates[pd.notnull(dates)]\n        reference_date = dates[0] if len(dates) > 0 else \"1970-01-01\"\n        # TODO: the strict enforcement of nanosecond precision Timestamps can be\n        # relaxed when addressing GitHub issue #7493.\n        reference_date = nanosecond_precision_timestamp(reference_date)\n    else:\n        reference_date = dates[0] if len(dates) > 0 else \"1970-01-01\"\n        reference_date = format_cftime_datetime(reference_date)\n    unique_timedeltas = np.unique(np.diff(dates))\n    units = _infer_time_units_from_diff(unique_timedeltas)\n    return f\"{units} since {reference_date}\"",
                "filename": "xarray/coding/times.py",
                "start_index": 11723,
                "end_index": 14521,
                "start_line": 345,
                "end_line": 405,
                "max_line": 762,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _parsed_string_to_bounds(date_type, resolution, parsed):\n    \"\"\"Generalization of\n    pandas.tseries.index.DatetimeIndex._parsed_string_to_bounds\n    for use with non-standard calendars and cftime.datetime\n    objects.\n    \"\"\"\n    if resolution == \"year\":\n        return (\n            date_type(parsed.year, 1, 1),\n            date_type(parsed.year + 1, 1, 1) - timedelta(microseconds=1),\n        )\n    elif resolution == \"month\":\n        if parsed.month == 12:\n            end = date_type(parsed.year + 1, 1, 1) - timedelta(microseconds=1)\n        else:\n            end = date_type(parsed.year, parsed.month + 1, 1) - timedelta(\n                microseconds=1\n            )\n        return date_type(parsed.year, parsed.month, 1), end\n    elif resolution == \"day\":\n        start = date_type(parsed.year, parsed.month, parsed.day)\n        return start, start + timedelta(days=1, microseconds=-1)\n    elif resolution == \"hour\":\n        start = date_type(parsed.year, parsed.month, parsed.day, parsed.hour)\n        return start, start + timedelta(hours=1, microseconds=-1)\n    elif resolution == \"minute\":\n        start = date_type(\n            parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute\n        )\n        return start, start + timedelta(minutes=1, microseconds=-1)\n    elif resolution == \"second\":\n        start = date_type(\n            parsed.year,\n            parsed.month,\n            parsed.day,\n            parsed.hour,\n            parsed.minute,\n            parsed.second,\n        )\n        return start, start + timedelta(seconds=1, microseconds=-1)\n    else:\n        raise KeyError\n\n\ndef get_date_field(datetimes, field):\n    \"\"\"Adapted from pandas.tslib.get_date_field\"\"\"\n    return np.array([getattr(date, field) for date in datetimes])\n\n\ndef _field_accessor(name, docstring=None, min_cftime_version=\"0.0\"):\n    \"\"\"Adapted from pandas.tseries.index._field_accessor\"\"\"\n\n    def f(self, min_cftime_version=min_cftime_version):\n        if cftime is None:\n            raise ModuleNotFoundError(\"No module named 'cftime'\")\n\n        if Version(cftime.__version__) >= Version(min_cftime_version):\n            return get_date_field(self._data, name)\n        else:\n            raise ImportError(\n                f\"The {name:!r} accessor requires a minimum \"\n                f\"version of cftime of {min_cftime_version}. Found an \"\n                f\"installed version of {cftime.__version__}.\"\n            )\n\n    f.__name__ = name\n    f.__doc__ = docstring\n    return property(f)\n\n\ndef get_date_type(self):\n    if self._data.size:\n        return type(self._data[0])\n    else:\n        return None",
                "filename": "xarray/coding/cftimeindex.py",
                "start_index": 4759,
                "end_index": 7378,
                "start_line": 144,
                "end_line": 218,
                "max_line": 859,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "e Dataset to another calendar.\n\n        Only converts the individual timestamps, does not modify any data except\n        in dropping invalid/surplus dates or inserting missing dates.\n\n        If the source and target calendars are either no_leap, all_leap or a\n        standard type, only the type of the time array is modified.\n        When converting to a leap year from a non-leap year, the 29th of February\n        is removed from the array. In the other direction the 29th of February\n        will be missing in the output, unless `missing` is specified,\n        in which case that value is inserted.\n\n        For conversions involving `360_day` calendars, see Notes.\n\n        This method is safe to use with sub-daily data as it doesn't touch the\n        time part of the timestamps.\n\n        Parameters\n        ---------\n        calendar : str\n            The target calendar name.\n        dim : Hashable, default: \"time\"\n            Name of the time coordinate.\n        align_on : {None, 'date', 'year'}, optional\n            Must be specified when either source or target is a `360_day` calendar,\n            ignored otherwise. See Notes.\n        missing : Any or None, optional\n            By default, i.e. if the value is None, this method will simply attempt\n            to convert the dates in the source calendar to the same dates in the\n            target calendar, and drop any of those that are not possible to\n            represent.  If a value is provided, a new time coordinate will be\n            created in the target calendar with the same frequency as the original\n            time coordinate; for any dates that are not present in the source, the\n            data will be filled with this value.  Note that using this mode requires\n            that the source data have an inferable frequency; for more information\n            see :py:func:`xarray.infer_freq`.  For certain frequency, source, and\n            target calendar combinations, this could result in many missing values, see notes.\n        use_cftime : bool or None, optional\n            Whether to use cftime objects in the output, only used if `calendar`\n            is one of {\"proleptic_gregorian\", \"gregorian\" or \"standard\"}.\n            If True, the new time axis uses cftime objects.\n            If None (default), it uses :py:class:`numpy.datetime64` values if the\n            date range permits it, and :py:class:`cftime.datetime` objects if not.\n            If False, it uses :py:class:`numpy.datetime64`  or fails.\n\n        Returns\n        -------\n        Dataset\n            Copy of the dataarray with the time coordinate converted to the\n            target calendar. If 'missing' was None (default), invalid dates in\n            the new calendar are dropped, but missing dates are not inserted.\n            If `missing` was given, the new data is reindexed to have a time axis\n            with the same frequency as the source, but in the new calendar; any\n            missing datapoints are filled with `missing`.\n\n        Notes\n        -----\n        Passing a value to `missing` is only usable if the source's time coordinate as an\n        inferable frequencies (see :py:func:`~xarray.infer_freq`) and is only appropriate\n        if the target coordinate, generated from this frequency, has dates equivalent to the\n        source. It is usually **not** appropriate to use this mode with:\n\n        - Period-end frequencies : 'A', 'Y', 'Q' or 'M', in opposition to 'AS' 'YS', 'QS' and 'MS'\n        - Sub-monthly frequencies that do not divide a day evenly : 'W', 'nD' where `N != 1`\n            or 'mH' where 24 % m != 0).\n\n        If one of the source or target calendars is `\"360_day\"`, `align_on` must\n        be specified and two options are offered.\n\n        - \"year\"\n            The dates are translated according to their relative position in the year,\n            ignoring their original month and day information, meaning that the\n            missing/surplus days are added/removed at regular intervals.\n\n            From a `360_day` to a standard calendar, the output will be missing the\n            following dates (day of year in parentheses):\n\n            To a leap year:\n                January 31st (31), March 31st (91), June 1st (153), July 31st (213),\n                September 31st (275) and November 30th (335).\n            To a non-leap year:\n                February 6th (36), April 19th (109), July 2nd (183),\n                September 12th (255), November 25th (329).\n\n            From a standard calendar to a `\"360_day\"`, the following dates in the\n            source array will be dropped:\n\n            From a leap year:\n                January 31st (31), April 1st (92), June 1st (153), August 1st (214),\n                September 31st (275), December 1st (336)\n            From a non-leap year:\n                February 6th (37), April 20th (110), July 2nd (183),\n                September 13th (256), November 25th (329)\n\n            This option is best used on daily and subdaily data.\n\n        - \"date\"\n            The month/day information is conserved and invalid dates are dropped\n            from the output. This means that when converting from a `\"360_day\"` to a\n            standard calendar, all 31st (Jan, March, May, July, August, October and\n            December) will be missing as there is no equivalent dates in the\n            `\"360_day\"` calendar and the 29th (on non-leap years) and 30th of February\n            will be dropped as there are no equivalent dates in a standard calendar.\n\n            This option is best used with data on a frequency coarser than daily.\n        \"\"\"\n        return conver",
                "filename": "xarray/core/dataset.py",
                "start_index": 370523,
                "end_index": 376171,
                "start_line": 9764,
                "end_line": 9870,
                "max_line": 10260,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Generate a datetime array with the same frequency, start and end as\n    another one, but in a different calendar.\n\n    Parameters\n    ----------\n    source : DataArray, CFTimeIndex, or pd.DatetimeIndex\n        1D datetime array\n    calendar : str\n        New calendar name.\n    use_cftime : bool, optional\n        If True, the output uses :py:class:`cftime.datetime` objects.\n        If None (default), :py:class:`numpy.datetime64` values are used if possible.\n        If False, :py:class:`numpy.datetime64` values are used or an error is raised.\n\n    Returns\n    -------\n    DataArray\n        1D datetime coordinate with the same start, end and frequency as the\n        source, but in the new calendar. The start date is assumed to exist in\n        the target calendar. If the end date doesn't exist, the code tries 1\n        and 2 calendar days before. There is a special case when the source time\n        series is daily or coarser and the end of the input range is on the\n        last day of the month. Then the output range will also end on the last\n        day of the month in the new calendar.\n    \"\"\"\n    from xarray.coding.frequencies import infer_freq\n    from xarray.core.dataarray import DataArray\n\n    if not isinstance(source, (pd.DatetimeIndex, CFTimeIndex)) and (\n        isinstance(source, DataArray)\n        and (source.ndim != 1)\n        or not _contains_datetime_like_objects(source.variable)\n    ):\n        raise ValueError(\n            \"'source' must be a 1D array of datetime objects for inferring its range.\"\n        )\n\n    freq = infer_freq(source)\n    if freq is None:\n        raise ValueError(\n            \"`date_range_like` was unable to generate a range as the source frequency was not inferable.\"\n        )\n\n    use_cftime = _should_cftime_be_used(source, calendar, use_cftime)\n\n    source_start = source.values.min()\n    source_end = source.values.max()\n    if is_np_datetime_like(source.dtype):\n        # We want to use datetime fields (datetime64 object don't have them)\n        source_calendar = \"standard\"\n        # TODO: the strict enforcement of nanosecond precision Timestamps can be\n        # relaxed when addressing GitHub issue #7493.\n        source_start = nanosecond_precision_timestamp(source_start)\n        source_end = nanosecond_precision_timestamp(source_end)\n    else:\n        if isinstance(source, CFTimeIndex):\n            source_calendar = source.calendar\n        else:  # DataArray\n            source_calendar = source.dt.calendar\n\n    if calendar == source_calendar and is_np_datetime_like(source.dtype) ^ use_cftime:\n        return source\n\n    date_type = get_date_type(calendar, use_cftime)\n    start = convert_time_or_go_back(source_start, date_type)\n    end = convert_time_or_go_back(source_end, date_type)\n\n    # For the cases where the source ends on the end of the month, we expect the same in the new calendar.",
                "filename": "xarray/coding/cftime_offsets.py",
                "start_index": 44080,
                "end_index": 46955,
                "start_line": 1244,
                "end_line": 1311,
                "max_line": 1322,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 1.0
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "xarray/core/accessor_dt.py": [
                {
                    "chunk": {
                        "code": "from __future__ import annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING, Generic\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.times import infer_calendar_name\nfrom xarray.core.common import (\n    _contains_datetime_like_objects,\n    is_np_datetime_like,\n    is_np_timedelta_like,\n)\nfrom xarray.core.pycompat import is_duck_dask_array\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.variable import IndexVariable\n\nif TYPE_CHECKING:\n    from numpy.typing import DTypeLike\n\n    from xarray.core.dataarray import DataArray\n    from xarray.core.dataset import Dataset\n    from xarray.core.types import CFCalendar\n\n\ndef _season_from_months(months):\n    \"\"\"Compute season (DJF, MAM, JJA, SON) from month ordinal\"\"\"\n    # TODO: Move \"season\" accessor upstream into pandas\n    seasons = np.array([\"DJF\", \"MAM\", \"JJA\", \"SON\", \"nan\"])\n    months = np.asarray(months)\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", message=\"invalid value encountered in floor_divide\"\n        )\n        warnings.filterwarnings(\n            \"ignore\", message=\"invalid value encountered in remainder\"\n        )\n        idx = (months // 3) % 4\n\n    idx[np.isnan(idx)] = 4\n    return seasons[idx.astype(int)]\n\n\ndef _access_through_cftimeindex(values, name):\n    \"\"\"Coerce an array of datetime-like values to a CFTimeIndex\n    and access requested datetime component\n    \"\"\"\n    from xarray.coding.cftimeindex import CFTimeIndex\n\n    if not isinstance(values, CFTimeIndex):\n        values_as_cftimeindex = CFTimeIndex(values.ravel())\n    else:\n        values_as_cftimeindex = values\n    if name == \"season\":\n        months = values_as_cftimeindex.month\n        field_values = _season_from_months(months)\n    elif name == \"date\":\n        raise AttributeError(\n            \"'CFTimeIndex' object has no attribute `date`. Consider using the floor method instead, for instance: `.time.dt.floor('D')`.\"\n        )\n    else:\n        field_values = getattr(values_as_cftimeindex, name)\n    return field_values.reshape(values.shape)\n\n\ndef _access_through_series(values, name):\n    \"\"\"Coerce an array of datetime-like values to a pandas Series and\n    access requested datetime component\n    \"\"\"\n    values_as_series = pd.Series(values.ravel(), copy=False)\n    if name == \"season\":\n        months = values_as_series.dt.month.values\n        field_values = _season_from_months(months)\n    elif name == \"isocalendar\":\n        # isocalendar returns iso- year, week, and weekday -> reshape\n        field_values = np.array(values_as_series.dt.isocalendar(), dtype=np.int64)\n        return field_values.T.reshape(3, *values.shape)\n    else:\n        field_values = getattr(values_as_series.dt, name).values\n    return field_values.reshape(values.shape)",
                        "filename": "xarray/core/accessor_dt.py",
                        "start_index": 0,
                        "end_index": 2782,
                        "start_line": 1,
                        "end_line": 140,
                        "max_line": 599,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the datetime accessor implementations which would be relevant for adding new calendar utility functions such as 'ds.time.dt.calendar'."
                }
            ],
            "xarray/coding/times.py": [
                {
                    "chunk": {
                        "code": "from __future__ import annotations\n\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime, timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING, Callable, Union\n\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime, OutOfBoundsTimedelta\n\nfrom xarray.coding.variables import (\n    SerializationWarning,\n    VariableCoder,\n    lazy_elemwise_func,\n    pop_to,\n    safe_setitem,\n    unpack_for_decoding,\n    unpack_for_encoding,\n)\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes, is_np_datetime_like\nfrom xarray.core.formatting import first_n_items, format_timestamp, last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.pycompat import is_duck_dask_array\nfrom xarray.core.variable import Variable\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\nif TYPE_CHECKING:\n    from xarray.core.types import CFCalendar\n\n    T_Name = Union[Hashable, None]\n\n# standard calendars recognized by cftime\n_STANDARD_CALENDARS = {\"standard\", \"gregorian\", \"proleptic_gregorian\"}\n\n_NS_PER_TIME_DELTA = {\n    \"ns\": 1,\n    \"us\": int(1e3),\n    \"ms\": int(1e6),\n    \"s\": int(1e9),\n    \"m\": int(1e9) * 60,\n    \"h\": int(1e9) * 60 * 60,\n    \"D\": int(1e9) * 60 * 60 * 24,\n}\n\n_US_PER_TIME_DELTA = {\n    \"microseconds\": 1,\n    \"milliseconds\": 1_000,\n    \"seconds\": 1_000_000,\n    \"minutes\": 60 * 1_000_000,\n    \"hours\": 60 * 60 * 1_000_000,\n    \"days\": 24 * 60 * 60 * 1_000_000,\n}\n\n_NETCDF_TIME_UNITS_CFTIME = [\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"milliseconds\",\n    \"microseconds\",\n]\n\n_NETCDF_TIME_UNITS_NUMPY = _NETCDF_TIME_UNITS_CFTIME + [\"nanoseconds\"]\n\nTIME_UNITS = frozenset(\n    [\n        \"days\",\n        \"hours\",\n        \"minutes\",\n        \"seconds\",\n        \"milliseconds\",\n        \"microseconds\",\n        \"nanoseconds\",\n    ]\n)\n\n\ndef _is_standard_calendar(calendar: str) -> bool:\n    return calendar.lower() in _STANDARD_CALENDARS\n\n\ndef _is_numpy_compatible_time_range(times):\n    if is_np_datetime_like(times.dtype):\n        return True\n    # times array contains cftime objects\n    times = np.asarray(times)\n    tmin = times.min()\n    tmax = times.max()\n    try:\n        convert_time_or_go_back(tmin, pd.Timestamp)\n        convert_time_or_go_back(tmax, pd.Timestamp)\n    except pd.errors.OutOfBoundsDatetime:\n        return False\n    except ValueError as err:\n        if err.args[0] == \"year 0 is out of range\":\n            return False\n        raise\n    else:\n        return True\n\n\ndef _netcdf_to_numpy_timeunit(units: str) -> str:\n    units = units.lower()\n    if not units.endswith(\"s\"):\n        units = f\"{units}s\"\n    return {\n        \"nanoseconds\": \"ns\",\n        \"microseconds\": \"us\",\n        \"milliseconds\": \"ms\",\n        \"seconds\": \"s\",\n        \"minutes\": \"m\",\n        \"hours\": \"h\",\n        \"days\": \"D\",\n    }[units]",
                        "filename": "xarray/coding/times.py",
                        "start_index": 0,
                        "end_index": 2910,
                        "start_line": 1,
                        "end_line": 122,
                        "max_line": 762,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes functions related to time units and calendars, which are essential for handling conversions between different calendar types."
                },
                {
                    "chunk": {
                        "code": "def _unit_timedelta_numpy(units: str) -> np.timedelta64:\n    numpy_units = _netcdf_to_numpy_timeunit(units)\n    return np.timedelta64(_NS_PER_TIME_DELTA[numpy_units], \"ns\")\n\n\ndef _infer_time_units_from_diff(unique_timedeltas) -> str:\n    unit_timedelta: Callable[[str], timedelta] | Callable[[str], np.timedelta64]\n    zero_timedelta: timedelta | np.timedelta64\n    if unique_timedeltas.dtype == np.dtype(\"O\"):\n        time_units = _NETCDF_TIME_UNITS_CFTIME\n        unit_timedelta = _unit_timedelta_cftime\n        zero_timedelta = timedelta(microseconds=0)\n    else:\n        time_units = _NETCDF_TIME_UNITS_NUMPY\n        unit_timedelta = _unit_timedelta_numpy\n        zero_timedelta = np.timedelta64(0, \"ns\")\n    for time_unit in time_units:\n        if np.all(unique_timedeltas % unit_timedelta(time_unit) == zero_timedelta):\n            return time_unit\n    return \"seconds\"\n\n\ndef infer_calendar_name(dates) -> CFCalendar:\n    \"\"\"Given an array of datetimes, infer the CF calendar name\"\"\"\n    if is_np_datetime_like(dates.dtype):\n        return \"proleptic_gregorian\"\n    elif dates.dtype == np.dtype(\"O\") and dates.size > 0:\n        # Logic copied from core.common.contains_cftime_datetimes.\n        if cftime is not None:\n            sample = np.asarray(dates).flat[0]\n            if is_duck_dask_array(sample):\n                sample = sample.compute()\n                if isinstance(sample, np.ndarray):\n                    sample = sample.item()\n            if isinstance(sample, cftime.datetime):\n                return sample.calendar\n\n    # Error raise if dtype is neither datetime or \"O\", if cftime is not importable, and if element of 'O' dtype is not cftime.\n    raise ValueError(\"Array does not contain datetime objects.\")\n\n\ndef infer_datetime_units(dates) -> str:\n    \"\"\"Given an array of datetimes, returns a CF compatible time-unit string of\n    the form \"{time_unit} since {date[0]}\", where `time_unit` is 'days',\n    'hours', 'minutes' or 'seconds' (the first one that can evenly divide all\n    unique time deltas in `dates`)\n    \"\"\"\n    dates = np.asarray(dates).ravel()\n    if np.asarray(dates).dtype == \"datetime64[ns]\":\n        dates = to_datetime_unboxed(dates)\n        dates = dates[pd.notnull(dates)]\n        reference_date = dates[0] if len(dates) > 0 else \"1970-01-01\"\n        # TODO: the strict enforcement of nanosecond precision Timestamps can be\n        # relaxed when addressing GitHub issue #7493.\n        reference_date = nanosecond_precision_timestamp(reference_date)\n    else:\n        reference_date = dates[0] if len(dates) > 0 else \"1970-01-01\"\n        reference_date = format_cftime_datetime(reference_date)\n    unique_timedeltas = np.unique(np.diff(dates))\n    units = _infer_time_units_from_diff(unique_timedeltas)\n    return f\"{units} since {reference_date}\"",
                        "filename": "xarray/coding/times.py",
                        "start_index": 11723,
                        "end_index": 14521,
                        "start_line": 345,
                        "end_line": 405,
                        "max_line": 762,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes functions for inferring calendar names and datetime units, which could be useful for querying the calendar type from a time coordinate."
                }
            ],
            "xarray/coding/calendar_ops.py": [
                {
                    "chunk": {
                        "code": "from __future__ import annotations\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.cftime_offsets import date_range_like, get_date_type\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.coding.times import _should_cftime_be_used, convert_times\nfrom xarray.core.common import _contains_datetime_like_objects, is_np_datetime_like\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\n\n_CALENDARS_WITHOUT_YEAR_ZERO = [\n    \"gregorian\",\n    \"proleptic_gregorian\",\n    \"julian\",\n    \"standard\",\n]\n\n\ndef _days_in_year(year, calendar, use_cftime=True):\n    \"\"\"Return the number of days in the input year according to the input calendar.\"\"\"\n    date_type = get_date_type(calendar, use_cftime=use_cftime)\n    if year == -1 and calendar in _CALENDARS_WITHOUT_YEAR_ZERO:\n        difference = date_type(year + 2, 1, 1) - date_type(year, 1, 1)\n    else:\n        difference = date_type(year + 1, 1, 1) - date_type(year, 1, 1)\n    return difference.days",
                        "filename": "xarray/coding/calendar_ops.py",
                        "start_index": 0,
                        "end_index": 971,
                        "start_line": 1,
                        "end_line": 32,
                        "max_line": 343,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains calendar operations and could be relevant for implementing new calendar conversion functions."
                },
                {
                    "chunk": {
                        "code": "from xarray.core.dataarray import DataArray\n\n    time = obj[dim]\n    if not _contains_datetime_like_objects(time.variable):\n        raise ValueError(f\"Coordinate {dim} must contain datetime objects.\")\n\n    use_cftime = _should_cftime_be_used(time, calendar, use_cftime)\n\n    source_calendar = time.dt.calendar\n    # Do nothing if request calendar is the same as the source\n    # AND source is np XOR use_cftime\n    if source_calendar == calendar and is_np_datetime_like(time.dtype) ^ use_cftime:\n        return obj\n\n    if (time.dt.year == 0).any() and calendar in _CALENDARS_WITHOUT_YEAR_ZERO:\n        raise ValueError(\n            f\"Source time coordinate contains dates with year 0, which is not supported by target calendar {calendar}.\"\n        )\n\n    if (source_calendar == \"360_day\" or calendar == \"360_day\") and align_on is None:\n        raise ValueError(\n            \"Argument `align_on` must be specified with either 'date' or \"\n            \"'year' when converting to or from a '360_day' calendar.\"\n        )\n\n    if source_calendar != \"360_day\" and calendar != \"360_day\":\n        align_on = \"date\"\n\n    out = obj.copy()\n\n    if align_on == \"year\":\n        # Special case for conversion involving 360_day calendar\n        # Instead of translating dates directly, this tries to keep the position within a year similar.\n\n        new_doy = time.groupby(f\"{dim}.year\").map(\n            _interpolate_day_of_year, target_calendar=calendar, use_cftime=use_cftime\n        )\n\n        # Convert the source datetimes, but override the day of year with our new day of years.\n        out[dim] = DataArray(\n            [\n                _convert_to_new_calendar_with_new_day_of_year(\n                    date, newdoy, calendar, use_cftime\n                )\n                for date, newdoy in zip(time.variable._data.array, new_doy)\n            ],\n            dims=(dim,),\n            name=dim,\n        )\n        # Remove duplicate timestamps, happens when reducing the number of days\n        out = out.isel({dim: np.unique(out[dim], return_index=True)[1]})\n    elif align_on == \"date\":\n        new_times = convert_times(\n            time.data,\n            get_date_type(calendar, use_cftime=use_cftime),\n            raise_on_invalid=False,\n        )\n        out[dim] = new_times\n\n        # Remove NaN that where put on invalid dates in target calendar\n        out = out.where(out[dim].notnull(), drop=True)\n\n    if missing is not None:\n        time_target = date_range_like(time, calendar=calendar, use_cftime=use_cftime)\n        out = out.reindex({dim: time_target}, fill_value=missing)\n\n    # Copy attrs but remove `calendar` if still present.\n    out[dim].attrs.update(time.attrs)\n    out[dim].attrs.pop(\"calendar\", None)\n    return out",
                        "filename": "xarray/coding/calendar_ops.py",
                        "start_index": 6525,
                        "end_index": 9260,
                        "start_line": 147,
                        "end_line": 343,
                        "max_line": 343,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the calendar operations file and includes logic for converting a dataset from one calendar type to another, which is directly related to the issue."
                }
            ],
            "xarray/coding/cftime_offsets.py": [
                {
                    "chunk": {
                        "code": "\"\"\"Generate a datetime array with the same frequency, start and end as\n    another one, but in a different calendar.\n\n    Parameters\n    ----------\n    source : DataArray, CFTimeIndex, or pd.DatetimeIndex\n        1D datetime array\n    calendar : str\n        New calendar name.\n    use_cftime : bool, optional\n        If True, the output uses :py:class:`cftime.datetime` objects.\n        If None (default), :py:class:`numpy.datetime64` values are used if possible.\n        If False, :py:class:`numpy.datetime64` values are used or an error is raised.\n\n    Returns\n    -------\n    DataArray\n        1D datetime coordinate with the same start, end and frequency as the\n        source, but in the new calendar. The start date is assumed to exist in\n        the target calendar. If the end date doesn't exist, the code tries 1\n        and 2 calendar days before. There is a special case when the source time\n        series is daily or coarser and the end of the input range is on the\n        last day of the month. Then the output range will also end on the last\n        day of the month in the new calendar.\n    \"\"\"\n    from xarray.coding.frequencies import infer_freq\n    from xarray.core.dataarray import DataArray\n\n    if not isinstance(source, (pd.DatetimeIndex, CFTimeIndex)) and (\n        isinstance(source, DataArray)\n        and (source.ndim != 1)\n        or not _contains_datetime_like_objects(source.variable)\n    ):\n        raise ValueError(\n            \"'source' must be a 1D array of datetime objects for inferring its range.\"\n        )\n\n    freq = infer_freq(source)\n    if freq is None:\n        raise ValueError(\n            \"`date_range_like` was unable to generate a range as the source frequency was not inferable.\"\n        )\n\n    use_cftime = _should_cftime_be_used(source, calendar, use_cftime)\n\n    source_start = source.values.min()\n    source_end = source.values.max()\n    if is_np_datetime_like(source.dtype):\n        # We want to use datetime fields (datetime64 object don't have them)\n        source_calendar = \"standard\"\n        # TODO: the strict enforcement of nanosecond precision Timestamps can be\n        # relaxed when addressing GitHub issue #7493.\n        source_start = nanosecond_precision_timestamp(source_start)\n        source_end = nanosecond_precision_timestamp(source_end)\n    else:\n        if isinstance(source, CFTimeIndex):\n            source_calendar = source.calendar\n        else:  # DataArray\n            source_calendar = source.dt.calendar\n\n    if calendar == source_calendar and is_np_datetime_like(source.dtype) ^ use_cftime:\n        return source\n\n    date_type = get_date_type(calendar, use_cftime)\n    start = convert_time_or_go_back(source_start, date_type)\n    end = convert_time_or_go_back(source_end, date_type)\n\n    # For the cases where the source ends on the end of the month, we expect the same in the new calendar.",
                        "filename": "xarray/coding/cftime_offsets.py",
                        "start_index": 44080,
                        "end_index": 46955,
                        "start_line": 1244,
                        "end_line": 1311,
                        "max_line": 1322,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is about generating a datetime array in a different calendar, which is relevant for the issue's third point about generating a time coordinate in the correct calendar."
                }
            ]
        },
        "solution_task": "To implement the requested calendar utilities in the xarray project, you can follow these steps:\n\n1. **Querying the calendar type from a time coordinate:**\n   - Implement a property in the `DatetimeAccessor` class in `xarray/core/accessor_dt.py` to return the calendar type.\n   - Use the `infer_calendar_name` function from `xarray/coding/times.py` to determine the calendar type.\n\n```python\n# In xarray/core/accessor_dt.py\nclass DatetimeAccessor:\n    # ... existing code ...\n\n    @property\n    def calendar(self):\n        return infer_calendar_name(self._obj.data)\n```\n\n2. **Converting a dataset from one calendar type to another:**\n   - Implement a top-level function `convert_calendar` in `xarray/core/dataset.py` or a new module if appropriate.\n   - Use the existing logic from the `convert_calendar` function in `xarray/coding/calendar_ops.py` as a reference.\n\n```python\n# In xarray/core/dataset.py or a new module\ndef convert_calendar(ds, new_calendar):\n    # ... use logic from xarray/coding/calendar_ops.py ...\n    return converted_ds\n```\n\n3. **Generating a time coordinate in the correct calendar:**\n   - Implement a function `date_range` in `xarray/coding/cftime_offsets.py` or a new module if appropriate.\n   - Use the `date_range_like` function as a reference, which chooses between `pd.date_range` and `xr.cftime_range` based on the calendar.\n\n```python\n# In xarray/coding/cftime_offsets.py or a new module\ndef date_range(start, end, calendar='standard', freq='D', use_cftime=None):\n    # ... use logic from date_range_like ...\n    return date_range\n```\n\nFor each of these features, you should also include appropriate unit tests to ensure correctness and handle edge cases. The existing functions in `xarray/coding/calendar_ops.py` and `xarray/coding/cftime_offsets.py` can serve as a reference for handling different calendar types and the nuances of date conversion.\n\nRemember to handle dependencies correctly, such as importing necessary modules and handling cases where the `cftime` module might not be available.\n\nFinally, ensure that the new features are documented in the API documentation, including examples of how to use them.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable plan for implementing the requested calendar utilities in the xarray project. It addresses all three aspects of the feature request with specific code examples and guidance on where to implement the changes within the xarray codebase. The RESPONSE also includes references to existing functions that can be used as a starting point, which shows a deep understanding of the xarray project and its code structure. Additionally, the RESPONSE suggests including unit tests and documentation for the new features, which is crucial for maintaining code quality and usability. The only reason it does not score a 10 is that it does not explicitly mention how to handle the edge cases mentioned in the prompt, such as dates that do not exist in the new calendar when converting calendar types.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711759466.915026,
        "result": "To implement the requested calendar utilities in the xarray project, you can follow these steps:\n\n1. **Querying the calendar type from a time coordinate:**\n   - Implement a property in the `DatetimeAccessor` class in `xarray/core/accessor_dt.py` to return the calendar type.\n   - Use the `infer_calendar_name` function from `xarray/coding/times.py` to determine the calendar type.\n\n```python\n# In xarray/core/accessor_dt.py\nclass DatetimeAccessor:\n    # ... existing code ...\n\n    @property\n    def calendar(self):\n        return infer_calendar_name(self._obj.data)\n```\n\n2. **Converting a dataset from one calendar type to another:**\n   - Implement a top-level function `convert_calendar` in `xarray/core/dataset.py` or a new module if appropriate.\n   - Use the existing logic from the `convert_calendar` function in `xarray/coding/calendar_ops.py` as a reference.\n\n```python\n# In xarray/core/dataset.py or a new module\ndef convert_calendar(ds, new_calendar):\n    # ... use logic from xarray/coding/calendar_ops.py ...\n    return converted_ds\n```\n\n3. **Generating a time coordinate in the correct calendar:**\n   - Implement a function `date_range` in `xarray/coding/cftime_offsets.py` or a new module if appropriate.\n   - Use the `date_range_like` function as a reference, which chooses between `pd.date_range` and `xr.cftime_range` based on the calendar.\n\n```python\n# In xarray/coding/cftime_offsets.py or a new module\ndef date_range(start, end, calendar='standard', freq='D', use_cftime=None):\n    # ... use logic from date_range_like ...\n    return date_range\n```\n\nFor each of these features, you should also include appropriate unit tests to ensure correctness and handle edge cases. The existing functions in `xarray/coding/calendar_ops.py` and `xarray/coding/cftime_offsets.py` can serve as a reference for handling different calendar types and the nuances of date conversion.\n\nRemember to handle dependencies correctly, such as importing necessary modules and handling cases where the `cftime` module might not be available.\n\nFinally, ensure that the new features are documented in the API documentation, including examples of how to use them.\n\n### Code snippets to check\n\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [core](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/core)- [Lines 1 - 140](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/core/accessor_dt.py#L1-L140)\n\n This snippet contains the datetime accessor implementations which would be relevant for adding new calendar utility functions such as 'ds.time.dt.calendar'.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 1 - 122](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/times.py#L1-L122)\n\n This snippet includes functions related to time units and calendars, which are essential for handling conversions between different calendar types. \n\n\n   - [Lines 345 - 405](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/times.py#L345-L405)\n\n This snippet includes functions for inferring calendar names and datetime units, which could be useful for querying the calendar type from a time coordinate.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 1 - 32](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/calendar_ops.py#L1-L32)\n\n This snippet contains calendar operations and could be relevant for implementing new calendar conversion functions. \n\n\n   - [Lines 147 - 343](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/calendar_ops.py#L147-L343)\n\n This snippet is part of the calendar operations file and includes logic for converting a dataset from one calendar type to another, which is directly related to the issue.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 1244 - 1311](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L1244-L1311)\n\n This snippet is about generating a datetime array in a different calendar, which is relevant for the issue's third point about generating a time coordinate in the correct calendar.",
        "context_relevance": 0.44000000000000006,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE provides a relevant and complete answer to the entire PROMPT.\nSupporting Evidence: The RESPONSE directly addresses the feature request related to calendar utilities by providing detailed steps and code snippets for implementing the desired functionalities in the xarray project. It covers all three common problems listed in the PROMPT: querying the calendar type, converting a dataset from one calendar type to another, and generating a time coordinate in the correct calendar. The RESPONSE also includes references to existing functions and modules within the xarray library that are relevant to the feature request, demonstrating a thorough understanding of the project's structure and the necessary changes. Additionally, the RESPONSE suggests including unit tests, handling dependencies, and updating documentation, which are all critical aspects of feature development. The RESPONSE is fully relevant to the entire PROMPT and answers it completely, thus deserving a score of 10."
        },
        "qa_relevance": 1.0
    }
}