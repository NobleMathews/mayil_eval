{
    "id": "matplotlib__matplotlib-26466",
    "repo_name": "testbed/matplotlib__matplotlib__3.7",
    "task_id": 7196377197303958175,
    "title": "Updating an array passed as the xy parameter to annotate updates the anottation",
    "body": "### Bug report\r\n\r\n**Bug summary**\r\nWhen an array is used as the _xy_ kwarg for an annotation that includes arrows, changing the array after calling the function changes the arrow position. It is very likely that the same array is kept instead of a copy.\r\n\r\n**Code for reproduction**\r\n\r\n\r\n```python\r\nfig = plt.figure(\"test\")\r\n\r\nax = fig.add_axes([0.13, 0.15, .8, .8])\r\nax.set_xlim(-5, 5)\r\nax.set_ylim(-3, 3)\r\n\r\nxy_0 =np.array((-4, 1))\r\nxy_f =np.array((-1, 1))\r\n# this annotation is messed by later changing the array passed as xy kwarg\r\nax.annotate(s='', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))\r\nxy_0[1] = 3# <--this  updates the arrow position\r\n\r\nxy_0 =np.array((1, 1))\r\nxy_f =np.array((4, 1))\r\n# using a copy of the array helps spoting where the problem is\r\nax.annotate(s='', xy=xy_0.copy(), xytext=xy_f, arrowprops=dict(arrowstyle='<->'))\r\nxy_0[1] = 3\r\n```\r\n\r\n**Actual outcome**\r\n\r\n![bug](https://user-images.githubusercontent.com/45225345/83718413-5d656a80-a60b-11ea-8ef0-a1a18337de28.png)\r\n\r\n**Expected outcome**\r\nBoth arrows should be horizontal\r\n\r\n**Matplotlib version**\r\n  * Operating system: Debian 9\r\n  * Matplotlib version: '3.0.3'\r\n  * Matplotlib backend: Qt5Agg\r\n  * Python version:'3.5.3'\r\n  * Jupyter version (if applicable):\r\n  * Other libraries: Numpy 1.17.3\r\n\r\nMatplotlib was installed using pip\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.7.git",
    "requested_commit": "",
    "mayil_response": "To resolve the issue where changing `xy_0` after calling `annotate` updates the arrow position, and to ensure that arrows remain horizontal and unaffected by changes to `xy_0` after the annotation is created, you should make a copy of the `xy` parameter inside the `annotate` function before using it. This will prevent the original data from being altered due to the mutability of numpy arrays when they are passed as arguments.\n\nHere is the solution:\n\n- Modify the `annotate` function to create a copy of the `xy` parameter.\n- Use `np.array(xy, copy=True)` to ensure a copy is made if `xy` is a numpy array.\n\nExample code change:\n\n```python\nimport numpy as np\n\ndef annotate(s, xy, xytext=None, arrowprops=None):\n    # ... existing code ...\n\n    # Ensure xy is copied to prevent reference issues\n    xy = np.array(xy, copy=True)\n\n    # ... rest of the function ...\n```\n\nApply this change wherever the `annotate` function is defined or before any call to `annotate` where `xy` is expected to be a mutable object like a numpy array.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib)- [Lines 1404 - 1455](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/offsetbox.py#L1404-L1455)\n\n This snippet contains the update_positions method in offsetbox.py, which is responsible for updating the positions of annotations, including arrows. The issue may be related to how the arrow positions are updated after the initial draw, which is handled in this method.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002305,
        "snippet_processor": 0.06133,
        "issue_star_solver": 0.06913,
        "issue_star_creation": 0.02505,
        "bouncer": 0.02653
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711695549.453561,
        "relevant_snippets": [
            {
                "code": "# Customizing arrow and bubble styles\n# -----------------------------------\n#\n# The arrow between *xytext* and the annotation point, as well as the bubble\n# that covers the annotation text, are highly customizable. Below are a few\n# parameter options as well as their resulting output.\n\nfig, ax = plt.subplots(figsize=(8, 5))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=3)\n\nax.annotate(\n    'straight',\n    xy=(0, 1), xycoords='data',\n    xytext=(-50, 30), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\"))\nax.annotate(\n    'arc3,\\nrad 0.2',\n    xy=(0.5, -1), xycoords='data',\n    xytext=(-80, -60), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"arc3,rad=.2\"))\nax.annotate(\n    'arc,\\nangle 50',\n    xy=(1., 1), xycoords='data',\n    xytext=(-90, 50), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"arc,angleA=0,armA=50,rad=10\"))\nax.annotate(\n    'arc,\\narms',\n    xy=(1.5, -1), xycoords='data',\n    xytext=(-80, -60), textcoords='offset points',\n    arrowprops=dict(\n        arrowstyle=\"->\",\n        connectionstyle=\"arc,angleA=0,armA=40,angleB=-90,armB=30,rad=7\"))\nax.annotate(\n    'angle,\\nangle 90',\n    xy=(2., 1), xycoords='data',\n    xytext=(-70, 30), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\nax.annotate(\n    'angle3,\\nangle -90',\n    xy=(2.5, -1), xycoords='data',\n    xytext=(-80, -60), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle3,angleA=0,angleB=-90\"))\nax.annotate(\n    'angle,\\nround',\n    xy=(3., 1), xycoords='data',\n    xytext=(-60, 30), textcoords='offset points',\n    bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\nax.annotate(\n    'angle,\\nround4',\n    xy=(3.5, -1), xycoords='data',\n    xytext=(-70, -80), textcoords='offset points',\n    size=20,\n    bbox=dict(boxstyle=\"round4,pad=.5\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=-90,rad=10\"))\nax.annotate(\n    'angle,\\nshrink',\n    xy=(4., 1), xycoords='data',\n    xytext=(-60, 30), textcoords='offset points',\n    bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    shrinkA=0, shrinkB=10,\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\n# You can pass an empty string to get only annotation arrows rendered\nax.annotate('', xy=(4., 1.), xycoords='data',\n            xytext=(4.5, -1), textcoords='data',\n            arrowprops=dict(arrowstyle=\"<->\",\n                            connectionstyle=\"bar\",\n                            ec=\"k\",\n                            shrinkA=5, shrinkB=5))\n\nax.set(xlim=(-1, 5), ylim=(-4, 3))\n\n# %%",
                "filename": "galleries/examples/text_labels_and_annotations/annotation_demo.py",
                "start_index": 5888,
                "end_index": 8840,
                "start_line": 153,
                "end_line": 299,
                "max_line": 388,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "ax.annotate(\"\",\n            xy=(0.2, 0.2), xycoords='data',\n            xytext=(0.8, 0.8), textcoords='data',\n            arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3\"))\n\n# %%\n# The arrow is drawn as follows:\n#\n# 1. A path connecting the two points is created, as specified by the\n#    *connectionstyle* parameter.\n# 2. The path is clipped to avoid patches *patchA* and *patchB*, if these are\n#    set.\n# 3. The path is further shrunk by *shrinkA* and *shrinkB* (in pixels).\n# 4. The path is transmuted to an arrow patch, as specified by the *arrowstyle*\n#    parameter.\n#\n# .. figure:: /gallery/userdemo/images/sphx_glr_annotate_explain_001.png\n#    :target: /gallery/userdemo/annotate_explain.html\n#    :align: center\n#\n# The creation of the connecting path between two points is controlled by\n# ``connectionstyle`` key and the following styles are available:\n#\n# ==========   =============================================\n# Name         Attrs\n# ==========   =============================================\n# ``angle``    angleA=90,angleB=0,rad=0.0\n# ``angle3``   angleA=90,angleB=0\n# ``arc``      angleA=0,angleB=0,armA=None,armB=None,rad=0.0\n# ``arc3``     rad=0.0\n# ``bar``      armA=0.0,armB=0.0,fraction=0.3,angle=None\n# ==========   =============================================\n#\n# Note that \"3\" in ``angle3`` and ``arc3`` is meant to indicate that the\n# resulting path is a quadratic spline segment (three control\n# points). As will be discussed below, some arrow style options can only\n# be used when the connecting path is a quadratic spline.\n#\n# The behavior of each connection style is (limitedly) demonstrated in the\n# example below. (Warning: The behavior of the ``bar`` style is currently not\n# well-defined and may be changed in the future).\n#\n# .. figure:: /gallery/userdemo/images/sphx_glr_connectionstyle_demo_001.png\n#    :target: /gallery/userdemo/connectionstyle_demo.html\n#    :align: center\n#\n# The connecting path (after clipping and shrinking) is then mutated to\n# an arrow patch, according to the given ``arrowstyle``:\n#\n# ==========   =============================================\n# Name         Attrs\n# ==========   =============================================\n# ``-``        None\n# ``->``       head_length=0.4,head_width=0.2\n# ``-[``       widthB=1.0,lengthB=0.2,angleB=None\n# ``|-|``      widthA=1.0,widthB=1.0\n# ``-|>``      head_length=0.4,head_width=0.2\n# ``<-``       head_length=0.4,head_width=0.2\n# ``<->``      head_length=0.4,head_width=0.2\n# ``<|-``      head_length=0.4,head_width=0.2\n# ``<|-|>``    head_length=0.4,head_width=0.2\n# ``fancy``    head_length=0.4,head_width=0.4,tail_width=0.4\n# ``simple``   head_length=0.5,head_width=0.5,tail_width=0.2\n# ``wedge``    tail_width=0.3,shrink_factor=0.5\n# ==========   =============================================\n#\n# .. figure:: /gallery/text_labels_and_annotations/images/sphx_glr_fancyarrow_demo_001.png\n#    :target: /gallery/text_labels_and_annotations/fancyarrow_demo.html\n#    :align: center",
                "filename": "galleries/users_explain/text/annotations.py",
                "start_index": 11820,
                "end_index": 14819,
                "start_line": 319,
                "end_line": 743,
                "max_line": 748,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# ==================  ========================================================\n# argument            coordinate system\n# ==================  ========================================================\n# 'offset points'     offset (in points) from the xy value\n# 'offset pixels'     offset (in pixels) from the xy value\n# ==================  ========================================================\n#\n# For physical coordinate systems (points or pixels) the origin is the\n# bottom-left of the figure or axes. Points are\n# `typographic points <https://en.wikipedia.org/wiki/Point_(typography)>`_\n# meaning that they are a physical unit measuring 1/72 of an inch. Points and\n# pixels are discussed in further detail in :ref:`transforms-fig-scale-dpi`.\n#\n# .. _annotation-data:\n#\n# Annotating data\n# ^^^^^^^^^^^^^^^\n#\n# This example places the text coordinates in fractional axes coordinates:\n\nfig, ax = plt.subplots(figsize=(3, 3))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xycoords='data',\n            xytext=(0.01, .99), textcoords='axes fraction',\n            va='top', ha='left',\n            arrowprops=dict(facecolor='black', shrink=0.05))\nax.set_ylim(-2, 2)\n\n# %%\n#\n# Annotating an Artist\n# ^^^^^^^^^^^^^^^^^^^^\n#\n# Annotations can be positioned relative to an `.Artist` instance by passing\n# that Artist in as *xycoords*. Then *xy* is interpreted as a fraction of the\n# Artist's bounding box.\n\nimport matplotlib.patches as mpatches\n\nfig, ax = plt.subplots(figsize=(3, 3))\narr = mpatches.FancyArrowPatch((1.25, 1.5), (1.75, 1.5),\n                               arrowstyle='->,head_width=.15', mutation_scale=20)\nax.add_patch(arr)\nax.annotate(\"label\", (.5, .5), xycoords=arr, ha='center', va='bottom')\nax.set(xlim=(1, 2), ylim=(1, 2))\n\n# %%\n# Here the annotation is placed at position (.5,.5) relative to the arrow's\n# lower left corner and is vertically and horizontally at that position.\n# Vertically, the bottom aligns to that reference point so that the label\n# is above the line. For an example of chaining annotation Artists, see the\n# :ref:`Artist section <artist_annotation_coord>` of\n# :ref:`annotating_coordinate_systems`.\n#\n#\n# .. _annotation-with-arrow:\n#\n# Annotating with arrows\n# ^^^^^^^^^^^^^^^^^^^^^^\n#\n# You can enable drawing of an arrow from the text to the annotated point\n# by giving a dictionary of arrow properties in the optional keyword\n# argument *arrowprops*.\n#\n# ==================== =====================================================\n# *arrowprops* key     description\n# ==================== =====================================================\n# width                the width of the arrow in points\n# frac                 the fraction of the arrow length occupied by the head\n# headwidth            the width of the base of the arrow head in points\n# shrink               move the tip and base some percent away from\n#                      the annotated point and text\n#",
                "filename": "galleries/users_explain/text/annotations.py",
                "start_index": 2989,
                "end_index": 5970,
                "start_line": 60,
                "end_line": 748,
                "max_line": 748,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nplt.show()\n\n# %%\n# You can use the ``ax.transData`` instance to transform from your\n# *data* to your *display* coordinate system, either a single point or a\n# sequence of points as shown below:\n#\n# .. sourcecode:: ipython\n#\n#     In [14]: type(ax.transData)\n#     Out[14]: <class 'matplotlib.transforms.CompositeGenericTransform'>\n#\n#     In [15]: ax.transData.transform((5, 0))\n#     Out[15]: array([ 335.175,  247.   ])\n#\n#     In [16]: ax.transData.transform([(5, 0), (1, 2)])\n#     Out[16]:\n#     array([[ 335.175,  247.   ],\n#            [ 132.435,  642.2  ]])\n#\n# You can use the :meth:`~matplotlib.transforms.Transform.inverted`\n# method to create a transform which will take you from *display* to *data*\n# coordinates:\n#\n# .. sourcecode:: ipython\n#\n#     In [41]: inv = ax.transData.inverted()\n#\n#     In [42]: type(inv)\n#     Out[42]: <class 'matplotlib.transforms.CompositeGenericTransform'>\n#\n#     In [43]: inv.transform((335.175,  247.))\n#     Out[43]: array([ 5.,  0.])\n#\n# If your are typing along with this tutorial, the exact values of the\n# *display* coordinates may differ if you have a different window size or\n# dpi setting.  Likewise, in the figure below, the display labeled\n# points are probably not the same as in the ipython session because the\n# documentation figure size defaults are different.\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nxdata, ydata = 5, 0\n# This computing the transform now, if anything\n# (figure size, dpi, axes placement, data limits, scales..)\n# changes re-calling transform will get a different value.\nxdisplay, ydisplay = ax.transData.transform((xdata, ydata))\n\nbbox = dict(boxstyle=\"round\", fc=\"0.8\")\narrowprops = dict(\n    arrowstyle=\"->\",\n    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\")\n\noffset = 72\nax.annotate(f'data = ({xdata:.1f}, {ydata:.1f})',\n            (xdata, ydata), xytext=(-2*offset, offset), textcoords='offset points',\n            bbox=bbox, arrowprops=arrowprops)\n\ndisp = ax.annotate(f'display = ({xdisplay:.1f}, {ydisplay:.1f})',\n                   (xdisplay, ydisplay), xytext=(0.5*offset, -offset),\n                   xycoords='figure pixels',\n                   textcoords='offset points',\n                   bbox=bbox, arrowprops=arrowprops)\n\nplt.show()\n\n# %%\n# .. warning::\n#\n#   If you run the source code in the example above in a GUI backend,\n#   you may also find that the two arrows for the *data* and *display*\n#   annotations do not point to exactly the same point.  This is because\n#   the display point was computed before the figure was displayed, and\n#   the GUI backend may slightly resize the figure when it is created.",
                "filename": "galleries/users_explain/artists/transforms_tutorial.py",
                "start_index": 8284,
                "end_index": 11239,
                "start_line": 119,
                "end_line": 211,
                "max_line": 587,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from matplotlib.text import OffsetFrom\n\nfig, ax = plt.subplots(figsize=(3, 3))\nan1 = ax.annotate(\"Test 1\", xy=(0.5, 0.5), xycoords=\"data\",\n                  va=\"center\", ha=\"center\",\n                  bbox=dict(boxstyle=\"round\", fc=\"w\"))\n\noffset_from = OffsetFrom(an1, (0.5, 0))\nan2 = ax.annotate(\"Test 2\", xy=(0.1, 0.1), xycoords=\"data\",\n                  xytext=(0, -10), textcoords=offset_from,\n                  # xytext is offset points from \"xy=(0.5, 0), xycoords=an1\"\n                  va=\"top\", ha=\"center\",\n                  bbox=dict(boxstyle=\"round\", fc=\"w\"),\n                  arrowprops=dict(arrowstyle=\"->\"))\n\n# %%\n# Non-text annotations\n# --------------------\n#\n# .. _using_connectionpatch:\n#\n# Using ConnectionPatch\n# ^^^^^^^^^^^^^^^^^^^^^\n#\n# `.ConnectionPatch` is like an annotation without text. While `~.Axes.annotate`\n# is sufficient in most situations, `.ConnectionPatch` is useful when you want\n# to connect points in different axes. For example, here we connect the point\n# *xy* in the data coordinates of ``ax1`` to point *xy* in the data coordinates\n# of ``ax2``:\n\nfrom matplotlib.patches import ConnectionPatch\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(6, 3))\nxy = (0.3, 0.2)\ncon = ConnectionPatch(xyA=xy, coordsA=ax1.transData,\n                      xyB=xy, coordsB=ax2.transData)\n\nfig.add_artist(con)\n\n# %%\n# Here, we added the `.ConnectionPatch` to the *figure*\n# (with `~.Figure.add_artist`) rather than to either axes. This ensures that\n# the ConnectionPatch artist is drawn on top of both axes, and is also necessary\n# when using :ref:`constrained_layout <constrainedlayout_guide>`\n# for positioning the axes.\n#\n# Zoom effect between Axes\n# ^^^^^^^^^^^^^^^^^^^^^^^^\n#\n# `mpl_toolkits.axes_grid1.inset_locator` defines some patch classes useful for\n# interconnecting two axes.\n#\n# .. figure:: /gallery/subplots_axes_and_figures/images/sphx_glr_axes_zoom_effect_001.png\n#    :target: /gallery/subplots_axes_and_figures/axes_zoom_effect.html\n#    :align: center\n#\n# The code for this figure is at\n# :doc:`/gallery/subplots_axes_and_figures/axes_zoom_effect` and\n# familiarity with :ref:`transforms_tutorial`\n# is recommended.",
                "filename": "galleries/users_explain/text/annotations.py",
                "start_index": 26623,
                "end_index": 28795,
                "start_line": 689,
                "end_line": 748,
                "max_line": 748,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def update_positions(self, renderer):\n        \"\"\"Update pixel positions for the annotated point, the text, and the arrow.\"\"\"\n\n        ox0, oy0 = self._get_xy(renderer, self.xybox, self.boxcoords)\n        bbox = self.offsetbox.get_bbox(renderer)\n        fw, fh = self._box_alignment\n        self.offsetbox.set_offset(\n            (ox0 - fw*bbox.width - bbox.x0, oy0 - fh*bbox.height - bbox.y0))\n\n        bbox = self.offsetbox.get_window_extent(renderer)\n        self.patch.set_bounds(bbox.bounds)\n\n        mutation_scale = renderer.points_to_pixels(self.get_fontsize())\n        self.patch.set_mutation_scale(mutation_scale)\n\n        if self.arrowprops:\n            # Use FancyArrowPatch if self.arrowprops has \"arrowstyle\" key.\n\n            # Adjust the starting point of the arrow relative to the textbox.\n            # TODO: Rotation needs to be accounted.\n            arrow_begin = bbox.p0 + bbox.size * self._arrow_relpos\n            arrow_end = self._get_position_xy(renderer)\n            # The arrow (from arrow_begin to arrow_end) will be first clipped\n            # by patchA and patchB, then shrunk by shrinkA and shrinkB (in\n            # points).  If patch A is not set, self.bbox_patch is used.\n            self.arrow_patch.set_positions(arrow_begin, arrow_end)\n\n            if \"mutation_scale\" in self.arrowprops:\n                mutation_scale = renderer.points_to_pixels(\n                    self.arrowprops[\"mutation_scale\"])\n                # Else, use fontsize-based mutation_scale defined above.\n            self.arrow_patch.set_mutation_scale(mutation_scale)\n\n            patchA = self.arrowprops.get(\"patchA\", self.patch)\n            self.arrow_patch.set_patchA(patchA)\n\n    def draw(self, renderer):\n        # docstring inherited\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        renderer.open_group(self.__class__.__name__, gid=self.get_gid())\n        self.update_positions(renderer)\n        if self.arrow_patch is not None:\n            if self.arrow_patch.figure is None and self.figure is not None:\n                self.arrow_patch.figure = self.figure\n            self.arrow_patch.draw(renderer)\n        self.patch.draw(renderer)\n        self.offsetbox.draw(renderer)\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False",
                "filename": "lib/matplotlib/offsetbox.py",
                "start_index": 46551,
                "end_index": 48939,
                "start_line": 1404,
                "end_line": 1455,
                "max_line": 1604,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "\"\"\"\n===================\nAnnotate Text Arrow\n===================\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots(figsize=(5, 5))\nax.set_aspect(1)\n\nx1 = -1 + np.random.randn(100)\ny1 = -1 + np.random.randn(100)\nx2 = 1. + np.random.randn(100)\ny2 = 1. + np.random.randn(100)\n\nax.scatter(x1, y1, color=\"r\")\nax.scatter(x2, y2, color=\"g\")\n\nbbox_props = dict(boxstyle=\"round\", fc=\"w\", ec=\"0.5\", alpha=0.9)\nax.text(-2, -2, \"Sample A\", ha=\"center\", va=\"center\", size=20,\n        bbox=bbox_props)\nax.text(2, 2, \"Sample B\", ha=\"center\", va=\"center\", size=20,\n        bbox=bbox_props)\n\n\nbbox_props = dict(boxstyle=\"rarrow\", fc=(0.8, 0.9, 0.9), ec=\"b\", lw=2)\nt = ax.text(0, 0, \"Direction\", ha=\"center\", va=\"center\", rotation=45,\n            size=15,\n            bbox=bbox_props)\n\nbb = t.get_bbox_patch()\nbb.set_boxstyle(\"rarrow\", pad=0.6)\n\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\n\nplt.show()",
                "filename": "galleries/examples/userdemo/annotate_text_arrow.py",
                "start_index": 0,
                "end_index": 975,
                "start_line": 1,
                "end_line": 43,
                "max_line": 43,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# We'll create another figure so that it doesn't get too cluttered\nfig, ax = plt.subplots()\n\nel = Ellipse((2, -1), 0.5, 0.5)\nax.add_patch(el)\n\nax.annotate('$->$',\n            xy=(2., -1), xycoords='data',\n            xytext=(-150, -140), textcoords='offset points',\n            bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n            arrowprops=dict(arrowstyle=\"->\",\n                            patchB=el,\n                            connectionstyle=\"angle,angleA=90,angleB=0,rad=10\"))\nax.annotate('arrow\\nfancy',\n            xy=(2., -1), xycoords='data',\n            xytext=(-100, 60), textcoords='offset points',\n            size=20,\n            arrowprops=dict(arrowstyle=\"fancy\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"angle3,angleA=0,angleB=-90\"))\nax.annotate('arrow\\nsimple',\n            xy=(2., -1), xycoords='data',\n            xytext=(100, 60), textcoords='offset points',\n            size=20,\n            arrowprops=dict(arrowstyle=\"simple\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"arc3,rad=0.3\"))\nax.annotate('wedge',\n            xy=(2., -1), xycoords='data',\n            xytext=(-100, -100), textcoords='offset points',\n            size=20,\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=0.7\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"arc3,rad=-0.3\"))\nax.annotate('bubble,\\ncontours',\n            xy=(2., -1), xycoords='data',\n            xytext=(0, -70), textcoords='offset points',\n            size=20,\n            bbox=dict(boxstyle=\"round\",\n                      fc=(1.0, 0.7, 0.7),\n                      ec=(1., .5, .5)),\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=1.\",\n                            fc=(1.0, 0.7, 0.7), ec=(1., .5, .5),\n                            patchA=None,\n                            patchB=el,\n                            relpos=(0.2, 0.8),\n                            connectionstyle=\"arc3,rad=-0.1\"))\nax.annotate('bubble',\n            xy=(2., -1), xycoords='data',\n            xytext=(55, 0), textcoords='offset points',\n            size=20, va=\"center\",\n            bbox=dict(boxstyle=\"round\", fc=(1.0, 0.7, 0.7), ec=\"none\"),\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=1.\",\n                            fc=(1.0, 0.7, 0.7), ec=\"none\",\n                            patchA=None,\n                            patchB=el,\n                            relpos=(0.2, 0.5)))\n\nax.set(xlim=(-1, 5), ylim=(-5, 3))\n\n# %%\n# More examples of coordinate systems\n# -----------------------------------\n#\n# Below we'll show a few more examples of coordinate systems and how the\n# location of annotations may be specified.\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\n\nbbox_args = dict(boxstyle=\"round\", fc=\"0.8\")\narrow_args = dict(arrowstyle=\"->\")",
                "filename": "galleries/examples/text_labels_and_annotations/annotation_demo.py",
                "start_index": 8841,
                "end_index": 11810,
                "start_line": 236,
                "end_line": 309,
                "max_line": 388,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# Here we'll demonstrate the extents of the coordinate system and how\n# we place annotating text.\n\nax1.annotate('figure fraction : 0, 0', xy=(0, 0), xycoords='figure fraction',\n             xytext=(20, 20), textcoords='offset points',\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate('figure fraction : 1, 1', xy=(1, 1), xycoords='figure fraction',\n             xytext=(-20, -20), textcoords='offset points',\n             ha=\"right\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate('axes fraction : 0, 0', xy=(0, 0), xycoords='axes fraction',\n             xytext=(20, 20), textcoords='offset points',\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate('axes fraction : 1, 1', xy=(1, 1), xycoords='axes fraction',\n             xytext=(-20, -20), textcoords='offset points',\n             ha=\"right\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\n# It is also possible to generate draggable annotations\n\nan1 = ax1.annotate('Drag me 1', xy=(.5, .7), xycoords='data',\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args)\n\nan2 = ax1.annotate('Drag me 2', xy=(.5, .5), xycoords=an1,\n                   xytext=(.5, .3), textcoords='axes fraction',\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args,\n                   arrowprops=dict(patchB=an1.get_bbox_patch(),\n                                   connectionstyle=\"arc3,rad=0.2\",\n                                   **arrow_args))\nan1.draggable()\nan2.draggable()\n\nan3 = ax1.annotate('', xy=(.5, .5), xycoords=an2,\n                   xytext=(.5, .5), textcoords=an1,\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args,\n                   arrowprops=dict(patchA=an1.get_bbox_patch(),\n                                   patchB=an2.get_bbox_patch(),\n                                   connectionstyle=\"arc3,rad=0.2\",\n                                   **arrow_args))\n\n# Finally we'll show off some more complex annotation and placement\n\ntext = ax2.annotate('xy=(0, 1)\\nxycoords=(\"data\", \"axes fraction\")',\n                    xy=(0, 1), xycoords=(\"data\", 'axes fraction'),\n                    xytext=(0, -20), textcoords='offset points',\n                    ha=\"center\", va=\"top\",\n                    bbox=bbox_args,\n                    arrowprops=arrow_args)\n\nax2.annotate('xy=(0.5, 0)\\nxycoords=artist',\n             xy=(0.5, 0.), xycoords=text,\n             xytext=(0, -20), textcoords='offset points',\n             ha=\"center\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)",
                "filename": "galleries/examples/text_labels_and_annotations/annotation_demo.py",
                "start_index": 11812,
                "end_index": 14542,
                "start_line": 311,
                "end_line": 385,
                "max_line": 388,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "ax2.annotate('xy=(0.8, 0.5)\\nxycoords=ax1.transData',\n             xy=(0.8, 0.5), xycoords=ax1.transData,\n             xytext=(10, 10),\n             textcoords=OffsetFrom(ax2.bbox, (0, 0), \"points\"),\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax2.set(xlim=[-2, 2], ylim=[-2, 2])\nplt.show()",
                "filename": "galleries/examples/text_labels_and_annotations/annotation_demo.py",
                "start_index": 14544,
                "end_index": 14893,
                "start_line": 379,
                "end_line": 388,
                "max_line": 388,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.7",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "lib/matplotlib/offsetbox.py": [
                {
                    "chunk": {
                        "code": "def update_positions(self, renderer):\n        \"\"\"Update pixel positions for the annotated point, the text, and the arrow.\"\"\"\n\n        ox0, oy0 = self._get_xy(renderer, self.xybox, self.boxcoords)\n        bbox = self.offsetbox.get_bbox(renderer)\n        fw, fh = self._box_alignment\n        self.offsetbox.set_offset(\n            (ox0 - fw*bbox.width - bbox.x0, oy0 - fh*bbox.height - bbox.y0))\n\n        bbox = self.offsetbox.get_window_extent(renderer)\n        self.patch.set_bounds(bbox.bounds)\n\n        mutation_scale = renderer.points_to_pixels(self.get_fontsize())\n        self.patch.set_mutation_scale(mutation_scale)\n\n        if self.arrowprops:\n            # Use FancyArrowPatch if self.arrowprops has \"arrowstyle\" key.\n\n            # Adjust the starting point of the arrow relative to the textbox.\n            # TODO: Rotation needs to be accounted.\n            arrow_begin = bbox.p0 + bbox.size * self._arrow_relpos\n            arrow_end = self._get_position_xy(renderer)\n            # The arrow (from arrow_begin to arrow_end) will be first clipped\n            # by patchA and patchB, then shrunk by shrinkA and shrinkB (in\n            # points).  If patch A is not set, self.bbox_patch is used.\n            self.arrow_patch.set_positions(arrow_begin, arrow_end)\n\n            if \"mutation_scale\" in self.arrowprops:\n                mutation_scale = renderer.points_to_pixels(\n                    self.arrowprops[\"mutation_scale\"])\n                # Else, use fontsize-based mutation_scale defined above.\n            self.arrow_patch.set_mutation_scale(mutation_scale)\n\n            patchA = self.arrowprops.get(\"patchA\", self.patch)\n            self.arrow_patch.set_patchA(patchA)\n\n    def draw(self, renderer):\n        # docstring inherited\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        renderer.open_group(self.__class__.__name__, gid=self.get_gid())\n        self.update_positions(renderer)\n        if self.arrow_patch is not None:\n            if self.arrow_patch.figure is None and self.figure is not None:\n                self.arrow_patch.figure = self.figure\n            self.arrow_patch.draw(renderer)\n        self.patch.draw(renderer)\n        self.offsetbox.draw(renderer)\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False",
                        "filename": "lib/matplotlib/offsetbox.py",
                        "start_index": 46551,
                        "end_index": 48939,
                        "start_line": 1404,
                        "end_line": 1455,
                        "max_line": 1604,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.7",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the update_positions method in offsetbox.py, which is responsible for updating the positions of annotations, including arrows. The issue may be related to how the arrow positions are updated after the initial draw, which is handled in this method."
                }
            ]
        },
        "solution_task": "To resolve the issue where changing `xy_0` after calling `annotate` updates the arrow position, and to ensure that arrows remain horizontal and unaffected by changes to `xy_0` after the annotation is created, you should make a copy of the `xy` parameter inside the `annotate` function before using it. This will prevent the original data from being altered due to the mutability of numpy arrays when they are passed as arguments.\n\nHere is the solution:\n\n- Modify the `annotate` function to create a copy of the `xy` parameter.\n- Use `np.array(xy, copy=True)` to ensure a copy is made if `xy` is a numpy array.\n\nExample code change:\n\n```python\nimport numpy as np\n\ndef annotate(s, xy, xytext=None, arrowprops=None):\n    # ... existing code ...\n\n    # Ensure xy is copied to prevent reference issues\n    xy = np.array(xy, copy=True)\n\n    # ... rest of the function ...\n```\n\nApply this change wherever the `annotate` function is defined or before any call to `annotate` where `xy` is expected to be a mutable object like a numpy array.",
        "bouncer_response": {
            "score": 7,
            "criteria": "The RESPONSE must provide actionable, relevant guidance to more parts of the PROMPT's described issue to score higher.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT by suggesting that a copy of the `xy` parameter should be made within the `annotate` function to prevent the original data from being altered. This directly addresses the issue of the arrow position being updated when the `xy_0` array is modified after the annotation is created. The RESPONSE also includes example code to illustrate how to implement the proposed solution, which is relevant and helpful. However, the RESPONSE does not address the specific context of the Matplotlib version or the fact that the user may not have the ability to modify the `annotate` function directly if it is part of a library. Additionally, the RESPONSE includes a link to a code snippet that is not directly related to the `annotate` function, which may cause confusion. Therefore, the RESPONSE is not entirely complete in addressing all aspects of the bug but does provide a substantial part of the solution.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711695713.816996,
        "result": "To resolve the issue where changing `xy_0` after calling `annotate` updates the arrow position, and to ensure that arrows remain horizontal and unaffected by changes to `xy_0` after the annotation is created, you should make a copy of the `xy` parameter inside the `annotate` function before using it. This will prevent the original data from being altered due to the mutability of numpy arrays when they are passed as arguments.\n\nHere is the solution:\n\n- Modify the `annotate` function to create a copy of the `xy` parameter.\n- Use `np.array(xy, copy=True)` to ensure a copy is made if `xy` is a numpy array.\n\nExample code change:\n\n```python\nimport numpy as np\n\ndef annotate(s, xy, xytext=None, arrowprops=None):\n    # ... existing code ...\n\n    # Ensure xy is copied to prevent reference issues\n    xy = np.array(xy, copy=True)\n\n    # ... rest of the function ...\n```\n\nApply this change wherever the `annotate` function is defined or before any call to `annotate` where `xy` is expected to be a mutable object like a numpy array.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.7/tree//lib/matplotlib)- [Lines 1404 - 1455](https://github.com/testbed/matplotlib__matplotlib__3.7/blob//lib/matplotlib/offsetbox.py#L1404-L1455)\n\n This snippet contains the update_positions method in offsetbox.py, which is responsible for updating the positions of annotations, including arrows. The issue may be related to how the arrow positions are updated after the initial draw, which is handled in this method.",
        "context_relevance": 0.25,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE directly addresses the bug report by providing a detailed explanation and a solution to the problem described in the PROMPT. It explains the cause of the issue (mutability of numpy arrays) and offers a code modification to prevent the problem. The RESPONSE also includes an example code change that is directly relevant to the bug summary and the expected outcome. Additionally, it provides a link to the relevant section of the codebase where the issue might be present, which is a thorough and complete answer to the bug report."
        },
        "qa_relevance": 1.0
    }
}