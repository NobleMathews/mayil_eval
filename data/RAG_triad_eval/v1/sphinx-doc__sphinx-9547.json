{
    "id": "sphinx-doc__sphinx-9547",
    "repo_name": "testbed/sphinx-doc__sphinx__4.2",
    "task_id": 8842207586295288450,
    "title": "Missing support for GNU extension types like `_Complex` or `_Fract`",
    "body": "I'm currently working on the transition of the GNU C compiler (GCC) manuals and I noticed there are unsupported C extensions like:\r\n\r\n```\r\n.. c:function:: complex long foo(int)\r\n.. c:function:: _Complex long foo(int)\r\n.. c:function:: long fract __satfractunssisq (unsigned int a)\r\n\r\n  My function.\r\n```\r\n\r\nwhere I see the following parsing error:\r\n```\r\n/home/marxin/Programming/texi2rst-generated/sphinx/demo/demo.rst:66: WARNING: Invalid C declaration: Expected identifier, got user-defined keyword: complex. Remove it from c_extra_keywords to allow it as identifier.\r\nCurrently c_extra_keywords is ['alignas', 'alignof', 'bool', 'complex', 'imaginary', 'noreturn', 'static_assert', 'thread_local']. [error at 7]\r\n  complex long foo(int)\r\n  -------^\r\n/home/marxin/Programming/texi2rst-generated/sphinx/demo/demo.rst:67: WARNING: Invalid C declaration: Expected identifier in nested name, got keyword: _Complex [error at 8]\r\n  _Complex long foo(int)\r\n  --------^\r\n/home/marxin/Programming/texi2rst-generated/sphinx/demo/demo.rst:68: WARNING: Error in declarator or parameters\r\nInvalid C declaration: Expecting \"(\" in parameters. [error at 11]\r\n  long fract __satfractunssisq (unsigned int a)\r\n  -----------^\r\n```\r\n\r\nRight now, there's some special casing for e.g. 'unsigned' type:\r\nhttps://github.com/sphinx-doc/sphinx/blob/6ac326e019db949c2c8d58f523c2534be36d4e62/sphinx/domains/c.py#L2566-L2585\r\n\r\nOne possible fix is adding the mentioned C extension handling for the following types:\r\nhttps://gcc.gnu.org/onlinedocs/gcc/Fixed-Point.html\r\nhttps://gcc.gnu.org/onlinedocs/gcc/Complex.html\r\n\r\nor I can see a domain parser can become public via an API entry point:\r\nhttps://github.com/sphinx-doc/sphinx/blob/6ac326e019db949c2c8d58f523c2534be36d4e62/sphinx/domains/c.py#L2128-L2131\r\n\r\nWhat do you think?\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__4.2.git",
    "requested_commit": "",
    "mayil_response": "To implement support for GNU extension types like `_Complex` and `_Fract` in the Sphinx C domain, you can follow these steps:\n\n- Extend the `_parse_simple_type_specifier` method in `sphinx/domains/c.py` to recognize the GNU extension types.\n- Update the `_simple_type_specifiers_re` regular expression to include the new types if they are not already part of the `c_extra_keywords`.\n- Ensure that the parser does not fail when encountering these types by modifying the checks against `_keywords` and `c_extra_keywords`.\n- Add tests for the new types to ensure that they are parsed correctly.\n\nHere's a rough implementation outline:\n\n1. Update the `_simple_type_specifiers_re` regular expression to include `_Complex` and `_Fract`:\n\n```python\n_simple_type_specifiers_re = re.compile(\n    r'(void|char|short|int|long|float|double|signed|unsigned'\n    r'|_Bool|_Complex|_Imaginary|_Fract|_Accum|_Sat|_Sat_Fract|_Sat_Accum'\n    r'|__int128_t|__int128|__uint128_t|__uint128|__builtin_va_list|__char16_t|__char32_t'\n    r'|__float128|__ibm128|__int8_t|__int16_t|__int32_t|__int64_t'\n    r'|__uint8_t|__uint16_t|__uint32_t|__uint64_t|__builtin_ms_va_list|__builtin_va_list)'\n)\n```\n\n2. Modify the `_parse_simple_type_specifier` method to handle the new types:\n\n```python\ndef _parse_simple_type_specifier(self) -> str | None:\n    if self.match(_simple_type_specifiers_re):\n        return self.matched_text\n    for t in ('_Complex', '_Fract', '_Accum', '_Sat'):\n        if t in self.config.c_extra_keywords:\n            if self.skip_word(t):\n                return t\n    return None\n```\n\n3. Update the checks against `_keywords` and `c_extra_keywords` to allow the new types:\n\n```python\n# In the _parse_nested_name method, update the error message to be more specific\n# about the new types being allowed as identifiers.\nif identifier in _keywords and identifier not in ('_Complex', '_Fract', '_Accum', '_Sat'):\n    self.fail(\"Expected identifier in nested name, got keyword: %s\" % identifier)\n```\n\n4. Add tests for the new types to ensure they are parsed correctly. This would involve creating test cases in the Sphinx test suite that use the new types in function declarations, struct definitions, etc., and verifying that the documentation is generated without errors.\n\n5. Update the documentation to mention the support for these new types.\n\nPlease note that this is a high-level overview and the actual implementation may require more detailed changes, including handling of the new types in other parts of the parser and ensuring compatibility with the rest of the Sphinx documentation system. Additionally, you may need to handle the attributes and qualifiers that can be used with these types.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx) \u2192 [domains](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx/domains)- [Lines 1 - 89](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L1-L89)\n\n This snippet contains the list of keywords and extra keywords for the C domain, which is relevant to the issue as the parsing error is related to the handling of certain keywords like '_Complex'. \n\n\n   - [Lines 2573 - 2643](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L2573-L2643)\n\n This snippet includes the parsing logic for nested names and type specifiers in the C domain, which is relevant to the issue since the parsing errors are related to the handling of type specifiers like 'complex', '_Complex', and 'long fract'. \n\n\n   - [Lines 3316 - 3847](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L3316-L3847)\n\n This snippet defines the classes for different C language objects, including functions and types, which may need to be reviewed or modified to support the GNU extension types mentioned in the issue. \n\n\n   - [Lines 3696 - 3764](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L3696-L3764)\n\n This snippet defines the object types and roles for the C domain, which could be relevant when considering how to handle the new types like '_Complex' or '_Fract' within the domain's structure.\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx/util)- [Lines 1 - 234](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/util/cfamily.py#L1-L234)\n\n This snippet contains regular expressions for parsing different literals and identifiers in the C and C++ domains, which might be relevant if the issue requires adjustments to the parsing logic for the new types.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00040449999999999997,
        "snippet_processor": 0.10314,
        "issue_star_creation": 0.027969999999999995,
        "issue_star_solver": 0.07187,
        "bouncer": 0.025009999999999998
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711702293.1337118,
        "relevant_snippets": [
            {
                "code": "\"\"\"The C language domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any, Callable, Generator, Iterator, TypeVar, Union, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node, TextElement, system_message\nfrom docutils.parsers.rst import directives\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import pending_xref\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.roles import SphinxRole, XRefRole\nfrom sphinx.transforms import SphinxTransform\nfrom sphinx.transforms.post_transforms import ReferencesResolver\nfrom sphinx.util import logging\nfrom sphinx.util.cfamily import (\n    ASTAttributeList,\n    ASTBaseBase,\n    ASTBaseParenExprList,\n    BaseParser,\n    DefinitionError,\n    NoOldIdError,\n    StringifyTransform,\n    UnsupportedMultiCharacterCharLiteral,\n    anon_identifier_re,\n    binary_literal_re,\n    char_literal_re,\n    float_literal_re,\n    float_literal_suffix_re,\n    hex_literal_re,\n    identifier_re,\n    integer_literal_re,\n    integers_literal_suffix_re,\n    octal_literal_re,\n    verify_description_mode,\n)\nfrom sphinx.util.docfields import Field, GroupedField, TypedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.nodes import make_refnode\nfrom sphinx.util.typing import OptionSpec\n\nlogger = logging.getLogger(__name__)\nT = TypeVar('T')\n\nDeclarationType = Union[\n    \"ASTStruct\", \"ASTUnion\", \"ASTEnum\", \"ASTEnumerator\",\n    \"ASTType\", \"ASTTypeWithInit\", \"ASTMacro\",\n]\n\n# https://en.cppreference.com/w/c/keyword\n_keywords = [\n    'auto', 'break', 'case', 'char', 'const', 'continue', 'default', 'do', 'double',\n    'else', 'enum', 'extern', 'float', 'for', 'goto', 'if', 'inline', 'int', 'long',\n    'register', 'restrict', 'return', 'short', 'signed', 'sizeof', 'static', 'struct',\n    'switch', 'typedef', 'union', 'unsigned', 'void', 'volatile', 'while',\n    '_Alignas', '_Alignof', '_Atomic', '_Bool', '_Complex',\n    '_Decimal32', '_Decimal64', '_Decimal128',\n    '_Generic', '_Imaginary', '_Noreturn', '_Static_assert', '_Thread_local',\n]\n# These are only keyword'y when the corresponding headers are included.\n# They are used as default value for c_extra_keywords.\n_macroKeywords = [\n    'alignas', 'alignof', 'bool', 'complex', 'imaginary', 'noreturn', 'static_assert',\n    'thread_local',\n]\n\n# these are ordered by preceedence\n_expression_bin_ops = [\n    ['||', 'or'],\n    ['&&', 'and'],\n    ['|', 'bitor'],\n    ['^', 'xor'],\n    ['&', 'bitand'],\n    ['==', '!=', 'not_eq'],\n    ['<=', '>=', '<', '>'],\n    ['<<', '>>'],\n    ['+', '-'],\n    ['*', '/', '%'],\n    ['.*', '->*'],\n]\n_expression_unary_ops = [\"++\", \"--\", \"*\", \"&\", \"+\", \"-\", \"!\", \"not\", \"~\", \"compl\"]",
                "filename": "sphinx/domains/c.py",
                "start_index": 0,
                "end_index": 2872,
                "start_line": 1,
                "end_line": 89,
                "max_line": 3876,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.9
            },
            {
                "code": "\"\"\"The C++ language domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any, Callable, Generator, Iterator, TypeVar\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node, TextElement, system_message\nfrom docutils.parsers.rst import directives\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import desc_signature, pending_xref\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.errors import NoUri\nfrom sphinx.locale import _, __\nfrom sphinx.roles import SphinxRole, XRefRole\nfrom sphinx.transforms import SphinxTransform\nfrom sphinx.transforms.post_transforms import ReferencesResolver\nfrom sphinx.util import logging\nfrom sphinx.util.cfamily import (\n    ASTAttributeList,\n    ASTBaseBase,\n    ASTBaseParenExprList,\n    BaseParser,\n    DefinitionError,\n    NoOldIdError,\n    StringifyTransform,\n    UnsupportedMultiCharacterCharLiteral,\n    anon_identifier_re,\n    binary_literal_re,\n    char_literal_re,\n    float_literal_re,\n    float_literal_suffix_re,\n    hex_literal_re,\n    identifier_re,\n    integer_literal_re,\n    integers_literal_suffix_re,\n    octal_literal_re,\n    verify_description_mode,\n)\nfrom sphinx.util.docfields import Field, GroupedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.nodes import make_refnode\nfrom sphinx.util.typing import OptionSpec\n\nlogger = logging.getLogger(__name__)\nT = TypeVar('T')",
                "filename": "sphinx/domains/cpp.py",
                "start_index": 0,
                "end_index": 1564,
                "start_line": 1,
                "end_line": 52,
                "max_line": 8160,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "\"\"\"C language domain.\"\"\"\n    name = 'c'\n    label = 'C'\n    object_types = {\n        # 'identifier' is the one used for xrefs generated in signatures, not in roles\n        'member': ObjType(_('member'), 'var', 'member', 'data', 'identifier'),\n        'var': ObjType(_('variable'),  'var', 'member', 'data', 'identifier'),\n        'function': ObjType(_('function'),     'func',          'identifier', 'type'),\n        'macro': ObjType(_('macro'),           'macro',         'identifier'),\n        'struct': ObjType(_('struct'),         'struct',        'identifier', 'type'),\n        'union': ObjType(_('union'),           'union',         'identifier', 'type'),\n        'enum': ObjType(_('enum'),             'enum',          'identifier', 'type'),\n        'enumerator': ObjType(_('enumerator'), 'enumerator',    'identifier'),\n        'type': ObjType(_('type'),                              'identifier', 'type'),\n        # generated object types\n        'functionParam': ObjType(_('function parameter'),       'identifier', 'var', 'member', 'data'),  # noqa: E501\n    }\n\n    directives = {\n        'member': CMemberObject,\n        'var': CMemberObject,\n        'function': CFunctionObject,\n        'macro': CMacroObject,\n        'struct': CStructObject,\n        'union': CUnionObject,\n        'enum': CEnumObject,\n        'enumerator': CEnumeratorObject,\n        'type': CTypeObject,\n        # scope control\n        'namespace': CNamespaceObject,\n        'namespace-push': CNamespacePushObject,\n        'namespace-pop': CNamespacePopObject,\n        # other\n        'alias': CAliasObject,\n    }\n    roles = {\n        'member': CXRefRole(),\n        'data': CXRefRole(),\n        'var': CXRefRole(),\n        'func': CXRefRole(fix_parens=True),\n        'macro': CXRefRole(),\n        'struct': CXRefRole(),\n        'union': CXRefRole(),\n        'enum': CXRefRole(),\n        'enumerator': CXRefRole(),\n        'type': CXRefRole(),\n        'expr': CExprRole(asCode=True),\n        'texpr': CExprRole(asCode=False),\n    }\n    initial_data: dict[str, Symbol | dict[str, tuple[str, str, str]]] = {\n        'root_symbol': Symbol(None, None, None, None, None),\n        'objects': {},  # fullname -> docname, node_id, objtype\n    }\n\n    def clear_doc(self, docname: str) -> None:\n        if Symbol.debug_show_tree:\n            print(\"clear_doc:\", docname)\n            print(\"\\tbefore:\")\n            print(self.data['root_symbol'].dump(1))\n            print(\"\\tbefore end\")\n\n        rootSymbol = self.data['root_symbol']\n        rootSymbol.clear_doc(docname)\n\n        if Symbol.debug_show_tree:\n            print(\"\\tafter:\")\n            print(self.data['root_symbol'].dump(1))\n            print(\"\\tafter end\")\n            print(\"clear_doc end:\", docname)",
                "filename": "sphinx/domains/c.py",
                "start_index": 143048,
                "end_index": 145788,
                "start_line": 3696,
                "end_line": 3764,
                "max_line": 3876,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"The Python domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nimport builtins\nimport inspect\nimport re\nimport typing\nfrom inspect import Parameter\nfrom typing import Any, Iterable, Iterator, List, NamedTuple, Tuple, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node\nfrom docutils.parsers.rst import directives\nfrom docutils.parsers.rst.states import Inliner\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, Index, IndexEntry, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.roles import XRefRole\nfrom sphinx.util import logging\nfrom sphinx.util.docfields import Field, GroupedField, TypedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.inspect import signature_from_str\nfrom sphinx.util.nodes import (\n    find_pending_xref_condition,\n    make_id,\n    make_refnode,\n    nested_parse_with_titles,\n)\nfrom sphinx.util.typing import OptionSpec, TextlikeNode\n\nlogger = logging.getLogger(__name__)\n\n\n# REs for Python signatures\npy_sig_re = re.compile(\n    r'''^ ([\\w.]*\\.)?            # class name(s)\n          (\\w+)  \\s*             # thing name\n          (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n           (?:\\s* -> \\s* (.*))?  #           return annotation\n          )? $                   # and nothing more\n          ''', re.VERBOSE)\n\n\npairindextypes = {\n    'module':    _('module'),\n    'keyword':   _('keyword'),\n    'operator':  _('operator'),\n    'object':    _('object'),\n    'exception': _('exception'),\n    'statement': _('statement'),\n    'builtin':   _('built-in function'),\n}\n\n\nclass ObjectEntry(NamedTuple):\n    docname: str\n    node_id: str\n    objtype: str\n    aliased: bool\n\n\nclass ModuleEntry(NamedTuple):\n    docname: str\n    node_id: str\n    synopsis: str\n    platform: str\n    deprecated: bool\n\n\ndef parse_reftarget(reftarget: str, suppress_prefix: bool = False,\n                    ) -> tuple[str, str, str, bool]:\n    \"\"\"Parse a type string and return (reftype, reftarget, title, refspecific flag)\"\"\"\n    refspecific = False\n    if reftarget.startswith('.'):\n        reftarget = reftarget[1:]\n        title = reftarget\n        refspecific = True\n    elif reftarget.startswith('~'):\n        reftarget = reftarget[1:]\n        title = reftarget.split('.')[-1]\n    elif suppress_prefix:\n        title = reftarget.split('.')[-1]\n    elif reftarget.startswith('typing.'):\n        title = reftarget[7:]\n    else:\n        title = reftarget\n\n    if reftarget == 'None' or reftarget.startswith('typing.'):\n        # typing module provides non-class types.  Obj reference is good to refer them.\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    return reftype, reftarget, title, refspecific",
                "filename": "sphinx/domains/python.py",
                "start_index": 0,
                "end_index": 2948,
                "start_line": 1,
                "end_line": 102,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "\"\"\"\n    Important note on ids\n    ----------------------------------------------------------------------------\n\n    Multiple id generation schemes are used due to backwards compatibility.\n    - v1: 1.2.3 <= version < 1.3\n          The style used before the rewrite.\n          It is not the actual old code, but a replication of the behaviour.\n    - v2: 1.3 <= version < now\n          Standardised mangling scheme from\n          https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling\n          though not completely implemented.\n    All versions are generated and attached to elements. The newest is used for\n    the index. All of the versions should work as permalinks.\n\n\n    Signature Nodes and Tagnames\n    ----------------------------------------------------------------------------\n\n    Each signature is in a desc_signature node, where all children are\n    desc_signature_line nodes. Each of these lines will have the attribute\n    'sphinx_line_type' set to one of the following (prioritized):\n    - 'declarator', if the line contains the name of the declared object.\n    - 'templateParams', if the line starts a template parameter list,\n    - 'templateParams', if the line has template parameters\n      Note: such lines might get a new tag in the future.\n    - 'templateIntroduction, if the line is on the form 'conceptName{...}'\n    No other desc_signature nodes should exist (so far).\n\n\n    Grammar\n    ----------------------------------------------------------------------------\n\n    See https://www.nongnu.org/hcb/ for the grammar,\n    and https://github.com/cplusplus/draft/blob/master/source/grammar.tex,\n    and https://github.com/cplusplus/concepts-ts\n    for the newest grammar.\n\n    common grammar things:\n        template-declaration ->\n            \"template\" \"<\" template-parameter-list \">\" declaration\n        template-parameter-list ->\n              template-parameter\n            | template-parameter-list \",\" template-parameter\n        template-parameter ->\n              type-parameter\n            | parameter-declaration # i.e., same as a function argument\n\n        type-parameter ->\n              \"class\"    \"...\"[opt] identifier[opt]\n            | \"class\"               identifier[opt] \"=\" type-id\n            | \"typename\" \"...\"[opt] identifier[opt]\n            | \"typename\"            identifier[opt] \"=\" type-id\n            | \"template\" \"<\" template-parameter-list \">\"\n                \"class\"  \"...\"[opt] identifier[opt]\n            | \"template\" \"<\" template-parameter-list \">\"\n                \"class\"             identifier[opt] \"=\" id-expression\n            # also, from C++17 we can have \"typename\" in template templates\n        templateDeclPrefix ->\n            \"template\" \"<\" template-parameter-list \">\"\n\n        simple-declaration ->\n            attribute-specifier-seq[opt] decl-specifier-seq[opt]\n                init-declarator-list[opt] ;\n        # Make the semicolon optional.\n        # For now: drop the attributes (TODO).\n        # Use at most 1 init-declarator.\n        -> decl-specifier-seq init-declarator\n        -> decl-specifier-seq declarator initializer\n\n        decl-specifier ->\n              storage-class-specifier ->\n                 (  \"static\" (only for member_object and function_object)\n                  | \"extern\" (only for member_object and function_object)\n                  | \"register\"\n                 )\n                 thread_local[opt] (only for member_object)\n                                   (it can also appear before the others)\n\n            | type-specifier -> trailing-type-specifier\n            | function-specifier -> \"inline\" | \"virtual\" | \"explicit\" (only\n              for function_object)\n            | \"friend\" (only for function_object)\n            | \"constexpr\" (only for member_object and function_object)\n        trailing-type-specifier ->\n              simple-type-specifier\n            | elaborated-type-specifier\n            | typename-specifier\n            | cv-qualifier -> \"const\" | \"volatile\"\n        stricter grammar for decl-specifier-seq (with everything, each object\n        uses a subset):\n            visibility storage-class-specifier function-specifier \"friend\"\n            \"constexpr\" \"volatile\" \"const\" trailing-type-specifier\n            # where trailing-type-specifier can no be cv-qualifier\n        # Inside e.g., template parameters a strict subset is used\n        # (see type-specifier-seq)\n        trailing-type-specifier ->\n              simple-type-specifier ->\n                ::[opt] nested-name-specifier[opt] type-name\n              | ::[opt] nested-name-specifier \"template\" simple-template-id\n              | \"char\" | \"bool\" | etc.\n              | decltype-specifier\n            | elaborated-type-specifier ->\n                class-key attribute-specifier-seq[opt] ::[opt]\n                nested-name-specifier[opt] identifier\n              | class-key ::[opt] nested-name-specifier[opt] template[opt]\n                simple-template-id\n              | \"enum\" ::[opt] nested-name-specifier[opt] identifier\n            | typename-specifier ->\n                \"typename\" ::[opt] nested-name-specifier identifier\n              | \"typename\" ::[opt] nested-name-specifier template[opt]\n                simple-template-id\n        class-key -> \"class\" | \"struct\" | \"union\"\n        type-name ->* identifier | simple-template-id\n        # ignoring attributes and decltype, and then some left-factoring\n        trailing-type-specifier ->\n            rest-of-trailing\n            (\"class\" | \"struct\" | \"union\" | \"typename\") rest-of-trailing\n            built-in -> \"char\" | \"bool\" | etc.\n            decltype-specifier\n        rest-of-trailing -> (with some simplification)\n            \"::\"[opt] list-of-elements-separated-by-::\n        element ->\n            \"template\"[opt] identifier (\"<\" template-argument-list \">\")[opt]\n        template-argument-list ->\n              template-argument \"...\"[opt]\n            | template-argument-list \",\" template-argument \"...\"[opt]\n        template-argument ->\n              constant-expression\n            | type-specifier-seq abstract-declarator\n            | id-expression\n\n\n        declarator ->\n              ptr-declarator\n            | noptr-declarator parameters-and-qualifiers trailing-return-type\n        ptr-declarator ->\n              noptr-declarator\n            | ptr-operator ptr-declarator\n        noptr-declarator ->\n              declarator-id attribute-specifier-seq[opt] ->\n                    \"...\"[opt] id-expression\n                  | rest-of-trailing\n            | noptr-declarator parameters-and-qualifiers\n            | noptr-declarator \"[\" constant-expression[opt] \"]\"\n              attribute-specifier-seq[opt]\n            | \"(\" ptr-declarator \")\"\n        ptr-operator ->\n              \"*\"  attribute-specifier-seq[opt] cv-qualifier-seq[opt]\n            | \"&   attribute-specifier-seq[opt]\n            | \"&&\" attribute-specifier-seq[opt]\n            | \"::\"[opt] nested-name-specifier \"*\" attribute-specifier-seq[opt]\n                cv-qualifier-seq[opt]\n        # function_object must use a parameters-and-qualifiers, the others may\n        # use it (e.g., function pointers)\n        parameters-and-qualifiers ->\n            \"(\" parameter-clause \")\" attribute-specifier-seq[opt]\n            cv-qualifier-seq[opt] ref-qualifier[opt]\n            exception-specification[opt]\n        ref-qualifier -> \"&\" | \"&&\"\n        exception-specification ->\n            \"noexcept\" (\"(\" constant-expression \")\")[opt]\n            \"throw\" (\"(\" type-id-list \")\")[opt]\n        # TODO: we don't implement attributes\n        # member functions can have initializers, but we fold them into here\n        memberFunctionInit -> \"=\" \"0\"\n        # (note: only \"0\" is allowed as the value, according to the standard,\n        # right?)\n\n        enum-head ->\n            enum-key attribute-specifier-seq[opt] nested-name-specifier[opt]\n                identifier enum-base[opt]\n        enum-key -> \"enum\" | \"enum struct\" | \"enum class\"\n        enum-base ->\n            \":\" type\n        enumerator-definition ->\n              identifier\n            | identifier \"=\" constant-expression\n\n    We additionally add the possibility for specifying the visibility as the\n    first thing.\n\n    concept_object:\n        goal:\n            just a declaration of the name (for now)\n\n        grammar: only a single template parameter list, and the nested name\n            may not have any template argument lists\n\n            \"template\" \"<\" template-parameter-list \">\"\n            nested-name-specifier\n\n    type_object:\n        goal:\n            either a single type (e.g., \"MyClass:Something_T\" or a typedef-like\n            thing (e.g. \"Something Something_T\" or \"int I_arr[]\"\n        grammar, single type: based on a type in a function parameter, but\n        without a name:\n               parameter-declaration\n            -> attribute-specifier-seq[opt] decl-specifier-seq\n               abstract-declarator[opt]\n            # Drop the attributes\n            -> decl-specifier-seq abstract-declarator[opt]\n        grammar, typedef-like: no initilizer\n            decl-specifier-seq declarator\n        Can start with a templateDeclPrefix.\n\n    member_object:\n        goal: as a type_object which must have a declarator, and optionally\n        with a initializer\n        grammar:\n            decl-specifier-seq declarator initializer\n        Can start with a templateDeclPrefix.\n\n    function_object:\n        goal: a function declaration, TODO: what about templates? for now: skip\n        grammar: no initializer\n           decl-specifier-seq declarator\n        Can start with a templateDeclPrefix.\n\n    class_object:\n        goal: a class declaration, but with specification of a base class\n        grammar:\n              attribute-specifier-seq[opt]\n                  nested-name \"final\"[opt] (\":\" base-specifier-list)[opt]\n            base-specifier-list ->\n              base-specifier \"...\"[opt]\n            | base-specifier-list, base-specifier \"...\"[opt]\n            base-specifier ->\n              base-type-specifier\n            | \"virtual\" access-spe\"cifier[opt]    base-type-specifier\n            | access-specifier[opt] \"virtual\"[opt] base-type-specifier\n        Can start with a templateDeclPrefix.\n\n    enum_object:\n        goal: an unscoped enum or a scoped enum, optionally with the underlying\n              type specified\n        grammar:\n            (\"class\" | \"struct\")[opt] visibility[opt]\n                attribute-specifier-seq[opt] nested-name (\":\" type)[opt]\n    enumerator_object:\n        goal: an element in a scoped or unscoped enum. The name should be\n              injected according to the scopedness.\n        grammar:\n            nested-name (\"=\" constant-expression)\n\n    namespace_object:\n        goal: a directive to put all following declarations in a specific scope\n        grammar:\n            nested-name\n\"\"\"",
                "filename": "sphinx/domains/cpp.py",
                "start_index": 1566,
                "end_index": 12453,
                "start_line": 1,
                "end_line": 7830,
                "max_line": 8160,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class CMemberObject(CObject):\n    object_type = 'member'\n\n    @property\n    def display_object_type(self) -> str:\n        # the distinction between var and member is only cosmetic\n        assert self.objtype in ('member', 'var')\n        return self.objtype\n\n\n_function_doc_field_types = [\n    TypedField('parameter', label=_('Parameters'),\n               names=('param', 'parameter', 'arg', 'argument'),\n               typerolename='expr', typenames=('type',)),\n    GroupedField('retval', label=_('Return values'),\n                 names=('retvals', 'retval'),\n                 can_collapse=True),\n    Field('returnvalue', label=_('Returns'), has_arg=False,\n          names=('returns', 'return')),\n    Field('returntype', label=_('Return type'), has_arg=False,\n          names=('rtype',)),\n]\n\n\nclass CFunctionObject(CObject):\n    object_type = 'function'\n\n    doc_field_types = _function_doc_field_types.copy()\n\n\nclass CMacroObject(CObject):\n    object_type = 'macro'\n\n    doc_field_types = _function_doc_field_types.copy()\n\n\nclass CStructObject(CObject):\n    object_type = 'struct'\n\n\nclass CUnionObject(CObject):\n    object_type = 'union'\n\n\nclass CEnumObject(CObject):\n    object_type = 'enum'\n\n\nclass CEnumeratorObject(CObject):\n    object_type = 'enumerator'\n\n\nclass CTypeObject(CObject):\n    object_type = 'type'\n\n\nclass CNamespaceObject(SphinxDirective):\n    \"\"\"\n    This directive is just to tell Sphinx that we're documenting stuff in\n    namespace foo.\n    \"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec: OptionSpec = {}\n\n    def run(self) -> list[Node]:\n        rootSymbol = self.env.domaindata['c']['root_symbol']\n        if self.arguments[0].strip() in ('NULL', '0', 'nullptr'):\n            symbol = rootSymbol\n            stack: list[Symbol] = []\n        else:\n            parser = DefinitionParser(self.arguments[0],\n                                      location=self.get_location(),\n                                      config=self.env.config)\n            try:\n                name = parser.parse_namespace_object()\n                parser.assert_end()\n            except DefinitionError as e:\n                logger.warning(e, location=self.get_location())\n                name = _make_phony_error_name()\n            symbol = rootSymbol.add_name(name)\n            stack = [symbol]\n        self.env.temp_data['c:parent_symbol'] = symbol\n        self.env.temp_data['c:namespace_stack'] = stack\n        self.env.ref_context['c:parent_key'] = symbol.get_lookup_key()\n        return []",
                "filename": "sphinx/domains/c.py",
                "start_index": 128975,
                "end_index": 131560,
                "start_line": 3316,
                "end_line": 3847,
                "max_line": 3876,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Utility functions common to the C and C++ domains.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom copy import deepcopy\nfrom typing import Any, Callable\n\nfrom docutils import nodes\nfrom docutils.nodes import TextElement\n\nfrom sphinx import addnodes\nfrom sphinx.config import Config\nfrom sphinx.util import logging\n\nlogger = logging.getLogger(__name__)\n\nStringifyTransform = Callable[[Any], str]\n\n\n_whitespace_re = re.compile(r'\\s+')\nanon_identifier_re = re.compile(r'(@[a-zA-Z0-9_])[a-zA-Z0-9_]*\\b')\nidentifier_re = re.compile(r'''\n    (   # This 'extends' _anon_identifier_re with the ordinary identifiers,\n        # make sure they are in sync.\n        (~?\\b[a-zA-Z_])  # ordinary identifiers\n    |   (@[a-zA-Z0-9_])  # our extension for names of anonymous entities\n    )\n    [a-zA-Z0-9_]*\\b\n''', flags=re.VERBOSE)\ninteger_literal_re = re.compile(r'[1-9][0-9]*(\\'[0-9]+)*')\noctal_literal_re = re.compile(r'0[0-7]*(\\'[0-7]+)*')\nhex_literal_re = re.compile(r'0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*')\nbinary_literal_re = re.compile(r'0[bB][01]+(\\'[01]+)*')\nintegers_literal_suffix_re = re.compile(r'''\n    # unsigned and/or (long) long, in any order, but at least one of them\n    (\n        ([uU]    ([lL]  |  (ll)  |  (LL))?)\n        |\n        (([lL]  |  (ll)  |  (LL))    [uU]?)\n    )\\b\n    # the ending word boundary is important for distinguishing\n    # between suffixes and UDLs in C++\n''', flags=re.VERBOSE)\nfloat_literal_re = re.compile(r'''\n    [+-]?(\n    # decimal\n      ([0-9]+(\\'[0-9]+)*[eE][+-]?[0-9]+(\\'[0-9]+)*)\n    | (([0-9]+(\\'[0-9]+)*)?\\.[0-9]+(\\'[0-9]+)*([eE][+-]?[0-9]+(\\'[0-9]+)*)?)\n    | ([0-9]+(\\'[0-9]+)*\\.([eE][+-]?[0-9]+(\\'[0-9]+)*)?)\n    # hex\n    | (0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*[pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)\n    | (0[xX]([0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?\\.\n        [0-9a-fA-F]+(\\'[0-9a-fA-F]+)*([pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?)\n    | (0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*\\.([pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?)\n    )\n''', flags=re.VERBOSE)\nfloat_literal_suffix_re = re.compile(r'[fFlL]\\b')\n# the ending word boundary is important for distinguishing between suffixes and UDLs in C++\nchar_literal_re = re.compile(r'''\n    ((?:u8)|u|U|L)?\n    '(\n      (?:[^\\\\'])\n    | (\\\\(\n        (?:['\"?\\\\abfnrtv])\n      | (?:[0-7]{1,3})\n      | (?:x[0-9a-fA-F]{2})\n      | (?:u[0-9a-fA-F]{4})\n      | (?:U[0-9a-fA-F]{8})\n      ))\n    )'\n''', flags=re.VERBOSE)\n\n\ndef verify_description_mode(mode: str) -> None:\n    if mode not in ('lastIsName', 'noneIsName', 'markType', 'markName', 'param', 'udl'):\n        raise Exception(\"Description mode '%s' is invalid.\" % mode)\n\n\nclass NoOldIdError(Exception):\n    # Used to avoid implementing unneeded id generation for old id schemes.\n    pass",
                "filename": "sphinx/util/cfamily.py",
                "start_index": 0,
                "end_index": 2724,
                "start_line": 1,
                "end_line": 234,
                "max_line": 461,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "\"\"\"The composite types for Sphinx.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport typing\nfrom struct import Struct\nfrom types import TracebackType\nfrom typing import Any, Callable, Dict, ForwardRef, List, Tuple, TypeVar, Union\n\nfrom docutils import nodes\nfrom docutils.parsers.rst.states import Inliner\n\ntry:\n    from types import UnionType  # type: ignore  # python 3.10 or above\nexcept ImportError:\n    UnionType = None\n\n# builtin classes that have incorrect __module__\nINVALID_BUILTIN_CLASSES = {\n    Struct: 'struct.Struct',  # Before Python 3.9\n    TracebackType: 'types.TracebackType',\n}\n\n\ndef is_invalid_builtin_class(obj: Any) -> bool:\n    \"\"\"Check *obj* is an invalid built-in class.\"\"\"\n    try:\n        return obj in INVALID_BUILTIN_CLASSES\n    except TypeError:  # unhashable type\n        return False\n\n\n# Text like nodes which are initialized with text and rawsource\nTextlikeNode = Union[nodes.Text, nodes.TextElement]\n\n# type of None\nNoneType = type(None)\n\n# path matcher\nPathMatcher = Callable[[str], bool]\n\n# common role functions\nRoleFunction = Callable[[str, str, str, int, Inliner, Dict[str, Any], List[str]],\n                        Tuple[List[nodes.Node], List[nodes.system_message]]]\n\n# A option spec for directive\nOptionSpec = Dict[str, Callable[[str], Any]]\n\n# title getter functions for enumerable nodes (see sphinx.domains.std)\nTitleGetter = Callable[[nodes.Node], str]\n\n# inventory data on memory\nInventoryItem = Tuple[\n    str,  # project name\n    str,  # project version\n    str,  # URL\n    str,  # display name\n]\nInventory = Dict[str, Dict[str, InventoryItem]]\n\n\ndef get_type_hints(\n    obj: Any, globalns: dict[str, Any] | None = None, localns: dict | None = None,\n) -> dict[str, Any]:\n    \"\"\"Return a dictionary containing type hints for a function, method, module or class\n    object.\n\n    This is a simple wrapper of `typing.get_type_hints()` that does not raise an error on\n    runtime.\n    \"\"\"\n    from sphinx.util.inspect import safe_getattr  # lazy loading\n\n    try:\n        return typing.get_type_hints(obj, globalns, localns)\n    except NameError:\n        # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n        return safe_getattr(obj, '__annotations__', {})\n    except AttributeError:\n        # Failed to evaluate ForwardRef (maybe not runtime checkable)\n        return safe_getattr(obj, '__annotations__', {})\n    except TypeError:\n        # Invalid object is given. But try to get __annotations__ as a fallback for\n        # the code using type union operator (PEP 604) in python 3.9 or below.\n        return safe_getattr(obj, '__annotations__', {})\n    except KeyError:\n        # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n        return {}\n\n\ndef is_system_TypeVar(typ: Any) -> bool:\n    \"\"\"Check *typ* is system defined TypeVar.\"\"\"\n    modname = getattr(typ, '__module__', '')\n    return modname == 'typing' and isinstance(typ, TypeVar)",
                "filename": "sphinx/util/typing.py",
                "start_index": 0,
                "end_index": 2933,
                "start_line": 1,
                "end_line": 94,
                "max_line": 361,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "if TYPE_CHECKING:\n    from typing import Literal, MutableMapping\n\n    from typing_extensions import overload\n\n    from sphinx.domains.c import CDomain\n    from sphinx.domains.changeset import ChangeSetDomain\n    from sphinx.domains.citation import CitationDomain\n    from sphinx.domains.cpp import CPPDomain\n    from sphinx.domains.index import IndexDomain\n    from sphinx.domains.javascript import JavaScriptDomain\n    from sphinx.domains.math import MathDomain\n    from sphinx.domains.python import PythonDomain\n    from sphinx.domains.rst import ReSTDomain\n    from sphinx.domains.std import StandardDomain\n    from sphinx.ext.duration import DurationDomain\n    from sphinx.ext.todo import TodoDomain\n\n    class _DomainsType(MutableMapping[str, Domain]):\n        @overload\n        def __getitem__(self, key: Literal[\"c\"]) -> CDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"cpp\"]) -> CPPDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"changeset\"]) -> ChangeSetDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"citation\"]) -> CitationDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"index\"]) -> IndexDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"js\"]) -> JavaScriptDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"math\"]) -> MathDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"py\"]) -> PythonDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"rst\"]) -> ReSTDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"std\"]) -> StandardDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"duration\"]) -> DurationDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: Literal[\"todo\"]) -> TodoDomain: ...  # NoQA: E704\n        @overload\n        def __getitem__(self, key: str) -> Domain: ...  # NoQA: E704\n        def __getitem__(self, key): raise NotImplementedError  # NoQA: E704\n        def __setitem__(self, key, value): raise NotImplementedError  # NoQA: E704\n        def __delitem__(self, key): raise NotImplementedError  # NoQA: E704\n        def __iter__(self): raise NotImplementedError  # NoQA: E704\n        def __len__(self): raise NotImplementedError  # NoQA: E704\n\nelse:\n    _DomainsType = dict",
                "filename": "sphinx/environment/__init__.py",
                "start_index": 2204,
                "end_index": 4711,
                "start_line": 32,
                "end_line": 130,
                "max_line": 730,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _parse_nested_name(self) -> ASTNestedName:\n        names: list[Any] = []\n\n        self.skip_ws()\n        rooted = False\n        if self.skip_string('.'):\n            rooted = True\n        while 1:\n            self.skip_ws()\n            if not self.match(identifier_re):\n                self.fail(\"Expected identifier in nested name.\")\n            identifier = self.matched_text\n            # make sure there isn't a keyword\n            if identifier in _keywords:\n                self.fail(\"Expected identifier in nested name, \"\n                          \"got keyword: %s\" % identifier)\n            if self.matched_text in self.config.c_extra_keywords:\n                msg = \"Expected identifier, got user-defined keyword: %s.\" \\\n                      + \" Remove it from c_extra_keywords to allow it as identifier.\\n\" \\\n                      + \"Currently c_extra_keywords is %s.\"\n                self.fail(msg % (self.matched_text,\n                                 str(self.config.c_extra_keywords)))\n            ident = ASTIdentifier(identifier)\n            names.append(ident)\n\n            self.skip_ws()\n            if not self.skip_string('.'):\n                break\n        return ASTNestedName(names, rooted)\n\n    def _parse_simple_type_specifier(self) -> str | None:\n        if self.match(_simple_type_specifiers_re):\n            return self.matched_text\n        for t in ('bool', 'complex', 'imaginary'):\n            if t in self.config.c_extra_keywords:\n                if self.skip_word(t):\n                    return t\n        return None\n\n    def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental | None:\n        names: list[str] = []\n\n        self.skip_ws()\n        while True:\n            t = self._parse_simple_type_specifier()\n            if t is None:\n                break\n            names.append(t)\n            self.skip_ws()\n        if len(names) == 0:\n            return None\n        return ASTTrailingTypeSpecFundamental(names)\n\n    def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:\n        # fundamental types, https://en.cppreference.com/w/c/language/type\n        # and extensions\n        self.skip_ws()\n        res = self._parse_simple_type_specifiers()\n        if res is not None:\n            return res\n\n        # prefixed\n        prefix = None\n        self.skip_ws()\n        for k in ('struct', 'enum', 'union'):\n            if self.skip_word_and_ws(k):\n                prefix = k\n                break\n\n        nestedName = self._parse_nested_name()\n        return ASTTrailingTypeSpecName(prefix, nestedName)",
                "filename": "sphinx/domains/c.py",
                "start_index": 97743,
                "end_index": 100315,
                "start_line": 2573,
                "end_line": 2643,
                "max_line": 3876,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                "sha": "",
                "context_relevance": 1.0
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "sphinx/domains/c.py": [
                {
                    "chunk": {
                        "code": "\"\"\"The C language domain.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Any, Callable, Generator, Iterator, TypeVar, Union, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element, Node, TextElement, system_message\nfrom docutils.parsers.rst import directives\n\nfrom sphinx import addnodes\nfrom sphinx.addnodes import pending_xref\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import Builder\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.domains import Domain, ObjType\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import _, __\nfrom sphinx.roles import SphinxRole, XRefRole\nfrom sphinx.transforms import SphinxTransform\nfrom sphinx.transforms.post_transforms import ReferencesResolver\nfrom sphinx.util import logging\nfrom sphinx.util.cfamily import (\n    ASTAttributeList,\n    ASTBaseBase,\n    ASTBaseParenExprList,\n    BaseParser,\n    DefinitionError,\n    NoOldIdError,\n    StringifyTransform,\n    UnsupportedMultiCharacterCharLiteral,\n    anon_identifier_re,\n    binary_literal_re,\n    char_literal_re,\n    float_literal_re,\n    float_literal_suffix_re,\n    hex_literal_re,\n    identifier_re,\n    integer_literal_re,\n    integers_literal_suffix_re,\n    octal_literal_re,\n    verify_description_mode,\n)\nfrom sphinx.util.docfields import Field, GroupedField, TypedField\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.nodes import make_refnode\nfrom sphinx.util.typing import OptionSpec\n\nlogger = logging.getLogger(__name__)\nT = TypeVar('T')\n\nDeclarationType = Union[\n    \"ASTStruct\", \"ASTUnion\", \"ASTEnum\", \"ASTEnumerator\",\n    \"ASTType\", \"ASTTypeWithInit\", \"ASTMacro\",\n]\n\n# https://en.cppreference.com/w/c/keyword\n_keywords = [\n    'auto', 'break', 'case', 'char', 'const', 'continue', 'default', 'do', 'double',\n    'else', 'enum', 'extern', 'float', 'for', 'goto', 'if', 'inline', 'int', 'long',\n    'register', 'restrict', 'return', 'short', 'signed', 'sizeof', 'static', 'struct',\n    'switch', 'typedef', 'union', 'unsigned', 'void', 'volatile', 'while',\n    '_Alignas', '_Alignof', '_Atomic', '_Bool', '_Complex',\n    '_Decimal32', '_Decimal64', '_Decimal128',\n    '_Generic', '_Imaginary', '_Noreturn', '_Static_assert', '_Thread_local',\n]\n# These are only keyword'y when the corresponding headers are included.\n# They are used as default value for c_extra_keywords.\n_macroKeywords = [\n    'alignas', 'alignof', 'bool', 'complex', 'imaginary', 'noreturn', 'static_assert',\n    'thread_local',\n]\n\n# these are ordered by preceedence\n_expression_bin_ops = [\n    ['||', 'or'],\n    ['&&', 'and'],\n    ['|', 'bitor'],\n    ['^', 'xor'],\n    ['&', 'bitand'],\n    ['==', '!=', 'not_eq'],\n    ['<=', '>=', '<', '>'],\n    ['<<', '>>'],\n    ['+', '-'],\n    ['*', '/', '%'],\n    ['.*', '->*'],\n]\n_expression_unary_ops = [\"++\", \"--\", \"*\", \"&\", \"+\", \"-\", \"!\", \"not\", \"~\", \"compl\"]",
                        "filename": "sphinx/domains/c.py",
                        "start_index": 0,
                        "end_index": 2872,
                        "start_line": 1,
                        "end_line": 89,
                        "max_line": 3876,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the list of keywords and extra keywords for the C domain, which is relevant to the issue as the parsing error is related to the handling of certain keywords like '_Complex'."
                },
                {
                    "chunk": {
                        "code": "def _parse_nested_name(self) -> ASTNestedName:\n        names: list[Any] = []\n\n        self.skip_ws()\n        rooted = False\n        if self.skip_string('.'):\n            rooted = True\n        while 1:\n            self.skip_ws()\n            if not self.match(identifier_re):\n                self.fail(\"Expected identifier in nested name.\")\n            identifier = self.matched_text\n            # make sure there isn't a keyword\n            if identifier in _keywords:\n                self.fail(\"Expected identifier in nested name, \"\n                          \"got keyword: %s\" % identifier)\n            if self.matched_text in self.config.c_extra_keywords:\n                msg = \"Expected identifier, got user-defined keyword: %s.\" \\\n                      + \" Remove it from c_extra_keywords to allow it as identifier.\\n\" \\\n                      + \"Currently c_extra_keywords is %s.\"\n                self.fail(msg % (self.matched_text,\n                                 str(self.config.c_extra_keywords)))\n            ident = ASTIdentifier(identifier)\n            names.append(ident)\n\n            self.skip_ws()\n            if not self.skip_string('.'):\n                break\n        return ASTNestedName(names, rooted)\n\n    def _parse_simple_type_specifier(self) -> str | None:\n        if self.match(_simple_type_specifiers_re):\n            return self.matched_text\n        for t in ('bool', 'complex', 'imaginary'):\n            if t in self.config.c_extra_keywords:\n                if self.skip_word(t):\n                    return t\n        return None\n\n    def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental | None:\n        names: list[str] = []\n\n        self.skip_ws()\n        while True:\n            t = self._parse_simple_type_specifier()\n            if t is None:\n                break\n            names.append(t)\n            self.skip_ws()\n        if len(names) == 0:\n            return None\n        return ASTTrailingTypeSpecFundamental(names)\n\n    def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:\n        # fundamental types, https://en.cppreference.com/w/c/language/type\n        # and extensions\n        self.skip_ws()\n        res = self._parse_simple_type_specifiers()\n        if res is not None:\n            return res\n\n        # prefixed\n        prefix = None\n        self.skip_ws()\n        for k in ('struct', 'enum', 'union'):\n            if self.skip_word_and_ws(k):\n                prefix = k\n                break\n\n        nestedName = self._parse_nested_name()\n        return ASTTrailingTypeSpecName(prefix, nestedName)",
                        "filename": "sphinx/domains/c.py",
                        "start_index": 97743,
                        "end_index": 100315,
                        "start_line": 2573,
                        "end_line": 2643,
                        "max_line": 3876,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the parsing logic for nested names and type specifiers in the C domain, which is relevant to the issue since the parsing errors are related to the handling of type specifiers like 'complex', '_Complex', and 'long fract'."
                },
                {
                    "chunk": {
                        "code": "class CMemberObject(CObject):\n    object_type = 'member'\n\n    @property\n    def display_object_type(self) -> str:\n        # the distinction between var and member is only cosmetic\n        assert self.objtype in ('member', 'var')\n        return self.objtype\n\n\n_function_doc_field_types = [\n    TypedField('parameter', label=_('Parameters'),\n               names=('param', 'parameter', 'arg', 'argument'),\n               typerolename='expr', typenames=('type',)),\n    GroupedField('retval', label=_('Return values'),\n                 names=('retvals', 'retval'),\n                 can_collapse=True),\n    Field('returnvalue', label=_('Returns'), has_arg=False,\n          names=('returns', 'return')),\n    Field('returntype', label=_('Return type'), has_arg=False,\n          names=('rtype',)),\n]\n\n\nclass CFunctionObject(CObject):\n    object_type = 'function'\n\n    doc_field_types = _function_doc_field_types.copy()\n\n\nclass CMacroObject(CObject):\n    object_type = 'macro'\n\n    doc_field_types = _function_doc_field_types.copy()\n\n\nclass CStructObject(CObject):\n    object_type = 'struct'\n\n\nclass CUnionObject(CObject):\n    object_type = 'union'\n\n\nclass CEnumObject(CObject):\n    object_type = 'enum'\n\n\nclass CEnumeratorObject(CObject):\n    object_type = 'enumerator'\n\n\nclass CTypeObject(CObject):\n    object_type = 'type'\n\n\nclass CNamespaceObject(SphinxDirective):\n    \"\"\"\n    This directive is just to tell Sphinx that we're documenting stuff in\n    namespace foo.\n    \"\"\"\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec: OptionSpec = {}\n\n    def run(self) -> list[Node]:\n        rootSymbol = self.env.domaindata['c']['root_symbol']\n        if self.arguments[0].strip() in ('NULL', '0', 'nullptr'):\n            symbol = rootSymbol\n            stack: list[Symbol] = []\n        else:\n            parser = DefinitionParser(self.arguments[0],\n                                      location=self.get_location(),\n                                      config=self.env.config)\n            try:\n                name = parser.parse_namespace_object()\n                parser.assert_end()\n            except DefinitionError as e:\n                logger.warning(e, location=self.get_location())\n                name = _make_phony_error_name()\n            symbol = rootSymbol.add_name(name)\n            stack = [symbol]\n        self.env.temp_data['c:parent_symbol'] = symbol\n        self.env.temp_data['c:namespace_stack'] = stack\n        self.env.ref_context['c:parent_key'] = symbol.get_lookup_key()\n        return []",
                        "filename": "sphinx/domains/c.py",
                        "start_index": 128975,
                        "end_index": 131560,
                        "start_line": 3316,
                        "end_line": 3847,
                        "max_line": 3876,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the classes for different C language objects, including functions and types, which may need to be reviewed or modified to support the GNU extension types mentioned in the issue."
                },
                {
                    "chunk": {
                        "code": "\"\"\"C language domain.\"\"\"\n    name = 'c'\n    label = 'C'\n    object_types = {\n        # 'identifier' is the one used for xrefs generated in signatures, not in roles\n        'member': ObjType(_('member'), 'var', 'member', 'data', 'identifier'),\n        'var': ObjType(_('variable'),  'var', 'member', 'data', 'identifier'),\n        'function': ObjType(_('function'),     'func',          'identifier', 'type'),\n        'macro': ObjType(_('macro'),           'macro',         'identifier'),\n        'struct': ObjType(_('struct'),         'struct',        'identifier', 'type'),\n        'union': ObjType(_('union'),           'union',         'identifier', 'type'),\n        'enum': ObjType(_('enum'),             'enum',          'identifier', 'type'),\n        'enumerator': ObjType(_('enumerator'), 'enumerator',    'identifier'),\n        'type': ObjType(_('type'),                              'identifier', 'type'),\n        # generated object types\n        'functionParam': ObjType(_('function parameter'),       'identifier', 'var', 'member', 'data'),  # noqa: E501\n    }\n\n    directives = {\n        'member': CMemberObject,\n        'var': CMemberObject,\n        'function': CFunctionObject,\n        'macro': CMacroObject,\n        'struct': CStructObject,\n        'union': CUnionObject,\n        'enum': CEnumObject,\n        'enumerator': CEnumeratorObject,\n        'type': CTypeObject,\n        # scope control\n        'namespace': CNamespaceObject,\n        'namespace-push': CNamespacePushObject,\n        'namespace-pop': CNamespacePopObject,\n        # other\n        'alias': CAliasObject,\n    }\n    roles = {\n        'member': CXRefRole(),\n        'data': CXRefRole(),\n        'var': CXRefRole(),\n        'func': CXRefRole(fix_parens=True),\n        'macro': CXRefRole(),\n        'struct': CXRefRole(),\n        'union': CXRefRole(),\n        'enum': CXRefRole(),\n        'enumerator': CXRefRole(),\n        'type': CXRefRole(),\n        'expr': CExprRole(asCode=True),\n        'texpr': CExprRole(asCode=False),\n    }\n    initial_data: dict[str, Symbol | dict[str, tuple[str, str, str]]] = {\n        'root_symbol': Symbol(None, None, None, None, None),\n        'objects': {},  # fullname -> docname, node_id, objtype\n    }\n\n    def clear_doc(self, docname: str) -> None:\n        if Symbol.debug_show_tree:\n            print(\"clear_doc:\", docname)\n            print(\"\\tbefore:\")\n            print(self.data['root_symbol'].dump(1))\n            print(\"\\tbefore end\")\n\n        rootSymbol = self.data['root_symbol']\n        rootSymbol.clear_doc(docname)\n\n        if Symbol.debug_show_tree:\n            print(\"\\tafter:\")\n            print(self.data['root_symbol'].dump(1))\n            print(\"\\tafter end\")\n            print(\"clear_doc end:\", docname)",
                        "filename": "sphinx/domains/c.py",
                        "start_index": 143048,
                        "end_index": 145788,
                        "start_line": 3696,
                        "end_line": 3764,
                        "max_line": 3876,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the object types and roles for the C domain, which could be relevant when considering how to handle the new types like '_Complex' or '_Fract' within the domain's structure."
                }
            ],
            "sphinx/util/cfamily.py": [
                {
                    "chunk": {
                        "code": "\"\"\"Utility functions common to the C and C++ domains.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom copy import deepcopy\nfrom typing import Any, Callable\n\nfrom docutils import nodes\nfrom docutils.nodes import TextElement\n\nfrom sphinx import addnodes\nfrom sphinx.config import Config\nfrom sphinx.util import logging\n\nlogger = logging.getLogger(__name__)\n\nStringifyTransform = Callable[[Any], str]\n\n\n_whitespace_re = re.compile(r'\\s+')\nanon_identifier_re = re.compile(r'(@[a-zA-Z0-9_])[a-zA-Z0-9_]*\\b')\nidentifier_re = re.compile(r'''\n    (   # This 'extends' _anon_identifier_re with the ordinary identifiers,\n        # make sure they are in sync.\n        (~?\\b[a-zA-Z_])  # ordinary identifiers\n    |   (@[a-zA-Z0-9_])  # our extension for names of anonymous entities\n    )\n    [a-zA-Z0-9_]*\\b\n''', flags=re.VERBOSE)\ninteger_literal_re = re.compile(r'[1-9][0-9]*(\\'[0-9]+)*')\noctal_literal_re = re.compile(r'0[0-7]*(\\'[0-7]+)*')\nhex_literal_re = re.compile(r'0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*')\nbinary_literal_re = re.compile(r'0[bB][01]+(\\'[01]+)*')\nintegers_literal_suffix_re = re.compile(r'''\n    # unsigned and/or (long) long, in any order, but at least one of them\n    (\n        ([uU]    ([lL]  |  (ll)  |  (LL))?)\n        |\n        (([lL]  |  (ll)  |  (LL))    [uU]?)\n    )\\b\n    # the ending word boundary is important for distinguishing\n    # between suffixes and UDLs in C++\n''', flags=re.VERBOSE)\nfloat_literal_re = re.compile(r'''\n    [+-]?(\n    # decimal\n      ([0-9]+(\\'[0-9]+)*[eE][+-]?[0-9]+(\\'[0-9]+)*)\n    | (([0-9]+(\\'[0-9]+)*)?\\.[0-9]+(\\'[0-9]+)*([eE][+-]?[0-9]+(\\'[0-9]+)*)?)\n    | ([0-9]+(\\'[0-9]+)*\\.([eE][+-]?[0-9]+(\\'[0-9]+)*)?)\n    # hex\n    | (0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*[pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)\n    | (0[xX]([0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?\\.\n        [0-9a-fA-F]+(\\'[0-9a-fA-F]+)*([pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?)\n    | (0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*\\.([pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?)\n    )\n''', flags=re.VERBOSE)\nfloat_literal_suffix_re = re.compile(r'[fFlL]\\b')\n# the ending word boundary is important for distinguishing between suffixes and UDLs in C++\nchar_literal_re = re.compile(r'''\n    ((?:u8)|u|U|L)?\n    '(\n      (?:[^\\\\'])\n    | (\\\\(\n        (?:['\"?\\\\abfnrtv])\n      | (?:[0-7]{1,3})\n      | (?:x[0-9a-fA-F]{2})\n      | (?:u[0-9a-fA-F]{4})\n      | (?:U[0-9a-fA-F]{8})\n      ))\n    )'\n''', flags=re.VERBOSE)\n\n\ndef verify_description_mode(mode: str) -> None:\n    if mode not in ('lastIsName', 'noneIsName', 'markType', 'markName', 'param', 'udl'):\n        raise Exception(\"Description mode '%s' is invalid.\" % mode)\n\n\nclass NoOldIdError(Exception):\n    # Used to avoid implementing unneeded id generation for old id schemes.\n    pass",
                        "filename": "sphinx/util/cfamily.py",
                        "start_index": 0,
                        "end_index": 2724,
                        "start_line": 1,
                        "end_line": 234,
                        "max_line": 461,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains regular expressions for parsing different literals and identifiers in the C and C++ domains, which might be relevant if the issue requires adjustments to the parsing logic for the new types."
                }
            ]
        },
        "solution_task": "To implement support for GNU extension types like `_Complex` and `_Fract` in the Sphinx C domain, you can follow these steps:\n\n- Extend the `_parse_simple_type_specifier` method in `sphinx/domains/c.py` to recognize the GNU extension types.\n- Update the `_simple_type_specifiers_re` regular expression to include the new types if they are not already part of the `c_extra_keywords`.\n- Ensure that the parser does not fail when encountering these types by modifying the checks against `_keywords` and `c_extra_keywords`.\n- Add tests for the new types to ensure that they are parsed correctly.\n\nHere's a rough implementation outline:\n\n1. Update the `_simple_type_specifiers_re` regular expression to include `_Complex` and `_Fract`:\n\n```python\n_simple_type_specifiers_re = re.compile(\n    r'(void|char|short|int|long|float|double|signed|unsigned'\n    r'|_Bool|_Complex|_Imaginary|_Fract|_Accum|_Sat|_Sat_Fract|_Sat_Accum'\n    r'|__int128_t|__int128|__uint128_t|__uint128|__builtin_va_list|__char16_t|__char32_t'\n    r'|__float128|__ibm128|__int8_t|__int16_t|__int32_t|__int64_t'\n    r'|__uint8_t|__uint16_t|__uint32_t|__uint64_t|__builtin_ms_va_list|__builtin_va_list)'\n)\n```\n\n2. Modify the `_parse_simple_type_specifier` method to handle the new types:\n\n```python\ndef _parse_simple_type_specifier(self) -> str | None:\n    if self.match(_simple_type_specifiers_re):\n        return self.matched_text\n    for t in ('_Complex', '_Fract', '_Accum', '_Sat'):\n        if t in self.config.c_extra_keywords:\n            if self.skip_word(t):\n                return t\n    return None\n```\n\n3. Update the checks against `_keywords` and `c_extra_keywords` to allow the new types:\n\n```python\n# In the _parse_nested_name method, update the error message to be more specific\n# about the new types being allowed as identifiers.\nif identifier in _keywords and identifier not in ('_Complex', '_Fract', '_Accum', '_Sat'):\n    self.fail(\"Expected identifier in nested name, got keyword: %s\" % identifier)\n```\n\n4. Add tests for the new types to ensure they are parsed correctly. This would involve creating test cases in the Sphinx test suite that use the new types in function declarations, struct definitions, etc., and verifying that the documentation is generated without errors.\n\n5. Update the documentation to mention the support for these new types.\n\nPlease note that this is a high-level overview and the actual implementation may require more detailed changes, including handling of the new types in other parts of the parser and ensuring compatibility with the rest of the Sphinx documentation system. Additionally, you may need to handle the attributes and qualifiers that can be used with these types.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant suggestions that can directly lead to the successful implementation or improvement of the requested feature.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable plan for implementing support for GNU extension types like `_Complex` and `_Fract` in the Sphinx C domain. It suggests extending the `_parse_simple_type_specifier` method, updating the `_simple_type_specifiers_re` regular expression, modifying checks against keywords, and adding tests for the new types. The RESPONSE also includes a rough implementation outline with code snippets, which is highly relevant to the feature request. Furthermore, it provides links to specific code snippets in the Sphinx repository that are relevant to the issue, which could be very useful for the developer working on this feature. The RESPONSE only lacks a minor detail about the potential need for handling attributes and qualifiers with these types, which prevents it from scoring a perfect 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711702401.190848,
        "result": "To implement support for GNU extension types like `_Complex` and `_Fract` in the Sphinx C domain, you can follow these steps:\n\n- Extend the `_parse_simple_type_specifier` method in `sphinx/domains/c.py` to recognize the GNU extension types.\n- Update the `_simple_type_specifiers_re` regular expression to include the new types if they are not already part of the `c_extra_keywords`.\n- Ensure that the parser does not fail when encountering these types by modifying the checks against `_keywords` and `c_extra_keywords`.\n- Add tests for the new types to ensure that they are parsed correctly.\n\nHere's a rough implementation outline:\n\n1. Update the `_simple_type_specifiers_re` regular expression to include `_Complex` and `_Fract`:\n\n```python\n_simple_type_specifiers_re = re.compile(\n    r'(void|char|short|int|long|float|double|signed|unsigned'\n    r'|_Bool|_Complex|_Imaginary|_Fract|_Accum|_Sat|_Sat_Fract|_Sat_Accum'\n    r'|__int128_t|__int128|__uint128_t|__uint128|__builtin_va_list|__char16_t|__char32_t'\n    r'|__float128|__ibm128|__int8_t|__int16_t|__int32_t|__int64_t'\n    r'|__uint8_t|__uint16_t|__uint32_t|__uint64_t|__builtin_ms_va_list|__builtin_va_list)'\n)\n```\n\n2. Modify the `_parse_simple_type_specifier` method to handle the new types:\n\n```python\ndef _parse_simple_type_specifier(self) -> str | None:\n    if self.match(_simple_type_specifiers_re):\n        return self.matched_text\n    for t in ('_Complex', '_Fract', '_Accum', '_Sat'):\n        if t in self.config.c_extra_keywords:\n            if self.skip_word(t):\n                return t\n    return None\n```\n\n3. Update the checks against `_keywords` and `c_extra_keywords` to allow the new types:\n\n```python\n# In the _parse_nested_name method, update the error message to be more specific\n# about the new types being allowed as identifiers.\nif identifier in _keywords and identifier not in ('_Complex', '_Fract', '_Accum', '_Sat'):\n    self.fail(\"Expected identifier in nested name, got keyword: %s\" % identifier)\n```\n\n4. Add tests for the new types to ensure they are parsed correctly. This would involve creating test cases in the Sphinx test suite that use the new types in function declarations, struct definitions, etc., and verifying that the documentation is generated without errors.\n\n5. Update the documentation to mention the support for these new types.\n\nPlease note that this is a high-level overview and the actual implementation may require more detailed changes, including handling of the new types in other parts of the parser and ensuring compatibility with the rest of the Sphinx documentation system. Additionally, you may need to handle the attributes and qualifiers that can be used with these types.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx) \u2192 [domains](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx/domains)- [Lines 1 - 89](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L1-L89)\n\n This snippet contains the list of keywords and extra keywords for the C domain, which is relevant to the issue as the parsing error is related to the handling of certain keywords like '_Complex'. \n\n\n   - [Lines 2573 - 2643](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L2573-L2643)\n\n This snippet includes the parsing logic for nested names and type specifiers in the C domain, which is relevant to the issue since the parsing errors are related to the handling of type specifiers like 'complex', '_Complex', and 'long fract'. \n\n\n   - [Lines 3316 - 3847](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L3316-L3847)\n\n This snippet defines the classes for different C language objects, including functions and types, which may need to be reviewed or modified to support the GNU extension types mentioned in the issue. \n\n\n   - [Lines 3696 - 3764](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/domains/c.py#L3696-L3764)\n\n This snippet defines the object types and roles for the C domain, which could be relevant when considering how to handle the new types like '_Complex' or '_Fract' within the domain's structure.\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx) \u2192 [util](https://github.com/testbed/sphinx-doc__sphinx__4.2/tree//sphinx/util)- [Lines 1 - 234](https://github.com/testbed/sphinx-doc__sphinx__4.2/blob//sphinx/util/cfamily.py#L1-L234)\n\n This snippet contains regular expressions for parsing different literals and identifiers in the C and C++ domains, which might be relevant if the issue requires adjustments to the parsing logic for the new types.",
        "context_relevance": 0.27,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant and answers the entire PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed solution to the problem described in the PROMPT, including steps to implement support for GNU extension types in the Sphinx C domain. It addresses the parsing errors, suggests modifications to the parser, and includes code snippets for clarity. The RESPONSE also acknowledges the need for tests and documentation updates, which are part of the complete solution. The RESPONSE is directly related to the technical issue presented and offers a comprehensive approach to resolving it, thus meeting the criteria for a score of 10."
        },
        "qa_relevance": 1.0
    }
}