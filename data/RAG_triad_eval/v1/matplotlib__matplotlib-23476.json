{
    "id": "matplotlib__matplotlib-23476",
    "repo_name": "testbed/matplotlib__matplotlib__3.5",
    "task_id": 5573563070922753988,
    "title": "[Bug]: DPI of a figure is doubled after unpickling on M1 Mac",
    "body": "### Bug summary\r\n\r\nWhen a figure is unpickled, it's dpi is doubled. This behaviour happens every time and if done in a loop it can cause an `OverflowError`.\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nimport numpy as np\r\nimport matplotlib\r\nimport matplotlib.pyplot as plt\r\nimport pickle\r\nimport platform\r\n\r\nprint(matplotlib.get_backend())\r\nprint('Matplotlib ver:', matplotlib.__version__)\r\nprint('Platform:', platform.platform())\r\nprint('System:', platform.system())\r\nprint('Release:', platform.release())\r\nprint('Python ver:', platform.python_version())\r\n\r\n\r\ndef dump_load_get_dpi(fig):\r\n    with open('sinus.pickle','wb') as file:\r\n        pickle.dump(fig, file)\r\n\r\n    with open('sinus.pickle', 'rb') as blob:\r\n        fig2 = pickle.load(blob)\r\n    return fig2, fig2.dpi\r\n\r\n\r\ndef run():\r\n    fig = plt.figure()\r\n    x = np.linspace(0,2*np.pi)\r\n    y = np.sin(x)\r\n\r\n    for i in range(32):\r\n        print(f'{i}: {fig.dpi}')\r\n        fig, dpi = dump_load_get_dpi(fig)\r\n\r\n\r\nif __name__ == '__main__':\r\n    run()\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\n```\r\nMacOSX\r\nMatplotlib ver: 3.5.2\r\nPlatform: macOS-12.4-arm64-arm-64bit\r\nSystem: Darwin\r\nRelease: 21.5.0\r\nPython ver: 3.9.12\r\n0: 200.0\r\n1: 400.0\r\n2: 800.0\r\n3: 1600.0\r\n4: 3200.0\r\n5: 6400.0\r\n6: 12800.0\r\n7: 25600.0\r\n8: 51200.0\r\n9: 102400.0\r\n10: 204800.0\r\n11: 409600.0\r\n12: 819200.0\r\n13: 1638400.0\r\n14: 3276800.0\r\n15: 6553600.0\r\n16: 13107200.0\r\n17: 26214400.0\r\n18: 52428800.0\r\n19: 104857600.0\r\n20: 209715200.0\r\n21: 419430400.0\r\nTraceback (most recent call last):\r\n  File \"/Users/wsykala/projects/matplotlib/example.py\", line 34, in <module>\r\n    run()\r\n  File \"/Users/wsykala/projects/matplotlib/example.py\", line 30, in run\r\n    fig, dpi = dump_load_get_dpi(fig)\r\n  File \"/Users/wsykala/projects/matplotlib/example.py\", line 20, in dump_load_get_dpi\r\n    fig2 = pickle.load(blob)\r\n  File \"/Users/wsykala/miniconda3/envs/playground/lib/python3.9/site-packages/matplotlib/figure.py\", line 2911, in __setstate__\r\n    mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\r\n  File \"/Users/wsykala/miniconda3/envs/playground/lib/python3.9/site-packages/matplotlib/backend_bases.py\", line 3499, in new_figure_manager_given_figure\r\n    canvas = cls.FigureCanvas(figure)\r\n  File \"/Users/wsykala/miniconda3/envs/playground/lib/python3.9/site-packages/matplotlib/backends/backend_macosx.py\", line 32, in __init__\r\n    _macosx.FigureCanvas.__init__(self, width, height)\r\nOverflowError: signed integer is greater than maximum\r\n```\r\n\r\n### Expected outcome\r\n\r\n```\r\nMacOSX\r\nMatplotlib ver: 3.5.2\r\nPlatform: macOS-12.4-arm64-arm-64bit\r\nSystem: Darwin\r\nRelease: 21.5.0\r\nPython ver: 3.9.12\r\n0: 200.0\r\n1: 200.0\r\n2: 200.0\r\n3: 200.0\r\n4: 200.0\r\n5: 200.0\r\n6: 200.0\r\n7: 200.0\r\n8: 200.0\r\n9: 200.0\r\n10: 200.0\r\n11: 200.0\r\n12: 200.0\r\n13: 200.0\r\n14: 200.0\r\n15: 200.0\r\n16: 200.0\r\n17: 200.0\r\n18: 200.0\r\n19: 200.0\r\n20: 200.0\r\n21: 200.0\r\n22: 200.0\r\n```\r\n\r\n### Additional information\r\n\r\nThis seems to happen only on M1 MacBooks and the version of python doesn't matter.\r\n\r\n### Operating system\r\n\r\nOS/X\r\n\r\n### Matplotlib Version\r\n\r\n3.5.2\r\n\r\n### Matplotlib Backend\r\n\r\nMacOSX\r\n\r\n### Python version\r\n\r\n3.9.12\r\n\r\n### Jupyter version\r\n\r\n_No response_\r\n\r\n### Installation\r\n\r\npip\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.5.git",
    "requested_commit": "",
    "mayil_response": "- Investigate if the `dpi` attribute of the `fig` object is being modified unintentionally during the pickling and unpickling process.\n- Ensure that the `dpi` attribute is set correctly before pickling the `fig` object.\n- After unpickling, explicitly set the `dpi` attribute of the `fig` object to its original value before it was pickled.\n- If the issue persists, consider using a different backend that does not exhibit this behavior on M1 MacBooks, such as switching from `MacOSX` to `TkAgg`, `Qt5Agg`, or another available backend.\n- If the issue is confirmed to be a bug in the `MacOSX` backend, report it to the Matplotlib development team for further investigation and potential fixing in a future release.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib/backends)- [Lines 141 - 215](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_macosx.py#L141-L215)\n\n This snippet contains the backend implementation for MacOSX, which is relevant to the issue as it is specific to M1 MacBooks and the MacOSX backend.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib)- [Lines 2122 - 2128](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backend_bases.py#L2122-L2128)\n\n This snippet is part of the code that sets the DPI for the figure during the save process, which could be related to the issue of DPI doubling after unpickling. \n\n\n   - [Lines 2116 - 2121](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backend_bases.py#L2116-L2121)\n\n This snippet deals with setting the DPI for the figure, which is directly related to the issue of DPI doubling.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib)- [Lines 1 - 84](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/_tight_bbox.py#L1-L84)\n\n This snippet includes code that adjusts the figure's DPI, which could be relevant to the issue if the DPI adjustment is not handled correctly after unpickling.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0008215,
        "snippet_processor": 0.06284000000000001,
        "issue_star_creation": 0.0276,
        "issue_star_solver": 0.07291,
        "bouncer": 0.024620000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711697908.565403,
        "relevant_snippets": [
            {
                "code": "# TODO:\n# * Documentation -- this will need a new section of the User's Guide.\n#      Both for Animations and just timers.\n#   - Also need to update\n#     https://scipy-cookbook.readthedocs.io/items/Matplotlib_Animations.html\n# * Blit\n#   * Currently broken with Qt4 for widgets that don't start on screen\n#   * Still a few edge cases that aren't working correctly\n#   * Can this integrate better with existing matplotlib animation artist flag?\n#     - If animated removes from default draw(), perhaps we could use this to\n#       simplify initial draw.\n# * Example\n#   * Frameless animation - pure procedural with no loop\n#   * Need example that uses something like inotify or subprocess\n#   * Complex syncing examples\n# * Movies\n#   * Can blit be enabled for movies?\n# * Need to consider event sources to allow clicking through multiple figures\n\n\nimport abc\nimport base64\nimport contextlib\nfrom io import BytesIO, TextIOWrapper\nimport itertools\nimport logging\nfrom pathlib import Path\nimport shutil\nimport subprocess\nimport sys\nfrom tempfile import TemporaryDirectory\nimport uuid\nimport warnings\n\nimport numpy as np\nfrom PIL import Image\n\nimport matplotlib as mpl\nfrom matplotlib._animation_data import (\n    DISPLAY_TEMPLATE, INCLUDED_FRAMES, JS_INCLUDE, STYLE_INCLUDE)\nfrom matplotlib import _api, cbook\nimport matplotlib.colors as mcolors\n\n_log = logging.getLogger(__name__)\n\n# Process creation flag for subprocess to prevent it raising a terminal\n# window. See for example https://stackoverflow.com/q/24130623/\nsubprocess_creation_flags = (\n    subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0)\n\n# Other potential writing methods:\n# * http://pymedia.org/\n# * libming (produces swf) python wrappers: https://github.com/libming/libming\n# * Wrap x264 API:\n\n# (https://stackoverflow.com/q/2940671/)\n\n\ndef adjusted_figsize(w, h, dpi, n):\n    \"\"\"\n    Compute figure size so that pixels are a multiple of n.\n\n    Parameters\n    ----------\n    w, h : float\n        Size in inches.\n\n    dpi : float\n        The dpi.\n\n    n : int\n        The target multiple.\n\n    Returns\n    -------\n    wnew, hnew : float\n        The new figure size in inches.\n    \"\"\"\n\n    # this maybe simplified if / when we adopt consistent rounding for\n    # pixel size across the whole library\n    def correct_roundoff(x, dpi, n):\n        if int(x*dpi) % n != 0:\n            if int(np.nextafter(x, np.inf)*dpi) % n == 0:\n                x = np.nextafter(x, np.inf)\n            elif int(np.nextafter(x, -np.inf)*dpi) % n == 0:\n                x = np.nextafter(x, -np.inf)\n        return x\n\n    wnew = int(w * dpi / n) * n / dpi\n    hnew = int(h * dpi / n) * n / dpi\n    return correct_roundoff(wnew, dpi, n), correct_roundoff(hnew, dpi, n)",
                "filename": "lib/matplotlib/animation.py",
                "start_index": 0,
                "end_index": 2721,
                "start_line": 1,
                "end_line": 92,
                "max_line": 1804,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "with cbook._setattr_cm(self, manager=None), \\\n             self._switch_canvas_and_return_print_method(format, backend) \\\n                 as print_method, \\\n             cbook._setattr_cm(self.figure, dpi=dpi), \\\n             cbook._setattr_cm(self.figure.canvas, _device_pixel_ratio=1), \\\n             cbook._setattr_cm(self.figure.canvas, _is_saving=True), \\\n             ExitStack() as stack:",
                "filename": "lib/matplotlib/backend_bases.py",
                "start_index": 76277,
                "end_index": 76673,
                "start_line": 2122,
                "end_line": 2128,
                "max_line": 3472,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n\n        # Remove the figure manager, if any, to avoid resizing the GUI widget.",
                "filename": "lib/matplotlib/backend_bases.py",
                "start_index": 76030,
                "end_index": 76268,
                "start_line": 2116,
                "end_line": 2121,
                "max_line": 3472,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.8
            },
            {
                "code": "\"\"\"\nHelper module for the *bbox_inches* parameter in `.Figure.savefig`.\n\"\"\"\n\nfrom matplotlib.transforms import Bbox, TransformedBbox, Affine2D\n\n\ndef adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n    \"\"\"\n    Temporarily adjust the figure so that only the specified area\n    (bbox_inches) is saved.\n\n    It modifies fig.bbox, fig.bbox_inches,\n    fig.transFigure._boxout, and fig.patch.  While the figure size\n    changes, the scale of the original figure is conserved.  A\n    function which restores the original values are returned.\n    \"\"\"\n    origBbox = fig.bbox\n    origBboxInches = fig.bbox_inches\n    _boxout = fig.transFigure._boxout\n\n    old_aspect = []\n    locator_list = []\n    sentinel = object()\n    for ax in fig.axes:\n        locator = ax.get_axes_locator()\n        if locator is not None:\n            ax.apply_aspect(locator(ax, None))\n        locator_list.append(locator)\n        current_pos = ax.get_position(original=False).frozen()\n        ax.set_axes_locator(lambda a, r, _pos=current_pos: _pos)\n        # override the method that enforces the aspect ratio on the Axes\n        if 'apply_aspect' in ax.__dict__:\n            old_aspect.append(ax.apply_aspect)\n        else:\n            old_aspect.append(sentinel)\n        ax.apply_aspect = lambda pos=None: None\n\n    def restore_bbox():\n        for ax, loc, aspect in zip(fig.axes, locator_list, old_aspect):\n            ax.set_axes_locator(loc)\n            if aspect is sentinel:\n                # delete our no-op function which un-hides the original method\n                del ax.apply_aspect\n            else:\n                ax.apply_aspect = aspect\n\n        fig.bbox = origBbox\n        fig.bbox_inches = origBboxInches\n        fig.transFigure._boxout = _boxout\n        fig.transFigure.invalidate()\n        fig.patch.set_bounds(0, 0, 1, 1)\n\n    if fixed_dpi is None:\n        fixed_dpi = fig.dpi\n    tr = Affine2D().scale(fixed_dpi)\n    dpi_scale = fixed_dpi / fig.dpi\n\n    fig.bbox_inches = Bbox.from_bounds(0, 0, *bbox_inches.size)\n    x0, y0 = tr.transform(bbox_inches.p0)\n    w1, h1 = fig.bbox.size * dpi_scale\n    fig.transFigure._boxout = Bbox.from_bounds(-x0, -y0, w1, h1)\n    fig.transFigure.invalidate()\n\n    fig.bbox = TransformedBbox(fig.bbox_inches, tr)\n\n    fig.patch.set_bounds(x0 / w1, y0 / h1,\n                         fig.bbox.width / w1, fig.bbox.height / h1)\n\n    return restore_bbox\n\n\ndef process_figure_for_rasterizing(fig, bbox_inches_restore, fixed_dpi=None):\n    \"\"\"\n    A function that needs to be called when figure dpi changes during the\n    drawing (e.g., rasterizing).  It recovers the bbox and re-adjust it with\n    the new dpi.\n    \"\"\"\n\n    bbox_inches, restore_bbox = bbox_inches_restore\n    restore_bbox()\n    r = adjust_bbox(fig, bbox_inches, fixed_dpi)\n\n    return bbox_inches, r",
                "filename": "lib/matplotlib/_tight_bbox.py",
                "start_index": 0,
                "end_index": 2786,
                "start_line": 1,
                "end_line": 84,
                "max_line": 84,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "name: Bug Report\ndescription: Report a bug or issue with Matplotlib.\ntitle: \"[Bug]: \"\nbody:\n  - type: textarea\n    id: summary\n    attributes:\n      label: Bug summary\n      description:  Describe the bug in 1-2 short sentences\n      placeholder:\n      value:\n    validations:\n      required: true\n  - type: textarea\n    id: reproduction\n    attributes:\n      label: Code for reproduction\n      description: |\n        If possible, please provide a minimum self-contained example.\n      placeholder: Paste your code here. This field is automatically formatted as Python code.\n      render: python\n    validations:\n      required: true\n  - type: textarea\n    id: actual\n    attributes:\n      label: Actual outcome\n      description: |\n        Paste the output produced by the code provided above, e.g.\n        console output, images/videos produced by the code, any relevant screenshots/screencasts, etc.\n    validations:\n      required: true\n  - type: textarea\n    id: expected\n    attributes:\n      label: Expected outcome\n      description: Describe (or provide a visual example of) the expected outcome from the code snippet.\n    validations:\n      required: true\n  - type: textarea\n    id: details\n    attributes:\n      label: Additional information\n      description: |\n        - What are the conditions under which this bug happens? input parameters, edge cases, etc?\n        - Has this worked in earlier versions?\n        - Do you know why this bug is happening?\n        - Do you maybe even know a fix?\n  - type: input\n    id: operating-system\n    attributes:\n      label: Operating system\n      description: Windows, OS/X, Arch, Debian, Ubuntu, etc.\n  - type: input\n    id: matplotlib-version\n    attributes:\n      label: Matplotlib Version\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.__version__)`\"\n    validations:\n      required: true\n  - type: input\n    id: matplotlib-backend\n    attributes:\n      label: Matplotlib Backend\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.get_backend())`\"\n  - type: input\n    id: python-version\n    attributes:\n      label: Python version\n      description: \"In console: `python --version`\"\n  - type: input\n    id: jupyter-version\n    attributes:\n      label: Jupyter version\n      description: \"In console: `jupyter notebook --version` or `jupyter lab --version`\"\n  - type: dropdown\n    id: install\n    attributes:\n      label: Installation\n      description: How did you install matplotlib?\n      options:\n        - pip\n        - conda\n        - Linux package manager\n        - from source (.tar.gz)\n        - git checkout",
                "filename": ".github/ISSUE_TEMPLATE/bug_report.yml",
                "start_index": 0,
                "end_index": 2631,
                "start_line": 1,
                "end_line": 86,
                "max_line": 86,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    def _print_ps(\n            self, fmt, outfile, *,\n            metadata=None, papertype=None, orientation='portrait',\n            bbox_inches_restore=None, **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.fromtimestamp(\n                int(source_date_epoch),\n                datetime.timezone.utc).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['figure', 'auto', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype,\n                bbox_inches_restore=bbox_inches_restore, **kwargs)",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 27430,
                "end_index": 29353,
                "start_line": 807,
                "end_line": 854,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "ax.imshow(rand(10, 5), extent=(1, 2, 1, 2), picker=True)\nax.imshow(rand(5, 10), extent=(3, 4, 1, 2), picker=True)\nax.imshow(rand(20, 25), extent=(1, 2, 3, 4), picker=True)\nax.imshow(rand(30, 12), extent=(3, 4, 3, 4), picker=True)\nax.set(xlim=(0, 5), ylim=(0, 5))\n\n\ndef onpick4(event):\n    artist = event.artist\n    if isinstance(artist, AxesImage):\n        im = artist\n        A = im.get_array()\n        print('onpick4 image', A.shape)\n\n\nfig.canvas.mpl_connect('pick_event', onpick4)\n\nplt.show()",
                "filename": "galleries/examples/event_handling/pick_event_demo.py",
                "start_index": 5963,
                "end_index": 6458,
                "start_line": 191,
                "end_line": 208,
                "max_line": 208,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "\"\"\"\nA wxPython backend for matplotlib.\n\nOriginally contributed by Jeremy O'Donoghue (jeremy@o-donoghue.com) and John\nHunter (jdhunter@ace.bsd.uchicago.edu).\n\nCopyright (C) Jeremy O'Donoghue & John Hunter, 2003-4.\n\"\"\"\n\nimport functools\nimport logging\nimport math\nimport pathlib\nimport sys\nimport weakref\n\nimport numpy as np\nimport PIL.Image\n\nimport matplotlib as mpl\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase,\n    GraphicsContextBase, MouseButton, NavigationToolbar2, RendererBase,\n    TimerBase, ToolContainerBase, cursors,\n    CloseEvent, KeyEvent, LocationEvent, MouseEvent, ResizeEvent)\n\nfrom matplotlib import _api, cbook, backend_tools\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Affine2D\n\nimport wx\n\n_log = logging.getLogger(__name__)\n\n# the True dots per inch on the screen; should be display dependent; see\n# http://groups.google.com/d/msg/comp.lang.postscript/-/omHAc9FEuAsJ?hl=en\n# for some info about screen dpi\nPIXELS_PER_INCH = 75\n\n\n# lru_cache holds a reference to the App and prevents it from being gc'ed.\n@functools.lru_cache(1)\ndef _create_wxapp():\n    wxapp = wx.App(False)\n    wxapp.SetExitOnFrameDelete(True)\n    cbook._setup_new_guiapp()\n    return wxapp\n\n\nclass TimerWx(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using wx.Timer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._timer = wx.Timer()\n        self._timer.Notify = self._on_timer\n        super().__init__(*args, **kwargs)\n\n    def _timer_start(self):\n        self._timer.Start(self._interval, self._single)\n\n    def _timer_stop(self):\n        self._timer.Stop()\n\n    def _timer_set_interval(self):\n        if self._timer.IsRunning():\n            self._timer_start()  # Restart with new interval.",
                "filename": "lib/matplotlib/backends/backend_wx.py",
                "start_index": 0,
                "end_index": 1808,
                "start_line": 1,
                "end_line": 67,
                "max_line": 1332,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "class FigureManagerMac(_macosx.FigureManager, FigureManagerBase):\n    _toolbar2_class = NavigationToolbar2Mac\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        _macosx.FigureManager.__init__(self, canvas)\n        icon_path = str(cbook._get_data_path('images/matplotlib.pdf'))\n        _macosx.FigureManager.set_icon(icon_path)\n        FigureManagerBase.__init__(self, canvas, num)\n        self._set_window_mode(mpl.rcParams.get(\"macosx.window_mode\", \"system\"))\n        if self.toolbar is not None:\n            self.toolbar.update()\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()\n\n    def _close_button_pressed(self):\n        Gcf.destroy(self)\n        self.canvas.flush_events()\n\n    def destroy(self):\n        # We need to clear any pending timers that never fired, otherwise\n        # we get a memory leak from the timer callbacks holding a reference\n        while self.canvas._timers:\n            timer = self.canvas._timers.pop()\n            timer.stop()\n        super().destroy()\n\n    @classmethod\n    def start_main_loop(cls):\n        # Set up a SIGINT handler to allow terminating a plot via CTRL-C.\n        # The logic is largely copied from qt_compat._maybe_allow_interrupt; see its\n        # docstring for details.  Parts are implemented by wake_on_fd_write in ObjC.\n\n        old_sigint_handler = signal.getsignal(signal.SIGINT)\n        if old_sigint_handler in (None, signal.SIG_IGN, signal.SIG_DFL):\n            _macosx.show()\n            return\n\n        handler_args = None\n        wsock, rsock = socket.socketpair()\n        wsock.setblocking(False)\n        rsock.setblocking(False)\n        old_wakeup_fd = signal.set_wakeup_fd(wsock.fileno())\n        _macosx.wake_on_fd_write(rsock.fileno())\n\n        def handle(*args):\n            nonlocal handler_args\n            handler_args = args\n            _macosx.stop()\n\n        signal.signal(signal.SIGINT, handle)\n        try:\n            _macosx.show()\n        finally:\n            wsock.close()\n            rsock.close()\n            signal.set_wakeup_fd(old_wakeup_fd)\n            signal.signal(signal.SIGINT, old_sigint_handler)\n            if handler_args is not None:\n                old_sigint_handler(*handler_args)\n\n    def show(self):\n        if not self._shown:\n            self._show()\n            self._shown = True\n        if mpl.rcParams[\"figure.raise_window\"]:\n            self._raise()\n\n\n@_Backend.export\nclass _BackendMac(_Backend):\n    FigureCanvas = FigureCanvasMac\n    FigureManager = FigureManagerMac\n    mainloop = FigureManagerMac.start_main_loop",
                "filename": "lib/matplotlib/backends/backend_macosx.py",
                "start_index": 5440,
                "end_index": 8036,
                "start_line": 141,
                "end_line": 215,
                "max_line": 215,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "import sys\n\nimport numpy as np\n\nfrom . import _backend_tk\nfrom .backend_cairo import cairo, FigureCanvasCairo\nfrom ._backend_tk import _BackendTk, FigureCanvasTk\n\n\nclass FigureCanvasTkCairo(FigureCanvasCairo, FigureCanvasTk):\n    def draw(self):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        buf = np.reshape(surface.get_data(), (height, width, 4))\n        _backend_tk.blit(\n            self._tkphoto, buf,\n            (2, 1, 0, 3) if sys.byteorder == \"little\" else (1, 2, 3, 0))\n\n\n@_BackendTk.export\nclass _BackendTkCairo(_BackendTk):\n    FigureCanvas = FigureCanvasTkCairo",
                "filename": "lib/matplotlib/backends/backend_tkcairo.py",
                "start_index": 0,
                "end_index": 844,
                "start_line": 1,
                "end_line": 26,
                "max_line": 26,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.1
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "lib/matplotlib/backends/backend_macosx.py": [
                {
                    "chunk": {
                        "code": "class FigureManagerMac(_macosx.FigureManager, FigureManagerBase):\n    _toolbar2_class = NavigationToolbar2Mac\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        _macosx.FigureManager.__init__(self, canvas)\n        icon_path = str(cbook._get_data_path('images/matplotlib.pdf'))\n        _macosx.FigureManager.set_icon(icon_path)\n        FigureManagerBase.__init__(self, canvas, num)\n        self._set_window_mode(mpl.rcParams.get(\"macosx.window_mode\", \"system\"))\n        if self.toolbar is not None:\n            self.toolbar.update()\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()\n\n    def _close_button_pressed(self):\n        Gcf.destroy(self)\n        self.canvas.flush_events()\n\n    def destroy(self):\n        # We need to clear any pending timers that never fired, otherwise\n        # we get a memory leak from the timer callbacks holding a reference\n        while self.canvas._timers:\n            timer = self.canvas._timers.pop()\n            timer.stop()\n        super().destroy()\n\n    @classmethod\n    def start_main_loop(cls):\n        # Set up a SIGINT handler to allow terminating a plot via CTRL-C.\n        # The logic is largely copied from qt_compat._maybe_allow_interrupt; see its\n        # docstring for details.  Parts are implemented by wake_on_fd_write in ObjC.\n\n        old_sigint_handler = signal.getsignal(signal.SIGINT)\n        if old_sigint_handler in (None, signal.SIG_IGN, signal.SIG_DFL):\n            _macosx.show()\n            return\n\n        handler_args = None\n        wsock, rsock = socket.socketpair()\n        wsock.setblocking(False)\n        rsock.setblocking(False)\n        old_wakeup_fd = signal.set_wakeup_fd(wsock.fileno())\n        _macosx.wake_on_fd_write(rsock.fileno())\n\n        def handle(*args):\n            nonlocal handler_args\n            handler_args = args\n            _macosx.stop()\n\n        signal.signal(signal.SIGINT, handle)\n        try:\n            _macosx.show()\n        finally:\n            wsock.close()\n            rsock.close()\n            signal.set_wakeup_fd(old_wakeup_fd)\n            signal.signal(signal.SIGINT, old_sigint_handler)\n            if handler_args is not None:\n                old_sigint_handler(*handler_args)\n\n    def show(self):\n        if not self._shown:\n            self._show()\n            self._shown = True\n        if mpl.rcParams[\"figure.raise_window\"]:\n            self._raise()\n\n\n@_Backend.export\nclass _BackendMac(_Backend):\n    FigureCanvas = FigureCanvasMac\n    FigureManager = FigureManagerMac\n    mainloop = FigureManagerMac.start_main_loop",
                        "filename": "lib/matplotlib/backends/backend_macosx.py",
                        "start_index": 5440,
                        "end_index": 8036,
                        "start_line": 141,
                        "end_line": 215,
                        "max_line": 215,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the backend implementation for MacOSX, which is relevant to the issue as it is specific to M1 MacBooks and the MacOSX backend."
                }
            ],
            "lib/matplotlib/backend_bases.py": [
                {
                    "chunk": {
                        "code": "with cbook._setattr_cm(self, manager=None), \\\n             self._switch_canvas_and_return_print_method(format, backend) \\\n                 as print_method, \\\n             cbook._setattr_cm(self.figure, dpi=dpi), \\\n             cbook._setattr_cm(self.figure.canvas, _device_pixel_ratio=1), \\\n             cbook._setattr_cm(self.figure.canvas, _is_saving=True), \\\n             ExitStack() as stack:",
                        "filename": "lib/matplotlib/backend_bases.py",
                        "start_index": 76277,
                        "end_index": 76673,
                        "start_line": 2122,
                        "end_line": 2128,
                        "max_line": 3472,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the code that sets the DPI for the figure during the save process, which could be related to the issue of DPI doubling after unpickling."
                },
                {
                    "chunk": {
                        "code": "if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n\n        # Remove the figure manager, if any, to avoid resizing the GUI widget.",
                        "filename": "lib/matplotlib/backend_bases.py",
                        "start_index": 76030,
                        "end_index": 76268,
                        "start_line": 2116,
                        "end_line": 2121,
                        "max_line": 3472,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet deals with setting the DPI for the figure, which is directly related to the issue of DPI doubling."
                }
            ],
            "lib/matplotlib/_tight_bbox.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\nHelper module for the *bbox_inches* parameter in `.Figure.savefig`.\n\"\"\"\n\nfrom matplotlib.transforms import Bbox, TransformedBbox, Affine2D\n\n\ndef adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n    \"\"\"\n    Temporarily adjust the figure so that only the specified area\n    (bbox_inches) is saved.\n\n    It modifies fig.bbox, fig.bbox_inches,\n    fig.transFigure._boxout, and fig.patch.  While the figure size\n    changes, the scale of the original figure is conserved.  A\n    function which restores the original values are returned.\n    \"\"\"\n    origBbox = fig.bbox\n    origBboxInches = fig.bbox_inches\n    _boxout = fig.transFigure._boxout\n\n    old_aspect = []\n    locator_list = []\n    sentinel = object()\n    for ax in fig.axes:\n        locator = ax.get_axes_locator()\n        if locator is not None:\n            ax.apply_aspect(locator(ax, None))\n        locator_list.append(locator)\n        current_pos = ax.get_position(original=False).frozen()\n        ax.set_axes_locator(lambda a, r, _pos=current_pos: _pos)\n        # override the method that enforces the aspect ratio on the Axes\n        if 'apply_aspect' in ax.__dict__:\n            old_aspect.append(ax.apply_aspect)\n        else:\n            old_aspect.append(sentinel)\n        ax.apply_aspect = lambda pos=None: None\n\n    def restore_bbox():\n        for ax, loc, aspect in zip(fig.axes, locator_list, old_aspect):\n            ax.set_axes_locator(loc)\n            if aspect is sentinel:\n                # delete our no-op function which un-hides the original method\n                del ax.apply_aspect\n            else:\n                ax.apply_aspect = aspect\n\n        fig.bbox = origBbox\n        fig.bbox_inches = origBboxInches\n        fig.transFigure._boxout = _boxout\n        fig.transFigure.invalidate()\n        fig.patch.set_bounds(0, 0, 1, 1)\n\n    if fixed_dpi is None:\n        fixed_dpi = fig.dpi\n    tr = Affine2D().scale(fixed_dpi)\n    dpi_scale = fixed_dpi / fig.dpi\n\n    fig.bbox_inches = Bbox.from_bounds(0, 0, *bbox_inches.size)\n    x0, y0 = tr.transform(bbox_inches.p0)\n    w1, h1 = fig.bbox.size * dpi_scale\n    fig.transFigure._boxout = Bbox.from_bounds(-x0, -y0, w1, h1)\n    fig.transFigure.invalidate()\n\n    fig.bbox = TransformedBbox(fig.bbox_inches, tr)\n\n    fig.patch.set_bounds(x0 / w1, y0 / h1,\n                         fig.bbox.width / w1, fig.bbox.height / h1)\n\n    return restore_bbox\n\n\ndef process_figure_for_rasterizing(fig, bbox_inches_restore, fixed_dpi=None):\n    \"\"\"\n    A function that needs to be called when figure dpi changes during the\n    drawing (e.g., rasterizing).  It recovers the bbox and re-adjust it with\n    the new dpi.\n    \"\"\"\n\n    bbox_inches, restore_bbox = bbox_inches_restore\n    restore_bbox()\n    r = adjust_bbox(fig, bbox_inches, fixed_dpi)\n\n    return bbox_inches, r",
                        "filename": "lib/matplotlib/_tight_bbox.py",
                        "start_index": 0,
                        "end_index": 2786,
                        "start_line": 1,
                        "end_line": 84,
                        "max_line": 84,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes code that adjusts the figure's DPI, which could be relevant to the issue if the DPI adjustment is not handled correctly after unpickling."
                }
            ]
        },
        "solution_task": "- Investigate if the `dpi` attribute of the `fig` object is being modified unintentionally during the pickling and unpickling process.\n- Ensure that the `dpi` attribute is set correctly before pickling the `fig` object.\n- After unpickling, explicitly set the `dpi` attribute of the `fig` object to its original value before it was pickled.\n- If the issue persists, consider using a different backend that does not exhibit this behavior on M1 MacBooks, such as switching from `MacOSX` to `TkAgg`, `Qt5Agg`, or another available backend.\n- If the issue is confirmed to be a bug in the `MacOSX` backend, report it to the Matplotlib development team for further investigation and potential fixing in a future release.",
        "bouncer_response": {
            "score": 7,
            "criteria": "RESPONSE that are highly relevant, offering clear and comprehensive guidance or solutions for the described bug, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a series of actionable steps that are relevant to the issue of the DPI doubling after unpickling a figure on an M1 Mac. It suggests checking if the DPI attribute is being modified during the pickling process, setting the DPI attribute correctly before and after pickling, and considering a different backend if the issue persists. Additionally, the RESPONSE provides links to specific code snippets in the Matplotlib library that could be related to the issue, which is helpful for further investigation. However, the RESPONSE does not address the fact that this issue is specific to M1 MacBooks, which could be an important factor in diagnosing and fixing the bug. It also does not provide a direct solution to the problem but rather a method to investigate and potentially work around it.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711698027.529216,
        "result": "- Investigate if the `dpi` attribute of the `fig` object is being modified unintentionally during the pickling and unpickling process.\n- Ensure that the `dpi` attribute is set correctly before pickling the `fig` object.\n- After unpickling, explicitly set the `dpi` attribute of the `fig` object to its original value before it was pickled.\n- If the issue persists, consider using a different backend that does not exhibit this behavior on M1 MacBooks, such as switching from `MacOSX` to `TkAgg`, `Qt5Agg`, or another available backend.\n- If the issue is confirmed to be a bug in the `MacOSX` backend, report it to the Matplotlib development team for further investigation and potential fixing in a future release.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib/backends)- [Lines 141 - 215](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_macosx.py#L141-L215)\n\n This snippet contains the backend implementation for MacOSX, which is relevant to the issue as it is specific to M1 MacBooks and the MacOSX backend.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib)- [Lines 2122 - 2128](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backend_bases.py#L2122-L2128)\n\n This snippet is part of the code that sets the DPI for the figure during the save process, which could be related to the issue of DPI doubling after unpickling. \n\n\n   - [Lines 2116 - 2121](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backend_bases.py#L2116-L2121)\n\n This snippet deals with setting the DPI for the figure, which is directly related to the issue of DPI doubling.\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib)- [Lines 1 - 84](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/_tight_bbox.py#L1-L84)\n\n This snippet includes code that adjusts the figure's DPI, which could be relevant to the issue if the DPI adjustment is not handled correctly after unpickling.",
        "context_relevance": 0.33,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant and answer the entire PROMPT completely to get a score of 10.\nSupporting Evidence: The RESPONSE provides a series of steps to investigate and potentially resolve the issue described in the PROMPT, which is the doubling of the DPI of a figure after unpickling on an M1 Mac. It suggests checking the `dpi` attribute before and after pickling and unpickling, considering a different backend, and reporting the issue to the development team if necessary. Additionally, the RESPONSE includes relevant code snippets from the Matplotlib repository that could be related to the issue. This RESPONSE is directly addressing the entire PROMPT, providing a comprehensive approach to troubleshooting the bug, and suggesting relevant code areas for further investigation."
        },
        "qa_relevance": 1.0
    }
}