{
    "id": "scikit-learn__scikit-learn-25308",
    "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
    "task_id": 7402774615921441846,
    "title": "Make error message uniform when calling `get_feature_names_out` before `fit`",
    "body": "While working #24838, we found out that we are not consistent with the error type and message when calling `get_feature_names_out` before `fit`.\r\n\r\nFrom @jpangas:\r\n> Here is the updated list of the estimators that raise inconsistent errors when `get_feature_names_out` is called before `fit`. Currently, these estimators have been whitelisted. Before we submit any PR for a particular estimator, we can remove the estimator from the list and run the test in #25223 to check if the code we submitted has raised the correct `NotFittedError`.\r\n\r\n> Remember to add your estimator and PR in the same change log entry in `v1.3.rst` introduced in #25294.\r\nPlease link the PRs you'll make with this issue so that I can update this list for all of us to know which estimators have been worked on:\r\n\r\n- [x] AdditiveChi2Sampler() #25291 \r\n- [x] Binarizer()  #25294\r\n- [x] MaxAbsScaler() #25294\r\n- [x] MinMaxScaler() #25294\r\n- [x] Normalizer()  #25294\r\n- [x] OrdinalEncoder()  #25294\r\n- [x] PowerTransformer() #25294\r\n- [x] QuantileTransformer()  #25294\r\n- [x] RobustScaler() #25294\r\n- [x] StackingClassifier() #25324\r\n- [x] StackingRegressor() #25324\r\n- [x] StandardScaler() #25294\r\n- [x] TfidfTransformer()  #25294\r\n- [x] VotingClassifier() #25324 \r\n- [x] VotingRegressor() #25324\r\n- [x] GaussianRandomProjection() #25308\r\n- [x] GenericUnivariateSelect() #25308\r\n- [x] IterativeImputer() #25367 \r\n- [x] RFE() #25308\r\n- [x] RFECV() #25308 \r\n- [x] SelectFdr() #25308 \r\n- [x] SelectFpr() #25308\r\n- [x] SelectFromModel() #25308\r\n- [x] SelectFwe() #25308\r\n- [x] SelectKBest() #25308\r\n- [x] SelectPercentile() #25308 \r\n- [x] SequentialFeatureSelector() #25308  \r\n- [x] SparseRandomProjection()  #25308\r\n- [x] VarianceThreshold() #25308\r\n- [x] KNNImputer() #25367\r\n- [x] SimpleImputer() #25367 \r\n- [x] SplineTransformer() #25402\r\n- [x] DictVectorizer() #25402\r\n- [x] KBinsDiscretizer() #25402\r\n- [x] MissingIndicator() #25402\r\n- [x] IsotonicRegression()\r\n\r\n<details>\r\n\r\n```pytb\r\n> pytest -vsl sklearn/tests/test_common.py -k error_get_feature_names_out\r\n==================================================================================== test session starts ====================================================================================\r\nplatform darwin -- Python 3.10.6, pytest-7.2.0, pluggy-1.0.0 -- /Users/glemaitre/mambaforge/envs/dev/bin/python3.10\r\ncachedir: .pytest_cache\r\nrootdir: /Users/glemaitre/Documents/packages/scikit-learn, configfile: setup.cfg\r\nplugins: xdist-3.0.2, anyio-3.6.2\r\ncollected 9473 items / 9275 deselected / 198 selected                                                                                                                                       \r\n\r\nsklearn/tests/test_common.py::test_estimators[ARDRegression()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[AdaBoostClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[AdaBoostRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[AdditiveChi2Sampler()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[AffinityPropagation()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[AgglomerativeClustering()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[BaggingClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[BaggingRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[BayesianGaussianMixture()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[BayesianRidge()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[BernoulliNB()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[BernoulliRBM()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis BernoulliRBM instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[Binarizer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[Birch()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis Birch instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[BisectingKMeans()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis BisectingKMeans instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[CCA()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis CCA instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[CalibratedClassifierCV(estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[CategoricalNB()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[ComplementNB()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[DBSCAN()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[DecisionTreeClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[DecisionTreeRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[DictionaryLearning()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis DictionaryLearning instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[DummyClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[DummyRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[ElasticNet()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[ElasticNetCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[EllipticEnvelope()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[EmpiricalCovariance()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[ExtraTreeClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[ExtraTreeRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[ExtraTreesClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[ExtraTreesRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[FactorAnalysis()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis FactorAnalysis instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[FastICA()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis FastICA instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[FeatureAgglomeration()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis FeatureAgglomeration instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[FunctionTransformer()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GammaRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GaussianMixture()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GaussianNB()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GaussianProcessClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GaussianProcessRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GaussianRandomProjection()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GenericUnivariateSelect()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[GradientBoostingClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GradientBoostingRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GraphicalLasso()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[GraphicalLassoCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[HistGradientBoostingClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[HistGradientBoostingRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[HuberRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[IncrementalPCA()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis IncrementalPCA instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[IsolationForest()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[Isomap()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis Isomap instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[KBinsDiscretizer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[KMeans()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis KMeans instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[KNNImputer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[KNeighborsClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[KNeighborsRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[KNeighborsTransformer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis KNeighborsTransformer instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[KernelCenterer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis KernelCenterer instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[KernelDensity()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[KernelPCA()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis KernelPCA instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[KernelRidge()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LabelPropagation()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LabelSpreading()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[Lars()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LarsCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[Lasso()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LassoCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LassoLars()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LassoLarsCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LassoLarsIC()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LatentDirichletAllocation()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis LatentDirichletAllocation instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[LedoitWolf()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LinearDiscriminantAnalysis()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis LinearDiscriminantAnalysis instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[LinearRegression()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LinearSVC()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LinearSVR()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LocalOutlierFactor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LocallyLinearEmbedding()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis LocallyLinearEmbedding instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[LogisticRegression()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[LogisticRegressionCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MDS()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MLPClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MLPRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MaxAbsScaler()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[MeanShift()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MinCovDet()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MinMaxScaler()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[MiniBatchDictionaryLearning()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis MiniBatchDictionaryLearning instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[MiniBatchKMeans()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis MiniBatchKMeans instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[MiniBatchNMF()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis MiniBatchNMF instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[MiniBatchSparsePCA()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis MiniBatchSparsePCA instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[MissingIndicator()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[MultiOutputRegressor(estimator=Ridge())-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MultiTaskElasticNet()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MultiTaskElasticNetCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MultiTaskLasso()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MultiTaskLassoCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[MultinomialNB()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[NMF()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis NMF instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[NearestCentroid()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[NearestNeighbors()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[NeighborhoodComponentsAnalysis()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis NeighborhoodComponentsAnalysis instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[Normalizer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[NuSVC()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[NuSVR()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[Nystroem()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis Nystroem instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[OAS()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[OPTICS()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[OneClassSVM()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[OneVsOneClassifier(estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[OneVsRestClassifier(estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[OrthogonalMatchingPursuit()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[OrthogonalMatchingPursuitCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[OutputCodeClassifier(estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[PCA()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis PCA instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[PLSCanonical()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis PLSCanonical instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[PLSRegression()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis PLSRegression instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[PLSSVD()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis PLSSVD instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[PassiveAggressiveClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[PassiveAggressiveRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[Perceptron()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[PoissonRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[PolynomialCountSketch()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis PolynomialCountSketch instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[PolynomialFeatures()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis PolynomialFeatures instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[PowerTransformer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[QuadraticDiscriminantAnalysis()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[QuantileRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[QuantileTransformer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[RANSACRegressor(estimator=LinearRegression())-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RBFSampler()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis RBFSampler instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[RFE(estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[RFECV(estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[RadiusNeighborsClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RadiusNeighborsRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RadiusNeighborsTransformer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis RadiusNeighborsTransformer instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[RandomForestClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RandomForestRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RandomTreesEmbedding()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis RandomTreesEmbedding instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[RegressorChain(base_estimator=Ridge())-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[Ridge()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RidgeCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RidgeClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RidgeClassifierCV()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[RobustScaler()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SGDClassifier()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SGDOneClassSVM()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SGDRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SVC()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SVR()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SelectFdr()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SelectFpr()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SelectFromModel(estimator=SGDRegressor(random_state=0))-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SelectFwe()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SelectKBest()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SelectPercentile()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SelfTrainingClassifier(base_estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SequentialFeatureSelector(estimator=LogisticRegression(C=1))-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[ShrunkCovariance()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SimpleImputer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SkewedChi2Sampler()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis SkewedChi2Sampler instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SparsePCA()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis SparsePCA instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[SparseRandomProjection()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SpectralBiclustering()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SpectralClustering()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SpectralCoclustering()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SpectralEmbedding()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[SplineTransformer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'AttributeError'>\r\n'SplineTransformer' object has no attribute 'bsplines_'\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[StackingClassifier(estimators=[('est1',LogisticRegression(C=0.1)),('est2',LogisticRegression(C=1))])-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'AttributeError'>\r\n'StackingClassifier' object has no attribute '_n_feature_outs'\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[StackingRegressor(estimators=[('est1',Ridge(alpha=0.1)),('est2',Ridge(alpha=1))])-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'AttributeError'>\r\n'StackingRegressor' object has no attribute '_n_feature_outs'\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[StandardScaler()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[TSNE()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[TfidfTransformer()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[TheilSenRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[TransformedTargetRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[TruncatedSVD()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'sklearn.exceptions.NotFittedError'>\r\nThis TruncatedSVD instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[TweedieRegressor()-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[VarianceThreshold()-check_error_get_feature_names_out_not_fitted] \r\n\r\n<class 'ValueError'>\r\nUnable to generate feature names without n_features_in_\r\n\r\nPASSED\r\nsklearn/tests/test_common.py::test_estimators[VotingClassifier(estimators=[('est1',LogisticRegression(C=0.1)),('est2',LogisticRegression(C=1))])-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_estimators[VotingRegressor(estimators=[('est1',Ridge(alpha=0.1)),('est2',Ridge(alpha=1))])-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[GridSearchCV(cv=2,estimator=Ridge(),param_grid={'alpha':[0.1,1.0]})-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[GridSearchCV(cv=2,estimator=LogisticRegression(),param_grid={'C':[0.1,1.0]})-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingGridSearchCV(cv=2,estimator=Ridge(),min_resources='smallest',param_grid={'alpha':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted0] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingGridSearchCV(cv=2,estimator=LogisticRegression(),min_resources='smallest',param_grid={'C':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted0] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[RandomizedSearchCV(cv=2,estimator=Ridge(),param_distributions={'alpha':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[RandomizedSearchCV(cv=2,estimator=LogisticRegression(),param_distributions={'C':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingGridSearchCV(cv=2,estimator=Ridge(),min_resources='smallest',param_grid={'alpha':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted1] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingGridSearchCV(cv=2,estimator=LogisticRegression(),min_resources='smallest',param_grid={'C':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted1] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[GridSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('ridge',Ridge())]),param_grid={'ridge__alpha':[0.1,1.0]})-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[GridSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('logisticregression',LogisticRegression())]),param_grid={'logisticregression__C':[0.1,1.0]})-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingGridSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('ridge',Ridge())]),min_resources='smallest',param_grid={'ridge__alpha':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingGridSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('logisticregression',LogisticRegression())]),min_resources='smallest',param_grid={'logisticregression__C':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[RandomizedSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('ridge',Ridge())]),param_distributions={'ridge__alpha':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[RandomizedSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('logisticregression',LogisticRegression())]),param_distributions={'logisticregression__C':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingRandomSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('ridge',Ridge())]),param_distributions={'ridge__alpha':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\nsklearn/tests/test_common.py::test_search_cv[HalvingRandomSearchCV(cv=2,error_score='raise',estimator=Pipeline(steps=[('pca',PCA()),('logisticregression',LogisticRegression())]),param_distributions={'logisticregression__C':[0.1,1.0]},random_state=0)-check_error_get_feature_names_out_not_fitted] PASSED\r\n```\r\n\r\n</details>\r\n\r\nI assume that the most adequate error should be a `NotFittedError` asking to fit the estimator.\r\n\r\n@scikit-learn/core-devs WDYT?\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__1.3.git",
    "requested_commit": "",
    "mayil_response": "- Ensure that all estimators raise a `NotFittedError` with a consistent error message when `get_feature_names_out` is called before `fit`.\n- Modify the `get_feature_names_out` method in each estimator to check if the model is fitted by looking for attributes set in `fit` (e.g., `n_features_in_`).\n- If the model is not fitted, raise a `NotFittedError` with a message following a consistent format, such as: `\"This {estimator_name} instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\"`.\n- Use the provided template for the `get_feature_names_out` method to implement the changes in all relevant estimators.\n- Update the test suite `test_estimators` in `sklearn/tests/test_common.py` to include a check for the `NotFittedError` message consistency across estimators when calling `get_feature_names_out` before `fit`.\n- Ensure that the test `pytest -vsl sklearn/tests/test_common.py -k error_get_feature_names_out` passes after the modifications.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn/utils)- [Lines 4160 - 4207](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/estimator_checks.py#L4160-L4207)\n\n This snippet contains checks for the error message consistency when calling `get_feature_names_out` before `fit`, which is directly related to the issue. \n\n\n   - [Lines 3892 - 3980](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/estimator_checks.py#L3892-L3980)\n\n This snippet includes checks for the `check_is_fitted` method, which is relevant to the issue as it pertains to the behavior of estimators before and after fitting. \n\n\n   - [Lines 181 - 1729](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/estimator_checks.py#L181-L1729)\n\n This snippet contains checks for fitting estimators with different data shapes and could be relevant for ensuring the error message is consistent when `get_feature_names_out` is called before `fit`.",
    "ai_cost": {
        "search_embedding": 2.6e-07,
        "issue_classifier": 0.004554,
        "snippet_processor": 0.29709,
        "issue_star_creation": 0.02362,
        "issue_star_solver": 0.06302,
        "bouncer": 0.02704
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711738633.778422,
        "relevant_snippets": [
            {
                "code": "\"\"\"Exhaustive search over specified parameter values for an estimator.\n\n    Important members are fit, predict.\n\n    GridSearchCV implements a \"fit\" and a \"score\" method.\n    It also implements \"score_samples\", \"predict\", \"predict_proba\",\n    \"decision_function\", \"transform\" and \"inverse_transform\" if they are\n    implemented in the estimator used.\n\n    The parameters of the estimator used to apply these methods are optimized\n    by cross-validated grid-search over a parameter grid.\n\n    Read more in the :ref:`User Guide <grid_search>`.\n\n    Parameters\n    ----------\n    estimator : estimator object\n        This is assumed to implement the scikit-learn estimator interface.\n        Either estimator needs to provide a ``score`` function,\n        or ``scoring`` must be passed.\n\n    param_grid : dict or list of dictionaries\n        Dictionary with parameters names (`str`) as keys and lists of\n        parameter settings to try as values, or a list of such\n        dictionaries, in which case the grids spanned by each dictionary\n        in the list are explored. This enables searching over any sequence\n        of parameter settings.\n\n    scoring : str, callable, list, tuple or dict, default=None\n        Strategy to evaluate the performance of the cross-validated model on\n        the test set.\n\n        If `scoring` represents a single score, one can use:\n\n        - a single string (see :ref:`scoring_parameter`);\n        - a callable (see :ref:`scoring`) that returns a single value.\n\n        If `scoring` represents multiple scores, one can use:\n\n        - a list or tuple of unique strings;\n        - a callable returning a dictionary where the keys are the metric\n          names and the values are the metric scores;\n        - a dictionary with metric names as keys and callables a values.\n\n        See :ref:`multimetric_grid_search` for an example.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n        .. versionchanged:: v0.20\n           `n_jobs` default changed from 1 to None\n\n    refit : bool, str, or callable, default=True\n        Refit an estimator using the best found parameters on the whole\n        dataset.\n\n        For multiple metric evaluation, this needs to be a `str` denoting the\n        scorer that would be used to find the best parameters for refitting\n        the estimator at the end.\n\n        Where there are considerations other than maximum score in\n        choosing a best estimator, ``refit`` can be set to a function which\n        returns the selected ``best_index_`` given ``cv_results_``. In that\n        case, the ``best_estimator_`` and ``best_params_`` will be set\n        according to the returned ``best_index_`` while the ``best_score_``\n        attribute will not be available.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``GridSearchCV`` instance.\n\n        Also for multiple metric evaluation, the attributes ``best_index_``,\n        ``best_score_`` and ``best_params_`` will only be available if\n        ``refit`` is set and all of them will be determined w.r.t this specific\n        scorer.\n\n        See ``scoring`` parameter to know more about multiple metric\n        evaluation.\n\n        See :ref:`sphx_glr_auto_examples_model_selection_plot_grid_search_digits.py`\n        to see how to design a custom selection strategy using a callable\n        via `refit`.\n\n        .. versionchanged:: 0.20\n            Support for callable added.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n        - >1 : the computation time for each fold and parameter candidate is\n          displayed;\n        - >2 : the score is also displayed;\n        - >3 : the fold and candidate parameter indexes are also displayed\n          together with the starting time of the computation.\n\n    pre_dispatch : int, or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n            - None, in which case all the jobs are immediately\n              created and spawned. Use this for lightweight and\n              fast-running jobs, to avoid delays due to on-demand\n              spawning of the jobs\n\n            - An int, giving the exact number of total jobs that are\n              spawned\n\n            - A str, giving an expression as a function of n_jobs,\n              as in '2*n_jobs'\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n        .. versionadded:: 0.19\n\n        .. versionchanged:: 0.21\n            Default value was changed from ``True`` to ``False``\n\n    Attributes\n    ----------\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``.\n\n        For instance the below given table\n\n        +------------+-----------+------------+-----------------+---+---------+\n        |param_kernel|param_gamma|param_degree|split0_test_score|...|rank_t...|\n        +============+===========+============+=================+===+=========+\n        |  'poly'    |     --    |      2     |       0.80      |...|    2    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'poly'    |     --    |      3     |       0.70      |...|    4    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'rbf'     |     0.1   |     --     |       0.80      |...|    3    |\n        +------------+-----------+------------+-----------------+---+---------+\n        |  'rbf'     |     0.2   |     --     |       0.93      |...|    1    |\n        +------------+-----------+------------+-----------------+---+---------+\n\n        will be represented by a ``cv_results_`` dict of::\n\n            {\n            'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],\n                                         mask = [False False False False]...)\n            'param_gamma': masked_array(data = [-- -- 0.1 0.2],\n                                        mask = [ True  True False False]...),\n            'param_degree': masked_array(data = [2.0 3.0 -- --],\n                                         mask = [False False  True  True]...),\n            'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],\n            'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],\n            'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],\n            'std_test_score'     : [0.01, 0.10, 0.05, 0.08],\n            'rank_test_score'    : [2, 4, 3, 1],\n            'split0_train_score' : [0.80, 0.92, 0.70, 0.93],\n            'split1_train_score' : [0.82, 0.55, 0.70, 0.87],\n            'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],\n            'std_train_score'    : [0.01, 0.19, 0.00, 0.03],\n            'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],\n            'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],\n            'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],\n            'std_score_time'     : [0.00, 0.00, 0.00, 0.01],\n            'params'             : [{'kernel': 'poly', 'degree': 2}, ...],\n            }\n\n        NOTE\n\n        The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is present only if ``refit`` is\n        specified.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    ParameterGrid : Generates all the combinations of a hyperparameter grid.\n    train_test_split : Utility function to split the data into a development\n        set usable for fitting a GridSearchCV instance and an evaluation set\n        for its final evaluation.\n    sklearn.metrics.make_scorer : Make a scorer from a performance metric or\n        loss function.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the left out\n    data, unless an explicit score is passed in which case it is used instead.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    point in the grid (and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn import svm, datasets\n    >>> from sklearn.model_selection import GridSearchCV\n    >>> iris = datasets.load_iris()\n    >>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n    >>> svc = svm.SVC()\n    >>> clf = GridSearchCV(svc, parameters)\n    >>> clf.fit(iris.data, iris.target)\n    GridSearchCV(estimator=SVC(),\n                 param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})\n    >>> sorted(clf.cv_results_.keys())\n    ['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n     'param_C', 'param_kernel', 'params',...\n     'rank_test_score', 'split0_test_score',...\n     'split2_test_score', ...\n     'std_fit_time', 'std_score_time', 'std_test_score']\n    \"\"\"",
                "filename": "sklearn/model_selection/_search.py",
                "start_index": 40693,
                "end_index": 54899,
                "start_line": 1060,
                "end_line": 1808,
                "max_line": 1813,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "\"\"\"Logistic Regression CV (aka logit, MaxEnt) classifier.\n\n    See glossary entry for :term:`cross-validation estimator`.\n\n    This class implements logistic regression using liblinear, newton-cg, sag\n    of lbfgs optimizer. The newton-cg, sag and lbfgs solvers support only L2\n    regularization with primal formulation. The liblinear solver supports both\n    L1 and L2 regularization, with a dual formulation only for the L2 penalty.\n    Elastic-Net penalty is only supported by the saga solver.\n\n    For the grid of `Cs` values and `l1_ratios` values, the best hyperparameter\n    is selected by the cross-validator\n    :class:`~sklearn.model_selection.StratifiedKFold`, but it can be changed\n    using the :term:`cv` parameter. The 'newton-cg', 'sag', 'saga' and 'lbfgs'\n    solvers can warm-start the coefficients (see :term:`Glossary<warm_start>`).\n\n    Read more in the :ref:`User Guide <logistic_regression>`.\n\n    Parameters\n    ----------\n    Cs : int or list of floats, default=10\n        Each of the values in Cs describes the inverse of regularization\n        strength. If Cs is as an int, then a grid of Cs values are chosen\n        in a logarithmic scale between 1e-4 and 1e4.\n        Like in support vector machines, smaller values specify stronger\n        regularization.\n\n    fit_intercept : bool, default=True\n        Specifies if a constant (a.k.a. bias or intercept) should be\n        added to the decision function.\n\n    cv : int or cross-validation generator, default=None\n        The default cross-validation generator used is Stratified K-Folds.\n        If an integer is provided, then it is the number of folds used.\n        See the module :mod:`sklearn.model_selection` module for the\n        list of possible cross-validation objects.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    dual : bool, default=False\n        Dual or primal formulation. Dual formulation is only implemented for\n        l2 penalty with liblinear solver. Prefer dual=False when\n        n_samples > n_features.\n\n    penalty : {'l1', 'l2', 'elasticnet'}, default='l2'\n        Specify the norm of the penalty:\n\n        - `'l2'`: add a L2 penalty term (used by default);\n        - `'l1'`: add a L1 penalty term;\n        - `'elasticnet'`: both L1 and L2 penalty terms are added.\n\n        .. warning::\n           Some penalties may not work with some solvers. See the parameter\n           `solver` below, to know the compatibility between the penalty and\n           solver.\n\n    scoring : str or callable, default=None\n        A string (see model evaluation documentation) or\n        a scorer callable object / function with signature\n        ``scorer(estimator, X, y)``. For a list of scoring functions\n        that can be used, look at :mod:`sklearn.metrics`. The\n        default scoring option used is 'accuracy'.\n\n    solver : {'lbfgs', 'liblinear', 'newton-cg', 'newton-cholesky', 'sag', 'saga'}, \\\n            default='lbfgs'\n\n        Algorithm to use in the optimization problem. Default is 'lbfgs'.\n        To choose a solver, you might want to consider the following aspects:\n\n            - For small datasets, 'liblinear' is a good choice, whereas 'sag'\n              and 'saga' are faster for large ones;\n            - For multiclass problems, only 'newton-cg', 'sag', 'saga' and\n              'lbfgs' handle multinomial loss;\n            - 'liblinear' might be slower in :class:`LogisticRegressionCV`\n              because it does not handle warm-starting. 'liblinear' is\n              limited to one-versus-rest schemes.\n            - 'newton-cholesky' is a good choice for `n_samples` >> `n_features`,\n              especially with one-hot encoded categorical features with rare\n              categories. Note that it is limited to binary classification and the\n              one-versus-rest reduction for multiclass classification. Be aware that\n              the memory usage of this solver has a quadratic dependency on\n              `n_features` because it explicitly computes the Hessian matrix.\n\n        .. warning::\n           The choice of the algorithm depends on the penalty chosen.\n           Supported penalties by solver:\n\n           - 'lbfgs'           -   ['l2']\n           - 'liblinear'       -   ['l1', 'l2']\n           - 'newton-cg'       -   ['l2']\n           - 'newton-cholesky' -   ['l2']\n           - 'sag'             -   ['l2']\n           - 'saga'            -   ['elasticnet', 'l1', 'l2']\n\n        .. note::\n           'sag' and 'saga' fast convergence is only guaranteed on features\n           with approximately the same scale. You can preprocess the data with\n           a scaler from :mod:`sklearn.preprocessing`.\n\n        .. versionadded:: 0.17\n           Stochastic Average Gradient descent solver.\n        .. versionadded:: 0.19\n           SAGA solver.\n        .. versionadded:: 1.2\n           newton-cholesky solver.\n\n    tol : float, default=1e-4\n        Tolerance for stopping criteria.\n\n    max_iter : int, default=100\n        Maximum number of iterations of the optimization algorithm.\n\n    class_weight : dict or 'balanced', default=None\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n        .. versionadded:: 0.17\n           class_weight == 'balanced'\n\n    n_jobs : int, default=None\n        Number of CPU cores used during the cross-validation loop.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : int, default=0\n        For the 'liblinear', 'sag' and 'lbfgs' solvers set verbose to any\n        positive number for verbosity.\n\n    refit : bool, default=True\n        If set to True, the scores are averaged across all folds, and the\n        coefs and the C that corresponds to the best score is taken, and a\n        final refit is done using these parameters.\n        Otherwise the coefs, intercepts and C that correspond to the\n        best scores across folds are averaged.\n\n    intercept_scaling : float, default=1\n        Useful only when the solver 'liblinear' is used\n        and self.fit_intercept is set to True. In this case, x becomes\n        [x, self.intercept_scaling],\n        i.e. a \"synthetic\" feature with constant value equal to\n        intercept_scaling is appended to the instance vector.\n        The intercept becomes ``intercept_scaling * synthetic_feature_weight``.\n\n        Note! the synthetic feature weight is subject to l1/l2 regularization\n        as all other features.\n        To lessen the effect of regularization on synthetic feature weight\n        (and therefore on the intercept) intercept_scaling has to be increased.\n\n    multi_class : {'auto, 'ovr', 'multinomial'}, default='auto'\n        If the option chosen is 'ovr', then a binary problem is fit for each\n        label. For 'multinomial' the loss minimised is the multinomial loss fit\n        across the entire probability distribution, *even when the data is\n        binary*. 'multinomial' is unavailable when solver='liblinear'.\n        'auto' selects 'ovr' if the data is binary, or if solver='liblinear',\n        and otherwise selects 'multinomial'.\n\n        .. versionadded:: 0.18\n           Stochastic Average Gradient descent solver for 'multinomial' case.\n        .. versionchanged:: 0.22\n            Default changed from 'ovr' to 'auto' in 0.22.\n\n    random_state : int, RandomState instance, default=None\n        Used when `solver='sag'`, 'saga' or 'liblinear' to shuffle the data.\n        Note that this only applies to the solver and not the cross-validation\n        generator. See :term:`Glossary <random_state>` for details.\n\n    l1_ratios : list of float, default=None\n        The list of Elastic-Net mixing parameter, with ``0 <= l1_ratio <= 1``.\n        Only used if ``penalty='elasticnet'``. A value of 0 is equivalent to\n        using ``penalty='l2'``, while 1 is equivalent to using\n        ``penalty='l1'``. For ``0 < l1_ratio <1``, the penalty is a combination\n        of L1 and L2.\n\n    Attributes\n    ----------\n    classes_ : ndarray of shape (n_classes, )\n        A list of class labels known to the classifier.\n\n    coef_ : ndarray of shape (1, n_features) or (n_classes, n_features)\n        Coefficient of the features in the decision function.\n\n        `coef_` is of shape (1, n_features) when the given problem\n        is binary.\n\n    intercept_ : ndarray of shape (1,) or (n_classes,)\n        Intercept (a.k.a. bias) added to the decision function.\n\n        If `fit_intercept` is set to False, the intercept is set to zero.\n        `intercept_` is of shape(1,) when the problem is binary.\n\n    Cs_ : ndarray of shape (n_cs)\n        Array of C i.e. inverse of regularization parameter values used\n        for cross-validation.\n\n    l1_ratios_ : ndarray of shape (n_l1_ratios)\n        Array of l1_ratios used for cross-validation. If no l1_ratio is used\n        (i.e. penalty is not 'elasticnet'), this is set to ``[None]``\n\n    coefs_paths_ : ndarray of shape (n_folds, n_cs, n_features) or \\",
                "filename": "sklearn/linear_model/_logistic.py",
                "start_index": 54232,
                "end_index": 63750,
                "start_line": 1435,
                "end_line": 1642,
                "max_line": 2222,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Search over specified parameter values with successive halving.\n\n    The search strategy starts evaluating all the candidates with a small\n    amount of resources and iteratively selects the best candidates, using\n    more and more resources.\n\n    Read more in the :ref:`User guide <successive_halving_user_guide>`.\n\n    .. note::\n\n      This estimator is still **experimental** for now: the predictions\n      and the API might change without any deprecation cycle. To use it,\n      you need to explicitly import ``enable_halving_search_cv``::\n\n        >>> # explicitly require this experimental feature\n        >>> from sklearn.experimental import enable_halving_search_cv # noqa\n        >>> # now you can import normally from model_selection\n        >>> from sklearn.model_selection import HalvingGridSearchCV\n\n    Parameters\n    ----------\n    estimator : estimator object\n        This is assumed to implement the scikit-learn estimator interface.\n        Either estimator needs to provide a ``score`` function,\n        or ``scoring`` must be passed.\n\n    param_grid : dict or list of dictionaries\n        Dictionary with parameters names (string) as keys and lists of\n        parameter settings to try as values, or a list of such\n        dictionaries, in which case the grids spanned by each dictionary\n        in the list are explored. This enables searching over any sequence\n        of parameter settings.\n\n    factor : int or float, default=3\n        The 'halving' parameter, which determines the proportion of candidates\n        that are selected for each subsequent iteration. For example,\n        ``factor=3`` means that only one third of the candidates are selected.\n\n    resource : ``'n_samples'`` or str, default='n_samples'\n        Defines the resource that increases with each iteration. By default,\n        the resource is the number of samples. It can also be set to any\n        parameter of the base estimator that accepts positive integer\n        values, e.g. 'n_iterations' or 'n_estimators' for a gradient\n        boosting estimator. In this case ``max_resources`` cannot be 'auto'\n        and must be set explicitly.\n\n    max_resources : int, default='auto'\n        The maximum amount of resource that any candidate is allowed to use\n        for a given iteration. By default, this is set to ``n_samples`` when\n        ``resource='n_samples'`` (default), else an error is raised.\n\n    min_resources : {'exhaust', 'smallest'} or int, default='exhaust'\n        The minimum amount of resource that any candidate is allowed to use\n        for a given iteration. Equivalently, this defines the amount of\n        resources `r0` that are allocated for each candidate at the first\n        iteration.\n\n        - 'smallest' is a heuristic that sets `r0` to a small value:\n\n            - ``n_splits * 2`` when ``resource='n_samples'`` for a regression\n              problem\n            - ``n_classes * n_splits * 2`` when ``resource='n_samples'`` for a\n              classification problem\n            - ``1`` when ``resource != 'n_samples'``\n\n        - 'exhaust' will set `r0` such that the **last** iteration uses as\n          much resources as possible. Namely, the last iteration will use the\n          highest value smaller than ``max_resources`` that is a multiple of\n          both ``min_resources`` and ``factor``. In general, using 'exhaust'\n          leads to a more accurate estimator, but is slightly more time\n          consuming.\n\n        Note that the amount of resources used at each iteration is always a\n        multiple of ``min_resources``.\n\n    aggressive_elimination : bool, default=False\n        This is only relevant in cases where there isn't enough resources to\n        reduce the remaining candidates to at most `factor` after the last\n        iteration. If ``True``, then the search process will 'replay' the\n        first iteration for as long as needed until the number of candidates\n        is small enough. This is ``False`` by default, which means that the\n        last iteration may evaluate more than ``factor`` candidates. See\n        :ref:`aggressive_elimination` for more details.\n\n    cv : int, cross-validation generator or iterable, default=5\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. note::\n            Due to implementation details, the folds produced by `cv` must be\n            the same across multiple calls to `cv.split()`. For\n            built-in `scikit-learn` iterators, this can be achieved by\n            deactivating shuffling (`shuffle=False`), or by setting the\n            `cv`'s `random_state` parameter to an integer.\n\n    scoring : str, callable, or None, default=None\n        A single string (see :ref:`scoring_parameter`) or a callable\n        (see :ref:`scoring`) to evaluate the predictions on the test set.\n        If None, the estimator's score method is used.\n\n    refit : bool, default=True\n        If True, refit an estimator using the best found parameters on the\n        whole dataset.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``HalvingGridSearchCV`` instance.\n\n    error_score : 'raise' or numeric\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error. Default is ``np.nan``.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n    random_state : int, RandomState instance or None, default=None\n        Pseudo random number generator state used for subsampling the dataset\n        when `resources != 'n_samples'`. Ignored otherwise.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    n_jobs : int or None, default=None\n        Number of jobs to run in parallel.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n    Attributes\n    ----------\n    n_resources_ : list of int\n        The amount of resources used at each iteration.\n\n    n_candidates_ : list of int\n        The number of candidate parameters that were evaluated at each\n        iteration.\n\n    n_remaining_candidates_ : int\n        The number of candidate parameters that are left after the last\n        iteration. It corresponds to `ceil(n_candidates[-1] / factor)`\n\n    max_resources_ : int\n        The maximum number of resources that any candidate is allowed to use\n        for a given iteration. Note that since the number of resources used\n        at each iteration must be a multiple of ``min_resources_``, the\n        actual number of resources used at the last iteration may be smaller\n        than ``max_resources_``.\n\n    min_resources_ : int\n        The amount of resources that are allocated for each candidate at the\n        first iteration.\n\n    n_iterations_ : int\n        The actual number of iterations that were run. This is equal to\n        ``n_required_iterations_`` if ``aggressive_elimination`` is ``True``.\n        Else, this is equal to ``min(n_possible_iterations_,\n        n_required_iterations_)``.\n\n    n_possible_iterations_ : int\n        The number of iterations that are possible starting with\n        ``min_resources_`` resources and without exceeding\n        ``max_resources_``.\n\n    n_required_iterations_ : int\n        The number of iterations that are required to end up with less than\n        ``factor`` candidates at the last iteration, starting with\n        ``min_resources_`` resources. This will be smaller than\n        ``n_possible_iterations_`` when there isn't enough resources.\n\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``. It contains lots of information\n        for analysing the results of a search.\n        Please refer to the :ref:`User guide<successive_halving_cv_results>`\n        for details.\n\n    best_estimator_ : estimator or dict\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    :class:`HalvingRandomSearchCV`:\n        Random search over a set of parameters using successive halving.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    All parameter combinations scored with a NaN will share the lowest rank.\n\n    Examples\n    --------\n\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> from sklearn.experimental import enable_halving_search_cv  # noqa\n    >>> from sklearn.model_selection import HalvingGridSearchCV\n    ...\n    >>> X, y = load_iris(return_X_y=True)\n    >>> clf = RandomForestClassifier(random_state=0)\n    ...\n    >>> param_grid = {\"max_depth\": [3, None],\n    ...               \"min_samples_split\": [5, 10]}\n    >>> search = HalvingGridSearchCV(clf, param_grid, resource='n_estimators',\n    ...                              max_resources=10,\n    ...                              random_state=0).fit(X, y)\n    >>> search.best_params_  # doctest: +SKIP\n    {'max_depth': None, 'min_samples_split': 10, 'n_estimators': 9}\n    \"\"\"",
                "filename": "sklearn/model_selection/_search_successive_halving.py",
                "start_index": 14818,
                "end_index": 27400,
                "start_line": 391,
                "end_line": 1021,
                "max_line": 1083,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "\"\"\"Randomized search on hyper parameters.\n\n    The search strategy starts evaluating all the candidates with a small\n    amount of resources and iteratively selects the best candidates, using more\n    and more resources.\n\n    The candidates are sampled at random from the parameter space and the\n    number of sampled candidates is determined by ``n_candidates``.\n\n    Read more in the :ref:`User guide<successive_halving_user_guide>`.\n\n    .. note::\n\n      This estimator is still **experimental** for now: the predictions\n      and the API might change without any deprecation cycle. To use it,\n      you need to explicitly import ``enable_halving_search_cv``::\n\n        >>> # explicitly require this experimental feature\n        >>> from sklearn.experimental import enable_halving_search_cv # noqa\n        >>> # now you can import normally from model_selection\n        >>> from sklearn.model_selection import HalvingRandomSearchCV\n\n    Parameters\n    ----------\n    estimator : estimator object\n        This is assumed to implement the scikit-learn estimator interface.\n        Either estimator needs to provide a ``score`` function,\n        or ``scoring`` must be passed.\n\n    param_distributions : dict\n        Dictionary with parameters names (string) as keys and distributions\n        or lists of parameters to try. Distributions must provide a ``rvs``\n        method for sampling (such as those from scipy.stats.distributions).\n        If a list is given, it is sampled uniformly.\n\n    n_candidates : \"exhaust\" or int, default=\"exhaust\"\n        The number of candidate parameters to sample, at the first\n        iteration. Using 'exhaust' will sample enough candidates so that the\n        last iteration uses as many resources as possible, based on\n        `min_resources`, `max_resources` and `factor`. In this case,\n        `min_resources` cannot be 'exhaust'.\n\n    factor : int or float, default=3\n        The 'halving' parameter, which determines the proportion of candidates\n        that are selected for each subsequent iteration. For example,\n        ``factor=3`` means that only one third of the candidates are selected.\n\n    resource : ``'n_samples'`` or str, default='n_samples'\n        Defines the resource that increases with each iteration. By default,\n        the resource is the number of samples. It can also be set to any\n        parameter of the base estimator that accepts positive integer\n        values, e.g. 'n_iterations' or 'n_estimators' for a gradient\n        boosting estimator. In this case ``max_resources`` cannot be 'auto'\n        and must be set explicitly.\n\n    max_resources : int, default='auto'\n        The maximum number of resources that any candidate is allowed to use\n        for a given iteration. By default, this is set ``n_samples`` when\n        ``resource='n_samples'`` (default), else an error is raised.\n\n    min_resources : {'exhaust', 'smallest'} or int, default='smallest'\n        The minimum amount of resource that any candidate is allowed to use\n        for a given iteration. Equivalently, this defines the amount of\n        resources `r0` that are allocated for each candidate at the first\n        iteration.\n\n        - 'smallest' is a heuristic that sets `r0` to a small value:\n\n            - ``n_splits * 2`` when ``resource='n_samples'`` for a regression\n              problem\n            - ``n_classes * n_splits * 2`` when ``resource='n_samples'`` for a\n              classification problem\n            - ``1`` when ``resource != 'n_samples'``\n\n        - 'exhaust' will set `r0` such that the **last** iteration uses as\n          much resources as possible. Namely, the last iteration will use the\n          highest value smaller than ``max_resources`` that is a multiple of\n          both ``min_resources`` and ``factor``. In general, using 'exhaust'\n          leads to a more accurate estimator, but is slightly more time\n          consuming. 'exhaust' isn't available when `n_candidates='exhaust'`.\n\n        Note that the amount of resources used at each iteration is always a\n        multiple of ``min_resources``.\n\n    aggressive_elimination : bool, default=False\n        This is only relevant in cases where there isn't enough resources to\n        reduce the remaining candidates to at most `factor` after the last\n        iteration. If ``True``, then the search process will 'replay' the\n        first iteration for as long as needed until the number of candidates\n        is small enough. This is ``False`` by default, which means that the\n        last iteration may evaluate more than ``factor`` candidates. See\n        :ref:`aggressive_elimination` for more details.\n\n    cv : int, cross-validation generator or an iterable, default=5\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. note::\n            Due to implementation details, the folds produced by `cv` must be\n            the same across multiple calls to `cv.split()`. For\n            built-in `scikit-learn` iterators, this can be achieved by\n            deactivating shuffling (`shuffle=False`), or by setting the\n            `cv`'s `random_state` parameter to an integer.\n\n    scoring : str, callable, or None, default=None\n        A single string (see :ref:`scoring_parameter`) or a callable\n        (see :ref:`scoring`) to evaluate the predictions on the test set.\n        If None, the estimator's score method is used.\n\n    refit : bool, default=True\n        If True, refit an estimator using the best found parameters on the\n        whole dataset.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``HalvingRandomSearchCV`` instance.\n\n    error_score : 'raise' or numeric\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error. Default is ``np.nan``.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n    random_state : int, RandomState instance or None, default=None\n        Pseudo random number generator state used for subsampling the dataset\n        when `resources != 'n_samples'`. Also used for random uniform\n        sampling from lists of possible values instead of scipy.stats\n        distributions.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    n_jobs : int or None, default=None\n        Number of jobs to run in parallel.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n    Attributes\n    ----------\n    n_resources_ : list of int\n        The amount of resources used at each iteration.\n\n    n_candidates_ : list of int\n        The number of candidate parameters that were evaluated at each\n        iteration.\n\n    n_remaining_candidates_ : int\n        The number of candidate parameters that are left after the last\n        iteration. It corresponds to `ceil(n_candidates[-1] / factor)`\n\n    max_resources_ : int\n        The maximum number of resources that any candidate is allowed to use\n        for a given iteration. Note that since the number of resources used at\n        each iteration must be a multiple of ``min_resources_``, the actual\n        number of resources used at the last iteration may be smaller than\n        ``max_resources_``.\n\n    min_resources_ : int\n        The amount of resources that are allocated for each candidate at the\n        first iteration.\n\n    n_iterations_ : int\n        The actual number of iterations that were run. This is equal to\n        ``n_required_iterations_`` if ``aggressive_elimination`` is ``True``.\n        Else, this is equal to ``min(n_possible_iterations_,\n        n_required_iterations_)``.\n\n    n_possible_iterations_ : int\n        The number of iterations that are possible starting with\n        ``min_resources_`` resources and without exceeding\n        ``max_resources_``.\n\n    n_required_iterations_ : int\n        The number of iterations that are required to end up with less than\n        ``factor`` candidates at the last iteration, starting with\n        ``min_resources_`` resources. This will be smaller than\n        ``n_possible_iterations_`` when there isn't enough resources.\n\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``. It contains lots of information\n        for analysing the results of a search.\n        Please refer to the :ref:`User guide<successive_halving_cv_results>`\n        for details.\n\n    best_estimator_ : estimator or dict\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    :class:`HalvingGridSearchCV`:\n        Search over a grid of parameters using successive halving.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    All parameter combinations scored with a NaN will share the lowest rank.\n\n    Examples\n    --------\n\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> from sklearn.experimental import enable_halving_search_cv  # noqa\n    >>> from sklearn.model_selection import HalvingRandomSearchCV\n    >>> from scipy.stats import randint\n    >>> import numpy as np\n    ...\n    >>> X, y = load_iris(return_X_y=True)\n    >>> clf = RandomForestClassifier(random_state=0)\n    >>> np.random.seed(0)\n    ...\n    >>> param_distributions = {\"max_depth\": [3, None],\n    ...                        \"min_samples_split\": randint(2, 11)}\n    >>> search = HalvingRandomSearchCV(clf, param_distributions,\n    ...                                resource='n_estimators',\n    ...                                max_resources=10,\n    ...                                random_state=0).fit(X, y)\n    >>> search.best_params_  # doctest: +SKIP\n    {'max_depth': None, 'min_samples_split': 10, 'n_estimators': 9}\n    \"\"\"",
                "filename": "sklearn/model_selection/_search_successive_halving.py",
                "start_index": 28714,
                "end_index": 42080,
                "start_line": 724,
                "end_line": 1021,
                "max_line": 1083,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "\"\"\"Randomized search on hyper parameters.\n\n    RandomizedSearchCV implements a \"fit\" and a \"score\" method.\n    It also implements \"score_samples\", \"predict\", \"predict_proba\",\n    \"decision_function\", \"transform\" and \"inverse_transform\" if they are\n    implemented in the estimator used.\n\n    The parameters of the estimator used to apply these methods are optimized\n    by cross-validated search over parameter settings.\n\n    In contrast to GridSearchCV, not all parameter values are tried out, but\n    rather a fixed number of parameter settings is sampled from the specified\n    distributions. The number of parameter settings that are tried is\n    given by n_iter.\n\n    If all parameters are presented as a list,\n    sampling without replacement is performed. If at least one parameter\n    is given as a distribution, sampling with replacement is used.\n    It is highly recommended to use continuous distributions for continuous\n    parameters.\n\n    Read more in the :ref:`User Guide <randomized_parameter_search>`.\n\n    .. versionadded:: 0.14\n\n    Parameters\n    ----------\n    estimator : estimator object\n        An object of that type is instantiated for each grid point.\n        This is assumed to implement the scikit-learn estimator interface.\n        Either estimator needs to provide a ``score`` function,\n        or ``scoring`` must be passed.\n\n    param_distributions : dict or list of dicts\n        Dictionary with parameters names (`str`) as keys and distributions\n        or lists of parameters to try. Distributions must provide a ``rvs``\n        method for sampling (such as those from scipy.stats.distributions).\n        If a list is given, it is sampled uniformly.\n        If a list of dicts is given, first a dict is sampled uniformly, and\n        then a parameter is sampled using that dict as above.\n\n    n_iter : int, default=10\n        Number of parameter settings that are sampled. n_iter trades\n        off runtime vs quality of the solution.\n\n    scoring : str, callable, list, tuple or dict, default=None\n        Strategy to evaluate the performance of the cross-validated model on\n        the test set.\n\n        If `scoring` represents a single score, one can use:\n\n        - a single string (see :ref:`scoring_parameter`);\n        - a callable (see :ref:`scoring`) that returns a single value.\n\n        If `scoring` represents multiple scores, one can use:\n\n        - a list or tuple of unique strings;\n        - a callable returning a dictionary where the keys are the metric\n          names and the values are the metric scores;\n        - a dictionary with metric names as keys and callables a values.\n\n        See :ref:`multimetric_grid_search` for an example.\n\n        If None, the estimator's score method is used.\n\n    n_jobs : int, default=None\n        Number of jobs to run in parallel.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n        .. versionchanged:: v0.20\n           `n_jobs` default changed from 1 to None\n\n    refit : bool, str, or callable, default=True\n        Refit an estimator using the best found parameters on the whole\n        dataset.\n\n        For multiple metric evaluation, this needs to be a `str` denoting the\n        scorer that would be used to find the best parameters for refitting\n        the estimator at the end.\n\n        Where there are considerations other than maximum score in\n        choosing a best estimator, ``refit`` can be set to a function which\n        returns the selected ``best_index_`` given the ``cv_results``. In that\n        case, the ``best_estimator_`` and ``best_params_`` will be set\n        according to the returned ``best_index_`` while the ``best_score_``\n        attribute will not be available.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``RandomizedSearchCV`` instance.\n\n        Also for multiple metric evaluation, the attributes ``best_index_``,\n        ``best_score_`` and ``best_params_`` will only be available if\n        ``refit`` is set and all of them will be determined w.r.t this specific\n        scorer.\n\n        See ``scoring`` parameter to know more about multiple metric\n        evaluation.\n\n        .. versionchanged:: 0.20\n            Support for callable added.\n\n    cv : int, cross-validation generator or an iterable, default=None\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 5-fold cross validation,\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used. These splitters are instantiated\n        with `shuffle=False` so the splits will be the same across calls.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.22\n            ``cv`` default value if None changed from 3-fold to 5-fold.\n\n    verbose : int\n        Controls the verbosity: the higher, the more messages.\n\n        - >1 : the computation time for each fold and parameter candidate is\n          displayed;\n        - >2 : the score is also displayed;\n        - >3 : the fold and candidate parameter indexes are also displayed\n          together with the starting time of the computation.\n\n    pre_dispatch : int, or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n            - None, in which case all the jobs are immediately\n              created and spawned. Use this for lightweight and\n              fast-running jobs, to avoid delays due to on-demand\n              spawning of the jobs\n\n            - An int, giving the exact number of total jobs that are\n              spawned\n\n            - A str, giving an expression as a function of n_jobs,\n              as in '2*n_jobs'\n\n    random_state : int, RandomState instance or None, default=None\n        Pseudo random number generator state used for random uniform sampling\n        from lists of possible values instead of scipy.stats distributions.\n        Pass an int for reproducible output across multiple\n        function calls.\n        See :term:`Glossary <random_state>`.\n\n    error_score : 'raise' or numeric, default=np.nan\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error.\n\n    return_train_score : bool, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n        .. versionadded:: 0.19\n\n        .. versionchanged:: 0.21\n            Default value was changed from ``True`` to ``False``\n\n    Attributes\n    ----------\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``.\n\n        For instance the below given table\n\n        +--------------+-------------+-------------------+---+---------------+\n        | param_kernel | param_gamma | split0_test_score |...|rank_test_score|\n        +==============+=============+===================+===+===============+\n        |    'rbf'     |     0.1     |       0.80        |...|       1       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.2     |       0.84        |...|       3       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.3     |       0.70        |...|       2       |\n        +--------------+-------------+-------------------+---+---------------+\n\n        will be represented by a ``cv_results_`` dict of::\n\n            {\n            'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],\n                                          mask = False),\n            'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),\n            'split0_test_score'  : [0.80, 0.84, 0.70],\n            'split1_test_score'  : [0.82, 0.50, 0.70],\n            'mean_test_score'    : [0.81, 0.67, 0.70],\n            'std_test_score'     : [0.01, 0.24, 0.00],\n            'rank_test_score'    : [1, 3, 2],\n            'split0_train_score' : [0.80, 0.92, 0.70],\n            'split1_train_score' : [0.82, 0.55, 0.70],\n            'mean_train_score'   : [0.81, 0.74, 0.70],\n            'std_train_score'    : [0.01, 0.19, 0.00],\n            'mean_fit_time'      : [0.73, 0.63, 0.43],\n            'std_fit_time'       : [0.01, 0.02, 0.01],\n            'mean_score_time'    : [0.01, 0.06, 0.04],\n            'std_score_time'     : [0.00, 0.00, 0.00],\n            'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],\n            }\n\n        NOTE\n\n        The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        For multi-metric evaluation, this attribute is present only if\n        ``refit`` is specified.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n        This attribute is not available if ``refit`` is a function.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n        .. versionadded:: 0.20\n\n    multimetric_ : bool\n        Whether or not the scorers compute several metrics.\n\n    classes_ : ndarray of shape (n_classes,)\n        The classes labels. This is present only if ``refit`` is specified and\n        the underlying estimator is a classifier.\n\n    n_features_in_ : int\n        Number of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `n_features_in_` when fit.\n\n        .. versionadded:: 0.24\n\n    feature_names_in_ : ndarray of shape (`n_features_in_`,)\n        Names of features seen during :term:`fit`. Only defined if\n        `best_estimator_` is defined (see the documentation for the `refit`\n        parameter for more details) and that `best_estimator_` exposes\n        `feature_names_in_` when fit.\n\n        .. versionadded:: 1.0\n\n    See Also\n    --------\n    GridSearchCV : Does exhaustive search over a grid of parameters.\n    ParameterSampler : A generator over parameter settings, constructed from\n        param_distributions.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    parameter setting(and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_iris\n    >>> from sklearn.linear_model import LogisticRegression\n    >>> from sklearn.model_selection import RandomizedSearchCV\n    >>> from scipy.stats import uniform\n    >>> iris = load_iris()\n    >>> logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,\n    ...                               random_state=0)\n    >>> distributions = dict(C=uniform(loc=0, scale=4),\n    ...                      penalty=['l2', 'l1'])\n    >>> clf = RandomizedSearchCV(logistic, distributions, random_state=0)\n    >>> search = clf.fit(iris.data, iris.target)\n    >>> search.best_params_\n    {'C': 2..., 'penalty': 'l1'}\n    \"\"\"",
                "filename": "sklearn/model_selection/_search.py",
                "start_index": 55934,
                "end_index": 70710,
                "start_line": 1426,
                "end_line": 1808,
                "max_line": 1813,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "\"\"\"Gradient Boosting for classification.\n\n    This algorithm builds an additive model in a forward stage-wise fashion; it\n    allows for the optimization of arbitrary differentiable loss functions. In\n    each stage ``n_classes_`` regression trees are fit on the negative gradient\n    of the loss function, e.g. binary or multiclass log loss. Binary\n    classification is a special case where only a single regression tree is\n    induced.\n\n    :class:`sklearn.ensemble.HistGradientBoostingClassifier` is a much faster\n    variant of this algorithm for intermediate datasets (`n_samples >= 10_000`).\n\n    Read more in the :ref:`User Guide <gradient_boosting>`.\n\n    Parameters\n    ----------\n    loss : {'log_loss', 'exponential'}, default='log_loss'\n        The loss function to be optimized. 'log_loss' refers to binomial and\n        multinomial deviance, the same as used in logistic regression.\n        It is a good choice for classification with probabilistic outputs.\n        For loss 'exponential', gradient boosting recovers the AdaBoost algorithm.\n\n    learning_rate : float, default=0.1\n        Learning rate shrinks the contribution of each tree by `learning_rate`.\n        There is a trade-off between learning_rate and n_estimators.\n        Values must be in the range `[0.0, inf)`.\n\n    n_estimators : int, default=100\n        The number of boosting stages to perform. Gradient boosting\n        is fairly robust to over-fitting so a large number usually\n        results in better performance.\n        Values must be in the range `[1, inf)`.\n\n    subsample : float, default=1.0\n        The fraction of samples to be used for fitting the individual base\n        learners. If smaller than 1.0 this results in Stochastic Gradient\n        Boosting. `subsample` interacts with the parameter `n_estimators`.\n        Choosing `subsample < 1.0` leads to a reduction of variance\n        and an increase in bias.\n        Values must be in the range `(0.0, 1.0]`.\n\n    criterion : {'friedman_mse', 'squared_error'}, default='friedman_mse'\n        The function to measure the quality of a split. Supported criteria are\n        'friedman_mse' for the mean squared error with improvement score by\n        Friedman, 'squared_error' for mean squared error. The default value of\n        'friedman_mse' is generally the best as it can provide a better\n        approximation in some cases.\n\n        .. versionadded:: 0.18\n\n    min_samples_split : int or float, default=2\n        The minimum number of samples required to split an internal node:\n\n        - If int, values must be in the range `[2, inf)`.\n        - If float, values must be in the range `(0.0, 1.0]` and `min_samples_split`\n          will be `ceil(min_samples_split * n_samples)`.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_samples_leaf : int or float, default=1\n        The minimum number of samples required to be at a leaf node.\n        A split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  This may have the effect of smoothing the model,\n        especially in regression.\n\n        - If int, values must be in the range `[1, inf)`.\n        - If float, values must be in the range `(0.0, 1.0)` and `min_samples_leaf`\n          will be `ceil(min_samples_leaf * n_samples)`.\n\n        .. versionchanged:: 0.18\n           Added float values for fractions.\n\n    min_weight_fraction_leaf : float, default=0.0\n        The minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. Samples have\n        equal weight when sample_weight is not provided.\n        Values must be in the range `[0.0, 0.5]`.\n\n    max_depth : int or None, default=3\n        Maximum depth of the individual regression estimators. The maximum\n        depth limits the number of nodes in the tree. Tune this parameter\n        for best performance; the best value depends on the interaction\n        of the input variables. If None, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n        If int, values must be in the range `[1, inf)`.\n\n    min_impurity_decrease : float, default=0.0\n        A node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n        Values must be in the range `[0.0, inf)`.\n\n        The weighted impurity decrease equation is the following::\n\n            N_t / N * (impurity - N_t_R / N_t * right_impurity\n                                - N_t_L / N_t * left_impurity)\n\n        where ``N`` is the total number of samples, ``N_t`` is the number of\n        samples at the current node, ``N_t_L`` is the number of samples in the\n        left child, and ``N_t_R`` is the number of samples in the right child.\n\n        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n        .. versionadded:: 0.19\n\n    init : estimator or 'zero', default=None\n        An estimator object that is used to compute the initial predictions.\n        ``init`` has to provide :term:`fit` and :term:`predict_proba`. If\n        'zero', the initial raw predictions are set to zero. By default, a\n        ``DummyEstimator`` predicting the classes priors is used.\n\n    random_state : int, RandomState instance or None, default=None\n        Controls the random seed given to each Tree estimator at each\n        boosting iteration.\n        In addition, it controls the random permutation of the features at\n        each split (see Notes for more details).\n        It also controls the random splitting of the training data to obtain a\n        validation set if `n_iter_no_change` is not None.\n        Pass an int for reproducible output across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    max_features : {'sqrt', 'log2'}, int or float, default=None\n        The number of features to consider when looking for the best split:\n\n        - If int, values must be in the range `[1, inf)`.\n        - If float, values must be in the range `(0.0, 1.0]` and the features\n          considered at each split will be `max(1, int(max_features * n_features_in_))`.\n        - If 'sqrt', then `max_features=sqrt(n_features)`.\n        - If 'log2', then `max_features=log2(n_features)`.\n        - If None, then `max_features=n_features`.\n\n        Choosing `max_features < n_features` leads to a reduction of variance\n        and an increase in bias.\n\n        Note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    verbose : int, default=0\n        Enable verbose output. If 1 then it prints progress and performance\n        once in a while (the more trees the lower the frequency). If greater\n        than 1 then it prints progress and performance for every tree.\n        Values must be in the range `[0, inf)`.\n\n    max_leaf_nodes : int, default=None\n        Grow trees with ``max_leaf_nodes`` in best-first fashion.\n        Best nodes are defined as relative reduction in impurity.\n        Values must be in the range `[2, inf)`.\n        If `None`, then unlimited number of leaf nodes.\n\n    warm_start : bool, default=False\n        When set to ``True``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just erase the\n        previous solution. See :term:`the Glossary <warm_start>`.\n\n    validation_fraction : float, default=0.1\n        The proportion of training data to set aside as validation set for\n        early stopping. Values must be in the range `(0.0, 1.0)`.\n        Only used if ``n_iter_no_change`` is set to an integer.\n\n        .. versionadded:: 0.20\n\n    n_iter_no_change : int, default=None\n        ``n_iter_no_change`` is used to decide if early stopping will be used\n        to terminate training when validation score is not improving. By\n        default it is set to None to disable early stopping. If set to a\n        number, it will set aside ``validation_fraction`` size of the training\n        data as validation and terminate training when validation score is not\n        improving in all of the previous ``n_iter_no_change`` numbers of\n        iterations. The split is stratified.\n        Values must be in the range `[1, inf)`.\n\n        .. versionadded:: 0.20\n\n    tol : float, default=1e-4\n        Tolerance for the early stopping. When the loss is not improving\n        by at least tol for ``n_iter_no_change`` iterations (if set to a\n        number), the training stops.\n        Values must be in the range `[0.0, inf)`.\n\n        .. versionadded:: 0.20\n\n    ccp_alpha : non-negative float, default=0.0\n        Complexity parameter used for Minimal Cost-Complexity Pruning. The\n        subtree with the largest cost complexity that is smaller than\n        ``ccp_alpha`` will be chosen. By default, no pruning is performed.\n        Values must be in the range `[0.0, inf)`.\n        See :ref:`minimal_cost_complexity_pruning` for details.\n\n        .. versionadded:: 0.22\n\n    Attributes\n    ----------\n    n_estimators_ : int\n        The number of estimators as selected by early stopping (if\n        ``n_iter_no_change`` is specified). Otherwise it is set to\n        ``n_estimators``.\n\n        .. versionadded:: 0.20\n\n    feature_importances_ : ndarray of shape (n_features,)\n        The impurity-based feature importances.\n        The higher, the more important the feature.\n        The importance of a feature is computed as the (normalized)\n        total reduction of the criterion brought by that feature.  It is also\n        known as the Gini importance.\n\n        Warning: impurity-based feature importances can be misleading for\n        high cardinality features (many unique values). See\n        :func:`sklearn.inspection.permutation_importance` as an alternative.\n\n    oob_improvement_ : ndarray of shape (n_estimators,)\n        The improvement in loss on the out-of-bag samples\n        relative to the previous iteration.\n        ``oob_improvement_[0]`` is the improvement in\n        loss of the first stage over the ``init`` estimator.\n        Only available if ``subsample < 1.0``.\n\n    oob_scores_ : ndarray of shape (n_estimators,)\n        The full history of the loss values on the out-of-bag\n        samples. Only available if `subsample < 1.0`.\n\n        .. versionadded:: 1.3\n\n    oob_score_ : float\n        The last value of the loss on the out-of-bag samples. It is\n        the same as `oob_scores_[-1]`. Only available if `subsample < 1.0`.\n\n        .. versionadded:: 1.3\n\n    train_score_ : ndarray of shape (n_estimators,)\n        The i-th score ``train_score_[i]`` is the loss of the\n        model at iteration ``i`` on the in-bag sample.\n        If ``subsample == 1`` this is the loss on the training data.\n\n    init_ : estimator\n        The estimator that provides the initial predictions.\n        Set via the ``init`` argument or ``loss.init_estimator``.\n\n    estimators_ : ndarray of DecisionTreeRegressor of \\",
                "filename": "sklearn/ensemble/_gb.py",
                "start_index": 31581,
                "end_index": 42812,
                "start_line": 835,
                "end_line": 1077,
                "max_line": 1828,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@ignore_warnings\ndef check_fit2d_1feature(name, estimator_orig):\n    # check fitting a 2d array with only 1 feature either works or returns\n    # informative message\n    rnd = np.random.RandomState(0)\n    X = 3 * rnd.uniform(size=(10, 1))\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    y = X[:, 0].astype(int)\n    estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if hasattr(estimator, \"n_components\"):\n        estimator.n_components = 1\n    if hasattr(estimator, \"n_clusters\"):\n        estimator.n_clusters = 1\n    # ensure two labels in subsample for RandomizedLogisticRegression\n    if name == \"RandomizedLogisticRegression\":\n        estimator.sample_fraction = 1\n    # ensure non skipped trials for RANSACRegressor\n    if name == \"RANSACRegressor\":\n        estimator.residual_threshold = 0.5\n\n    y = _enforce_estimator_tags_y(estimator, y)\n    set_random_state(estimator, 1)\n\n    msgs = [r\"1 feature\\(s\\)\", \"n_features = 1\", \"n_features=1\"]\n\n    with raises(ValueError, match=msgs, may_pass=True):\n        estimator.fit(X, y)\n\n\n@ignore_warnings\ndef check_fit1d(name, estimator_orig):\n    # check fitting 1d X array raises a ValueError\n    rnd = np.random.RandomState(0)\n    X = 3 * rnd.uniform(size=(20))\n    y = X.astype(int)\n    estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if hasattr(estimator, \"n_components\"):\n        estimator.n_components = 1\n    if hasattr(estimator, \"n_clusters\"):\n        estimator.n_clusters = 1\n\n    set_random_state(estimator, 1)\n    with raises(ValueError):\n        estimator.fit(X, y)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_transformer_general(name, transformer, readonly_memmap=False):\n    X, y = make_blobs(\n        n_samples=30,\n        centers=[[0, 0, 0], [1, 1, 1]],\n        random_state=0,\n        n_features=2,\n        cluster_std=0.1,\n    )\n    X = StandardScaler().fit_transform(X)\n    X = _enforce_estimator_tags_X(transformer, X)\n\n    if readonly_memmap:\n        X, y = create_memmap_backed_data([X, y])\n\n    _check_transformer(name, transformer, X, y)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_transformer_data_not_an_array(name, transformer):\n    X, y = make_blobs(\n        n_samples=30,\n        centers=[[0, 0, 0], [1, 1, 1]],\n        random_state=0,\n        n_features=2,\n        cluster_std=0.1,\n    )\n    X = StandardScaler().fit_transform(X)\n    X = _enforce_estimator_tags_X(transformer, X)\n    this_X = _NotAnArray(X)\n    this_y = _NotAnArray(np.asarray(y))\n    _check_transformer(name, transformer, this_X, this_y)\n    # try the same with some list\n    _check_transformer(name, transformer, X.tolist(), y.tolist())",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 55999,
                "end_index": 58685,
                "start_line": 181,
                "end_line": 1729,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "def check_fit_check_is_fitted(name, estimator_orig):\n    # Make sure that estimator doesn't pass check_is_fitted before calling fit\n    # and that passes check_is_fitted once it's fit.\n\n    rng = np.random.RandomState(42)\n\n    estimator = clone(estimator_orig)\n    set_random_state(estimator)\n    if \"warm_start\" in estimator.get_params():\n        estimator.set_params(warm_start=False)\n\n    n_samples = 100\n    X = rng.normal(loc=100, size=(n_samples, 2))\n    X = _enforce_estimator_tags_X(estimator, X)\n    if is_regressor(estimator_orig):\n        y = rng.normal(size=n_samples)\n    else:\n        y = rng.randint(low=0, high=2, size=n_samples)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if not _safe_tags(estimator).get(\"stateless\", False):\n        # stateless estimators (such as FunctionTransformer) are always \"fit\"!\n        try:\n            check_is_fitted(estimator)\n            raise AssertionError(\n                f\"{estimator.__class__.__name__} passes check_is_fitted before being\"\n                \" fit!\"\n            )\n        except NotFittedError:\n            pass\n    estimator.fit(X, y)\n    try:\n        check_is_fitted(estimator)\n    except NotFittedError as e:\n        raise NotFittedError(\n            \"Estimator fails to pass `check_is_fitted` even though it has been fit.\"\n        ) from e\n\n\ndef check_n_features_in(name, estimator_orig):\n    # Make sure that n_features_in_ attribute doesn't exist until fit is\n    # called, and that its value is correct.\n\n    rng = np.random.RandomState(0)\n\n    estimator = clone(estimator_orig)\n    set_random_state(estimator)\n    if \"warm_start\" in estimator.get_params():\n        estimator.set_params(warm_start=False)\n\n    n_samples = 100\n    X = rng.normal(loc=100, size=(n_samples, 2))\n    X = _enforce_estimator_tags_X(estimator, X)\n    if is_regressor(estimator_orig):\n        y = rng.normal(size=n_samples)\n    else:\n        y = rng.randint(low=0, high=2, size=n_samples)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    assert not hasattr(estimator, \"n_features_in_\")\n    estimator.fit(X, y)\n    assert hasattr(estimator, \"n_features_in_\")\n    assert estimator.n_features_in_ == X.shape[1]\n\n\ndef check_requires_y_none(name, estimator_orig):\n    # Make sure that an estimator with requires_y=True fails gracefully when\n    # given y=None\n\n    rng = np.random.RandomState(0)\n\n    estimator = clone(estimator_orig)\n    set_random_state(estimator)\n\n    n_samples = 100\n    X = rng.normal(loc=100, size=(n_samples, 2))\n    X = _enforce_estimator_tags_X(estimator, X)\n\n    expected_err_msgs = (\n        \"requires y to be passed, but the target y is None\",\n        \"Expected array-like (array or non-string sequence), got None\",\n        \"y should be a 1d array\",\n    )\n\n    try:\n        estimator.fit(X, None)\n    except ValueError as ve:\n        if not any(msg in str(ve) for msg in expected_err_msgs):\n            raise ve",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 138164,
                "end_index": 141063,
                "start_line": 3892,
                "end_line": 3980,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "invalid_names = [\n        (names[::-1], \"Feature names must be in the same order as they were in fit.\"),\n        (\n            [f\"another_prefix_{i}\" for i in range(n_features)],\n            (\n                \"Feature names unseen at fit time:\\n- another_prefix_0\\n-\"\n                \" another_prefix_1\\n\"\n            ),\n        ),\n        (\n            names[:3],\n            f\"Feature names seen at fit time, yet now missing:\\n- {min(names[3:])}\\n\",\n        ),\n    ]\n    params = {\n        key: value\n        for key, value in estimator.get_params().items()\n        if \"early_stopping\" in key\n    }\n    early_stopping_enabled = any(value is True for value in params.values())\n\n    for invalid_name, additional_message in invalid_names:\n        X_bad = pd.DataFrame(X, columns=invalid_name, copy=False)\n\n        expected_msg = re.escape(\n            \"The feature names should match those that were passed during fit.\\n\"\n            f\"{additional_message}\"\n        )\n        for name, method in check_methods:\n            with raises(\n                ValueError, match=expected_msg, err_msg=f\"{name} did not raise\"\n            ):\n                method(X_bad)\n\n        # partial_fit checks on second call\n        # Do not call partial fit if early_stopping is on\n        if not hasattr(estimator, \"partial_fit\") or early_stopping_enabled:\n            continue\n\n        estimator = clone(estimator_orig)\n        if is_classifier(estimator):\n            classes = np.unique(y)\n            estimator.partial_fit(X, y, classes=classes)\n        else:\n            estimator.partial_fit(X, y)\n\n        with raises(ValueError, match=expected_msg):\n            estimator.partial_fit(X_bad, y)",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 146663,
                "end_index": 148346,
                "start_line": 4160,
                "end_line": 4207,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "@ignore_warnings(category=FutureWarning)\ndef check_classifiers_multilabel_output_format_decision_function(name, classifier_orig):\n    \"\"\"Check the output of the `decision_function` method for classifiers supporting\n    multilabel-indicator targets.\"\"\"\n    classifier = clone(classifier_orig)\n    set_random_state(classifier)\n\n    n_samples, test_size, n_outputs = 100, 25, 5\n    X, y = make_multilabel_classification(\n        n_samples=n_samples,\n        n_features=2,\n        n_classes=n_outputs,\n        n_labels=3,\n        length=50,\n        allow_unlabeled=True,\n        random_state=0,\n    )\n    X = scale(X)\n\n    X_train, X_test = X[:-test_size], X[-test_size:]\n    y_train = y[:-test_size]\n    classifier.fit(X_train, y_train)\n\n    response_method_name = \"decision_function\"\n    decision_function_method = getattr(classifier, response_method_name, None)\n    if decision_function_method is None:\n        raise SkipTest(f\"{name} does not have a {response_method_name} method.\")\n\n    y_pred = decision_function_method(X_test)\n\n    # y_pred.shape -> y_test.shape with floating dtype\n    assert isinstance(y_pred, np.ndarray), (\n        f\"{name}.decision_function is expected to output a NumPy array.\"\n        f\" Got {type(y_pred)} instead.\"\n    )\n    assert y_pred.shape == (test_size, n_outputs), (\n        f\"{name}.decision_function is expected to provide a NumPy array \"\n        f\"of shape (n_samples, n_outputs). Got {y_pred.shape} instead of \"\n        f\"{(test_size, n_outputs)}.\"\n    )\n    assert y_pred.dtype.kind == \"f\", (\n        f\"{name}.decision_function is expected to output a floating dtype.\"\n        f\" Got {y_pred.dtype} instead.\"\n    )\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_get_feature_names_out_error(name, estimator_orig):\n    \"\"\"Check the error raised by get_feature_names_out when called before fit.\n\n    Unfitted estimators with get_feature_names_out should raise a NotFittedError.\n    \"\"\"\n\n    estimator = clone(estimator_orig)\n    err_msg = (\n        f\"Estimator {name} should have raised a NotFitted error when fit is called\"\n        \" before get_feature_names_out\"\n    )\n    with raises(NotFittedError, err_msg=err_msg):\n        estimator.get_feature_names_out()\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_estimators_fit_returns_self(name, estimator_orig, readonly_memmap=False):\n    \"\"\"Check if self is returned when calling fit.\"\"\"\n    X, y = make_blobs(random_state=0, n_samples=21)\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n\n    estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if readonly_memmap:\n        X, y = create_memmap_backed_data([X, y])\n\n    set_random_state(estimator)\n    assert estimator.fit(X, y) is estimator",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 98469,
                "end_index": 101199,
                "start_line": 181,
                "end_line": 2872,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                "sha": "",
                "context_relevance": 1.0
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sklearn/utils/estimator_checks.py": [
                {
                    "chunk": {
                        "code": "invalid_names = [\n        (names[::-1], \"Feature names must be in the same order as they were in fit.\"),\n        (\n            [f\"another_prefix_{i}\" for i in range(n_features)],\n            (\n                \"Feature names unseen at fit time:\\n- another_prefix_0\\n-\"\n                \" another_prefix_1\\n\"\n            ),\n        ),\n        (\n            names[:3],\n            f\"Feature names seen at fit time, yet now missing:\\n- {min(names[3:])}\\n\",\n        ),\n    ]\n    params = {\n        key: value\n        for key, value in estimator.get_params().items()\n        if \"early_stopping\" in key\n    }\n    early_stopping_enabled = any(value is True for value in params.values())\n\n    for invalid_name, additional_message in invalid_names:\n        X_bad = pd.DataFrame(X, columns=invalid_name, copy=False)\n\n        expected_msg = re.escape(\n            \"The feature names should match those that were passed during fit.\\n\"\n            f\"{additional_message}\"\n        )\n        for name, method in check_methods:\n            with raises(\n                ValueError, match=expected_msg, err_msg=f\"{name} did not raise\"\n            ):\n                method(X_bad)\n\n        # partial_fit checks on second call\n        # Do not call partial fit if early_stopping is on\n        if not hasattr(estimator, \"partial_fit\") or early_stopping_enabled:\n            continue\n\n        estimator = clone(estimator_orig)\n        if is_classifier(estimator):\n            classes = np.unique(y)\n            estimator.partial_fit(X, y, classes=classes)\n        else:\n            estimator.partial_fit(X, y)\n\n        with raises(ValueError, match=expected_msg):\n            estimator.partial_fit(X_bad, y)",
                        "filename": "sklearn/utils/estimator_checks.py",
                        "start_index": 146663,
                        "end_index": 148346,
                        "start_line": 4160,
                        "end_line": 4207,
                        "max_line": 4639,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains checks for the error message consistency when calling `get_feature_names_out` before `fit`, which is directly related to the issue."
                },
                {
                    "chunk": {
                        "code": "def check_fit_check_is_fitted(name, estimator_orig):\n    # Make sure that estimator doesn't pass check_is_fitted before calling fit\n    # and that passes check_is_fitted once it's fit.\n\n    rng = np.random.RandomState(42)\n\n    estimator = clone(estimator_orig)\n    set_random_state(estimator)\n    if \"warm_start\" in estimator.get_params():\n        estimator.set_params(warm_start=False)\n\n    n_samples = 100\n    X = rng.normal(loc=100, size=(n_samples, 2))\n    X = _enforce_estimator_tags_X(estimator, X)\n    if is_regressor(estimator_orig):\n        y = rng.normal(size=n_samples)\n    else:\n        y = rng.randint(low=0, high=2, size=n_samples)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if not _safe_tags(estimator).get(\"stateless\", False):\n        # stateless estimators (such as FunctionTransformer) are always \"fit\"!\n        try:\n            check_is_fitted(estimator)\n            raise AssertionError(\n                f\"{estimator.__class__.__name__} passes check_is_fitted before being\"\n                \" fit!\"\n            )\n        except NotFittedError:\n            pass\n    estimator.fit(X, y)\n    try:\n        check_is_fitted(estimator)\n    except NotFittedError as e:\n        raise NotFittedError(\n            \"Estimator fails to pass `check_is_fitted` even though it has been fit.\"\n        ) from e\n\n\ndef check_n_features_in(name, estimator_orig):\n    # Make sure that n_features_in_ attribute doesn't exist until fit is\n    # called, and that its value is correct.\n\n    rng = np.random.RandomState(0)\n\n    estimator = clone(estimator_orig)\n    set_random_state(estimator)\n    if \"warm_start\" in estimator.get_params():\n        estimator.set_params(warm_start=False)\n\n    n_samples = 100\n    X = rng.normal(loc=100, size=(n_samples, 2))\n    X = _enforce_estimator_tags_X(estimator, X)\n    if is_regressor(estimator_orig):\n        y = rng.normal(size=n_samples)\n    else:\n        y = rng.randint(low=0, high=2, size=n_samples)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    assert not hasattr(estimator, \"n_features_in_\")\n    estimator.fit(X, y)\n    assert hasattr(estimator, \"n_features_in_\")\n    assert estimator.n_features_in_ == X.shape[1]\n\n\ndef check_requires_y_none(name, estimator_orig):\n    # Make sure that an estimator with requires_y=True fails gracefully when\n    # given y=None\n\n    rng = np.random.RandomState(0)\n\n    estimator = clone(estimator_orig)\n    set_random_state(estimator)\n\n    n_samples = 100\n    X = rng.normal(loc=100, size=(n_samples, 2))\n    X = _enforce_estimator_tags_X(estimator, X)\n\n    expected_err_msgs = (\n        \"requires y to be passed, but the target y is None\",\n        \"Expected array-like (array or non-string sequence), got None\",\n        \"y should be a 1d array\",\n    )\n\n    try:\n        estimator.fit(X, None)\n    except ValueError as ve:\n        if not any(msg in str(ve) for msg in expected_err_msgs):\n            raise ve",
                        "filename": "sklearn/utils/estimator_checks.py",
                        "start_index": 138164,
                        "end_index": 141063,
                        "start_line": 3892,
                        "end_line": 3980,
                        "max_line": 4639,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes checks for the `check_is_fitted` method, which is relevant to the issue as it pertains to the behavior of estimators before and after fitting."
                },
                {
                    "chunk": {
                        "code": "@ignore_warnings\ndef check_fit2d_1feature(name, estimator_orig):\n    # check fitting a 2d array with only 1 feature either works or returns\n    # informative message\n    rnd = np.random.RandomState(0)\n    X = 3 * rnd.uniform(size=(10, 1))\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    y = X[:, 0].astype(int)\n    estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if hasattr(estimator, \"n_components\"):\n        estimator.n_components = 1\n    if hasattr(estimator, \"n_clusters\"):\n        estimator.n_clusters = 1\n    # ensure two labels in subsample for RandomizedLogisticRegression\n    if name == \"RandomizedLogisticRegression\":\n        estimator.sample_fraction = 1\n    # ensure non skipped trials for RANSACRegressor\n    if name == \"RANSACRegressor\":\n        estimator.residual_threshold = 0.5\n\n    y = _enforce_estimator_tags_y(estimator, y)\n    set_random_state(estimator, 1)\n\n    msgs = [r\"1 feature\\(s\\)\", \"n_features = 1\", \"n_features=1\"]\n\n    with raises(ValueError, match=msgs, may_pass=True):\n        estimator.fit(X, y)\n\n\n@ignore_warnings\ndef check_fit1d(name, estimator_orig):\n    # check fitting 1d X array raises a ValueError\n    rnd = np.random.RandomState(0)\n    X = 3 * rnd.uniform(size=(20))\n    y = X.astype(int)\n    estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n\n    if hasattr(estimator, \"n_components\"):\n        estimator.n_components = 1\n    if hasattr(estimator, \"n_clusters\"):\n        estimator.n_clusters = 1\n\n    set_random_state(estimator, 1)\n    with raises(ValueError):\n        estimator.fit(X, y)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_transformer_general(name, transformer, readonly_memmap=False):\n    X, y = make_blobs(\n        n_samples=30,\n        centers=[[0, 0, 0], [1, 1, 1]],\n        random_state=0,\n        n_features=2,\n        cluster_std=0.1,\n    )\n    X = StandardScaler().fit_transform(X)\n    X = _enforce_estimator_tags_X(transformer, X)\n\n    if readonly_memmap:\n        X, y = create_memmap_backed_data([X, y])\n\n    _check_transformer(name, transformer, X, y)\n\n\n@ignore_warnings(category=FutureWarning)\ndef check_transformer_data_not_an_array(name, transformer):\n    X, y = make_blobs(\n        n_samples=30,\n        centers=[[0, 0, 0], [1, 1, 1]],\n        random_state=0,\n        n_features=2,\n        cluster_std=0.1,\n    )\n    X = StandardScaler().fit_transform(X)\n    X = _enforce_estimator_tags_X(transformer, X)\n    this_X = _NotAnArray(X)\n    this_y = _NotAnArray(np.asarray(y))\n    _check_transformer(name, transformer, this_X, this_y)\n    # try the same with some list\n    _check_transformer(name, transformer, X.tolist(), y.tolist())",
                        "filename": "sklearn/utils/estimator_checks.py",
                        "start_index": 55999,
                        "end_index": 58685,
                        "start_line": 181,
                        "end_line": 1729,
                        "max_line": 4639,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__1.3",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains checks for fitting estimators with different data shapes and could be relevant for ensuring the error message is consistent when `get_feature_names_out` is called before `fit`."
                }
            ]
        },
        "solution_task": "- Ensure that all estimators raise a `NotFittedError` with a consistent error message when `get_feature_names_out` is called before `fit`.\n- Modify the `get_feature_names_out` method in each estimator to check if the model is fitted by looking for attributes set in `fit` (e.g., `n_features_in_`).\n- If the model is not fitted, raise a `NotFittedError` with a message following a consistent format, such as: `\"This {estimator_name} instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\"`.\n- Use the provided template for the `get_feature_names_out` method to implement the changes in all relevant estimators.\n- Update the test suite `test_estimators` in `sklearn/tests/test_common.py` to include a check for the `NotFittedError` message consistency across estimators when calling `get_feature_names_out` before `fit`.\n- Ensure that the test `pytest -vsl sklearn/tests/test_common.py -k error_get_feature_names_out` passes after the modifications.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSES that are highly relevant, offering clear and comprehensive guidance or solutions for the described bug, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a clear and comprehensive plan to address the issue of inconsistent error messages when calling `get_feature_names_out` before `fit`. It suggests ensuring all estimators raise a `NotFittedError` with a consistent message, modifying the method to check for fitted attributes, raising the error with a consistent format, updating the test suite, and ensuring the test passes. The RESPONSE also provides relevant code snippets from the sklearn repository that can be used to implement and test the changes. This RESPONSE is highly actionable and directly addresses the problem described in the PROMPT, providing a near-complete solution. The only reason it does not score a 10 is that it does not explicitly mention the need to remove the estimator from the whitelist before running the test, which is a minor detail mentioned in the PROMPT.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711738736.5124202,
        "result": "- Ensure that all estimators raise a `NotFittedError` with a consistent error message when `get_feature_names_out` is called before `fit`.\n- Modify the `get_feature_names_out` method in each estimator to check if the model is fitted by looking for attributes set in `fit` (e.g., `n_features_in_`).\n- If the model is not fitted, raise a `NotFittedError` with a message following a consistent format, such as: `\"This {estimator_name} instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\"`.\n- Use the provided template for the `get_feature_names_out` method to implement the changes in all relevant estimators.\n- Update the test suite `test_estimators` in `sklearn/tests/test_common.py` to include a check for the `NotFittedError` message consistency across estimators when calling `get_feature_names_out` before `fit`.\n- Ensure that the test `pytest -vsl sklearn/tests/test_common.py -k error_get_feature_names_out` passes after the modifications.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__1.3/tree//sklearn/utils)- [Lines 4160 - 4207](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/estimator_checks.py#L4160-L4207)\n\n This snippet contains checks for the error message consistency when calling `get_feature_names_out` before `fit`, which is directly related to the issue. \n\n\n   - [Lines 3892 - 3980](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/estimator_checks.py#L3892-L3980)\n\n This snippet includes checks for the `check_is_fitted` method, which is relevant to the issue as it pertains to the behavior of estimators before and after fitting. \n\n\n   - [Lines 181 - 1729](https://github.com/testbed/scikit-learn__scikit-learn__1.3/blob//sklearn/utils/estimator_checks.py#L181-L1729)\n\n This snippet contains checks for fitting estimators with different data shapes and could be relevant for ensuring the error message is consistent when `get_feature_names_out` is called before `fit`.",
        "context_relevance": 0.8400000000000001,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT and answer the entire PROMPT completely to get a score of 10.\nSupporting Evidence: The RESPONSE provides a comprehensive and relevant solution to the issue described in the PROMPT. It addresses the need for uniform error messages across different estimators when `get_feature_names_out` is called before `fit`. The RESPONSE outlines a clear plan to ensure that all estimators raise a `NotFittedError` with a consistent message, suggests modifications to the `get_feature_names_out` method, and includes updating the test suite to check for message consistency. It also references the test command to ensure that the changes pass the existing tests. The RESPONSE is directly related to the issue at hand and provides actionable steps for resolution, which is in line with the entire PROMPT."
        },
        "qa_relevance": 1.0
    }
}