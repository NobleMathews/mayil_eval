{
    "id": "astropy__astropy-14439",
    "repo_name": "testbed/astropy__astropy__5.1",
    "task_id": 8375603229667220491,
    "title": "Regarding FITS standard definition for 'Jy/beam'",
    "body": "Astropy unit definition for Jy/beam currently exports it as 'beam-1 Jy'\r\n`from astropy import units as u`\r\n`(u.Jy/u.beam).to_string('FITS')`\r\n'beam-1 Jy'\r\n\r\nThis is contrary to how most radio astronomy packages define the unit. 'Jy/beam' seems to be the accepted convention. The space after beam-1 makes parsing needlessly cumbersome as well. Is this something that can be fixed? See related issues opened in SpectralCube and SoFiA2.\r\n\r\nhttps://github.com/radio-astro-tools/spectral-cube/issues/806\r\n\r\nhttps://github.com/SoFiA-Admin/SoFiA-2/issues/74\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__5.1.git",
    "requested_commit": "",
    "mayil_response": "- Locate the `to_string` method in the `Unit` class within the Astropy units module.\n- Modify the `to_string` method to ensure that when the 'FITS' format is specified, the unit string is formatted as `'Jy/beam'` instead of `'beam-1 Jy'`.\n- Ensure that the change respects the FITS standard and does not affect other unit representations in FITS format.\n- Add a unit test to cover the case `(u.Jy/u.beam).to_string('FITS')` to ensure it returns `'Jy/beam'`.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.1/tree//astropy) \u2192 [units](https://github.com/testbed/astropy__astropy__5.1/tree//astropy/units)- [Lines 699 - 904](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/equivalencies.py#L699-L904)\n\n This snippet directly deals with the conversion between 'Jy/beam' and 'Jy/steradian' units, which is at the core of the issue reported. \n\n\n   - [Lines 665 - 904](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/equivalencies.py#L665-L904)\n\n This snippet includes the conversion functions between 'Jy/beam' and 'K' (Kelvin), which may need to be reviewed to ensure consistency with the 'Jy/beam' unit representation. \n\n\n   - [Lines 327 - 664](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/equivalencies.py#L327-L664)\n\n This snippet defines the 'brightness_temperature' equivalency, which involves 'Jy/beam' units and may be relevant for understanding how the unit is used throughout the codebase.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.1/tree//astropy) \u2192 [units](https://github.com/testbed/astropy__astropy__5.1/tree//astropy/units)- [Lines 24 - 240](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/astrophys.py#L24-L240)\n\n This snippet defines the 'beam' unit in the astrophysics context, which is relevant to the issue since the problem is with the 'Jy/beam' unit representation.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0004969999999999999,
        "snippet_processor": 0.060770000000000005,
        "issue_star_creation": 0.030649999999999997,
        "issue_star_solver": 0.0659,
        "bouncer": 0.0239
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711736155.8309262,
        "relevant_snippets": [
            {
                "code": "factor_K = (astrophys.Jy / (2 * _si.k_B * nu**2 / _si.c**2)).to(si.K).value\n\n    if beam_area is not None:\n        beam = beam_area.to_value(si.sr)\n\n        def convert_Jy_to_K(x_jybm):\n            return x_jybm / beam / factor_Jy\n\n        def convert_K_to_Jy(x_K):\n            return x_K * beam / factor_K\n\n        return Equivalency(\n            [\n                (astrophys.Jy, si.K, convert_Jy_to_K, convert_K_to_Jy),\n                (astrophys.Jy / astrophys.beam, si.K, convert_Jy_to_K, convert_K_to_Jy),\n            ],\n            \"brightness_temperature\",\n            {\"frequency\": frequency, \"beam_area\": beam_area},\n        )\n    else:\n\n        def convert_JySr_to_K(x_jysr):\n            return x_jysr / factor_Jy\n\n        def convert_K_to_JySr(x_K):\n            return x_K / factor_K  # multiplied by 1x for 1 steradian\n\n        return Equivalency(\n            [(astrophys.Jy / si.sr, si.K, convert_JySr_to_K, convert_K_to_JySr)],\n            \"brightness_temperature\",\n            {\"frequency\": frequency, \"beam_area\": beam_area},\n        )",
                "filename": "astropy/units/equivalencies.py",
                "start_index": 22722,
                "end_index": 23773,
                "start_line": 665,
                "end_line": 904,
                "max_line": 908,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def beam_angular_area(beam_area):\n    \"\"\"\n    Convert between the ``beam`` unit, which is commonly used to express the area\n    of a radio telescope resolution element, and an area on the sky.\n    This equivalency also supports direct conversion between ``Jy/beam`` and\n    ``Jy/steradian`` units, since that is a common operation.\n\n    Parameters\n    ----------\n    beam_area : unit-like\n        The area of the beam in angular area units (e.g., steradians)\n        Must have angular area equivalent units.\n    \"\"\"\n    return Equivalency(\n        [\n            (astrophys.beam, Unit(beam_area)),\n            (astrophys.beam**-1, Unit(beam_area) ** -1),\n            (astrophys.Jy / astrophys.beam, astrophys.Jy / Unit(beam_area)),\n        ],\n        \"beam_angular_area\",\n        {\"beam_area\": beam_area},\n    )",
                "filename": "astropy/units/equivalencies.py",
                "start_index": 23776,
                "end_index": 24586,
                "start_line": 699,
                "end_line": 904,
                "max_line": 908,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "[\n        ([\"A\"], u.A, \"Ampere\"),\n        ([\"a\"], u.a, \"year\", [\"P\"]),\n        ([\"a0\"], _si.a0, \"Bohr radius\"),\n        ([\"al\"], u.lyr, \"Light year\", [\"c\", \"d\"]),\n        ([\"lyr\"], u.lyr, \"Light year\"),\n        ([\"alpha\"], _si.alpha, \"Fine structure constant\"),\n        (([\"AA\", \"\u00c5\"], [\"Angstrom\", \"Angstroem\"]), u.AA, \"Angstrom\"),\n        ([\"arcmin\", \"arcm\"], u.arcminute, \"minute of arc\"),\n        ([\"arcsec\", \"arcs\"], u.arcsecond, \"second of arc\"),\n        ([\"atm\"], _si.atm, \"atmosphere\"),\n        ([\"AU\", \"au\"], u.au, \"astronomical unit\"),\n        ([\"bar\"], u.bar, \"bar\"),\n        ([\"barn\"], u.barn, \"barn\"),\n        ([\"bit\"], u.bit, \"bit\"),\n        ([\"byte\"], u.byte, \"byte\"),\n        ([\"C\"], u.C, \"Coulomb\"),\n        ([\"c\"], _si.c, \"speed of light\", [\"p\"]),\n        ([\"cal\"], 4.1854 * u.J, \"calorie\"),\n        ([\"cd\"], u.cd, \"candela\"),\n        ([\"ct\"], u.ct, \"count\"),\n        ([\"D\"], u.D, \"Debye (dipole)\"),\n        ([\"d\"], u.d, \"Julian day\", [\"c\"]),\n        (([\"deg\", \"\u00b0\"], [\"degree\"]), u.degree, \"degree\"),\n        ([\"dyn\"], u.dyn, \"dyne\"),\n        ([\"e\"], _si.e, \"electron charge\", [\"m\"]),\n        ([\"eps0\"], _si.eps0, \"electric constant\"),\n        ([\"erg\"], u.erg, \"erg\"),\n        ([\"eV\"], u.eV, \"electron volt\"),\n        ([\"F\"], u.F, \"Farad\"),\n        ([\"G\"], _si.G, \"Gravitation constant\"),\n        ([\"g\"], u.g, \"gram\"),\n        ([\"gauss\"], u.G, \"Gauss\"),\n        ([\"geoMass\", \"Mgeo\"], u.M_earth, \"Earth mass\"),\n        ([\"H\"], u.H, \"Henry\"),\n        ([\"h\"], u.h, \"hour\", [\"p\"]),\n        ([\"hr\"], u.h, \"hour\"),\n        ([\"\\\\h\"], _si.h, \"Planck constant\"),\n        ([\"Hz\"], u.Hz, \"Hertz\"),\n        ([\"inch\"], 0.0254 * u.m, \"inch\"),\n        ([\"J\"], u.J, \"Joule\"),\n        ([\"JD\"], u.d, \"Julian day\", [\"M\"]),\n        ([\"jovMass\", \"Mjup\"], u.M_jup, \"Jupiter mass\"),\n        ([\"Jy\"], u.Jy, \"Jansky\"),\n        ([\"K\"], u.K, \"Kelvin\"),\n        ([\"k\"], _si.k_B, \"Boltzmann\"),\n        ([\"l\"], u.l, \"litre\", [\"a\"]),\n        ([\"lm\"], u.lm, \"lumen\"),\n        ([\"Lsun\", \"solLum\"], u.solLum, \"solar luminosity\"),\n        ([\"lx\"], u.lx, \"lux\"),\n        ([\"m\"], u.m, \"meter\"),\n        ([\"mag\"], u.mag, \"magnitude\"),\n        ([\"me\"], _si.m_e, \"electron mass\"),\n        ([\"min\"], u.minute, \"minute\"),\n        ([\"MJD\"], u.d, \"Julian day\"),\n        ([\"mmHg\"], 133.322387415 * u.Pa, \"millimeter of mercury\"),\n        ([\"mol\"], u.mol, \"mole\"),\n        ([\"mp\"], _si.m_p, \"proton mass\"),\n        ([\"Msun\", \"solMass\"], u.solMass, \"solar mass\"),\n        (([\"mu0\", \"\u00b50\"], []), _si.mu0, \"magnetic constant\"),\n        ([\"muB\"], _si.muB, \"Bohr magneton\"),\n        ([\"N\"], u.N, \"Newton\"),\n        ([\"Ohm\"], u.Ohm, \"Ohm\"),\n        ([\"Pa\"], u.Pa, \"Pascal\"),\n        ([\"pc\"], u.pc, \"parsec\"),\n        ([\"ph\"], u.ph, \"photon\"),\n        ([\"pi\"], u.Unit(np.pi), \"\u03c0\"),\n        ([\"pix\"], u.pix, \"pixel\"),\n        ([\"ppm\"], u.Unit(1e-6), \"parts per million\"),\n        ([\"R\"], _si.R, \"gas constant\"),\n        ([\"rad\"], u.radian, \"radian\"),\n        ([\"Rgeo\"], _si.R_earth, \"Earth equatorial radius\"),",
                "filename": "astropy/units/cds.py",
                "start_index": 1609,
                "end_index": 4581,
                "start_line": 43,
                "end_line": 119,
                "max_line": 196,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "elif ctype == \"BETA\":\n\n                def spectralcoord_from_beta(beta):\n                    if isinstance(beta, SpectralCoord):\n                        return beta\n                    return SpectralCoord(\n                        beta * C_SI,\n                        unit=u.m / u.s,\n                        doppler_convention=\"relativistic\",\n                        doppler_rest=self.wcs.restwav * u.m,\n                        observer=observer,\n                        target=target,\n                    )\n\n                def beta_from_spectralcoord(spectralcoord):\n                    # TODO: check target is consistent between WCS and SpectralCoord,\n                    # if they are not the transformation doesn't make conceptual sense.\n                    doppler_equiv = u.doppler_relativistic(self.wcs.restwav * u.m)\n                    if (\n                        observer is None\n                        or spectralcoord.observer is None\n                        or spectralcoord.target is None\n                    ):\n                        if observer is None:\n                            msg = \"No observer defined on WCS\"\n                        elif spectralcoord.observer is None:\n                            msg = \"No observer defined on SpectralCoord\"\n                        else:\n                            msg = \"No target defined on SpectralCoord\"\n                        warnings.warn(\n                            f\"{msg}, SpectralCoord \"\n                            \"will be converted without any velocity \"\n                            \"frame change\",\n                            AstropyUserWarning,\n                        )\n                        return spectralcoord.to_value(u.m / u.s, doppler_equiv) / C_SI\n                    else:\n                        return (\n                            spectralcoord.with_observer_stationary_relative_to(\n                                observer\n                            ).to_value(u.m / u.s, doppler_equiv)\n                            / C_SI\n                        )\n\n                classes[\"spectral\"] = (u.Quantity, (), {}, spectralcoord_from_beta)\n                components[self.wcs.spec] = (\"spectral\", 0, beta_from_spectralcoord)",
                "filename": "astropy/wcs/wcsapi/fitswcs.py",
                "start_index": 20918,
                "end_index": 23133,
                "start_line": 589,
                "end_line": 634,
                "max_line": 805,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "r\"\"\"\n    Defines the conversion between Jy/sr and \"brightness temperature\",\n    :math:`T_B`, in Kelvins.  The brightness temperature is a unit very\n    commonly used in radio astronomy.  See, e.g., \"Tools of Radio Astronomy\"\n    (Wilson 2009) eqn 8.16 and eqn 8.19 (these pages are available on `google\n    books\n    <https://books.google.com/books?id=9KHw6R8rQEMC&pg=PA179&source=gbs_toc_r&cad=4#v=onepage&q&f=false>`__).\n\n    :math:`T_B \\equiv S_\\nu / \\left(2 k \\nu^2 / c^2 \\right)`\n\n    If the input is in Jy/beam or Jy (assuming it came from a single beam), the\n    beam area is essential for this computation: the brightness temperature is\n    inversely proportional to the beam area.\n\n    Parameters\n    ----------\n    frequency : `~astropy.units.Quantity`\n        The observed ``spectral`` equivalent `~astropy.units.Unit` (e.g.,\n        frequency or wavelength).  The variable is named 'frequency' because it\n        is more commonly used in radio astronomy.\n        BACKWARD COMPATIBILITY NOTE: previous versions of the brightness\n        temperature equivalency used the keyword ``disp``, which is no longer\n        supported.\n    beam_area : `~astropy.units.Quantity` ['solid angle']\n        Beam area in angular units, i.e. steradian equivalent\n\n    Examples\n    --------\n    Arecibo C-band beam::\n\n        >>> import numpy as np\n        >>> from astropy import units as u\n        >>> beam_sigma = 50*u.arcsec\n        >>> beam_area = 2*np.pi*(beam_sigma)**2\n        >>> freq = 5*u.GHz\n        >>> equiv = u.brightness_temperature(freq)\n        >>> (1*u.Jy/beam_area).to(u.K, equivalencies=equiv)  # doctest: +FLOAT_CMP\n        <Quantity 3.526295144567176 K>\n\n    VLA synthetic beam::\n\n        >>> bmaj = 15*u.arcsec\n        >>> bmin = 15*u.arcsec\n        >>> fwhm_to_sigma = 1./(8*np.log(2))**0.5\n        >>> beam_area = 2.*np.pi*(bmaj*bmin*fwhm_to_sigma**2)\n        >>> freq = 5*u.GHz\n        >>> equiv = u.brightness_temperature(freq)\n        >>> (u.Jy/beam_area).to(u.K, equivalencies=equiv)  # doctest: +FLOAT_CMP\n        <Quantity 217.2658703625732 K>\n\n    Any generic surface brightness:\n\n        >>> surf_brightness = 1e6*u.MJy/u.sr\n        >>> surf_brightness.to(u.K, equivalencies=u.brightness_temperature(500*u.GHz)) # doctest: +FLOAT_CMP\n        <Quantity 130.1931904778803 K>\n    \"\"\"\n    if frequency.unit.is_equivalent(si.sr):\n        if not beam_area.unit.is_equivalent(si.Hz):\n            raise ValueError(\n                \"The inputs to `brightness_temperature` are frequency and angular area.\"\n            )\n        warnings.warn(\n            \"The inputs to `brightness_temperature` have changed. \"\n            \"Frequency is now the first input, and angular area \"\n            \"is the second, optional input.\",\n            AstropyDeprecationWarning,\n        )\n        frequency, beam_area = beam_area, frequency\n\n    nu = frequency.to(si.GHz, spectral())\n    factor_Jy = (2 * _si.k_B * si.K * nu**2 / _si.c**2).to(astrophys.Jy).value",
                "filename": "astropy/units/equivalencies.py",
                "start_index": 19755,
                "end_index": 22717,
                "start_line": 327,
                "end_line": 664,
                "max_line": 908,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "[\"uas\"],\n    0.000001 * arcsec,\n    namespace=_ns,\n    doc=\"micro arc second: angular measurement\",\n    format={\"latex\": r\"\\mu as\", \"unicode\": \"\u03bcas\"},\n)\ndef_unit(\n    [\"sr\", \"steradian\"],\n    rad**2,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"steradian: unit of solid angle in SI\",\n)\n\n\n###########################################################################\n# TIME\n\ndef_unit(\n    [\"s\", \"second\"],\n    namespace=_ns,\n    prefixes=True,\n    exclude_prefixes=[\"a\"],\n    doc=\"second: base unit of time in SI.\",\n)\ndef_unit(\n    [\"min\", \"minute\"],\n    60 * s,\n    prefixes=True,\n    namespace=_ns,\n)\ndef_unit(\n    [\"h\", \"hour\", \"hr\"],\n    3600 * s,\n    namespace=_ns,\n    prefixes=True,\n    exclude_prefixes=[\"p\"],\n)\ndef_unit(\n    [\"d\", \"day\"],\n    24 * h,\n    namespace=_ns,\n    prefixes=True,\n    exclude_prefixes=[\"c\", \"y\"],\n)\ndef_unit(\n    [\"sday\"],\n    86164.09053 * s,\n    namespace=_ns,\n    doc=\"Sidereal day (sday) is the time of one rotation of the Earth.\",\n)\ndef_unit(\n    [\"wk\", \"week\"],\n    7 * day,\n    namespace=_ns,\n)\ndef_unit(\n    [\"fortnight\"],\n    2 * wk,\n    namespace=_ns,\n)\ndef_unit(\n    [\"a\", \"annum\"],\n    365.25 * d,\n    namespace=_ns,\n    prefixes=True,\n    exclude_prefixes=[\"P\"],\n)\ndef_unit(\n    [\"yr\", \"year\"],\n    365.25 * d,\n    namespace=_ns,\n    prefixes=True,\n)\n\n\n###########################################################################\n# FREQUENCY\n\ndef_unit(\n    [\"Hz\", \"Hertz\", \"hertz\"],\n    1 / s,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Frequency\",\n)\n\n\n###########################################################################\n# MASS\n\ndef_unit(\n    [\"kg\", \"kilogram\"],\n    namespace=_ns,\n    doc=\"kilogram: base unit of mass in SI.\",\n)\ndef_unit(\n    [\"g\", \"gram\"],\n    1.0e-3 * kg,\n    namespace=_ns,\n    prefixes=True,\n    exclude_prefixes=[\"k\", \"kilo\"],\n)\ndef_unit(\n    [\"t\", \"tonne\"],\n    1000 * kg,\n    namespace=_ns,\n    doc=\"Metric tonne\",\n)\n\n\n###########################################################################\n# AMOUNT OF SUBSTANCE\n\ndef_unit(\n    [\"mol\", \"mole\"],\n    namespace=_ns,\n    prefixes=True,\n    doc=\"mole: amount of a chemical substance in SI.\",\n)\n\n\n###########################################################################\n# TEMPERATURE\n\ndef_unit(\n    [\"K\", \"Kelvin\"],\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Kelvin: temperature with a null point at absolute zero.\",\n)\ndef_unit(\n    [\"deg_C\", \"Celsius\"],\n    namespace=_ns,\n    doc=\"Degrees Celsius\",\n    format={\"latex\": r\"{}^{\\circ}C\", \"unicode\": \"\u00b0C\", \"fits\": \"Celsius\"},\n)\n\n\n###########################################################################\n# FORCE\n\ndef_unit(\n    [\"N\", \"Newton\", \"newton\"],\n    kg * m * s**-2,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Newton: force\",\n)\n\n\n##########################################################################\n# ENERGY\n\ndef_unit(\n    [\"J\", \"Joule\", \"joule\"],\n    N * m,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Joule: energy\",\n)\ndef_unit(",
                "filename": "astropy/units/si.py",
                "start_index": 2850,
                "end_index": 5789,
                "start_line": 120,
                "end_line": 421,
                "max_line": 452,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "_unit(\n    [\"Ry\", \"rydberg\"],\n    (_si.Ryd * _si.c * _si.h.to(si.eV * si.s)).to(si.eV),\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Rydberg: Energy of a photon whose wavenumber is the Rydberg constant\",\n    format={\"latex\": r\"R_{\\infty}\", \"unicode\": \"R\u221e\"},\n)\n\n###########################################################################\n# ILLUMINATION\n\ndef_unit(\n    [\"solLum\", \"L_sun\", \"Lsun\"],\n    _si.L_sun,\n    namespace=_ns,\n    prefixes=False,\n    doc=\"Solar luminance\",\n    format={\"latex\": r\"L_{\\odot}\", \"unicode\": \"L\\N{SUN}\"},\n)\n\n\n###########################################################################\n# SPECTRAL DENSITY\n\ndef_unit(\n    ([\"ph\", \"photon\"], [\"photon\"]),\n    format={\"ogip\": \"photon\", \"vounit\": \"photon\"},\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"Jy\", \"Jansky\", \"jansky\"],\n    1e-26 * si.W / si.m**2 / si.Hz,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Jansky: spectral flux density\",\n)\ndef_unit(\n    [\"R\", \"Rayleigh\", \"rayleigh\"],\n    (1e10 / (4 * _np.pi)) * ph * si.m**-2 * si.s**-1 * si.sr**-1,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Rayleigh: photon flux\",\n)\n\n\n###########################################################################\n# EVENTS\n\ndef_unit(\n    ([\"ct\", \"count\"], [\"count\"]),\n    format={\"fits\": \"count\", \"ogip\": \"count\", \"vounit\": \"count\"},\n    namespace=_ns,\n    prefixes=True,\n    exclude_prefixes=[\"p\"],\n)\ndef_unit(\n    [\"adu\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"DN\", \"dn\"],\n    namespace=_ns,\n    prefixes=False,\n)\n\n###########################################################################\n# MISCELLANEOUS\n\n# Some of these are very FITS-specific and perhaps considered a mistake.\n# Maybe they should be moved into the FITS format class?\n# TODO: This is defined by the FITS standard as \"relative to the sun\".\n# Is that mass, volume, what?\ndef_unit(\n    [\"Sun\"],\n    namespace=_ns,\n)\ndef_unit(\n    [\"chan\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"bin\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"beam\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"electron\"],\n    doc=\"Number of electrons\",\n    namespace=_ns,\n    format={\"latex\": r\"e^{-}\", \"unicode\": \"e\u207b\"},\n)\n\n###########################################################################\n# CLEANUP\n\ndel UnitBase\ndel def_unit\ndel si\n\n\n###########################################################################\n# DOCSTRING\n\nif __doc__ is not None:\n    # This generates a docstring for this module that describes all of the\n    # standard units defined here.\n    from .utils import generate_unit_summary as _generate_unit_summary\n\n    __doc__ += _generate_unit_summary(globals())\n\n\n# -------------------------------------------------------------------------\n\n\ndef _",
                "filename": "astropy/units/astrophys.py",
                "start_index": 2860,
                "end_index": 5617,
                "start_line": 24,
                "end_line": 240,
                "max_line": 256,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "([\"Rjup\"], _si.R_jup, \"Jupiter equatorial radius\"),\n        ([\"Rsun\", \"solRad\"], u.solRad, \"solar radius\"),\n        ([\"Ry\"], u.Ry, \"Rydberg\"),\n        ([\"S\"], u.S, \"Siemens\"),\n        ([\"s\", \"sec\"], u.s, \"second\"),\n        ([\"sr\"], u.sr, \"steradian\"),\n        ([\"Sun\"], u.Sun, \"solar unit\"),\n        ([\"T\"], u.T, \"Tesla\"),\n        ([\"t\"], 1e3 * u.kg, \"metric tonne\", [\"c\"]),\n        ([\"u\"], _si.u, \"atomic mass\", [\"da\", \"a\"]),\n        ([\"V\"], u.V, \"Volt\"),\n        ([\"W\"], u.W, \"Watt\"),\n        ([\"Wb\"], u.Wb, \"Weber\"),\n        ([\"yr\"], u.a, \"year\"),\n    ]",
                "filename": "astropy/units/cds.py",
                "start_index": 4590,
                "end_index": 5146,
                "start_line": 120,
                "end_line": 134,
                "max_line": 196,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def brightness_temperature(frequency, beam_area=None):",
                "filename": "astropy/units/equivalencies.py",
                "start_index": 19696,
                "end_index": 19750,
                "start_line": 593,
                "end_line": 593,
                "max_line": 908,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@property\n    def input_units(self):\n        # The input units are those of the 'x' value, which will depend on the\n        # units compatible with the expected output units.\n        if self._output_units.is_equivalent(self._native_output_units[\"SNU\"]):\n            return {self.inputs[0]: u.Hz}\n        else:\n            # only other option is equivalent with SLAM\n            return {self.inputs[0]: u.AA}\n\n    def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n        return {\"temperature\": u.K}\n\n    @property\n    def bolometric_flux(self):\n        \"\"\"Bolometric flux.\"\"\"\n        if self.scale.unit is not None:\n            # Will be dimensionless at this point, but may not be dimensionless_unscaled\n            scale = self.scale.quantity.to(u.dimensionless_unscaled)\n        else:\n            scale = self.scale.value\n\n        # bolometric flux in the native units of the planck function\n        native_bolflux = scale * const.sigma_sb * self.temperature**4 / np.pi\n        # return in more \"astro\" units\n        return native_bolflux.to(u.erg / (u.cm**2 * u.s))\n\n    @property\n    def lambda_max(self):\n        \"\"\"Peak wavelength when the curve is expressed as power density.\"\"\"\n        return const.b_wien / self.temperature\n\n    @property\n    def nu_max(self):\n        \"\"\"Peak frequency when the curve is expressed as power density.\"\"\"\n        return 2.8214391 * const.k_B * self.temperature / const.h",
                "filename": "astropy/modeling/physical_models.py",
                "start_index": 7547,
                "end_index": 8978,
                "start_line": 213,
                "end_line": 248,
                "max_line": 809,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.1",
                "sha": "",
                "context_relevance": 0.0
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "astropy/units/equivalencies.py": [
                {
                    "chunk": {
                        "code": "def beam_angular_area(beam_area):\n    \"\"\"\n    Convert between the ``beam`` unit, which is commonly used to express the area\n    of a radio telescope resolution element, and an area on the sky.\n    This equivalency also supports direct conversion between ``Jy/beam`` and\n    ``Jy/steradian`` units, since that is a common operation.\n\n    Parameters\n    ----------\n    beam_area : unit-like\n        The area of the beam in angular area units (e.g., steradians)\n        Must have angular area equivalent units.\n    \"\"\"\n    return Equivalency(\n        [\n            (astrophys.beam, Unit(beam_area)),\n            (astrophys.beam**-1, Unit(beam_area) ** -1),\n            (astrophys.Jy / astrophys.beam, astrophys.Jy / Unit(beam_area)),\n        ],\n        \"beam_angular_area\",\n        {\"beam_area\": beam_area},\n    )",
                        "filename": "astropy/units/equivalencies.py",
                        "start_index": 23776,
                        "end_index": 24586,
                        "start_line": 699,
                        "end_line": 904,
                        "max_line": 908,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet directly deals with the conversion between 'Jy/beam' and 'Jy/steradian' units, which is at the core of the issue reported."
                },
                {
                    "chunk": {
                        "code": "factor_K = (astrophys.Jy / (2 * _si.k_B * nu**2 / _si.c**2)).to(si.K).value\n\n    if beam_area is not None:\n        beam = beam_area.to_value(si.sr)\n\n        def convert_Jy_to_K(x_jybm):\n            return x_jybm / beam / factor_Jy\n\n        def convert_K_to_Jy(x_K):\n            return x_K * beam / factor_K\n\n        return Equivalency(\n            [\n                (astrophys.Jy, si.K, convert_Jy_to_K, convert_K_to_Jy),\n                (astrophys.Jy / astrophys.beam, si.K, convert_Jy_to_K, convert_K_to_Jy),\n            ],\n            \"brightness_temperature\",\n            {\"frequency\": frequency, \"beam_area\": beam_area},\n        )\n    else:\n\n        def convert_JySr_to_K(x_jysr):\n            return x_jysr / factor_Jy\n\n        def convert_K_to_JySr(x_K):\n            return x_K / factor_K  # multiplied by 1x for 1 steradian\n\n        return Equivalency(\n            [(astrophys.Jy / si.sr, si.K, convert_JySr_to_K, convert_K_to_JySr)],\n            \"brightness_temperature\",\n            {\"frequency\": frequency, \"beam_area\": beam_area},\n        )",
                        "filename": "astropy/units/equivalencies.py",
                        "start_index": 22722,
                        "end_index": 23773,
                        "start_line": 665,
                        "end_line": 904,
                        "max_line": 908,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the conversion functions between 'Jy/beam' and 'K' (Kelvin), which may need to be reviewed to ensure consistency with the 'Jy/beam' unit representation."
                },
                {
                    "chunk": {
                        "code": "r\"\"\"\n    Defines the conversion between Jy/sr and \"brightness temperature\",\n    :math:`T_B`, in Kelvins.  The brightness temperature is a unit very\n    commonly used in radio astronomy.  See, e.g., \"Tools of Radio Astronomy\"\n    (Wilson 2009) eqn 8.16 and eqn 8.19 (these pages are available on `google\n    books\n    <https://books.google.com/books?id=9KHw6R8rQEMC&pg=PA179&source=gbs_toc_r&cad=4#v=onepage&q&f=false>`__).\n\n    :math:`T_B \\equiv S_\\nu / \\left(2 k \\nu^2 / c^2 \\right)`\n\n    If the input is in Jy/beam or Jy (assuming it came from a single beam), the\n    beam area is essential for this computation: the brightness temperature is\n    inversely proportional to the beam area.\n\n    Parameters\n    ----------\n    frequency : `~astropy.units.Quantity`\n        The observed ``spectral`` equivalent `~astropy.units.Unit` (e.g.,\n        frequency or wavelength).  The variable is named 'frequency' because it\n        is more commonly used in radio astronomy.\n        BACKWARD COMPATIBILITY NOTE: previous versions of the brightness\n        temperature equivalency used the keyword ``disp``, which is no longer\n        supported.\n    beam_area : `~astropy.units.Quantity` ['solid angle']\n        Beam area in angular units, i.e. steradian equivalent\n\n    Examples\n    --------\n    Arecibo C-band beam::\n\n        >>> import numpy as np\n        >>> from astropy import units as u\n        >>> beam_sigma = 50*u.arcsec\n        >>> beam_area = 2*np.pi*(beam_sigma)**2\n        >>> freq = 5*u.GHz\n        >>> equiv = u.brightness_temperature(freq)\n        >>> (1*u.Jy/beam_area).to(u.K, equivalencies=equiv)  # doctest: +FLOAT_CMP\n        <Quantity 3.526295144567176 K>\n\n    VLA synthetic beam::\n\n        >>> bmaj = 15*u.arcsec\n        >>> bmin = 15*u.arcsec\n        >>> fwhm_to_sigma = 1./(8*np.log(2))**0.5\n        >>> beam_area = 2.*np.pi*(bmaj*bmin*fwhm_to_sigma**2)\n        >>> freq = 5*u.GHz\n        >>> equiv = u.brightness_temperature(freq)\n        >>> (u.Jy/beam_area).to(u.K, equivalencies=equiv)  # doctest: +FLOAT_CMP\n        <Quantity 217.2658703625732 K>\n\n    Any generic surface brightness:\n\n        >>> surf_brightness = 1e6*u.MJy/u.sr\n        >>> surf_brightness.to(u.K, equivalencies=u.brightness_temperature(500*u.GHz)) # doctest: +FLOAT_CMP\n        <Quantity 130.1931904778803 K>\n    \"\"\"\n    if frequency.unit.is_equivalent(si.sr):\n        if not beam_area.unit.is_equivalent(si.Hz):\n            raise ValueError(\n                \"The inputs to `brightness_temperature` are frequency and angular area.\"\n            )\n        warnings.warn(\n            \"The inputs to `brightness_temperature` have changed. \"\n            \"Frequency is now the first input, and angular area \"\n            \"is the second, optional input.\",\n            AstropyDeprecationWarning,\n        )\n        frequency, beam_area = beam_area, frequency\n\n    nu = frequency.to(si.GHz, spectral())\n    factor_Jy = (2 * _si.k_B * si.K * nu**2 / _si.c**2).to(astrophys.Jy).value",
                        "filename": "astropy/units/equivalencies.py",
                        "start_index": 19755,
                        "end_index": 22717,
                        "start_line": 327,
                        "end_line": 664,
                        "max_line": 908,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the 'brightness_temperature' equivalency, which involves 'Jy/beam' units and may be relevant for understanding how the unit is used throughout the codebase."
                }
            ],
            "astropy/units/astrophys.py": [
                {
                    "chunk": {
                        "code": "_unit(\n    [\"Ry\", \"rydberg\"],\n    (_si.Ryd * _si.c * _si.h.to(si.eV * si.s)).to(si.eV),\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Rydberg: Energy of a photon whose wavenumber is the Rydberg constant\",\n    format={\"latex\": r\"R_{\\infty}\", \"unicode\": \"R\u221e\"},\n)\n\n###########################################################################\n# ILLUMINATION\n\ndef_unit(\n    [\"solLum\", \"L_sun\", \"Lsun\"],\n    _si.L_sun,\n    namespace=_ns,\n    prefixes=False,\n    doc=\"Solar luminance\",\n    format={\"latex\": r\"L_{\\odot}\", \"unicode\": \"L\\N{SUN}\"},\n)\n\n\n###########################################################################\n# SPECTRAL DENSITY\n\ndef_unit(\n    ([\"ph\", \"photon\"], [\"photon\"]),\n    format={\"ogip\": \"photon\", \"vounit\": \"photon\"},\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"Jy\", \"Jansky\", \"jansky\"],\n    1e-26 * si.W / si.m**2 / si.Hz,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Jansky: spectral flux density\",\n)\ndef_unit(\n    [\"R\", \"Rayleigh\", \"rayleigh\"],\n    (1e10 / (4 * _np.pi)) * ph * si.m**-2 * si.s**-1 * si.sr**-1,\n    namespace=_ns,\n    prefixes=True,\n    doc=\"Rayleigh: photon flux\",\n)\n\n\n###########################################################################\n# EVENTS\n\ndef_unit(\n    ([\"ct\", \"count\"], [\"count\"]),\n    format={\"fits\": \"count\", \"ogip\": \"count\", \"vounit\": \"count\"},\n    namespace=_ns,\n    prefixes=True,\n    exclude_prefixes=[\"p\"],\n)\ndef_unit(\n    [\"adu\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"DN\", \"dn\"],\n    namespace=_ns,\n    prefixes=False,\n)\n\n###########################################################################\n# MISCELLANEOUS\n\n# Some of these are very FITS-specific and perhaps considered a mistake.\n# Maybe they should be moved into the FITS format class?\n# TODO: This is defined by the FITS standard as \"relative to the sun\".\n# Is that mass, volume, what?\ndef_unit(\n    [\"Sun\"],\n    namespace=_ns,\n)\ndef_unit(\n    [\"chan\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"bin\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"beam\"],\n    namespace=_ns,\n    prefixes=True,\n)\ndef_unit(\n    [\"electron\"],\n    doc=\"Number of electrons\",\n    namespace=_ns,\n    format={\"latex\": r\"e^{-}\", \"unicode\": \"e\u207b\"},\n)\n\n###########################################################################\n# CLEANUP\n\ndel UnitBase\ndel def_unit\ndel si\n\n\n###########################################################################\n# DOCSTRING\n\nif __doc__ is not None:\n    # This generates a docstring for this module that describes all of the\n    # standard units defined here.\n    from .utils import generate_unit_summary as _generate_unit_summary\n\n    __doc__ += _generate_unit_summary(globals())\n\n\n# -------------------------------------------------------------------------\n\n\ndef _",
                        "filename": "astropy/units/astrophys.py",
                        "start_index": 2860,
                        "end_index": 5617,
                        "start_line": 24,
                        "end_line": 240,
                        "max_line": 256,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the 'beam' unit in the astrophysics context, which is relevant to the issue since the problem is with the 'Jy/beam' unit representation."
                }
            ]
        },
        "solution_task": "- Locate the `to_string` method in the `Unit` class within the Astropy units module.\n- Modify the `to_string` method to ensure that when the 'FITS' format is specified, the unit string is formatted as `'Jy/beam'` instead of `'beam-1 Jy'`.\n- Ensure that the change respects the FITS standard and does not affect other unit representations in FITS format.\n- Add a unit test to cover the case `(u.Jy/u.beam).to_string('FITS')` to ensure it returns `'Jy/beam'`.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable step-by-step guide to address the issue with the 'Jy/beam' unit representation in the Astropy library. It suggests locating and modifying the 'to_string' method in the 'Unit' class to ensure the correct format is used when converting to the 'FITS' format. The RESPONSE also correctly identifies the need to respect the FITS standard and to avoid affecting other unit representations, which is crucial for maintaining the integrity of the library. Additionally, the RESPONSE advises adding a unit test to verify the fix, which is a best practice in software development. The provided code snippets are relevant and would likely be the areas of the codebase that need to be reviewed and potentially modified to resolve the issue. The RESPONSE is comprehensive and would be very useful to a developer tasked with fixing this bug.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711736273.342025,
        "result": "- Locate the `to_string` method in the `Unit` class within the Astropy units module.\n- Modify the `to_string` method to ensure that when the 'FITS' format is specified, the unit string is formatted as `'Jy/beam'` instead of `'beam-1 Jy'`.\n- Ensure that the change respects the FITS standard and does not affect other unit representations in FITS format.\n- Add a unit test to cover the case `(u.Jy/u.beam).to_string('FITS')` to ensure it returns `'Jy/beam'`.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.1/tree//astropy) \u2192 [units](https://github.com/testbed/astropy__astropy__5.1/tree//astropy/units)- [Lines 699 - 904](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/equivalencies.py#L699-L904)\n\n This snippet directly deals with the conversion between 'Jy/beam' and 'Jy/steradian' units, which is at the core of the issue reported. \n\n\n   - [Lines 665 - 904](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/equivalencies.py#L665-L904)\n\n This snippet includes the conversion functions between 'Jy/beam' and 'K' (Kelvin), which may need to be reviewed to ensure consistency with the 'Jy/beam' unit representation. \n\n\n   - [Lines 327 - 664](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/equivalencies.py#L327-L664)\n\n This snippet defines the 'brightness_temperature' equivalency, which involves 'Jy/beam' units and may be relevant for understanding how the unit is used throughout the codebase.\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.1/tree//astropy) \u2192 [units](https://github.com/testbed/astropy__astropy__5.1/tree//astropy/units)- [Lines 24 - 240](https://github.com/testbed/astropy__astropy__5.1/blob//astropy/units/astrophys.py#L24-L240)\n\n This snippet defines the 'beam' unit in the astrophysics context, which is relevant to the issue since the problem is with the 'Jy/beam' unit representation.",
        "context_relevance": 0.18,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed action plan to address the issue raised in the PROMPT, which is the incorrect formatting of 'Jy/beam' in the Astropy library. It suggests code modifications, adherence to the FITS standard, and the addition of a unit test. The RESPONSE also references specific code snippets in the Astropy repository that are relevant to the issue, demonstrating a thorough understanding of the problem and its context within the codebase. The RESPONSE is directly related to the concerns about the FITS standard definition for 'Jy/beam' and the related issues in SpectralCube and SoFiA2, making it highly relevant to the entire PROMPT."
        },
        "qa_relevance": 1.0
    }
}