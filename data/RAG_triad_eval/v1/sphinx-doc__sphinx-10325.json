{
    "id": "sphinx-doc__sphinx-10325",
    "repo_name": "testbed/sphinx-doc__sphinx__5.0",
    "task_id": 4366659913234867900,
    "title": "inherited-members should support more than one class",
    "body": "**Is your feature request related to a problem? Please describe.**\r\nI have two situations:\r\n- A class inherits from multiple other classes. I want to document members from some of the base classes but ignore some of the base classes\r\n- A module contains several class definitions that inherit from different classes that should all be ignored (e.g., classes that inherit from list or set or tuple). I want to ignore members from list, set, and tuple while documenting all other inherited members in classes in the module.\r\n\r\n**Describe the solution you'd like**\r\nThe :inherited-members: option to automodule should accept a list of classes. If any of these classes are encountered as base classes when instantiating autoclass documentation, they should be ignored.\r\n\r\n**Describe alternatives you've considered**\r\nThe alternative is to not use automodule, but instead manually enumerate several autoclass blocks for a module. This only addresses the second bullet in the problem description and not the first. It is also tedious for modules containing many class definitions.\r\n\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__5.0.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature where `:inherited-members:` option in Sphinx's `automodule` directive supports ignoring specific base classes, you can follow these steps:\n\n- Modify the `get_class_members` function to filter out members from the specified base classes.\n- Add a configuration option to specify the classes to be ignored.\n- Update the `skip_member` function to use the new configuration option.\n\nHere's a high-level overview of the changes:\n\n1. Add a new configuration option in `conf.py`:\n```python\n# conf.py\nautodoc_inherited_member_ignore = ['list', 'set', 'tuple']  # Example classes to ignore\n```\n\n2. Modify the `get_class_members` function in `generate.py` to check against the new configuration option and skip the specified base classes:\n```python\ndef get_class_members(obj: Any) -> dict[str, Any]:\n    members = sphinx.ext.autodoc.get_class_members(obj, [qualname], safe_getattr)\n    ignored_bases = app.config.autodoc_inherited_member_ignore  # Retrieve the new config option\n    filtered_members = {}\n    for name, member in members.items():\n        if not any(base.__name__ in ignored_bases for base in inspect.getmro(member.object)):\n            filtered_members[name] = member.object\n    return filtered_members\n```\n\n3. Update the `skip_member` function to use the new configuration option if the object type is a class:\n```python\ndef skip_member(obj: Any, name: str, objtype: str) -> bool:\n    if objtype == 'class':\n        ignored_bases = app.config.autodoc_inherited_member_ignore\n        if any(base.__name__ in ignored_bases for base in inspect.getmro(obj)):\n            return True\n    # ... existing code ...\n```\n\n4. Ensure that the new configuration option is properly documented and that users are aware of how to use it.\n\nThis is a high-level overview, and the actual implementation may require additional error handling and integration with the rest of the Sphinx codebase. The provided code snippets are meant to guide the implementation and may need to be adapted to fit the actual code structure and style of the Sphinx project.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__5.0/tree//sphinx) \u2192 [ext](https://github.com/testbed/sphinx-doc__sphinx__5.0/tree//sphinx/ext) \u2192 [autosummary](https://github.com/testbed/sphinx-doc__sphinx__5.0/tree//sphinx/ext/autosummary)- [Lines 231 - 329](https://github.com/testbed/sphinx-doc__sphinx__5.0/blob//sphinx/ext/autosummary/generate.py#L231-L329)\n\n This snippet contains the logic for determining which members to document in autosummary, which is relevant to the issue of filtering inherited members from specific classes. \n\n\n   - [Lines 152 - 222](https://github.com/testbed/sphinx-doc__sphinx__5.0/blob//sphinx/ext/autosummary/generate.py#L152-L222)\n\n This snippet is part of the autosummary generation process and includes logic for skipping members, which could be relevant when considering how to handle inherited members from specific classes.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0012189999999999998,
        "snippet_processor": 0.07866000000000001,
        "issue_star_creation": 0.04956,
        "issue_star_solver": 0.07722,
        "bouncer": 0.04662
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711701504.0324428,
        "relevant_snippets": [
            {
                "code": "doc = get_documenter(app, obj, parent)\n\n    def skip_member(obj: Any, name: str, objtype: str) -> bool:\n        try:\n            return app.emit_firstresult('autodoc-skip-member', objtype, name,\n                                        obj, False, {})\n        except Exception as exc:\n            logger.warning(__('autosummary: failed to determine %r to be documented, '\n                              'the following exception was raised:\\n%s'),\n                           name, exc, type='autosummary')\n            return False\n\n    def get_class_members(obj: Any) -> dict[str, Any]:\n        members = sphinx.ext.autodoc.get_class_members(obj, [qualname], safe_getattr)\n        return {name: member.object for name, member in members.items()}\n\n    def get_module_members(obj: Any) -> dict[str, Any]:\n        members = {}\n        for name in members_of(obj, app.config):\n            try:\n                members[name] = safe_getattr(obj, name)\n            except AttributeError:\n                continue\n        return members\n\n    def get_all_members(obj: Any) -> dict[str, Any]:\n        if doc.objtype == \"module\":\n            return get_module_members(obj)\n        elif doc.objtype == \"class\":\n            return get_class_members(obj)\n        return {}\n\n    def get_members(obj: Any, types: set[str], include_public: list[str] = [],\n                    imported: bool = True) -> tuple[list[str], list[str]]:\n        items: list[str] = []\n        public: list[str] = []\n\n        all_members = get_all_members(obj)\n        for name, value in all_members.items():\n            documenter = get_documenter(app, value, obj)\n            if documenter.objtype in types:\n                # skip imported members if expected\n                if imported or getattr(value, '__module__', None) == obj.__name__:\n                    skipped = skip_member(value, name, documenter.objtype)\n                    if skipped is True:\n                        pass\n                    elif skipped is False:\n                        # show the member forcedly\n                        items.append(name)\n                        public.append(name)\n                    else:\n                        items.append(name)\n                        if name in include_public or not name.startswith('_'):\n                            # considers member as public\n                            public.append(name)\n        return public, items",
                "filename": "sphinx/ext/autosummary/generate.py",
                "start_index": 7690,
                "end_index": 10096,
                "start_line": 231,
                "end_line": 329,
                "max_line": 704,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "for name, obj in inspect.getmembers(mod):\n                # diverse module attributes are ignored:\n                if name[0] == '_':\n                    # begins in an underscore\n                    continue\n                if not hasattr(obj, '__module__'):\n                    # cannot be attributed to a module\n                    continue\n                if obj.__module__ != mod_name:\n                    # is not defined in this module\n                    continue\n\n                full_name = f'{mod_name}.{name}'\n                if self.ignore_pyobj(full_name):\n                    continue\n\n                if inspect.isfunction(obj):\n                    if full_name not in objects:\n                        for exp in self.fun_ignorexps:\n                            if exp.match(name):\n                                break\n                        else:\n                            if skip_undoc and not obj.__doc__:\n                                continue\n                            funcs.append(name)\n                elif inspect.isclass(obj):\n                    for exp in self.cls_ignorexps:\n                        if exp.match(name):\n                            break\n                    else:\n                        if full_name not in objects:\n                            if skip_undoc and not obj.__doc__:\n                                continue\n                            # not documented at all\n                            classes[name] = []\n                            continue\n\n                        attrs: list[str] = []\n\n                        for attr_name in dir(obj):\n                            if attr_name not in obj.__dict__:\n                                continue\n                            try:\n                                attr = safe_getattr(obj, attr_name)\n                            except AttributeError:\n                                continue\n                            if not (inspect.ismethod(attr) or\n                                    inspect.isfunction(attr)):\n                                continue\n                            if attr_name[0] == '_':\n                                # starts with an underscore, ignore it\n                                continue\n                            if skip_undoc and not attr.__doc__:\n                                # skip methods without docstring if wished\n                                continue\n                            full_attr_name = f'{full_name}.{attr_name}'\n                            if self.ignore_pyobj(full_attr_name):\n                                continue\n                            if full_attr_name not in objects:\n                                attrs.append(attr_name)\n                        if attrs:\n                            # some attributes are undocumented\n                            classes[name] = attrs\n\n            self.py_undoc[mod_name] = {'funcs': funcs, 'classes': classes}",
                "filename": "sphinx/ext/coverage.py",
                "start_index": 6188,
                "end_index": 9119,
                "start_line": 163,
                "end_line": 227,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "r\"\"\"Defines a docutils directive for inserting inheritance diagrams.\n\nProvide the directive with one or more classes or modules (separated\nby whitespace).  For modules, all of the classes in that module will\nbe used.\n\nExample::\n\n   Given the following classes:\n\n   class A: pass\n   class B(A): pass\n   class C(A): pass\n   class D(B, C): pass\n   class E(B): pass\n\n   .. inheritance-diagram: D E\n\n   Produces a graph like the following:\n\n               A\n              / \\\n             B   C\n            / \\ /\n           E   D\n\nThe graph is inserted as a PNG+image map into HTML and a PDF in\nLaTeX.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport builtins\nimport inspect\nimport re\nfrom importlib import import_module\nfrom typing import Any, Iterable, cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Node\nfrom docutils.parsers.rst import directives\n\nimport sphinx\nfrom sphinx import addnodes\nfrom sphinx.application import Sphinx\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.ext.graphviz import (\n    figure_wrapper,\n    graphviz,\n    render_dot_html,\n    render_dot_latex,\n    render_dot_texinfo,\n)\nfrom sphinx.util import md5\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.util.typing import OptionSpec\nfrom sphinx.writers.html import HTML5Translator\nfrom sphinx.writers.latex import LaTeXTranslator\nfrom sphinx.writers.texinfo import TexinfoTranslator\n\nmodule_sig_re = re.compile(r'''^(?:([\\w.]*)\\.)?  # module names\n                           (\\w+)  \\s* $          # class/final module name\n                           ''', re.VERBOSE)\n\n\npy_builtins = [obj for obj in vars(builtins).values()\n               if inspect.isclass(obj)]\n\n\ndef try_import(objname: str) -> Any:\n    \"\"\"Import a object or module using *name* and *currentmodule*.\n    *name* should be a relative name from *currentmodule* or\n    a fully-qualified name.\n\n    Returns imported object or module.  If failed, returns None value.\n    \"\"\"\n    try:\n        return import_module(objname)\n    except TypeError:\n        # Relative import\n        return None\n    except ImportError:\n        matched = module_sig_re.match(objname)\n\n        if not matched:\n            return None\n\n        modname, attrname = matched.groups()\n\n        if modname is None:\n            return None\n        try:\n            module = import_module(modname)\n            return getattr(module, attrname, None)\n        except ImportError:\n            return None",
                "filename": "sphinx/ext/inheritance_diagram.py",
                "start_index": 0,
                "end_index": 2441,
                "start_line": 1,
                "end_line": 96,
                "max_line": 479,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n    Given a list of classes, determines the set of classes that they inherit\n    from all the way to the root \"object\", and then is able to generate a\n    graphviz dot graph from them.\n    \"\"\"\n    def __init__(self, class_names: list[str], currmodule: str, show_builtins: bool = False,\n                 private_bases: bool = False, parts: int = 0,\n                 aliases: dict[str, str] | None = None, top_classes: list[Any] = [],\n                 ) -> None:\n        \"\"\"*class_names* is a list of child classes to show bases from.\n\n        If *show_builtins* is True, then Python builtins will be shown\n        in the graph.\n        \"\"\"\n        self.class_names = class_names\n        classes = self._import_classes(class_names, currmodule)\n        self.class_info = self._class_info(classes, show_builtins,\n                                           private_bases, parts, aliases, top_classes)\n        if not self.class_info:\n            raise InheritanceException('No classes found for '\n                                       'inheritance diagram')\n\n    def _import_classes(self, class_names: list[str], currmodule: str) -> list[Any]:\n        \"\"\"Import a list of classes.\"\"\"\n        classes: list[Any] = []\n        for name in class_names:\n            classes.extend(import_classes(name, currmodule))\n        return classes",
                "filename": "sphinx/ext/inheritance_diagram.py",
                "start_index": 3604,
                "end_index": 4935,
                "start_line": 1,
                "end_line": 162,
                "max_line": 479,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if undoc['classes']:\n                        op.write('Classes:\\n')\n                        for class_name, methods in sorted(\n                                undoc['classes'].items()):\n                            if not methods:\n                                op.write(' * %s\\n' % class_name)\n                                if self.config.coverage_show_missing_items:\n                                    if self.app.quiet or self.app.warningiserror:\n                                        logger.warning(\n                                            __('undocumented python class: %s :: %s'),\n                                            name, class_name)\n                                    else:\n                                        logger.info(red('undocumented  ') + 'py  ' +\n                                                    'class     ' + '%-30s' % class_name +\n                                                    red(' - in module ') + name)\n                            else:\n                                op.write(' * %s -- missing methods:\\n\\n' % class_name)\n                                op.writelines('   - %s\\n' % x for x in methods)\n                                if self.config.coverage_show_missing_items:\n                                    if self.app.quiet or self.app.warningiserror:\n                                        for meth in methods:\n                                            logger.warning(\n                                                __('undocumented python method:' +\n                                                   ' %s :: %s :: %s'),\n                                                name, class_name, meth)\n                                    else:\n                                        for meth in methods:\n                                            logger.info(red('undocumented  ') + 'py  ' +\n                                                        'method    ' + '%-30s' %\n                                                        (class_name + '.' + meth) +\n                                                        red(' - in module ') + name)\n                        op.write('\\n')",
                "filename": "sphinx/ext/coverage.py",
                "start_index": 10707,
                "end_index": 12849,
                "start_line": 259,
                "end_line": 290,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "ignore = False\n            for exp in self.mod_ignorexps:\n                if exp.match(mod_name):\n                    ignore = True\n                    break\n            if ignore or self.ignore_pyobj(mod_name):\n                continue\n\n            try:\n                mod = import_module(mod_name)\n            except ImportError as err:\n                logger.warning(__('module %s could not be imported: %s'), mod_name, err)\n                self.py_undoc[mod_name] = {'error': err}\n                continue\n\n            funcs = []\n            classes: dict[str, list[str]] = {}",
                "filename": "sphinx/ext/coverage.py",
                "start_index": 5593,
                "end_index": 6174,
                "start_line": 145,
                "end_line": 161,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n    Description of a general Python object.\n\n    :cvar allow_nesting: Class is an object that allows for nested namespaces\n    :vartype allow_nesting: bool\n    \"\"\"\n    option_spec: OptionSpec = {\n        'noindex': directives.flag,\n        'noindexentry': directives.flag,\n        'nocontentsentry': directives.flag,\n        'module': directives.unchanged,\n        'canonical': directives.unchanged,\n        'annotation': directives.unchanged,\n    }\n\n    doc_field_types = [\n        PyTypedField('parameter', label=_('Parameters'),\n                     names=('param', 'parameter', 'arg', 'argument',\n                            'keyword', 'kwarg', 'kwparam'),\n                     typerolename='class', typenames=('paramtype', 'type'),\n                     can_collapse=True),\n        PyTypedField('variable', label=_('Variables'),\n                     names=('var', 'ivar', 'cvar'),\n                     typerolename='class', typenames=('vartype',),\n                     can_collapse=True),\n        PyGroupedField('exceptions', label=_('Raises'), rolename='exc',\n                       names=('raises', 'raise', 'exception', 'except'),\n                       can_collapse=True),\n        Field('returnvalue', label=_('Returns'), has_arg=False,\n              names=('returns', 'return')),\n        PyField('returntype', label=_('Return type'), has_arg=False,\n                names=('rtype',), bodyrolename='class'),\n    ]\n\n    allow_nesting = False\n\n    def get_signature_prefix(self, sig: str) -> list[nodes.Node]:\n        \"\"\"May return a prefix to put before the object name in the\n        signature.\n        \"\"\"\n        return []\n\n    def needs_arglist(self) -> bool:\n        \"\"\"May return true if an empty argument list is to be generated even if\n        the document contains none.\n        \"\"\"\n        return False",
                "filename": "sphinx/domains/python.py",
                "start_index": 17615,
                "end_index": 19437,
                "start_line": 1,
                "end_line": 915,
                "max_line": 1517,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class TypeAliasForwardRef:\n    \"\"\"Pseudo typing class for autodoc_type_aliases.\n\n    This avoids the error on evaluating the type inside `get_type_hints()`.\n    \"\"\"\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n    def __call__(self) -> None:\n        # Dummy method to imitate special typing classes\n        pass\n\n    def __eq__(self, other: Any) -> bool:\n        return self.name == other\n\n    def __hash__(self) -> int:\n        return hash(self.name)\n\n    def __repr__(self) -> str:\n        return self.name\n\n\nclass TypeAliasModule:\n    \"\"\"Pseudo module class for autodoc_type_aliases.\"\"\"\n\n    def __init__(self, modname: str, mapping: dict[str, str]) -> None:\n        self.__modname = modname\n        self.__mapping = mapping\n\n        self.__module: ModuleType | None = None\n\n    def __getattr__(self, name: str) -> Any:\n        fullname = '.'.join(filter(None, [self.__modname, name]))\n        if fullname in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[fullname])\n        else:\n            prefix = fullname + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(fullname, nested)\n            else:\n                # no sub modules or classes found.\n                try:\n                    # return the real submodule if exists\n                    return import_module(fullname)\n                except ImportError:\n                    # return the real class\n                    if self.__module is None:\n                        self.__module = import_module(self.__modname)\n\n                    return getattr(self.__module, name)\n\n\nclass TypeAliasNamespace(Dict[str, Any]):\n    \"\"\"Pseudo namespace class for autodoc_type_aliases.\n\n    This enables to look up nested modules and classes like `mod1.mod2.Class`.\n    \"\"\"\n\n    def __init__(self, mapping: dict[str, str]) -> None:\n        self.__mapping = mapping\n\n    def __getitem__(self, key: str) -> Any:\n        if key in self.__mapping:\n            # exactly matched\n            return TypeAliasForwardRef(self.__mapping[key])\n        else:\n            prefix = key + '.'\n            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}\n            if nested:\n                # sub modules or classes found\n                return TypeAliasModule(key, nested)\n            else:\n                raise KeyError\n\n\ndef _should_unwrap(subject: Callable) -> bool:\n    \"\"\"Check the function should be unwrapped on getting signature.\"\"\"\n    __globals__ = getglobals(subject)\n    if (__globals__.get('__name__') == 'contextlib' and\n            __globals__.get('__file__') == contextlib.__file__):\n        # contextmanger should be unwrapped\n        return True\n\n    return False",
                "filename": "sphinx/util/inspect.py",
                "start_index": 13767,
                "end_index": 16641,
                "start_line": 436,
                "end_line": 522,
                "max_line": 817,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class ModuleScanner:\n    def __init__(self, app: Any, obj: Any) -> None:\n        self.app = app\n        self.object = obj\n\n    def get_object_type(self, name: str, value: Any) -> str:\n        return get_documenter(self.app, value, self.object).objtype\n\n    def is_skipped(self, name: str, value: Any, objtype: str) -> bool:\n        try:\n            return self.app.emit_firstresult('autodoc-skip-member', objtype,\n                                             name, value, False, {})\n        except Exception as exc:\n            logger.warning(__('autosummary: failed to determine %r to be documented, '\n                              'the following exception was raised:\\n%s'),\n                           name, exc, type='autosummary')\n            return False\n\n    def scan(self, imported_members: bool) -> list[str]:\n        members = []\n        try:\n            analyzer = ModuleAnalyzer.for_module(self.object.__name__)\n            attr_docs = analyzer.find_attr_docs()\n        except PycodeError:\n            attr_docs = {}\n\n        for name in members_of(self.object, self.app.config):\n            try:\n                value = safe_getattr(self.object, name)\n            except AttributeError:\n                value = None\n\n            objtype = self.get_object_type(name, value)\n            if self.is_skipped(name, value, objtype):\n                continue\n\n            try:\n                if ('', name) in attr_docs:\n                    imported = False\n                elif inspect.ismodule(value):  # NoQA: SIM114\n                    imported = True\n                elif safe_getattr(value, '__module__') != self.object.__name__:\n                    imported = True\n                else:\n                    imported = False\n            except AttributeError:\n                imported = False\n\n            respect_module_all = not self.app.config.autosummary_ignore_module_all\n            if (\n                # list all members up\n                imported_members\n                # list not-imported members\n                or imported is False\n                # list members that have __all__ set\n                or (respect_module_all and '__all__' in dir(self.object))\n            ):\n                members.append(name)\n\n        return members\n\n\ndef members_of(obj: Any, conf: Config) -> Sequence[str]:\n    \"\"\"Get the members of ``obj``, possibly ignoring the ``__all__`` module attribute\n\n    Follows the ``conf.autosummary_ignore_module_all`` setting.\"\"\"\n\n    if conf.autosummary_ignore_module_all:\n        return dir(obj)\n    else:\n        return getall(obj) or dir(obj)",
                "filename": "sphinx/ext/autosummary/generate.py",
                "start_index": 4680,
                "end_index": 7269,
                "start_line": 152,
                "end_line": 222,
                "max_line": 704,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if name != '__weakref__' and has_doc and is_member:\n        cls_is_owner = False\n        if what in ('class', 'exception'):\n            qualname = getattr(obj, '__qualname__', '')\n            cls_path, _, _ = qualname.rpartition('.')\n            if cls_path:\n                try:\n                    if '.' in cls_path:\n                        import functools\n                        import importlib\n\n                        mod = importlib.import_module(obj.__module__)\n                        mod_path = cls_path.split('.')\n                        cls = functools.reduce(getattr, mod_path, mod)\n                    else:\n                        cls = inspect.unwrap(obj).__globals__[cls_path]\n                except Exception:\n                    cls_is_owner = False\n                else:\n                    cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore\n                                    name in cls.__dict__)\n            else:\n                cls_is_owner = False\n\n        if what == 'module' or cls_is_owner:\n            is_init = (name == '__init__')\n            is_special = (not is_init and name.startswith('__') and\n                          name.endswith('__'))\n            is_private = (not is_init and not is_special and\n                          name.startswith('_'))\n            inc_init = app.config.napoleon_include_init_with_doc\n            inc_special = app.config.napoleon_include_special_with_doc\n            inc_private = app.config.napoleon_include_private_with_doc\n            if ((is_special and inc_special) or\n                    (is_private and inc_private) or\n                    (is_init and inc_init)):\n                return False\n    return None",
                "filename": "sphinx/ext/napoleon/__init__.py",
                "start_index": 16236,
                "end_index": 17935,
                "start_line": 437,
                "end_line": 474,
                "max_line": 474,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "sphinx/ext/autosummary/generate.py": [
                {
                    "chunk": {
                        "code": "doc = get_documenter(app, obj, parent)\n\n    def skip_member(obj: Any, name: str, objtype: str) -> bool:\n        try:\n            return app.emit_firstresult('autodoc-skip-member', objtype, name,\n                                        obj, False, {})\n        except Exception as exc:\n            logger.warning(__('autosummary: failed to determine %r to be documented, '\n                              'the following exception was raised:\\n%s'),\n                           name, exc, type='autosummary')\n            return False\n\n    def get_class_members(obj: Any) -> dict[str, Any]:\n        members = sphinx.ext.autodoc.get_class_members(obj, [qualname], safe_getattr)\n        return {name: member.object for name, member in members.items()}\n\n    def get_module_members(obj: Any) -> dict[str, Any]:\n        members = {}\n        for name in members_of(obj, app.config):\n            try:\n                members[name] = safe_getattr(obj, name)\n            except AttributeError:\n                continue\n        return members\n\n    def get_all_members(obj: Any) -> dict[str, Any]:\n        if doc.objtype == \"module\":\n            return get_module_members(obj)\n        elif doc.objtype == \"class\":\n            return get_class_members(obj)\n        return {}\n\n    def get_members(obj: Any, types: set[str], include_public: list[str] = [],\n                    imported: bool = True) -> tuple[list[str], list[str]]:\n        items: list[str] = []\n        public: list[str] = []\n\n        all_members = get_all_members(obj)\n        for name, value in all_members.items():\n            documenter = get_documenter(app, value, obj)\n            if documenter.objtype in types:\n                # skip imported members if expected\n                if imported or getattr(value, '__module__', None) == obj.__name__:\n                    skipped = skip_member(value, name, documenter.objtype)\n                    if skipped is True:\n                        pass\n                    elif skipped is False:\n                        # show the member forcedly\n                        items.append(name)\n                        public.append(name)\n                    else:\n                        items.append(name)\n                        if name in include_public or not name.startswith('_'):\n                            # considers member as public\n                            public.append(name)\n        return public, items",
                        "filename": "sphinx/ext/autosummary/generate.py",
                        "start_index": 7690,
                        "end_index": 10096,
                        "start_line": 231,
                        "end_line": 329,
                        "max_line": 704,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the logic for determining which members to document in autosummary, which is relevant to the issue of filtering inherited members from specific classes."
                },
                {
                    "chunk": {
                        "code": "class ModuleScanner:\n    def __init__(self, app: Any, obj: Any) -> None:\n        self.app = app\n        self.object = obj\n\n    def get_object_type(self, name: str, value: Any) -> str:\n        return get_documenter(self.app, value, self.object).objtype\n\n    def is_skipped(self, name: str, value: Any, objtype: str) -> bool:\n        try:\n            return self.app.emit_firstresult('autodoc-skip-member', objtype,\n                                             name, value, False, {})\n        except Exception as exc:\n            logger.warning(__('autosummary: failed to determine %r to be documented, '\n                              'the following exception was raised:\\n%s'),\n                           name, exc, type='autosummary')\n            return False\n\n    def scan(self, imported_members: bool) -> list[str]:\n        members = []\n        try:\n            analyzer = ModuleAnalyzer.for_module(self.object.__name__)\n            attr_docs = analyzer.find_attr_docs()\n        except PycodeError:\n            attr_docs = {}\n\n        for name in members_of(self.object, self.app.config):\n            try:\n                value = safe_getattr(self.object, name)\n            except AttributeError:\n                value = None\n\n            objtype = self.get_object_type(name, value)\n            if self.is_skipped(name, value, objtype):\n                continue\n\n            try:\n                if ('', name) in attr_docs:\n                    imported = False\n                elif inspect.ismodule(value):  # NoQA: SIM114\n                    imported = True\n                elif safe_getattr(value, '__module__') != self.object.__name__:\n                    imported = True\n                else:\n                    imported = False\n            except AttributeError:\n                imported = False\n\n            respect_module_all = not self.app.config.autosummary_ignore_module_all\n            if (\n                # list all members up\n                imported_members\n                # list not-imported members\n                or imported is False\n                # list members that have __all__ set\n                or (respect_module_all and '__all__' in dir(self.object))\n            ):\n                members.append(name)\n\n        return members\n\n\ndef members_of(obj: Any, conf: Config) -> Sequence[str]:\n    \"\"\"Get the members of ``obj``, possibly ignoring the ``__all__`` module attribute\n\n    Follows the ``conf.autosummary_ignore_module_all`` setting.\"\"\"\n\n    if conf.autosummary_ignore_module_all:\n        return dir(obj)\n    else:\n        return getall(obj) or dir(obj)",
                        "filename": "sphinx/ext/autosummary/generate.py",
                        "start_index": 4680,
                        "end_index": 7269,
                        "start_line": 152,
                        "end_line": 222,
                        "max_line": 704,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the autosummary generation process and includes logic for skipping members, which could be relevant when considering how to handle inherited members from specific classes."
                }
            ]
        },
        "solution_task": "To implement the feature where `:inherited-members:` option in Sphinx's `automodule` directive supports ignoring specific base classes, you can follow these steps:\n\n- Modify the `get_class_members` function to filter out members from the specified base classes.\n- Add a configuration option to specify the classes to be ignored.\n- Update the `skip_member` function to use the new configuration option.\n\nHere's a high-level overview of the changes:\n\n1. Add a new configuration option in `conf.py`:\n```python\n# conf.py\nautodoc_inherited_member_ignore = ['list', 'set', 'tuple']  # Example classes to ignore\n```\n\n2. Modify the `get_class_members` function in `generate.py` to check against the new configuration option and skip the specified base classes:\n```python\ndef get_class_members(obj: Any) -> dict[str, Any]:\n    members = sphinx.ext.autodoc.get_class_members(obj, [qualname], safe_getattr)\n    ignored_bases = app.config.autodoc_inherited_member_ignore  # Retrieve the new config option\n    filtered_members = {}\n    for name, member in members.items():\n        if not any(base.__name__ in ignored_bases for base in inspect.getmro(member.object)):\n            filtered_members[name] = member.object\n    return filtered_members\n```\n\n3. Update the `skip_member` function to use the new configuration option if the object type is a class:\n```python\ndef skip_member(obj: Any, name: str, objtype: str) -> bool:\n    if objtype == 'class':\n        ignored_bases = app.config.autodoc_inherited_member_ignore\n        if any(base.__name__ in ignored_bases for base in inspect.getmro(obj)):\n            return True\n    # ... existing code ...\n```\n\n4. Ensure that the new configuration option is properly documented and that users are aware of how to use it.\n\nThis is a high-level overview, and the actual implementation may require additional error handling and integration with the rest of the Sphinx codebase. The provided code snippets are meant to guide the implementation and may need to be adapted to fit the actual code structure and style of the Sphinx project.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The VALUE score should reflect how well the RESPONSE addresses the specific needs and context presented in the PROMPT, regardless of the completeness of the PROMPT itself.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable plan for implementing the feature request to allow the :inherited-members: option in Sphinx's automodule directive to support ignoring specific base classes. It suggests modifying existing functions and adding a new configuration option, which is directly relevant to the feature request. The RESPONSE also includes code snippets and references to the relevant parts of the Sphinx codebase, which are useful for guiding the implementation. The RESPONSE does not address the first bullet of the problem description, which involves a class inheriting from multiple other classes and selectively documenting members from some of the base classes. However, the RESPONSE does provide a comprehensive solution for the second bullet and the overall feature request, which is why it receives a high score.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711701582.273304,
        "result": "To implement the feature where `:inherited-members:` option in Sphinx's `automodule` directive supports ignoring specific base classes, you can follow these steps:\n\n- Modify the `get_class_members` function to filter out members from the specified base classes.\n- Add a configuration option to specify the classes to be ignored.\n- Update the `skip_member` function to use the new configuration option.\n\nHere's a high-level overview of the changes:\n\n1. Add a new configuration option in `conf.py`:\n```python\n# conf.py\nautodoc_inherited_member_ignore = ['list', 'set', 'tuple']  # Example classes to ignore\n```\n\n2. Modify the `get_class_members` function in `generate.py` to check against the new configuration option and skip the specified base classes:\n```python\ndef get_class_members(obj: Any) -> dict[str, Any]:\n    members = sphinx.ext.autodoc.get_class_members(obj, [qualname], safe_getattr)\n    ignored_bases = app.config.autodoc_inherited_member_ignore  # Retrieve the new config option\n    filtered_members = {}\n    for name, member in members.items():\n        if not any(base.__name__ in ignored_bases for base in inspect.getmro(member.object)):\n            filtered_members[name] = member.object\n    return filtered_members\n```\n\n3. Update the `skip_member` function to use the new configuration option if the object type is a class:\n```python\ndef skip_member(obj: Any, name: str, objtype: str) -> bool:\n    if objtype == 'class':\n        ignored_bases = app.config.autodoc_inherited_member_ignore\n        if any(base.__name__ in ignored_bases for base in inspect.getmro(obj)):\n            return True\n    # ... existing code ...\n```\n\n4. Ensure that the new configuration option is properly documented and that users are aware of how to use it.\n\nThis is a high-level overview, and the actual implementation may require additional error handling and integration with the rest of the Sphinx codebase. The provided code snippets are meant to guide the implementation and may need to be adapted to fit the actual code structure and style of the Sphinx project.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__5.0/tree//sphinx) \u2192 [ext](https://github.com/testbed/sphinx-doc__sphinx__5.0/tree//sphinx/ext) \u2192 [autosummary](https://github.com/testbed/sphinx-doc__sphinx__5.0/tree//sphinx/ext/autosummary)- [Lines 231 - 329](https://github.com/testbed/sphinx-doc__sphinx__5.0/blob//sphinx/ext/autosummary/generate.py#L231-L329)\n\n This snippet contains the logic for determining which members to document in autosummary, which is relevant to the issue of filtering inherited members from specific classes. \n\n\n   - [Lines 152 - 222](https://github.com/testbed/sphinx-doc__sphinx__5.0/blob//sphinx/ext/autosummary/generate.py#L152-L222)\n\n This snippet is part of the autosummary generation process and includes logic for skipping members, which could be relevant when considering how to handle inherited members from specific classes.",
        "context_relevance": 0.2,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the entire PROMPT completely.\nSupporting Evidence: The RESPONSE directly addresses the feature request described in the PROMPT by providing a detailed solution to the problem of selectively documenting inherited members in Sphinx. It offers a step-by-step guide on how to implement the desired functionality, including code snippets and modifications to specific functions within Sphinx's codebase. The RESPONSE also acknowledges the need for documentation and user awareness of the new feature. Additionally, it provides relevant links to the Sphinx repository, indicating where the changes would be applied, which directly supports the user's request for the `:inherited-members:` option to accept a list of classes to ignore. The RESPONSE is comprehensive and provides a complete answer to the feature request, fulfilling all aspects of the PROMPT."
        },
        "qa_relevance": 1.0
    }
}