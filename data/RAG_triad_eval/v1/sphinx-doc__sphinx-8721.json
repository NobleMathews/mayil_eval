{
    "id": "sphinx-doc__sphinx-8721",
    "repo_name": "testbed/sphinx-doc__sphinx__3.5",
    "task_id": 2499513814769304767,
    "title": "viewcode creates pages for epub even if `viewcode_enable_epub=False` on `make html epub`",
    "body": "**Describe the bug**\r\nviewcode creates pages for epub even if `viewcode_enable_epub=False` on `make html epub`\r\n\r\n**To Reproduce**\r\n```\r\n$ make html epub\r\n```\r\n\r\n**Expected behavior**\r\nmodule pages should not be created for epub by default.\r\n\r\n**Your project**\r\nNo\r\n\r\n**Screenshots**\r\nNo\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.1\r\n- Sphinx version: HEAD of 3.x\r\n- Sphinx extensions:  sphinx.ext.viewcode\r\n- Extra tools: No\r\n\r\n**Additional context**\r\nNo\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__3.5.git",
    "requested_commit": "",
    "mayil_response": "- The issue is that `sphinx.ext.viewcode` is generating module pages for the EPUB format even when the `viewcode_enable_epub` configuration is set to `False`.\n- The expected behavior is that when `viewcode_enable_epub` is `False`, no module pages should be generated for the EPUB format.\n\nTo resolve the issue:\n\n- Modify the `sphinx.ext.viewcode` extension to check the `viewcode_enable_epub` configuration value before generating module pages for EPUB.\n- In the `sphinx/ext/viewcode.py` file, update the `doctree_read` function to include a condition that checks the `viewcode_enable_epub` setting before adding `viewcode_anchor` nodes to the document tree.\n\n```python\ndef doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n\n    # Add this condition to check if viewcode is enabled for epub\n    if app.builder.format == 'epub' and not app.config.viewcode_enable_epub:\n        return\n\n    # ... rest of the function remains unchanged ...\n```\n\n- Ensure that the `viewcode_enable_epub` configuration value is properly initialized in the `setup` function of the `sphinx.ext.viewcode` extension.\n\n```python\ndef setup(app):\n    app.add_config_value('viewcode_enable_epub', default=False, rebuild='')\n    # ... rest of the setup function remains unchanged ...\n```\n\n- This will prevent the `viewcode` extension from processing and adding source code links to the EPUB output when `viewcode_enable_epub` is set to `False`.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx) \u2192 [ext](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx/ext)- [Lines 70 - 297](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/ext/viewcode.py#L70-L297)\n\n This snippet contains the logic for generating module pages, which should be conditioned by the 'viewcode_enable_epub' configuration. \n\n\n   - [Lines 133 - 200](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/ext/viewcode.py#L133-L200)\n\n This snippet includes functions that handle the merging of environment information and purging of documents, which may be relevant if the issue involves conditional inclusion of viewcode pages. \n\n\n   - [Lines 69 - 130](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/ext/viewcode.py#L69-L130)\n\n This snippet is part of the viewcode extension and handles the reading of the doctree, which may need to be adjusted to respect the 'viewcode_enable_epub' setting.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00029749999999999997,
        "snippet_processor": 0.06237,
        "issue_star_creation": 0.01838,
        "issue_star_solver": 0.06822,
        "bouncer": 0.023030000000000002
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711702960.454634,
        "relevant_snippets": [
            {
                "code": "env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not is_supported_builder(app.builder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        maxindex = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, maxindex)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']",
                "filename": "sphinx/ext/viewcode.py",
                "start_index": 8110,
                "end_index": 11106,
                "start_line": 70,
                "end_line": 297,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.4
            },
            {
                "code": "\"\"\"Build epub3 files.\n\nOriginally derived from epub.py.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport html\nimport re\nfrom os import path\nfrom typing import Any, NamedTuple\n\nfrom sphinx import package_dir\nfrom sphinx.application import Sphinx\nfrom sphinx.builders import _epub_base\nfrom sphinx.config import ENUM, Config\nfrom sphinx.locale import __\nfrom sphinx.util import logging\nfrom sphinx.util.fileutil import copy_asset_file\nfrom sphinx.util.i18n import format_date\nfrom sphinx.util.osutil import make_filename\n\nlogger = logging.getLogger(__name__)\n\n\nclass NavPoint(NamedTuple):\n    text: str\n    refuri: str\n    children: list[Any]     # mypy does not support recursive types\n                            # https://github.com/python/mypy/issues/7069\n\n\n# writing modes\nPAGE_PROGRESSION_DIRECTIONS = {\n    'horizontal': 'ltr',\n    'vertical': 'rtl',\n}\nIBOOK_SCROLL_AXIS = {\n    'horizontal': 'vertical',\n    'vertical': 'horizontal',\n}\nTHEME_WRITING_MODES = {\n    'vertical': 'vertical-rl',\n    'horizontal': 'horizontal-tb',\n}\n\nDOCTYPE = '''<!DOCTYPE html>'''\n\nHTML_TAG = (\n    '<html xmlns=\"http://www.w3.org/1999/xhtml\" '\n    'xmlns:epub=\"http://www.idpf.org/2007/ops\">'\n)\n\n# https://www.w3.org/TR/REC-xml/#NT-Name\n_xml_name_start_char = (\n    ':|[A-Z]|_|[a-z]|[\\u00C0-\\u00D6]'\n    '|[\\u00D8-\\u00F6]|[\\u00F8-\\u02FF]|[\\u0370-\\u037D]'\n    '|[\\u037F-\\u1FFF]|[\\u200C-\\u200D]|[\\u2070-\\u218F]'\n    '|[\\u2C00-\\u2FEF]|[\\u3001-\\uD7FF]|[\\uF900-\\uFDCF]'\n    '|[\\uFDF0-\\uFFFD]|[\\U00010000-\\U000EFFFF]'\n)\n_xml_name_char = (\n    _xml_name_start_char + r'\\-|\\.' '|[0-9]|\\u00B7|[\\u0300-\\u036F]|[\\u203F-\\u2040]'\n)\n_XML_NAME_PATTERN = re.compile(f'({_xml_name_start_char})({_xml_name_char})*')",
                "filename": "sphinx/builders/epub3.py",
                "start_index": 0,
                "end_index": 1683,
                "start_line": 1,
                "end_line": 65,
                "max_line": 293,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class EpubBuilder(StandaloneHTMLBuilder):",
                "filename": "sphinx/builders/_epub_base.py",
                "start_index": 2767,
                "end_index": 2808,
                "start_line": 120,
                "end_line": 120,
                "max_line": 706,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def env_merge_info(app: Sphinx, env: BuildEnvironment, docnames: Iterable[str],\n                   other: BuildEnvironment) -> None:\n    if not hasattr(other, '_viewcode_modules'):\n        return\n    # create a _viewcode_modules dict on the main environment\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n    # now merge in the information from the subprocess\n    for modname, entry in other._viewcode_modules.items():\n        if modname not in env._viewcode_modules:  # type: ignore\n            env._viewcode_modules[modname] = entry  # type: ignore\n        else:\n            if env._viewcode_modules[modname]:  # type: ignore\n                used = env._viewcode_modules[modname][2]  # type: ignore\n                for fullname, docname in entry[2].items():\n                    if fullname not in used:\n                        used[fullname] = docname\n\n\ndef env_purge_doc(app: Sphinx, env: BuildEnvironment, docname: str) -> None:\n    modules = getattr(env, '_viewcode_modules', {})\n\n    for modname, entry in list(modules.items()):\n        if entry is False:\n            continue\n\n        code, tags, used, refname = entry\n        for fullname in list(used):\n            if used[fullname] == docname:\n                used.pop(fullname)\n\n        if len(used) == 0:\n            modules.pop(modname)\n\n\nclass ViewcodeAnchorTransform(SphinxPostTransform):\n    \"\"\"Convert or remove viewcode_anchor nodes depends on builder.\"\"\"\n    default_priority = 100\n\n    def run(self, **kwargs: Any) -> None:\n        if is_supported_builder(self.app.builder):\n            self.convert_viewcode_anchors()\n        else:\n            self.remove_viewcode_anchors()\n\n    def convert_viewcode_anchors(self) -> None:\n        for node in self.document.findall(viewcode_anchor):\n            anchor = nodes.inline('', _('[source]'), classes=['viewcode-link'])\n            refnode = make_refnode(self.app.builder, node['refdoc'], node['reftarget'],\n                                   node['refid'], anchor)\n            node.replace_self(refnode)\n\n    def remove_viewcode_anchors(self) -> None:\n        for node in list(self.document.findall(viewcode_anchor)):\n            node.parent.remove(node)\n\n\ndef get_module_filename(app: Sphinx, modname: str) -> str | None:\n    \"\"\"Get module filename for *modname*.\"\"\"\n    source_info = app.emit_firstresult('viewcode-find-source', modname)\n    if source_info:\n        return None\n    else:\n        try:\n            filename, source = ModuleAnalyzer.get_module_source(modname)\n            return filename\n        except Exception:\n            return None",
                "filename": "sphinx/ext/viewcode.py",
                "start_index": 4659,
                "end_index": 7278,
                "start_line": 133,
                "end_line": 200,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def handle_page(self, pagename: str, addctx: dict, templatename: str = 'page.html',\n                    outfilename: str | None = None, event_arg: Any = None) -> None:\n        \"\"\"Create a rendered page.\n\n        This method is overwritten for genindex pages in order to fix href link\n        attributes.\n        \"\"\"\n        if pagename.startswith('genindex') and 'genindexentries' in addctx:\n            if not self.use_index:\n                return\n            self.fix_genindex(addctx['genindexentries'])\n        addctx['doctype'] = self.doctype\n        super().handle_page(pagename, addctx, templatename, outfilename, event_arg)\n\n    def build_mimetype(self) -> None:\n        \"\"\"Write the metainfo file mimetype.\"\"\"\n        logger.info(__('writing mimetype file...'))\n        copy_asset_file(path.join(self.template_dir, 'mimetype'), self.outdir)\n\n    def build_container(self, outname: str = 'META-INF/container.xml') -> None:\n        \"\"\"Write the metainfo file META-INF/container.xml.\"\"\"\n        logger.info(__('writing META-INF/container.xml file...'))\n        outdir = path.join(self.outdir, 'META-INF')\n        ensuredir(outdir)\n        copy_asset_file(path.join(self.template_dir, 'container.xml'), outdir)\n\n    def content_metadata(self) -> dict[str, Any]:\n        \"\"\"Create a dictionary with all metadata for the content.opf\n        file properly escaped.\n        \"\"\"\n        metadata: dict[str, Any] = {}\n        metadata['title'] = html.escape(self.config.epub_title)\n        metadata['author'] = html.escape(self.config.epub_author)\n        metadata['uid'] = html.escape(self.config.epub_uid)\n        metadata['lang'] = html.escape(self.config.epub_language)\n        metadata['publisher'] = html.escape(self.config.epub_publisher)\n        metadata['copyright'] = html.escape(self.config.epub_copyright)\n        metadata['scheme'] = html.escape(self.config.epub_scheme)\n        metadata['id'] = html.escape(self.config.epub_identifier)\n        metadata['date'] = html.escape(format_date(\"%Y-%m-%d\", language='en'))\n        metadata['manifest_items'] = []\n        metadata['spines'] = []\n        metadata['guides'] = []\n        return metadata",
                "filename": "sphinx/builders/_epub_base.py",
                "start_index": 17001,
                "end_index": 19156,
                "start_line": 452,
                "end_line": 670,
                "max_line": 706,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "for name in self.files:\n            if name not in spinefiles and name.endswith(self.out_suffix):\n                spine = Spine(html.escape(self.make_id(name)), False)\n                metadata['spines'].append(spine)\n\n        # add the optional cover\n        html_tmpl = None\n        if self.config.epub_cover:\n            image, html_tmpl = self.config.epub_cover\n            image = image.replace(os.sep, '/')\n            metadata['cover'] = html.escape(self.make_id(image))\n            if html_tmpl:\n                spine = Spine(html.escape(self.make_id(self.coverpage_name)), True)\n                metadata['spines'].insert(0, spine)\n                if self.coverpage_name not in self.files:\n                    ext = path.splitext(self.coverpage_name)[-1]\n                    self.files.append(self.coverpage_name)\n                    item = ManifestItem(html.escape(self.coverpage_name),\n                                        html.escape(self.make_id(self.coverpage_name)),\n                                        html.escape(self.media_types[ext]))\n                    metadata['manifest_items'].append(item)\n                ctx = {'image': html.escape(image), 'title': self.config.project}\n                self.handle_page(\n                    path.splitext(self.coverpage_name)[0], ctx, html_tmpl)\n                spinefiles.add(self.coverpage_name)\n\n        auto_add_cover = True\n        auto_add_toc = True\n        if self.config.epub_guide:\n            for type, uri, title in self.config.epub_guide:\n                file = uri.split('#')[0]\n                if file not in self.files:\n                    self.files.append(file)\n                if type == 'cover':\n                    auto_add_cover = False\n                if type == 'toc':\n                    auto_add_toc = False\n                metadata['guides'].append(Guide(html.escape(type),\n                                                html.escape(title),\n                                                html.escape(uri)))\n        if auto_add_cover and html_tmpl:\n            metadata['guides'].append(Guide('cover',\n                                            self.guide_titles['cover'],\n                                            html.escape(self.coverpage_name)))\n        if auto_add_toc and self.refnodes:\n            metadata['guides'].append(Guide('toc',\n                                            self.guide_titles['toc'],\n                                            html.escape(self.refnodes[0]['refuri'])))\n\n        # write the project file\n        copy_asset_file(path.join(self.template_dir, 'content.opf_t'), self.outdir, metadata)",
                "filename": "sphinx/builders/_epub_base.py",
                "start_index": 22018,
                "end_index": 24640,
                "start_line": 556,
                "end_line": 606,
                "max_line": 706,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@progress_message(__('writing additional pages'))\n    def gen_additional_pages(self) -> None:\n        # additional pages from conf.py\n        for pagename, template in self.config.html_additional_pages.items():\n            logger.info(pagename + ' ', nonl=True)\n            self.handle_page(pagename, {}, template)\n\n        # the search page\n        if self.search:\n            logger.info('search ', nonl=True)\n            self.handle_page('search', {}, 'search.html')\n\n        # the opensearch xml file\n        if self.config.html_use_opensearch and self.search:\n            logger.info('opensearch ', nonl=True)\n            fn = path.join(self.outdir, '_static', 'opensearch.xml')\n            self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)\n\n    def write_genindex(self) -> None:\n        # the total count of lines for each index letter, used to distribute\n        # the entries into two columns\n        genindex = IndexEntries(self.env).create_index(self)\n        indexcounts = []\n        for _k, entries in genindex:\n            indexcounts.append(sum(1 + len(subitems)\n                                   for _, (_, subitems, _) in entries))\n\n        genindexcontext = {\n            'genindexentries': genindex,\n            'genindexcounts': indexcounts,\n            'split_index': self.config.html_split_index,\n        }\n        logger.info('genindex ', nonl=True)\n\n        if self.config.html_split_index:\n            self.handle_page('genindex', genindexcontext,\n                             'genindex-split.html')\n            self.handle_page('genindex-all', genindexcontext,\n                             'genindex.html')\n            for (key, entries), count in zip(genindex, indexcounts):\n                ctx = {'key': key, 'entries': entries, 'count': count,\n                       'genindexentries': genindex}\n                self.handle_page('genindex-' + key, ctx,\n                                 'genindex-single.html')\n        else:\n            self.handle_page('genindex', genindexcontext, 'genindex.html')\n\n    def write_domain_indices(self) -> None:\n        for indexname, indexcls, content, collapse in self.domain_indices:\n            indexcontext = {\n                'indextitle': indexcls.localname,\n                'content': content,\n                'collapse_index': collapse,\n            }\n            logger.info(indexname + ' ', nonl=True)\n            self.handle_page(indexname, indexcontext, 'domainindex.html')",
                "filename": "sphinx/builders/html/__init__.py",
                "start_index": 27367,
                "end_index": 29832,
                "start_line": 704,
                "end_line": 759,
                "max_line": 1395,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "def doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n\n    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n        entry = env._viewcode_modules.get(modname, None)  # type: ignore\n        if entry is False:\n            return False\n\n        code_tags = app.emit_firstresult('viewcode-find-source', modname)\n        if code_tags is None:\n            try:\n                analyzer = ModuleAnalyzer.for_module(modname)\n                analyzer.find_tags()\n            except Exception:\n                env._viewcode_modules[modname] = False  # type: ignore\n                return False\n\n            code = analyzer.code\n            tags = analyzer.tags\n        else:\n            code, tags = code_tags\n\n        if entry is None or entry[0] != code:\n            entry = code, tags, {}, refname\n            env._viewcode_modules[modname] = entry  # type: ignore\n        _, tags, used, _ = entry\n        if fullname in tags:\n            used[fullname] = docname\n            return True\n\n        return False\n\n    for objnode in list(doctree.findall(addnodes.desc)):\n        if objnode.get('domain') != 'py':\n            continue\n        names: set[str] = set()\n        for signode in objnode:\n            if not isinstance(signode, addnodes.desc_signature):\n                continue\n            modname = signode.get('module')\n            fullname = signode.get('fullname')\n            refname = modname\n            if env.config.viewcode_follow_imported_members:\n                new_modname = app.emit_firstresult(\n                    'viewcode-follow-imported', modname, fullname,\n                )\n                if not new_modname:\n                    new_modname = _get_full_modname(app, modname, fullname)\n                modname = new_modname\n            if not modname:\n                continue\n            fullname = signode.get('fullname')\n            if not has_tag(modname, fullname, env.docname, refname):\n                continue\n            if fullname in names:\n                # only one link per name, please\n                continue\n            names.add(fullname)\n            pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n            signode += viewcode_anchor(reftarget=pagename, refid=fullname, refdoc=env.docname)",
                "filename": "sphinx/ext/viewcode.py",
                "start_index": 2249,
                "end_index": 4656,
                "start_line": 69,
                "end_line": 130,
                "max_line": 340,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    app.add_builder(Epub3Builder)\n\n    # config values\n    app.add_config_value('epub_basename', lambda self: make_filename(self.project), False)\n    app.add_config_value('epub_version', 3.0, 'epub')  # experimental\n    app.add_config_value('epub_theme', 'epub', 'epub')\n    app.add_config_value('epub_theme_options', {}, 'epub')\n    app.add_config_value('epub_title', lambda self: self.project, 'epub')\n    app.add_config_value('epub_author', lambda self: self.author, 'epub')\n    app.add_config_value('epub_language', lambda self: self.language or 'en', 'epub')\n    app.add_config_value('epub_publisher', lambda self: self.author, 'epub')\n    app.add_config_value('epub_copyright', lambda self: self.copyright, 'epub')\n    app.add_config_value('epub_identifier', 'unknown', 'epub')\n    app.add_config_value('epub_scheme', 'unknown', 'epub')\n    app.add_config_value('epub_uid', 'unknown', 'env')\n    app.add_config_value('epub_cover', (), 'env')\n    app.add_config_value('epub_guide', (), 'env')\n    app.add_config_value('epub_pre_files', [], 'env')\n    app.add_config_value('epub_post_files', [], 'env')\n    app.add_config_value('epub_css_files', lambda config: config.html_css_files, 'epub')\n    app.add_config_value('epub_exclude_files', [], 'env')\n    app.add_config_value('epub_tocdepth', 3, 'env')\n    app.add_config_value('epub_tocdup', True, 'env')\n    app.add_config_value('epub_tocscope', 'default', 'env')\n    app.add_config_value('epub_fix_images', False, 'env')\n    app.add_config_value('epub_max_image_width', 0, 'env')\n    app.add_config_value('epub_show_urls', 'inline', 'epub')\n    app.add_config_value('epub_use_index', lambda self: self.html_use_index, 'epub')\n    app.add_config_value('epub_description', 'unknown', 'epub')\n    app.add_config_value('epub_contributor', 'unknown', 'epub')\n    app.add_config_value('epub_writing_mode', 'horizontal', 'epub',\n                         ENUM('horizontal', 'vertical'))\n\n    # event handlers\n    app.connect('config-inited', convert_epub_css_files, priority=800)\n    app.connect('builder-inited', validate_config_values)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }",
                "filename": "sphinx/builders/epub3.py",
                "start_index": 9033,
                "end_index": 11283,
                "start_line": 251,
                "end_line": 293,
                "max_line": 293,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "\"\"\"\n    Builder that outputs epub3 files.\n\n    It creates the metainfo files content.opf, nav.xhtml, toc.ncx, mimetype,\n    and META-INF/container.xml. Afterwards, all necessary files are zipped to\n    an epub file.\n    \"\"\"\n    name = 'epub'\n    epilog = __('The ePub file is in %(outdir)s.')\n\n    supported_remote_images = False\n    template_dir = path.join(package_dir, 'templates', 'epub3')\n    doctype = DOCTYPE\n    html_tag = HTML_TAG\n    use_meta_charset = True\n\n    # Finish by building the epub file\n    def handle_finish(self) -> None:\n        \"\"\"Create the metainfo files and finally the epub.\"\"\"\n        self.get_toc()\n        self.build_mimetype()\n        self.build_container()\n        self.build_content()\n        self.build_navigation_doc()\n        self.build_toc()\n        self.build_epub()\n\n    def content_metadata(self) -> dict[str, Any]:\n        \"\"\"Create a dictionary with all metadata for the content.opf\n        file properly escaped.\n        \"\"\"\n        writing_mode = self.config.epub_writing_mode\n\n        metadata = super().content_metadata()\n        metadata['description'] = html.escape(self.config.epub_description)\n        metadata['contributor'] = html.escape(self.config.epub_contributor)\n        metadata['page_progression_direction'] = PAGE_PROGRESSION_DIRECTIONS.get(writing_mode)\n        metadata['ibook_scroll_axis'] = IBOOK_SCROLL_AXIS.get(writing_mode)\n        metadata['date'] = html.escape(format_date(\"%Y-%m-%dT%H:%M:%SZ\", language='en'))\n        metadata['version'] = html.escape(self.config.version)\n        metadata['epub_version'] = self.config.epub_version\n        return metadata\n\n    def prepare_writing(self, docnames: set[str]) -> None:\n        super().prepare_writing(docnames)\n\n        writing_mode = self.config.epub_writing_mode\n        self.globalcontext['theme_writing_mode'] = THEME_WRITING_MODES.get(writing_mode)\n        self.globalcontext['html_tag'] = self.html_tag\n        self.globalcontext['use_meta_charset'] = self.use_meta_charset\n        self.globalcontext['skip_ua_compatible'] = True",
                "filename": "sphinx/builders/epub3.py",
                "start_index": 1734,
                "end_index": 3789,
                "start_line": 1,
                "end_line": 119,
                "max_line": 293,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sphinx/ext/viewcode.py": [
                {
                    "chunk": {
                        "code": "env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not is_supported_builder(app.builder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        maxindex = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, maxindex)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']",
                        "filename": "sphinx/ext/viewcode.py",
                        "start_index": 8110,
                        "end_index": 11106,
                        "start_line": 70,
                        "end_line": 297,
                        "max_line": 340,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the logic for generating module pages, which should be conditioned by the 'viewcode_enable_epub' configuration."
                },
                {
                    "chunk": {
                        "code": "def env_merge_info(app: Sphinx, env: BuildEnvironment, docnames: Iterable[str],\n                   other: BuildEnvironment) -> None:\n    if not hasattr(other, '_viewcode_modules'):\n        return\n    # create a _viewcode_modules dict on the main environment\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n    # now merge in the information from the subprocess\n    for modname, entry in other._viewcode_modules.items():\n        if modname not in env._viewcode_modules:  # type: ignore\n            env._viewcode_modules[modname] = entry  # type: ignore\n        else:\n            if env._viewcode_modules[modname]:  # type: ignore\n                used = env._viewcode_modules[modname][2]  # type: ignore\n                for fullname, docname in entry[2].items():\n                    if fullname not in used:\n                        used[fullname] = docname\n\n\ndef env_purge_doc(app: Sphinx, env: BuildEnvironment, docname: str) -> None:\n    modules = getattr(env, '_viewcode_modules', {})\n\n    for modname, entry in list(modules.items()):\n        if entry is False:\n            continue\n\n        code, tags, used, refname = entry\n        for fullname in list(used):\n            if used[fullname] == docname:\n                used.pop(fullname)\n\n        if len(used) == 0:\n            modules.pop(modname)\n\n\nclass ViewcodeAnchorTransform(SphinxPostTransform):\n    \"\"\"Convert or remove viewcode_anchor nodes depends on builder.\"\"\"\n    default_priority = 100\n\n    def run(self, **kwargs: Any) -> None:\n        if is_supported_builder(self.app.builder):\n            self.convert_viewcode_anchors()\n        else:\n            self.remove_viewcode_anchors()\n\n    def convert_viewcode_anchors(self) -> None:\n        for node in self.document.findall(viewcode_anchor):\n            anchor = nodes.inline('', _('[source]'), classes=['viewcode-link'])\n            refnode = make_refnode(self.app.builder, node['refdoc'], node['reftarget'],\n                                   node['refid'], anchor)\n            node.replace_self(refnode)\n\n    def remove_viewcode_anchors(self) -> None:\n        for node in list(self.document.findall(viewcode_anchor)):\n            node.parent.remove(node)\n\n\ndef get_module_filename(app: Sphinx, modname: str) -> str | None:\n    \"\"\"Get module filename for *modname*.\"\"\"\n    source_info = app.emit_firstresult('viewcode-find-source', modname)\n    if source_info:\n        return None\n    else:\n        try:\n            filename, source = ModuleAnalyzer.get_module_source(modname)\n            return filename\n        except Exception:\n            return None",
                        "filename": "sphinx/ext/viewcode.py",
                        "start_index": 4659,
                        "end_index": 7278,
                        "start_line": 133,
                        "end_line": 200,
                        "max_line": 340,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes functions that handle the merging of environment information and purging of documents, which may be relevant if the issue involves conditional inclusion of viewcode pages."
                },
                {
                    "chunk": {
                        "code": "def doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n\n    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n        entry = env._viewcode_modules.get(modname, None)  # type: ignore\n        if entry is False:\n            return False\n\n        code_tags = app.emit_firstresult('viewcode-find-source', modname)\n        if code_tags is None:\n            try:\n                analyzer = ModuleAnalyzer.for_module(modname)\n                analyzer.find_tags()\n            except Exception:\n                env._viewcode_modules[modname] = False  # type: ignore\n                return False\n\n            code = analyzer.code\n            tags = analyzer.tags\n        else:\n            code, tags = code_tags\n\n        if entry is None or entry[0] != code:\n            entry = code, tags, {}, refname\n            env._viewcode_modules[modname] = entry  # type: ignore\n        _, tags, used, _ = entry\n        if fullname in tags:\n            used[fullname] = docname\n            return True\n\n        return False\n\n    for objnode in list(doctree.findall(addnodes.desc)):\n        if objnode.get('domain') != 'py':\n            continue\n        names: set[str] = set()\n        for signode in objnode:\n            if not isinstance(signode, addnodes.desc_signature):\n                continue\n            modname = signode.get('module')\n            fullname = signode.get('fullname')\n            refname = modname\n            if env.config.viewcode_follow_imported_members:\n                new_modname = app.emit_firstresult(\n                    'viewcode-follow-imported', modname, fullname,\n                )\n                if not new_modname:\n                    new_modname = _get_full_modname(app, modname, fullname)\n                modname = new_modname\n            if not modname:\n                continue\n            fullname = signode.get('fullname')\n            if not has_tag(modname, fullname, env.docname, refname):\n                continue\n            if fullname in names:\n                # only one link per name, please\n                continue\n            names.add(fullname)\n            pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n            signode += viewcode_anchor(reftarget=pagename, refid=fullname, refdoc=env.docname)",
                        "filename": "sphinx/ext/viewcode.py",
                        "start_index": 2249,
                        "end_index": 4656,
                        "start_line": 69,
                        "end_line": 130,
                        "max_line": 340,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the viewcode extension and handles the reading of the doctree, which may need to be adjusted to respect the 'viewcode_enable_epub' setting."
                }
            ]
        },
        "solution_task": "- The issue is that `sphinx.ext.viewcode` is generating module pages for the EPUB format even when the `viewcode_enable_epub` configuration is set to `False`.\n- The expected behavior is that when `viewcode_enable_epub` is `False`, no module pages should be generated for the EPUB format.\n\nTo resolve the issue:\n\n- Modify the `sphinx.ext.viewcode` extension to check the `viewcode_enable_epub` configuration value before generating module pages for EPUB.\n- In the `sphinx/ext/viewcode.py` file, update the `doctree_read` function to include a condition that checks the `viewcode_enable_epub` setting before adding `viewcode_anchor` nodes to the document tree.\n\n```python\ndef doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n\n    # Add this condition to check if viewcode is enabled for epub\n    if app.builder.format == 'epub' and not app.config.viewcode_enable_epub:\n        return\n\n    # ... rest of the function remains unchanged ...\n```\n\n- Ensure that the `viewcode_enable_epub` configuration value is properly initialized in the `setup` function of the `sphinx.ext.viewcode` extension.\n\n```python\ndef setup(app):\n    app.add_config_value('viewcode_enable_epub', default=False, rebuild='')\n    # ... rest of the setup function remains unchanged ...\n```\n\n- This will prevent the `viewcode` extension from processing and adding source code links to the EPUB output when `viewcode_enable_epub` is set to `False`.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSES that are highly relevant, offering clear and comprehensive guidance or solutions for the described bug, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a clear and detailed solution to the bug described in the PROMPT. It correctly identifies the issue with the `sphinx.ext.viewcode` extension generating module pages for EPUB despite the `viewcode_enable_epub` being set to `False`. The RESPONSE offers actionable steps to modify the `sphinx.ext.viewcode` extension, including specific code snippets and the exact location in the code where the changes should be made. It also suggests ensuring that the `viewcode_enable_epub` configuration value is properly initialized, which is a relevant and necessary step for the solution to work. The RESPONSE includes links to the relevant code sections, which is helpful for developers to quickly locate and address the issue. The RESPONSE does not address all aspects of the bug, such as testing the changes or considering potential side effects, which is why it does not receive a perfect score.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711703125.728523,
        "result": "- The issue is that `sphinx.ext.viewcode` is generating module pages for the EPUB format even when the `viewcode_enable_epub` configuration is set to `False`.\n- The expected behavior is that when `viewcode_enable_epub` is `False`, no module pages should be generated for the EPUB format.\n\nTo resolve the issue:\n\n- Modify the `sphinx.ext.viewcode` extension to check the `viewcode_enable_epub` configuration value before generating module pages for EPUB.\n- In the `sphinx/ext/viewcode.py` file, update the `doctree_read` function to include a condition that checks the `viewcode_enable_epub` setting before adding `viewcode_anchor` nodes to the document tree.\n\n```python\ndef doctree_read(app: Sphinx, doctree: Node) -> None:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        env._viewcode_modules = {}  # type: ignore\n\n    # Add this condition to check if viewcode is enabled for epub\n    if app.builder.format == 'epub' and not app.config.viewcode_enable_epub:\n        return\n\n    # ... rest of the function remains unchanged ...\n```\n\n- Ensure that the `viewcode_enable_epub` configuration value is properly initialized in the `setup` function of the `sphinx.ext.viewcode` extension.\n\n```python\ndef setup(app):\n    app.add_config_value('viewcode_enable_epub', default=False, rebuild='')\n    # ... rest of the setup function remains unchanged ...\n```\n\n- This will prevent the `viewcode` extension from processing and adding source code links to the EPUB output when `viewcode_enable_epub` is set to `False`.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx) \u2192 [ext](https://github.com/testbed/sphinx-doc__sphinx__3.5/tree//sphinx/ext)- [Lines 70 - 297](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/ext/viewcode.py#L70-L297)\n\n This snippet contains the logic for generating module pages, which should be conditioned by the 'viewcode_enable_epub' configuration. \n\n\n   - [Lines 133 - 200](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/ext/viewcode.py#L133-L200)\n\n This snippet includes functions that handle the merging of environment information and purging of documents, which may be relevant if the issue involves conditional inclusion of viewcode pages. \n\n\n   - [Lines 69 - 130](https://github.com/testbed/sphinx-doc__sphinx__3.5/blob//sphinx/ext/viewcode.py#L69-L130)\n\n This snippet is part of the viewcode extension and handles the reading of the doctree, which may need to be adjusted to respect the 'viewcode_enable_epub' setting.",
        "context_relevance": 0.15999999999999998,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE directly addresses the reported bug by acknowledging the issue with `sphinx.ext.viewcode` and the `viewcode_enable_epub` setting. It provides a detailed explanation of the expected behavior, which matches the PROMPT's description of the bug. The RESPONSE then offers a solution with specific code modifications and checks, which are directly related to the bug's reproduction steps and the expected behavior. Additionally, the RESPONSE includes code snippets and links to the relevant sections of the codebase, which are pertinent to the bug report. This RESPONSE is comprehensive and provides all the necessary information to understand and potentially resolve the issue, thus meeting the criteria for a score of 10."
        },
        "qa_relevance": 1.0
    }
}