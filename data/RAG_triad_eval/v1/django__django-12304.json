{
    "id": "django__django-12304",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 152426544958753928,
    "title": "Enumeration Types are not usable in templates.",
    "body": "Description\n\t \n\t\t(last modified by Mariusz Felisiak)\n\t \nThe new \u200benumeration types are great but can't be used in Django templates due to their being callable. For example this doesn't work:\n{% if student.year_in_school == YearInSchool.FRESHMAN %}\nThis is because YearInSchool, being a class, is callable, and Django Templates always call callables with no arguments. The call fails because the required value argument is missing.\nThe easy solution would be to declare do_not_call_in_templates = True on the various Choices classes.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "- Add the `do_not_call_in_templates` attribute to the `YearInSchool` enumeration class.\n- Ensure that `YearInSchool` inherits from `TextChoices` to utilize the `ChoicesMeta` metaclass which already contains the `do_not_call_in_templates` property.\n\n```python\nfrom django.db import models\n\nclass YearInSchool(models.TextChoices):\n    FRESHMAN = 'FR', 'Freshman'\n    SOPHOMORE = 'SO', 'Sophomore'\n    # ... other choices ...\n```\n\n- Update the template snippet to compare the string representation of `student.year_in_school` with the string representation of `YearInSchool.FRESHMAN`.\n\n```django\n{% if student.year_in_school == 'FR' %}\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [db](https://github.com/testbed/django__django__3.1/tree//django/db) \u2192 [models](https://github.com/testbed/django__django__3.1/tree//django/db/models)- [Lines 1 - 92](https://github.com/testbed/django__django__3.1/blob//django/db/models/enums.py#L1-L92)\n\n This snippet defines the ChoicesMeta and Choices classes which are related to enumeration types that are not usable in templates. The issue can be fixed by modifying the Choices class to include the 'do_not_call_in_templates' attribute.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.001254,
        "snippet_processor": 0.06692000000000001,
        "issue_star_creation": 0.02413,
        "issue_star_solver": 0.057440000000000005,
        "bouncer": 0.02357
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711731668.378475,
        "relevant_snippets": [
            {
                "code": "import enum\nfrom types import DynamicClassAttribute\n\nfrom django.utils.functional import Promise\n\n__all__ = [\"Choices\", \"IntegerChoices\", \"TextChoices\"]\n\n\nclass ChoicesMeta(enum.EnumMeta):\n    \"\"\"A metaclass for creating a enum choices.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict, **kwds):\n        labels = []\n        for key in classdict._member_names:\n            value = classdict[key]\n            if (\n                isinstance(value, (list, tuple))\n                and len(value) > 1\n                and isinstance(value[-1], (Promise, str))\n            ):\n                *value, label = value\n                value = tuple(value)\n            else:\n                label = key.replace(\"_\", \" \").title()\n            labels.append(label)\n            # Use dict.__setitem__() to suppress defenses against double\n            # assignment in enum's classdict.\n            dict.__setitem__(classdict, key, value)\n        cls = super().__new__(metacls, classname, bases, classdict, **kwds)\n        for member, label in zip(cls.__members__.values(), labels):\n            member._label_ = label\n        return enum.unique(cls)\n\n    def __contains__(cls, member):\n        if not isinstance(member, enum.Enum):\n            # Allow non-enums to match against member values.\n            return any(x.value == member for x in cls)\n        return super().__contains__(member)\n\n    @property\n    def names(cls):\n        empty = [\"__empty__\"] if hasattr(cls, \"__empty__\") else []\n        return empty + [member.name for member in cls]\n\n    @property\n    def choices(cls):\n        empty = [(None, cls.__empty__)] if hasattr(cls, \"__empty__\") else []\n        return empty + [(member.value, member.label) for member in cls]\n\n    @property\n    def labels(cls):\n        return [label for _, label in cls.choices]\n\n    @property\n    def values(cls):\n        return [value for value, _ in cls.choices]\n\n\nclass Choices(enum.Enum, metaclass=ChoicesMeta):\n    \"\"\"Class for creating enumerated choices.\"\"\"\n\n    @DynamicClassAttribute\n    def label(self):\n        return self._label_\n\n    @property\n    def do_not_call_in_templates(self):\n        return True\n\n    def __str__(self):\n        \"\"\"\n        Use value when cast to str, so that Choices set as model instance\n        attributes are rendered as expected in templates and similar contexts.\n        \"\"\"\n        return str(self.value)\n\n    # A similar format was proposed for Python 3.10.\n    def __repr__(self):\n        return f\"{self.__class__.__qualname__}.{self._name_}\"\n\n\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n\n    pass\n\n\nclass TextChoices(str, Choices):\n    \"\"\"Class for creating enumerated string choices.\"\"\"\n\n    def _generate_next_value_(name, start, count, last_values):\n        return name",
                "filename": "django/db/models/enums.py",
                "start_index": 0,
                "end_index": 2803,
                "start_line": 1,
                "end_line": 92,
                "max_line": 92,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "import datetime\n\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import models\nfrom django.http import Http404\nfrom django.utils import timezone\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import gettext as _\nfrom django.views.generic.base import View\nfrom django.views.generic.detail import (\n    BaseDetailView,\n    SingleObjectTemplateResponseMixin,\n)\nfrom django.views.generic.list import (\n    MultipleObjectMixin,\n    MultipleObjectTemplateResponseMixin,\n)\n\n\nclass YearMixin:\n    \"\"\"Mixin for views manipulating year-based data.\"\"\"\n\n    year_format = \"%Y\"\n    year = None\n\n    def get_year_format(self):\n        \"\"\"\n        Get a year format string in strptime syntax to be used to parse the\n        year from url variables.\n        \"\"\"\n        return self.year_format\n\n    def get_year(self):\n        \"\"\"Return the year for which this view should display data.\"\"\"\n        year = self.year\n        if year is None:\n            try:\n                year = self.kwargs[\"year\"]\n            except KeyError:\n                try:\n                    year = self.request.GET[\"year\"]\n                except KeyError:\n                    raise Http404(_(\"No year specified\"))\n        return year\n\n    def get_next_year(self, date):\n        \"\"\"Get the next valid year.\"\"\"\n        return _get_next_prev(self, date, is_previous=False, period=\"year\")\n\n    def get_previous_year(self, date):\n        \"\"\"Get the previous valid year.\"\"\"\n        return _get_next_prev(self, date, is_previous=True, period=\"year\")\n\n    def _get_next_year(self, date):\n        \"\"\"\n        Return the start date of the next interval.\n\n        The interval is defined by start date <= item date < next start date.\n        \"\"\"\n        try:\n            return date.replace(year=date.year + 1, month=1, day=1)\n        except ValueError:\n            raise Http404(_(\"Date out of range\"))\n\n    def _get_current_year(self, date):\n        \"\"\"Return the start date of the current interval.\"\"\"\n        return date.replace(month=1, day=1)",
                "filename": "django/views/generic/dates.py",
                "start_index": 0,
                "end_index": 2091,
                "start_line": 1,
                "end_line": 68,
                "max_line": 795,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "import datetime\n\nfrom django.contrib.admin.templatetags.admin_urls import add_preserved_filters\nfrom django.contrib.admin.utils import (\n    display_for_field,\n    display_for_value,\n    get_fields_from_path,\n    label_for_field,\n    lookup_field,\n)\nfrom django.contrib.admin.views.main import (\n    ALL_VAR,\n    IS_FACETS_VAR,\n    IS_POPUP_VAR,\n    ORDER_VAR,\n    PAGE_VAR,\n    SEARCH_VAR,\n)\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.db import models\nfrom django.template import Library\nfrom django.template.loader import get_template\nfrom django.templatetags.static import static\nfrom django.urls import NoReverseMatch\nfrom django.utils import formats, timezone\nfrom django.utils.html import format_html\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import capfirst\nfrom django.utils.translation import gettext as _\n\nfrom .base import InclusionAdminNode\n\nregister = Library()\n\n\n@register.simple_tag\ndef paginator_number(cl, i):\n    \"\"\"\n    Generate an individual page index link in a paginated list.\n    \"\"\"\n    if i == cl.paginator.ELLIPSIS:\n        return format_html(\"{} \", cl.paginator.ELLIPSIS)\n    elif i == cl.page_num:\n        return format_html('<span class=\"this-page\">{}</span> ', i)\n    else:\n        return format_html(\n            '<a href=\"{}\"{}>{}</a> ',\n            cl.get_query_string({PAGE_VAR: i}),\n            mark_safe(' class=\"end\"' if i == cl.paginator.num_pages else \"\"),\n            i,\n        )\n\n\ndef pagination(cl):\n    \"\"\"\n    Generate the series of links to the pages in a paginated list.\n    \"\"\"\n    pagination_required = (not cl.show_all or not cl.can_show_all) and cl.multi_page\n    page_range = (\n        cl.paginator.get_elided_page_range(cl.page_num) if pagination_required else []\n    )\n    need_show_all_link = cl.can_show_all and not cl.show_all and cl.multi_page\n    return {\n        \"cl\": cl,\n        \"pagination_required\": pagination_required,\n        \"show_all_url\": need_show_all_link and cl.get_query_string({ALL_VAR: \"\"}),\n        \"page_range\": page_range,\n        \"ALL_VAR\": ALL_VAR,\n        \"1\": 1,\n    }\n\n\n@register.tag(name=\"pagination\")\ndef pagination_tag(parser, token):\n    return InclusionAdminNode(\n        parser,\n        token,\n        func=pagination,\n        template_name=\"pagination.html\",\n        takes_context=False,\n    )",
                "filename": "django/contrib/admin/templatetags/admin_list.py",
                "start_index": 0,
                "end_index": 2334,
                "start_line": 1,
                "end_line": 530,
                "max_line": 530,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "class RadioSelect(ChoiceWidget):\n    input_type = \"radio\"\n    template_name = \"django/forms/widgets/radio.html\"\n    option_template_name = \"django/forms/widgets/radio_option.html\"\n    use_fieldset = True\n\n    def id_for_label(self, id_, index=None):\n        \"\"\"\n        Don't include for=\"field_0\" in <label> to improve accessibility when\n        using a screen reader, in addition clicking such a label would toggle\n        the first input.\n        \"\"\"\n        if index is None:\n            return \"\"\n        return super().id_for_label(id_, index)\n\n\nclass CheckboxSelectMultiple(RadioSelect):\n    allow_multiple_selected = True\n    input_type = \"checkbox\"\n    template_name = \"django/forms/widgets/checkbox_select.html\"\n    option_template_name = \"django/forms/widgets/checkbox_option.html\"\n\n    def use_required_attribute(self, initial):\n        # Don't use the 'required' attribute because browser validation would\n        # require all checkboxes to be checked instead of at least one.\n        return False\n\n    def value_omitted_from_data(self, data, files, name):\n        # HTML checkboxes don't appear in POST data if not checked, so it's\n        # never known if the value is actually omitted.\n        return False",
                "filename": "django/forms/widgets.py",
                "start_index": 26683,
                "end_index": 27906,
                "start_line": 841,
                "end_line": 872,
                "max_line": 1200,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import re\nfrom datetime import date, datetime, timezone\nfrom decimal import Decimal\n\nfrom django import template\nfrom django.template import defaultfilters\nfrom django.utils.formats import number_format\nfrom django.utils.safestring import mark_safe\nfrom django.utils.timezone import is_aware\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import (\n    gettext_lazy,\n    ngettext,\n    ngettext_lazy,\n    npgettext_lazy,\n    pgettext,\n    round_away_from_one,\n)\n\nregister = template.Library()\n\n\n@register.filter(is_safe=True)\ndef ordinal(value):\n    \"\"\"\n    Convert an integer to its ordinal as a string. 1 is '1st', 2 is '2nd',\n    3 is '3rd', etc. Works for any integer.\n    \"\"\"\n    try:\n        value = int(value)\n    except (TypeError, ValueError):\n        return value\n    if value % 100 in (11, 12, 13):\n        # Translators: Ordinal format for 11 (11th), 12 (12th), and 13 (13th).\n        value = pgettext(\"ordinal 11, 12, 13\", \"{}th\").format(value)\n    else:\n        templates = (\n            # Translators: Ordinal format when value ends with 0, e.g. 80th.\n            pgettext(\"ordinal 0\", \"{}th\"),\n            # Translators: Ordinal format when value ends with 1, e.g. 81st, except 11.\n            pgettext(\"ordinal 1\", \"{}st\"),\n            # Translators: Ordinal format when value ends with 2, e.g. 82nd, except 12.\n            pgettext(\"ordinal 2\", \"{}nd\"),\n            # Translators: Ordinal format when value ends with 3, e.g. 83rd, except 13.\n            pgettext(\"ordinal 3\", \"{}rd\"),\n            # Translators: Ordinal format when value ends with 4, e.g. 84th.\n            pgettext(\"ordinal 4\", \"{}th\"),\n            # Translators: Ordinal format when value ends with 5, e.g. 85th.\n            pgettext(\"ordinal 5\", \"{}th\"),\n            # Translators: Ordinal format when value ends with 6, e.g. 86th.\n            pgettext(\"ordinal 6\", \"{}th\"),\n            # Translators: Ordinal format when value ends with 7, e.g. 87th.\n            pgettext(\"ordinal 7\", \"{}th\"),\n            # Translators: Ordinal format when value ends with 8, e.g. 88th.\n            pgettext(\"ordinal 8\", \"{}th\"),\n            # Translators: Ordinal format when value ends with 9, e.g. 89th.\n            pgettext(\"ordinal 9\", \"{}th\"),\n        )\n        value = templates[value % 10].format(value)\n    # Mark value safe so i18n does not break with <sup> or <sub> see #19988\n    return mark_safe(value)",
                "filename": "django/contrib/humanize/templatetags/humanize.py",
                "start_index": 0,
                "end_index": 2419,
                "start_line": 1,
                "end_line": 61,
                "max_line": 322,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "from decimal import Decimal\n\nfrom django.conf import settings\nfrom django.template import Library, Node, TemplateSyntaxError, Variable\nfrom django.template.base import TokenType, render_value_in_context\nfrom django.template.defaulttags import token_kwargs\nfrom django.utils import translation\nfrom django.utils.safestring import SafeData, SafeString, mark_safe\n\nregister = Library()\n\n\nclass GetAvailableLanguagesNode(Node):\n    def __init__(self, variable):\n        self.variable = variable\n\n    def render(self, context):\n        context[self.variable] = [\n            (k, translation.gettext(v)) for k, v in settings.LANGUAGES\n        ]\n        return \"\"\n\n\nclass GetLanguageInfoNode(Node):\n    def __init__(self, lang_code, variable):\n        self.lang_code = lang_code\n        self.variable = variable\n\n    def render(self, context):\n        lang_code = self.lang_code.resolve(context)\n        context[self.variable] = translation.get_language_info(lang_code)\n        return \"\"\n\n\nclass GetLanguageInfoListNode(Node):\n    def __init__(self, languages, variable):\n        self.languages = languages\n        self.variable = variable\n\n    def get_language_info(self, language):\n        # ``language`` is either a language code string or a sequence\n        # with the language code as its first item\n        if len(language[0]) > 1:\n            return translation.get_language_info(language[0])\n        else:\n            return translation.get_language_info(str(language))\n\n    def render(self, context):\n        langs = self.languages.resolve(context)\n        context[self.variable] = [self.get_language_info(lang) for lang in langs]\n        return \"\"\n\n\nclass GetCurrentLanguageNode(Node):\n    def __init__(self, variable):\n        self.variable = variable\n\n    def render(self, context):\n        context[self.variable] = translation.get_language()\n        return \"\"\n\n\nclass GetCurrentLanguageBidiNode(Node):\n    def __init__(self, variable):\n        self.variable = variable\n\n    def render(self, context):\n        context[self.variable] = translation.get_language_bidi()\n        return \"\"",
                "filename": "django/templatetags/i18n.py",
                "start_index": 0,
                "end_index": 2089,
                "start_line": 1,
                "end_line": 202,
                "max_line": 616,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "default_error_messages = {\n        \"invalid\": _(\"\u201c%(value)s\u201d value must be either None, True or False.\"),\n        \"invalid_nullable\": _(\"\u201c%(value)s\u201d value must be either None, True or False.\"),\n    }\n    description = _(\"Boolean (Either True, False or None)\")\n    system_check_removed_details = {\n        \"msg\": (\n            \"NullBooleanField is removed except for support in historical \"\n            \"migrations.\"\n        ),\n        \"hint\": \"Use BooleanField(null=True, blank=True) instead.\",\n        \"id\": \"fields.E903\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        kwargs[\"null\"] = True\n        kwargs[\"blank\"] = True\n        super().__init__(*args, **kwargs)\n\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        del kwargs[\"null\"]\n        del kwargs[\"blank\"]\n        return name, path, args, kwargs\n\n\nclass PositiveIntegerRelDbTypeMixin:\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        if not hasattr(cls, \"integer_field_class\"):\n            cls.integer_field_class = next(\n                (\n                    parent\n                    for parent in cls.__mro__[1:]\n                    if issubclass(parent, IntegerField)\n                ),\n                None,\n            )\n\n    def rel_db_type(self, connection):\n        \"\"\"\n        Return the data type that a related field pointing to this field should\n        use. In most cases, a foreign key pointing to a positive integer\n        primary key will have an integer column data type but some databases\n        (e.g. MySQL) have an unsigned integer type. In that case\n        (related_fields_match_type=True), the primary key should return its\n        db_type.\n        \"\"\"\n        if connection.features.related_fields_match_type:\n            return self.db_type(connection)\n        else:\n            return self.integer_field_class().db_type(connection=connection)\n\n\nclass PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, BigIntegerField):\n    description = _(\"Positive big integer\")\n\n    def get_internal_type(self):\n        return \"PositiveBigIntegerField\"\n\n    def formfield(self, **kwargs):\n        return super().formfield(\n            **{\n                \"min_value\": 0,\n                **kwargs,\n            }\n        )\n\n\nclass PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):\n    description = _(\"Positive integer\")\n\n    def get_internal_type(self):\n        return \"PositiveIntegerField\"\n\n    def formfield(self, **kwargs):\n        return super().formfield(\n            **{\n                \"min_value\": 0,\n                **kwargs,\n            }\n        )\n\n\nclass PositiveSmallIntegerField(PositiveIntegerRe",
                "filename": "django/db/models/fields/__init__.py",
                "start_index": 79202,
                "end_index": 81903,
                "start_line": 128,
                "end_line": 2377,
                "max_line": 2869,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "class ChoiceField(Field):\n    widget = Select\n    default_error_messages = {\n        \"invalid_choice\": _(\n            \"Select a valid choice. %(value)s is not one of the available choices.\"\n        ),\n    }\n\n    def __init__(self, *, choices=(), **kwargs):\n        super().__init__(**kwargs)\n        if isinstance(choices, ChoicesMeta):\n            choices = choices.choices\n        self.choices = choices\n\n    def __deepcopy__(self, memo):\n        result = super().__deepcopy__(memo)\n        result._choices = copy.deepcopy(self._choices, memo)\n        return result\n\n    def _get_choices(self):\n        return self._choices\n\n    def _set_choices(self, value):\n        # Setting choices also sets the choices on the widget.\n        # choices can be any iterable, but we call list() on it because\n        # it will be consumed more than once.\n        if callable(value):\n            value = CallableChoiceIterator(value)\n        else:\n            value = list(value)\n\n        self._choices = self.widget.choices = value\n\n    choices = property(_get_choices, _set_choices)\n\n    def to_python(self, value):\n        \"\"\"Return a string.\"\"\"\n        if value in self.empty_values:\n            return \"\"\n        return str(value)\n\n    def validate(self, value):\n        \"\"\"Validate that the input is in self.choices.\"\"\"\n        super().validate(value)\n        if value and not self.valid_value(value):\n            raise ValidationError(\n                self.error_messages[\"invalid_choice\"],\n                code=\"invalid_choice\",\n                params={\"value\": value},\n            )\n\n    def valid_value(self, value):\n        \"\"\"Check to see if the provided value is a valid choice.\"\"\"\n        text_value = str(value)\n        for k, v in self.choices:\n            if isinstance(v, (list, tuple)):\n                # This is an optgroup, so look inside the group for options\n                for k2, v2 in v:\n                    if value == k2 or text_value == str(k2):\n                        return True\n            else:\n                if value == k or text_value == str(k):\n                    return True\n        return False\n\n\nclass TypedChoiceField(ChoiceField):\n    def __init__(self, *, coerce=lambda val: val, empty_value=\"\", **kwargs):\n        self.coerce = coerce\n        self.empty_value = empty_value\n        super().__init__(**kwargs)\n\n    def _coerce(self, value):\n        \"\"\"\n        Validate that the value can be coerced to the right type (if not empty).\n        \"\"\"\n        if value == self.empty_value or value in self.empty_values:\n            return self.empty_value\n        try:\n            value = self.coerce(value)\n        except (ValueError, TypeError, ValidationError):\n            raise ValidationError(\n                self.error_messages[\"invalid_choice\"],\n                code=\"invalid_choice\",\n                params={\"value\": value},\n            )\n        return value\n\n    def clean(self, value):\n        value = super().clean(value)\n        return self._coerce(value)",
                "filename": "django/forms/fields.py",
                "start_index": 30330,
                "end_index": 33328,
                "start_line": 872,
                "end_line": 1038,
                "max_line": 1412,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "lass Deferrable(Enum):\n    DEFERRED = \"deferred\"\n    IMMEDIATE = \"immediate\"\n\n    # A similar format was proposed for Python 3.10.\n    def __repr__(self):\n        return f\"{self.__class__.__qualname__}.{self._name_}\"\n\n\nc",
                "filename": "django/db/models/constraints.py",
                "start_index": 6588,
                "end_index": 6808,
                "start_line": 170,
                "end_line": 465,
                "max_line": 466,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "lDbTypeMixin, SmallIntegerField):\n    description = _(\"Positive small integer\")\n\n    def get_internal_type(self):\n        return \"PositiveSmallIntegerField\"\n\n    def formfield(self, **kwargs):\n        return super().formfield(\n            **{\n                \"min_value\": 0,\n                **kwargs,\n            }\n        )\n\n\nclass SlugField(CharField):\n    default_validators = [validators.validate_slug]\n    description = _(\"Slug (up to %(max_length)s)\")\n\n    def __init__(\n        self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs\n    ):\n        self.allow_unicode = allow_unicode\n        if self.allow_unicode:\n            self.default_validators = [validators.validate_unicode_slug]\n        super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)\n\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        if kwargs.get(\"max_length\") == 50:\n            del kwargs[\"max_length\"]\n        if self.db_index is False:\n            kwargs[\"db_index\"] = False\n        else:\n            del kwargs[\"db_index\"]\n        if self.allow_unicode is not False:\n            kwargs[\"allow_unicode\"] = self.allow_unicode\n        return name, path, args, kwargs\n\n    def get_internal_type(self):\n        return \"SlugField\"\n\n    def formfield(self, **kwargs):\n        return super().formfield(\n            **{\n                \"form_class\": forms.SlugField,\n                \"allow_unicode\": self.allow_unicode,\n                **kwargs,\n            }\n        )\n\n\nclass TextField(Field):\n    description = _(\"Text",
                "filename": "django/db/models/fields/__init__.py",
                "start_index": 81903,
                "end_index": 83476,
                "start_line": 2377,
                "end_line": 2430,
                "max_line": 2869,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.0
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/db/models/enums.py": [
                {
                    "chunk": {
                        "code": "import enum\nfrom types import DynamicClassAttribute\n\nfrom django.utils.functional import Promise\n\n__all__ = [\"Choices\", \"IntegerChoices\", \"TextChoices\"]\n\n\nclass ChoicesMeta(enum.EnumMeta):\n    \"\"\"A metaclass for creating a enum choices.\"\"\"\n\n    def __new__(metacls, classname, bases, classdict, **kwds):\n        labels = []\n        for key in classdict._member_names:\n            value = classdict[key]\n            if (\n                isinstance(value, (list, tuple))\n                and len(value) > 1\n                and isinstance(value[-1], (Promise, str))\n            ):\n                *value, label = value\n                value = tuple(value)\n            else:\n                label = key.replace(\"_\", \" \").title()\n            labels.append(label)\n            # Use dict.__setitem__() to suppress defenses against double\n            # assignment in enum's classdict.\n            dict.__setitem__(classdict, key, value)\n        cls = super().__new__(metacls, classname, bases, classdict, **kwds)\n        for member, label in zip(cls.__members__.values(), labels):\n            member._label_ = label\n        return enum.unique(cls)\n\n    def __contains__(cls, member):\n        if not isinstance(member, enum.Enum):\n            # Allow non-enums to match against member values.\n            return any(x.value == member for x in cls)\n        return super().__contains__(member)\n\n    @property\n    def names(cls):\n        empty = [\"__empty__\"] if hasattr(cls, \"__empty__\") else []\n        return empty + [member.name for member in cls]\n\n    @property\n    def choices(cls):\n        empty = [(None, cls.__empty__)] if hasattr(cls, \"__empty__\") else []\n        return empty + [(member.value, member.label) for member in cls]\n\n    @property\n    def labels(cls):\n        return [label for _, label in cls.choices]\n\n    @property\n    def values(cls):\n        return [value for value, _ in cls.choices]\n\n\nclass Choices(enum.Enum, metaclass=ChoicesMeta):\n    \"\"\"Class for creating enumerated choices.\"\"\"\n\n    @DynamicClassAttribute\n    def label(self):\n        return self._label_\n\n    @property\n    def do_not_call_in_templates(self):\n        return True\n\n    def __str__(self):\n        \"\"\"\n        Use value when cast to str, so that Choices set as model instance\n        attributes are rendered as expected in templates and similar contexts.\n        \"\"\"\n        return str(self.value)\n\n    # A similar format was proposed for Python 3.10.\n    def __repr__(self):\n        return f\"{self.__class__.__qualname__}.{self._name_}\"\n\n\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n\n    pass\n\n\nclass TextChoices(str, Choices):\n    \"\"\"Class for creating enumerated string choices.\"\"\"\n\n    def _generate_next_value_(name, start, count, last_values):\n        return name",
                        "filename": "django/db/models/enums.py",
                        "start_index": 0,
                        "end_index": 2803,
                        "start_line": 1,
                        "end_line": 92,
                        "max_line": 92,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the ChoicesMeta and Choices classes which are related to enumeration types that are not usable in templates. The issue can be fixed by modifying the Choices class to include the 'do_not_call_in_templates' attribute."
                }
            ]
        },
        "solution_task": "- Add the `do_not_call_in_templates` attribute to the `YearInSchool` enumeration class.\n- Ensure that `YearInSchool` inherits from `TextChoices` to utilize the `ChoicesMeta` metaclass which already contains the `do_not_call_in_templates` property.\n\n```python\nfrom django.db import models\n\nclass YearInSchool(models.TextChoices):\n    FRESHMAN = 'FR', 'Freshman'\n    SOPHOMORE = 'SO', 'Sophomore'\n    # ... other choices ...\n```\n\n- Update the template snippet to compare the string representation of `student.year_in_school` with the string representation of `YearInSchool.FRESHMAN`.\n\n```django\n{% if student.year_in_school == 'FR' %}\n```",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT. It suggests adding the 'do_not_call_in_templates' attribute to the 'YearInSchool' enumeration class, which is a direct response to the issue of enumeration types being callable in Django templates. Furthermore, it advises ensuring that 'YearInSchool' inherits from 'TextChoices', which is relevant because the 'ChoicesMeta' metaclass contains the 'do_not_call_in_templates' property, addressing the root cause of the problem. The RESPONSE also includes a practical update to the template snippet, suggesting a comparison of string representations, which is a valid workaround for the issue. Lastly, the RESPONSE provides a link to the relevant code snippets, which is helpful for implementing the suggested changes. The only reason it does not score a 10 is that it does not explicitly state that the 'do_not_call_in_templates' attribute should be set to True, which is a minor detail that could be inferred.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711731810.782464,
        "result": "- Add the `do_not_call_in_templates` attribute to the `YearInSchool` enumeration class.\n- Ensure that `YearInSchool` inherits from `TextChoices` to utilize the `ChoicesMeta` metaclass which already contains the `do_not_call_in_templates` property.\n\n```python\nfrom django.db import models\n\nclass YearInSchool(models.TextChoices):\n    FRESHMAN = 'FR', 'Freshman'\n    SOPHOMORE = 'SO', 'Sophomore'\n    # ... other choices ...\n```\n\n- Update the template snippet to compare the string representation of `student.year_in_school` with the string representation of `YearInSchool.FRESHMAN`.\n\n```django\n{% if student.year_in_school == 'FR' %}\n```\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [db](https://github.com/testbed/django__django__3.1/tree//django/db) \u2192 [models](https://github.com/testbed/django__django__3.1/tree//django/db/models)- [Lines 1 - 92](https://github.com/testbed/django__django__3.1/blob//django/db/models/enums.py#L1-L92)\n\n This snippet defines the ChoicesMeta and Choices classes which are related to enumeration types that are not usable in templates. The issue can be fixed by modifying the Choices class to include the 'do_not_call_in_templates' attribute.",
        "context_relevance": 0.18,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT and answer it completely to get a score of 10.\nSupporting Evidence: The RESPONSE directly addresses the issue described in the PROMPT by providing a solution to make enumeration types usable in Django templates. It suggests adding the `do_not_call_in_templates` attribute to the `YearInSchool` enumeration class and ensuring it inherits from `TextChoices`. Additionally, it provides a code snippet to update the template comparison, which is a practical solution to the problem described. The RESPONSE also references the relevant code snippets in the Django repository, which is directly related to the issue at hand. The RESPONSE is relevant to the entire PROMPT and answers it completely, thus meeting the criteria for a score of 10."
        },
        "qa_relevance": 1.0
    }
}