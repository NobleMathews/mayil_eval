{
    "id": "django__django-15206",
    "repo_name": "testbed/django__django__4.1",
    "task_id": 4256868793548147605,
    "title": "never_cache()/cache_control() decorators raise error on duck-typed requests.",
    "body": "Description\n\t\nThe cache decorators cache_control, never_cache and sensitive_post_parameters no longer work with Django REST framework because they strictly check for an HttpRequest instance.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__4.1.git",
    "requested_commit": "",
    "mayil_response": "To resolve the issue with the compatibility of Django cache decorators with Django REST framework requests, you should:\n\n- Create a custom decorator that checks if the request object is an instance of `rest_framework.request.Request` and extracts the underlying Django `HttpRequest` object if necessary.\n- Apply this custom decorator to your views before applying the `never_cache`, `cache_control`, and `sensitive_post_parameters` decorators.\n\nHere is an example of how you can create and use such a custom decorator:\n\n```python\nfrom functools import wraps\nfrom django.utils.decorators import available_attrs\nfrom rest_framework.request import Request as DRFRequest\n\ndef ensure_django_request(view_func):\n    @wraps(view_func, assigned=available_attrs(view_func))\n    def _wrapped_view(view, request, *args, **kwargs):\n        # If the request is a DRF Request, use the underlying Django HttpRequest\n        if isinstance(request, DRFRequest):\n            request = request._request\n        return view_func(view, request, *args, **kwargs)\n    return _wrapped_view\n\n# Usage with Django views\n@ensure_django_request\n@never_cache\n@cache_control(max_age=0, no_cache=True, no_store=True, must_revalidate=True)\n@sensitive_post_parameters('password', 'credit_card_number')\ndef my_view(request):\n    # ...\n```\n\nThis custom decorator should be applied to each view before the other decorators to ensure that they receive a proper `HttpRequest` object.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.1/tree//django) \u2192 [views](https://github.com/testbed/django__django__4.1/tree//django/views) \u2192 [decorators](https://github.com/testbed/django__django__4.1/tree//django/views/decorators)- [Lines 1 - 84](https://github.com/testbed/django__django__4.1/blob//django/views/decorators/cache.py#L1-L84)\n\n This snippet contains the cache_control and never_cache decorators which are mentioned in the issue as not working with Django REST framework due to strict HttpRequest instance checks.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0003315,
        "snippet_processor": 0.05657000000000001,
        "issue_star_creation": 0.02274,
        "issue_star_solver": 0.055200000000000006,
        "bouncer": 0.02198
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711719796.957618,
        "relevant_snippets": [
            {
                "code": "\"\"\"\nDecorators for views based on HTTP headers.\n\"\"\"\nimport datetime\nfrom functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.http import HttpResponseNotAllowed\nfrom django.middleware.http import ConditionalGetMiddleware\nfrom django.utils import timezone\nfrom django.utils.cache import get_conditional_response\nfrom django.utils.decorators import decorator_from_middleware\nfrom django.utils.http import http_date, quote_etag\nfrom django.utils.log import log_response\n\nconditional_page = decorator_from_middleware(ConditionalGetMiddleware)\n\n\ndef require_http_methods(request_method_list):\n    \"\"\"\n    Decorator to make a view only accept particular request methods.  Usage::\n\n        @require_http_methods([\"GET\", \"POST\"])\n        def my_view(request):\n            # I can assume now that only GET or POST requests make it this far\n            # ...\n\n    Note that request methods should be in uppercase.\n    \"\"\"\n\n    def decorator(func):\n        if iscoroutinefunction(func):\n\n            @wraps(func)\n            async def inner(request, *args, **kwargs):\n                if request.method not in request_method_list:\n                    response = HttpResponseNotAllowed(request_method_list)\n                    log_response(\n                        \"Method Not Allowed (%s): %s\",\n                        request.method,\n                        request.path,\n                        response=response,\n                        request=request,\n                    )\n                    return response\n                return await func(request, *args, **kwargs)\n\n        else:\n\n            @wraps(func)\n            def inner(request, *args, **kwargs):\n                if request.method not in request_method_list:\n                    response = HttpResponseNotAllowed(request_method_list)\n                    log_response(\n                        \"Method Not Allowed (%s): %s\",\n                        request.method,\n                        request.path,\n                        response=response,\n                        request=request,\n                    )\n                    return response\n                return func(request, *args, **kwargs)\n\n        return inner\n\n    return decorator\n\n\nrequire_GET = require_http_methods([\"GET\"])\nrequire_GET.__doc__ = \"Decorator to require that a view only accepts the GET method.\"\n\nrequire_POST = require_http_methods([\"POST\"])\nrequire_POST.__doc__ = \"Decorator to require that a view only accepts the POST method.\"\n\nrequire_safe = require_http_methods([\"GET\", \"HEAD\"])\nrequire_safe.__doc__ = (\n    \"Decorator to require that a view only accepts safe methods: GET and HEAD.\"\n)",
                "filename": "django/views/decorators/http.py",
                "start_index": 0,
                "end_index": 2653,
                "start_line": 1,
                "end_line": 168,
                "max_line": 168,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.middleware.cache import CacheMiddleware\nfrom django.utils.cache import add_never_cache_headers, patch_cache_control\nfrom django.utils.decorators import decorator_from_middleware_with_args\n\n\ndef cache_page(timeout, *, cache=None, key_prefix=None):\n    \"\"\"\n    Decorator for views that tries getting the page from the cache and\n    populates the cache if the page isn't in the cache yet.\n\n    The cache is keyed by the URL and some data from the headers.\n    Additionally there is the key prefix that is used to distinguish different\n    cache areas in a multi-site setup. You could use the\n    get_current_site().domain, for example, as that is unique across a Django\n    project.\n\n    Additionally, all headers from the response's Vary header will be taken\n    into account on caching -- just like the middleware does.\n    \"\"\"\n    return decorator_from_middleware_with_args(CacheMiddleware)(\n        page_timeout=timeout,\n        cache_alias=cache,\n        key_prefix=key_prefix,\n    )\n\n\ndef _check_request(request, decorator_name):\n    # Ensure argument looks like a request.\n    if not hasattr(request, \"META\"):\n        raise TypeError(\n            f\"{decorator_name} didn't receive an HttpRequest. If you are \"\n            \"decorating a classmethod, be sure to use @method_decorator.\"\n        )\n\n\ndef cache_control(**kwargs):\n    def _cache_controller(viewfunc):\n        if iscoroutinefunction(viewfunc):\n\n            async def _view_wrapper(request, *args, **kw):\n                _check_request(request, \"cache_control\")\n                response = await viewfunc(request, *args, **kw)\n                patch_cache_control(response, **kwargs)\n                return response\n\n        else:\n\n            def _view_wrapper(request, *args, **kw):\n                _check_request(request, \"cache_control\")\n                response = viewfunc(request, *args, **kw)\n                patch_cache_control(response, **kwargs)\n                return response\n\n        return wraps(viewfunc)(_view_wrapper)\n\n    return _cache_controller\n\n\ndef never_cache(view_func):\n    \"\"\"\n    Decorator that adds headers to a response so that it will never be cached.\n    \"\"\"\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            _check_request(request, \"never_cache\")\n            response = await view_func(request, *args, **kwargs)\n            add_never_cache_headers(response)\n            return response\n\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            _check_request(request, \"never_cache\")\n            response = view_func(request, *args, **kwargs)\n            add_never_cache_headers(response)\n            return response\n\n    return wraps(view_func)(_view_wrapper)",
                "filename": "django/views/decorators/cache.py",
                "start_index": 0,
                "end_index": 2820,
                "start_line": 1,
                "end_line": 84,
                "max_line": 84,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "def decorator(func):\n        def _pre_process_request(request, *args, **kwargs):\n            # Compute values (if any) for the requested resource.\n            res_last_modified = None\n            if last_modified_func:\n                if dt := last_modified_func(request, *args, **kwargs):\n                    if not timezone.is_aware(dt):\n                        dt = timezone.make_aware(dt, datetime.timezone.utc)\n                    res_last_modified = int(dt.timestamp())\n            # The value from etag_func() could be quoted or unquoted.\n            res_etag = etag_func(request, *args, **kwargs) if etag_func else None\n            res_etag = quote_etag(res_etag) if res_etag is not None else None\n            response = get_conditional_response(\n                request,\n                etag=res_etag,\n                last_modified=res_last_modified,\n            )\n            return response, res_etag, res_last_modified\n\n        def _post_process_request(request, response, res_etag, res_last_modified):\n            # Set relevant headers on the response if they don't already exist\n            # and if the request method is safe.\n            if request.method in (\"GET\", \"HEAD\"):\n                if res_last_modified and not response.has_header(\"Last-Modified\"):\n                    response.headers[\"Last-Modified\"] = http_date(res_last_modified)\n                if res_etag:\n                    response.headers.setdefault(\"ETag\", res_etag)\n\n        if iscoroutinefunction(func):\n\n            @wraps(func)\n            async def inner(request, *args, **kwargs):\n                response, res_etag, res_last_modified = _pre_process_request(\n                    request, *args, **kwargs\n                )\n                if response is None:\n                    response = await func(request, *args, **kwargs)\n                _post_process_request(request, response, res_etag, res_last_modified)\n                return response\n\n        else:\n\n            @wraps(func)\n            def inner(request, *args, **kwargs):\n                response, res_etag, res_last_modified = _pre_process_request(\n                    request, *args, **kwargs\n                )\n                if response is None:\n                    response = func(request, *args, **kwargs)\n                _post_process_request(request, response, res_etag, res_last_modified)\n                return response\n\n        return inner\n\n    return decorator",
                "filename": "django/views/decorators/http.py",
                "start_index": 3859,
                "end_index": 6290,
                "start_line": 32,
                "end_line": 159,
                "max_line": 168,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class DeprecationInstanceCheck(type):\n    def __instancecheck__(self, instance):\n        warnings.warn(\n            \"`%s` is deprecated, use `%s` instead.\" % (self.__name__, self.alternative),\n            self.deprecation_warning,\n            2,\n        )\n        return super().__instancecheck__(instance)\n\n\nclass MiddlewareMixin:\n    sync_capable = True\n    async_capable = True\n\n    def __init__(self, get_response):\n        if get_response is None:\n            raise ValueError(\"get_response must be provided.\")\n        self.get_response = get_response\n        self._async_check()\n        super().__init__()\n\n    def __repr__(self):\n        return \"<%s get_response=%s>\" % (\n            self.__class__.__qualname__,\n            getattr(\n                self.get_response,\n                \"__qualname__\",\n                self.get_response.__class__.__name__,\n            ),\n        )\n\n    def _async_check(self):\n        \"\"\"\n        If get_response is a coroutine function, turns us into async mode so\n        a thread is not consumed during a whole request.\n        \"\"\"\n        if iscoroutinefunction(self.get_response):\n            # Mark the class as async-capable, but do the actual switch\n            # inside __call__ to avoid swapping out dunder methods\n            markcoroutinefunction(self)\n\n    def __call__(self, request):\n        # Exit out to async mode, if needed\n        if iscoroutinefunction(self):\n            return self.__acall__(request)\n        response = None\n        if hasattr(self, \"process_request\"):\n            response = self.process_request(request)\n        response = response or self.get_response(request)\n        if hasattr(self, \"process_response\"):\n            response = self.process_response(request, response)\n        return response\n\n    async def __acall__(self, request):\n        \"\"\"\n        Async version of __call__ that is swapped in when an async request\n        is running.\n        \"\"\"\n        response = None\n        if hasattr(self, \"process_request\"):\n            response = await sync_to_async(\n                self.process_request,\n                thread_sensitive=True,\n            )(request)\n        response = response or await self.get_response(request)\n        if hasattr(self, \"process_response\"):\n            response = await sync_to_async(\n                self.process_response,\n                thread_sensitive=True,\n            )(request, response)\n        return response",
                "filename": "django/utils/deprecation.py",
                "start_index": 2790,
                "end_index": 5228,
                "start_line": 86,
                "end_line": 156,
                "max_line": 156,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\nThis module contains helper functions for controlling caching. It does so by\nmanaging the \"Vary\" header of responses. It includes functions to patch the\nheader of response objects directly and decorators that change functions to do\nthat header-patching themselves.\n\nFor information on the Vary header, see RFC 9110 Section 12.5.5.\n\nEssentially, the \"Vary\" HTTP header defines which headers a cache should take\ninto account when building its cache key. Requests with the same path but\ndifferent header content for headers named in \"Vary\" need to get different\ncache keys to prevent delivery of wrong content.\n\nAn example: i18n middleware would need to distinguish caches by the\n\"Accept-language\" header.\n\"\"\"\nimport time\nfrom collections import defaultdict\nfrom hashlib import md5\n\nfrom django.conf import settings\nfrom django.core.cache import caches\nfrom django.http import HttpResponse, HttpResponseNotModified\nfrom django.utils.http import http_date, parse_etags, parse_http_date_safe, quote_etag\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_current_timezone_name\nfrom django.utils.translation import get_language\n\ncc_delim_re = _lazy_re_compile(r\"\\s*,\\s*\")",
                "filename": "django/utils/cache.py",
                "start_index": 0,
                "end_index": 1253,
                "start_line": 1,
                "end_line": 30,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "import pathlib\n\nfrom django.conf import settings\nfrom django.core.cache import DEFAULT_CACHE_ALIAS, caches\nfrom django.core.cache.backends.filebased import FileBasedCache\n\nfrom . import Error, Tags, Warning, register\n\nE001 = Error(\n    \"You must define a '%s' cache in your CACHES setting.\" % DEFAULT_CACHE_ALIAS,\n    id=\"caches.E001\",\n)\n\n\n@register(Tags.caches)\ndef check_default_cache_is_configured(app_configs, **kwargs):\n    if DEFAULT_CACHE_ALIAS not in settings.CACHES:\n        return [E001]\n    return []\n\n\n@register(Tags.caches, deploy=True)\ndef check_cache_location_not_exposed(app_configs, **kwargs):\n    errors = []\n    for name in (\"MEDIA_ROOT\", \"STATIC_ROOT\", \"STATICFILES_DIRS\"):\n        setting = getattr(settings, name, None)\n        if not setting:\n            continue\n        if name == \"STATICFILES_DIRS\":\n            paths = set()\n            for staticfiles_dir in setting:\n                if isinstance(staticfiles_dir, (list, tuple)):\n                    _, staticfiles_dir = staticfiles_dir\n                paths.add(pathlib.Path(staticfiles_dir).resolve())\n        else:\n            paths = {pathlib.Path(setting).resolve()}\n        for alias in settings.CACHES:\n            cache = caches[alias]\n            if not isinstance(cache, FileBasedCache):\n                continue\n            cache_path = pathlib.Path(cache._dir).resolve()\n            if any(path == cache_path for path in paths):\n                relation = \"matches\"\n            elif any(path in cache_path.parents for path in paths):\n                relation = \"is inside\"\n            elif any(cache_path in path.parents for path in paths):\n                relation = \"contains\"\n            else:\n                continue\n            errors.append(\n                Warning(\n                    f\"Your '{alias}' cache configuration might expose your cache \"\n                    f\"or lead to corruption of your data because its LOCATION \"\n                    f\"{relation} {name}.\",\n                    id=\"caches.W002\",\n                )\n            )\n    return errors\n\n\n@register(Tags.caches)\ndef check_file_based_cache_is_absolute(app_configs, **kwargs):\n    errors = []\n    for alias, config in settings.CACHES.items():\n        cache = caches[alias]\n        if not isinstance(cache, FileBasedCache):\n            continue\n        if not pathlib.Path(config[\"LOCATION\"]).is_absolute():\n            errors.append(\n                Warning(\n                    f\"Your '{alias}' cache LOCATION path is relative. Use an \"\n                    f\"absolute path instead.\",\n                    id=\"caches.W003\",\n                )\n            )\n    return errors",
                "filename": "django/core/checks/caches.py",
                "start_index": 0,
                "end_index": 2642,
                "start_line": 1,
                "end_line": 76,
                "max_line": 76,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import codecs\nimport copy\nfrom io import BytesIO\nfrom itertools import chain\nfrom urllib.parse import parse_qsl, quote, urlencode, urljoin, urlsplit\n\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.core.exceptions import (\n    DisallowedHost,\n    ImproperlyConfigured,\n    RequestDataTooBig,\n    TooManyFieldsSent,\n)\nfrom django.core.files import uploadhandler\nfrom django.http.multipartparser import (\n    MultiPartParser,\n    MultiPartParserError,\n    TooManyFilesSent,\n)\nfrom django.utils.datastructures import (\n    CaseInsensitiveMapping,\n    ImmutableList,\n    MultiValueDict,\n)\nfrom django.utils.encoding import escape_uri_path, iri_to_uri\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain, parse_header_parameters\nfrom django.utils.regex_helper import _lazy_re_compile\n\nRAISE_ERROR = object()\nhost_validation_re = _lazy_re_compile(\n    r\"^([a-z0-9.-]+|\\[[a-f0-9]*:[a-f0-9\\.:]+\\])(:[0-9]+)?$\"\n)\n\n\nclass UnreadablePostError(OSError):\n    pass\n\n\nclass RawPostDataException(Exception):\n    \"\"\"\n    You cannot access raw_post_data from a request that has\n    multipart/* POST data if it has been accessed via POST,\n    FILES, etc..\n    \"\"\"\n\n    pass",
                "filename": "django/http/request.py",
                "start_index": 0,
                "end_index": 1228,
                "start_line": 1,
                "end_line": 108,
                "max_line": 737,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.utils.cache import patch_vary_headers\n\n\ndef vary_on_headers(*headers):\n    \"\"\"\n    A view decorator that adds the specified headers to the Vary header of the\n    response. Usage:\n\n       @vary_on_headers('Cookie', 'Accept-language')\n       def index(request):\n           ...\n\n    Note that the header names are not case-sensitive.\n    \"\"\"\n\n    def decorator(func):\n        if iscoroutinefunction(func):\n\n            async def _view_wrapper(request, *args, **kwargs):\n                response = await func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n\n        else:\n\n            def _view_wrapper(request, *args, **kwargs):\n                response = func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n\n        return wraps(func)(_view_wrapper)\n\n    return decorator\n\n\nvary_on_cookie = vary_on_headers(\"Cookie\")\nvary_on_cookie.__doc__ = (\n    'A view decorator that adds \"Cookie\" to the Vary header of a response. This '\n    \"indicates that a page's contents depends on cookies.\"\n)",
                "filename": "django/views/decorators/vary.py",
                "start_index": 0,
                "end_index": 1200,
                "start_line": 1,
                "end_line": 44,
                "max_line": 44,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _if_none_match_passes(target_etag, etags):\n    \"\"\"\n    Test the If-None-Match comparison as defined in RFC 9110 Section 13.1.2.\n    \"\"\"\n    if not target_etag:\n        # If there isn't an ETag, then there isn't a match.\n        return True\n    elif etags == [\"*\"]:\n        # The existence of an ETag means that there is \"a current\n        # representation for the target resource\", so there is a match to '*'.\n        return False\n    else:\n        # The comparison should be weak, so look for a match after stripping\n        # off any weak indicators.\n        target_etag = target_etag.strip(\"W/\")\n        etags = (etag.strip(\"W/\") for etag in etags)\n        return target_etag not in etags\n\n\ndef _if_modified_since_passes(last_modified, if_modified_since):\n    \"\"\"\n    Test the If-Modified-Since comparison as defined in RFC 9110 Section\n    13.1.3.\n    \"\"\"\n    return not last_modified or last_modified > if_modified_since\n\n\ndef patch_response_headers(response, cache_timeout=None):\n    \"\"\"\n    Add HTTP caching headers to the given HttpResponse: Expires and\n    Cache-Control.\n\n    Each header is only added if it isn't already set.\n\n    cache_timeout is in seconds. The CACHE_MIDDLEWARE_SECONDS setting is used\n    by default.\n    \"\"\"\n    if cache_timeout is None:\n        cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n    if cache_timeout < 0:\n        cache_timeout = 0  # Can't have max-age negative\n    if not response.has_header(\"Expires\"):\n        response.headers[\"Expires\"] = http_date(time.time() + cache_timeout)\n    patch_cache_control(response, max_age=cache_timeout)\n\n\ndef add_never_cache_headers(response):\n    \"\"\"\n    Add headers to a response to indicate that a page should never be cached.\n    \"\"\"\n    patch_response_headers(response, cache_timeout=-1)\n    patch_cache_control(\n        response, no_cache=True, no_store=True, must_revalidate=True, private=True\n    )",
                "filename": "django/utils/cache.py",
                "start_index": 8517,
                "end_index": 10412,
                "start_line": 242,
                "end_line": 372,
                "max_line": 443,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.middleware.csrf import CsrfViewMiddleware, get_token\nfrom django.utils.decorators import decorator_from_middleware\n\ncsrf_protect = decorator_from_middleware(CsrfViewMiddleware)\ncsrf_protect.__name__ = \"csrf_protect\"\ncsrf_protect.__doc__ = \"\"\"\nThis decorator adds CSRF protection in exactly the same way as\nCsrfViewMiddleware, but it can be used on a per view basis.  Using both, or\nusing the decorator multiple times, is harmless and efficient.\n\"\"\"\n\n\nclass _EnsureCsrfToken(CsrfViewMiddleware):\n    # Behave like CsrfViewMiddleware but don't reject requests or log warnings.\n    def _reject(self, request, reason):\n        return None\n\n\nrequires_csrf_token = decorator_from_middleware(_EnsureCsrfToken)\nrequires_csrf_token.__name__ = \"requires_csrf_token\"\nrequires_csrf_token.__doc__ = \"\"\"\nUse this decorator on views that need a correct csrf_token available to\nRequestContext, but without the CSRF protection that csrf_protect\nenforces.\n\"\"\"\n\n\nclass _EnsureCsrfCookie(CsrfViewMiddleware):\n    def _reject(self, request, reason):\n        return None\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        retval = super().process_view(request, callback, callback_args, callback_kwargs)\n        # Force process_response to send the cookie\n        get_token(request)\n        return retval\n\n\nensure_csrf_cookie = decorator_from_middleware(_EnsureCsrfCookie)\nensure_csrf_cookie.__name__ = \"ensure_csrf_cookie\"\nensure_csrf_cookie.__doc__ = \"\"\"\nUse this decorator to ensure that a view sets a CSRF cookie, whether or not it\nuses the csrf_token template tag, or the CsrfViewMiddleware is used.\n\"\"\"\n\n\ndef csrf_exempt(view_func):\n    \"\"\"Mark a view function as being exempt from the CSRF view protection.\"\"\"\n\n    # view_func.csrf_exempt = True would also work, but decorators are nicer\n    # if they don't have side effects, so return a new function.\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            return await view_func(request, *args, **kwargs)\n\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            return view_func(request, *args, **kwargs)\n\n    _view_wrapper.csrf_exempt = True\n\n    return wraps(view_func)(_view_wrapper)",
                "filename": "django/views/decorators/csrf.py",
                "start_index": 0,
                "end_index": 2323,
                "start_line": 1,
                "end_line": 69,
                "max_line": 69,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/views/decorators/cache.py": [
                {
                    "chunk": {
                        "code": "from functools import wraps\n\nfrom asgiref.sync import iscoroutinefunction\n\nfrom django.middleware.cache import CacheMiddleware\nfrom django.utils.cache import add_never_cache_headers, patch_cache_control\nfrom django.utils.decorators import decorator_from_middleware_with_args\n\n\ndef cache_page(timeout, *, cache=None, key_prefix=None):\n    \"\"\"\n    Decorator for views that tries getting the page from the cache and\n    populates the cache if the page isn't in the cache yet.\n\n    The cache is keyed by the URL and some data from the headers.\n    Additionally there is the key prefix that is used to distinguish different\n    cache areas in a multi-site setup. You could use the\n    get_current_site().domain, for example, as that is unique across a Django\n    project.\n\n    Additionally, all headers from the response's Vary header will be taken\n    into account on caching -- just like the middleware does.\n    \"\"\"\n    return decorator_from_middleware_with_args(CacheMiddleware)(\n        page_timeout=timeout,\n        cache_alias=cache,\n        key_prefix=key_prefix,\n    )\n\n\ndef _check_request(request, decorator_name):\n    # Ensure argument looks like a request.\n    if not hasattr(request, \"META\"):\n        raise TypeError(\n            f\"{decorator_name} didn't receive an HttpRequest. If you are \"\n            \"decorating a classmethod, be sure to use @method_decorator.\"\n        )\n\n\ndef cache_control(**kwargs):\n    def _cache_controller(viewfunc):\n        if iscoroutinefunction(viewfunc):\n\n            async def _view_wrapper(request, *args, **kw):\n                _check_request(request, \"cache_control\")\n                response = await viewfunc(request, *args, **kw)\n                patch_cache_control(response, **kwargs)\n                return response\n\n        else:\n\n            def _view_wrapper(request, *args, **kw):\n                _check_request(request, \"cache_control\")\n                response = viewfunc(request, *args, **kw)\n                patch_cache_control(response, **kwargs)\n                return response\n\n        return wraps(viewfunc)(_view_wrapper)\n\n    return _cache_controller\n\n\ndef never_cache(view_func):\n    \"\"\"\n    Decorator that adds headers to a response so that it will never be cached.\n    \"\"\"\n\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            _check_request(request, \"never_cache\")\n            response = await view_func(request, *args, **kwargs)\n            add_never_cache_headers(response)\n            return response\n\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            _check_request(request, \"never_cache\")\n            response = view_func(request, *args, **kwargs)\n            add_never_cache_headers(response)\n            return response\n\n    return wraps(view_func)(_view_wrapper)",
                        "filename": "django/views/decorators/cache.py",
                        "start_index": 0,
                        "end_index": 2820,
                        "start_line": 1,
                        "end_line": 84,
                        "max_line": 84,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the cache_control and never_cache decorators which are mentioned in the issue as not working with Django REST framework due to strict HttpRequest instance checks."
                }
            ]
        },
        "solution_task": "To resolve the issue with the compatibility of Django cache decorators with Django REST framework requests, you should:\n\n- Create a custom decorator that checks if the request object is an instance of `rest_framework.request.Request` and extracts the underlying Django `HttpRequest` object if necessary.\n- Apply this custom decorator to your views before applying the `never_cache`, `cache_control`, and `sensitive_post_parameters` decorators.\n\nHere is an example of how you can create and use such a custom decorator:\n\n```python\nfrom functools import wraps\nfrom django.utils.decorators import available_attrs\nfrom rest_framework.request import Request as DRFRequest\n\ndef ensure_django_request(view_func):\n    @wraps(view_func, assigned=available_attrs(view_func))\n    def _wrapped_view(view, request, *args, **kwargs):\n        # If the request is a DRF Request, use the underlying Django HttpRequest\n        if isinstance(request, DRFRequest):\n            request = request._request\n        return view_func(view, request, *args, **kwargs)\n    return _wrapped_view\n\n# Usage with Django views\n@ensure_django_request\n@never_cache\n@cache_control(max_age=0, no_cache=True, no_store=True, must_revalidate=True)\n@sensitive_post_parameters('password', 'credit_card_number')\ndef my_view(request):\n    # ...\n```\n\nThis custom decorator should be applied to each view before the other decorators to ensure that they receive a proper `HttpRequest` object.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT, which is the incompatibility of Django cache decorators with Django REST framework requests. The RESPONSE suggests creating a custom decorator to ensure that the request object is a proper HttpRequest instance before applying the cache decorators. It also includes a code example that demonstrates how to implement and use the custom decorator, which is directly applicable to the issue at hand. The RESPONSE is highly relevant and offers a comprehensive guide to address the problem. The only reason it does not score a 10 is that it does not explicitly mention testing the solution or considering any potential side effects, which would be the final steps in fully resolving the issue.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711719992.489934,
        "result": "To resolve the issue with the compatibility of Django cache decorators with Django REST framework requests, you should:\n\n- Create a custom decorator that checks if the request object is an instance of `rest_framework.request.Request` and extracts the underlying Django `HttpRequest` object if necessary.\n- Apply this custom decorator to your views before applying the `never_cache`, `cache_control`, and `sensitive_post_parameters` decorators.\n\nHere is an example of how you can create and use such a custom decorator:\n\n```python\nfrom functools import wraps\nfrom django.utils.decorators import available_attrs\nfrom rest_framework.request import Request as DRFRequest\n\ndef ensure_django_request(view_func):\n    @wraps(view_func, assigned=available_attrs(view_func))\n    def _wrapped_view(view, request, *args, **kwargs):\n        # If the request is a DRF Request, use the underlying Django HttpRequest\n        if isinstance(request, DRFRequest):\n            request = request._request\n        return view_func(view, request, *args, **kwargs)\n    return _wrapped_view\n\n# Usage with Django views\n@ensure_django_request\n@never_cache\n@cache_control(max_age=0, no_cache=True, no_store=True, must_revalidate=True)\n@sensitive_post_parameters('password', 'credit_card_number')\ndef my_view(request):\n    # ...\n```\n\nThis custom decorator should be applied to each view before the other decorators to ensure that they receive a proper `HttpRequest` object.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.1/tree//django) \u2192 [views](https://github.com/testbed/django__django__4.1/tree//django/views) \u2192 [decorators](https://github.com/testbed/django__django__4.1/tree//django/views/decorators)- [Lines 1 - 84](https://github.com/testbed/django__django__4.1/blob//django/views/decorators/cache.py#L1-L84)\n\n This snippet contains the cache_control and never_cache decorators which are mentioned in the issue as not working with Django REST framework due to strict HttpRequest instance checks.",
        "context_relevance": 0.33,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE directly addresses the issue described in the PROMPT by providing a solution to the compatibility problem between Django cache decorators and Django REST framework requests. It offers a detailed explanation and a code example of how to create a custom decorator to ensure that the cache decorators receive a proper HttpRequest object. The RESPONSE also includes a reference to the code snippets that are relevant to the issue, which is a direct response to the PROMPT's description of the problem with the cache decorators. The RESPONSE is comprehensive, relevant to all parts of the PROMPT, and provides a complete answer, thus meriting a score of 10."
        },
        "qa_relevance": 1.0
    }
}