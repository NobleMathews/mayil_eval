{
    "id": "matplotlib__matplotlib-20374",
    "repo_name": "testbed/matplotlib__matplotlib__3.4",
    "task_id": 3952295647185439439,
    "title": "plot_directive is confused by include directives, part 2 (context option)",
    "body": "### Bug summary\r\n\r\nWhenever a file `b.rst` is included in `a.rst` via the RST `include` directive, Sphinx rebuilds the `a.html` page; but in plot_directive, `a.rst` is not considered 'out of date' (as judged by the `out_of_date()` function), because the modification time of `a.rst` was not changed.\r\n\r\nThis discrepancy is part of the reason why #17860 exists; and while working on it (at PR #20374) I discovered also that figures with the `:context:` option set will get confused. A specific example is shown below. It's quite hard to encounter in real life but it is directly relevant to matplotlib's tests as there is a very similar construct in plots 6-9 of matplotlib's `test_sphinxext.py`.\r\n\r\n### Code for reproduction\r\n\r\n**conf.py**\r\n```python\r\nextensions = ['matplotlib.sphinxext.plot_directive']\r\nexclude_patterns = ['_build']\r\n```\r\n\r\n**index.rst**\r\n```rst\r\nIndex\r\n=====\r\n\r\n.. toctree::\r\n   \r\n   a\r\n   b\r\n```\r\n\r\n**a.rst**\r\n```rst\r\nFile A\r\n======\r\n\r\nIt's important that the first plot produces an image, and also sets a variable\r\nvia ``:context:``.\r\n\r\n\r\n.. plot::\r\n   :context:\r\n\r\n   plt.plot(range(2))\r\n   a = 1  \r\n\r\nThe second plot must not use ``:context:``. It doesn't necessarily have to\r\nproduce an image. The important thing is that it must close the figure from the\r\nprevious plot, so that the third plot doesn't actually produce an image (if\r\nfigures aren't closed, then the third plot will reuse the same image from the\r\nfirst plot).\r\n\r\n.. plot::\r\n\r\n   plt.plot(range(3))\r\n\r\nThe third plot must try to use a variable previously saved in `:context:`` and\r\nmust not produce an image.\r\n\r\n\r\n.. plot::\r\n   :context:\r\n\r\n   assert a == 1\r\n\r\nLastly we include another file.\r\n\r\n.. include:: b.rst\r\n```\r\n\r\n**b.rst**\r\n```rst\r\nFile B\r\n======\r\n\r\nThis can be anything.\r\n```\r\n\r\n\r\n### Steps to reproduce\r\n\r\n1. Put the four files above in a directory and `cd` into it.\r\n2. Build the docs the first time using `sphinx-build -b html . ./_build/html`.\r\n3. Modify `b.rst` in any way.\r\n4. Build the docs again.\r\n\r\n### Actual outcome\r\n\r\nThe third plot in `a.rst` throws an error.\r\n\r\n```\r\n/Users/yongrenjie/test/rst/a.rst:21: WARNING: Exception occurred in plotting a-3\r\n from /Users/yongrenjie/test/rst/a.rst:\r\nTraceback (most recent call last):\r\n  File \"/Users/yongrenjie/progs/matplotlib/lib/matplotlib/sphinxext/plot_directive.py\", line 497, in _run_code\r\n    exec(code, ns)\r\n  File \"<string>\", line 1, in <module>\r\nNameError: name 'a' is not defined\r\n```\r\n\r\nThe reason for this, as suggested above, is because of the `out_of_date()` function. When `sphinx-build` is invoked again, Sphinx decides that both `a.rst` and `b.rst` must be recompiled. Now:\r\n\r\n - Plot 1 is not considered out of date, because the image file already exists and `a.rst` was not modified. So the code is never run and `a` is never saved to the context.\r\n - Plot 2 is there to ensure that figures are closed prior to Plot 3, so that Plot 3 never generates an image file.\r\n - Plot 3 is considered out of date, because there is no image file that corresponds to it. Thus it is run again, and doesn't see `a` in the context, hence the warning.\r\n\r\n### Expected outcome\r\n\r\nThere shouldn't be any errors.\r\n\r\nOne easy way to accomplish this is to make sure that Sphinx re-runs all code snippets which are context-dependent, whenever a file is recompiled. That is, if a plot directive has :context: on, then the code should always be considered out of date regardless of the file modification times.\r\n\r\nThis will lead to some excessive regeneration of plots whenever included files are modified. For example, in the above code, whenever `b.rst` is modified, Plots 1 and 3 will always be re-created, even if `a.rst` is untouched. But IMO this is more sensible behaviour than the current bug. It would also be in line with what happens if *any* part of `a.rst` is modified, including the text outside the plot directives: all the plots in `a.rst` would be re-created.\r\n\r\nThis doesn't change the case where neither `a.rst` nor `b.rst` are modified, because in that case Sphinx will never attempt to recompile either file and plot_directive will never be called.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.4.git",
    "requested_commit": "",
    "mayil_response": "To address the issue where the `plot_directive` is not marking `a.rst` as out of date when only `b.rst` is modified, and the `:context:` option in plot directives is not functioning correctly when files are included, consider the following solution:\n\n- Modify the `out_of_date` function in `plot_directive.py` to account for the context dependency of the plots. If a plot is context-dependent, the modification time of the context files should also be checked.\n- Update the `out_of_date` function to accept a new parameter that indicates whether the plot is context-dependent.\n- In the `run` method of the `PlotDirective` class, determine if the plot is context-dependent by checking for the `:context:` option.\n- Pass the context dependency information to the `out_of_date` function when it is called.\n\nHere is a code snippet that implements the solution:\n\n```python\n# In plot_directive.py\n\ndef out_of_date(original, derived, includes=None, context_dependent=False):\n    \"\"\"\n    Return whether *derived* is out-of-date relative to *original* or any of\n    the RST files included in it using the RST include directive (*includes*).\n    If context_dependent is True, also check the modification time of context\n    files.\n    *derived* and *original* are full paths, and *includes* is optionally a\n    list of full paths which may have been included in the *original*.\n    \"\"\"\n    if not os.path.exists(derived):\n        return True\n\n    if includes is None:\n        includes = []\n    files_to_check = [original, *includes]\n\n    if context_dependent:\n        # Add context files to the list of files to check\n        context_files = plot_context.get('_context_files', [])\n        files_to_check.extend(context_files)\n\n    def out_of_date_one(original, derived_mtime):\n        return (os.path.exists(original) and\n                derived_mtime < os.stat(original).st_mtime)\n\n    derived_mtime = os.stat(derived).st_mtime\n    return any(out_of_date_one(f, derived_mtime) for f in files_to_check)\n\n# In the run method of the PlotDirective class, determine if the plot is context-dependent\ncontext_dependent = 'context' in options\n\n# When calling out_of_date, pass the context_dependent flag\nif out_of_date(source_file_name, path_to_output_file, source_file_includes, context_dependent):\n    # The file is out of date and needs to be recompiled\n    pass\n```\n\nMake sure to update the call to `out_of_date` in the `run` method of the `PlotDirective` class to include the new `context_dependent` parameter. Additionally, ensure that the `plot_context` dictionary is properly maintained to include the filenames of the context files when the `:context:` option is used.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.4/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.4/tree//lib/matplotlib) \u2192 [sphinxext](https://github.com/testbed/matplotlib__matplotlib__3.4/tree//lib/matplotlib/sphinxext)- [Lines 424 - 845](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L424-L845)\n\n This snippet contains the 'out_of_date' function which is central to the issue described, as it determines whether a plot is considered out of date. The issue is that this function does not account for changes in included files via the RST 'include' directive. \n\n\n   - [Lines 278 - 933](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L278-L933)\n\n This snippet includes the 'render_figures' function call, which is where the 'out_of_date' function's result is used to decide if a plot should be re-rendered. It is relevant to understand how the context and out-of-date checks are applied to the plot rendering process. \n\n\n   - [Lines 800 - 855](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L800-L855)\n\n This snippet deals with the handling of included RST files and how they are processed in relation to the plot directive. It is relevant because the issue involves the 'include' directive and how changes to included files are not triggering a recompilation of plots. \n\n\n   - [Lines 724 - 799](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L724-L799)\n\n This snippet shows the setup for plot options and handling of the 'context' option within the plot directive. It is relevant because the issue specifically mentions problems with the ':context:' option.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0006825,
        "snippet_processor": 0.08729,
        "issue_star_creation": 0.02624,
        "issue_star_solver": 0.09030000000000002,
        "bouncer": 0.03663
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711698837.137394,
        "relevant_snippets": [
            {
                "code": "TEMPLATE = _SOURCECODE + \"\"\"\n\n   {% for img in images %}\n   .. figure:: {{ build_dir }}/{{ img.basename }}.{{ default_fmt }}\n      {% for option in options -%}\n      {{ option }}\n      {% endfor %}\n\n      {% if html_show_formats and multi_image -%}\n        (\n        {%- for fmt in img.formats -%}\n        {%- if not loop.first -%}, {% endif -%}\n        :download:`{{ fmt }} <{{ build_dir }}/{{ img.basename }}.{{ fmt }}>`\n        {%- endfor -%}\n        )\n      {%- endif -%}\n\n      {{ caption }}  {# appropriate leading whitespace added beforehand #}\n   {% endfor %}\n\n.. only:: not html\n\n   {% for img in images %}\n   .. figure:: {{ build_dir }}/{{ img.basename }}.*\n      {% for option in options -%}\n      {{ option }}\n      {% endfor -%}\n\n      {{ caption }}  {# appropriate leading whitespace added beforehand #}\n   {% endfor %}\n\n\"\"\"\n\nexception_template = \"\"\"\n.. only:: html\n\n   [`source code <%(linkdir)s/%(basename)s.py>`__]\n\nException occurred rendering plot.\n\n\"\"\"\n\n# the context of the plot for all directives specified with the\n# :context: option\nplot_context = dict()\n\n\nclass ImageFile:\n    def __init__(self, basename, dirname):\n        self.basename = basename\n        self.dirname = dirname\n        self.formats = []\n\n    def filename(self, format):\n        return os.path.join(self.dirname, f\"{self.basename}.{format}\")\n\n    def filenames(self):\n        return [self.filename(fmt) for fmt in self.formats]\n\n\ndef out_of_date(original, derived, includes=None):\n    \"\"\"\n    Return whether *derived* is out-of-date relative to *original* or any of\n    the RST files included in it using the RST include directive (*includes*).\n    *derived* and *original* are full paths, and *includes* is optionally a\n    list of full paths which may have been included in the *original*.\n    \"\"\"\n    if not os.path.exists(derived):\n        return True\n\n    if includes is None:\n        includes = []\n    files_to_check = [original, *includes]\n\n    def out_of_date_one(original, derived_mtime):\n        return (os.path.exists(original) and\n                derived_mtime < os.stat(original).st_mtime)\n\n    derived_mtime = os.stat(derived).st_mtime\n    return any(out_of_date_one(f, derived_mtime) for f in files_to_check)\n\n\nclass PlotError(RuntimeError):\n    pass",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 14277,
                "end_index": 16535,
                "start_line": 424,
                "end_line": 845,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\nA directive for including a Matplotlib plot in a Sphinx document\n================================================================\n\nThis is a Sphinx extension providing a reStructuredText directive\n``.. plot::`` for including a plot in a Sphinx document.\n\nIn HTML output, ``.. plot::`` will include a .png file with a link\nto a high-res .png and .pdf.  In LaTeX output, it will include a .pdf.\n\nThe plot content may be defined in one of three ways:\n\n1. **A path to a source file** as the argument to the directive::\n\n     .. plot:: path/to/plot.py\n\n   When a path to a source file is given, the content of the\n   directive may optionally contain a caption for the plot::\n\n     .. plot:: path/to/plot.py\n\n        The plot caption.\n\n   Additionally, one may specify the name of a function to call (with\n   no arguments) immediately after importing the module::\n\n     .. plot:: path/to/plot.py plot_function1\n\n2. Included as **inline content** to the directive::\n\n     .. plot::\n\n        import matplotlib.pyplot as plt\n        plt.plot([1, 2, 3], [4, 5, 6])\n        plt.title(\"A plotting exammple\")\n\n3. Using **doctest** syntax::\n\n     .. plot::\n\n        A plotting example:\n        >>> import matplotlib.pyplot as plt\n        >>> plt.plot([1, 2, 3], [4, 5, 6])\n\nOptions\n-------\n\nThe ``.. plot::`` directive supports the following options:\n\n``:format:`` : {'python', 'doctest'}\n    The format of the input.  If unset, the format is auto-detected.\n\n``:include-source:`` : bool\n    Whether to display the source code. The default can be changed using\n    the ``plot_include_source`` variable in :file:`conf.py` (which itself\n    defaults to False).\n\n``:show-source-link:`` : bool\n    Whether to show a link to the source in HTML. The default can be\n    changed using the ``plot_html_show_source_link`` variable in\n    :file:`conf.py` (which itself defaults to True).\n\n``:context:`` : bool or str\n    If provided, the code will be run in the context of all previous plot\n    directives for which the ``:context:`` option was specified.  This only\n    applies to inline code plot directives, not those run from files. If\n    the ``:context: reset`` option is specified, the context is reset\n    for this and future plots, and previous figures are closed prior to\n    running the code. ``:context: close-figs`` keeps the context but closes\n    previous figures before running the code.\n\n``:nofigs:`` : bool\n    If specified, the code block will be run, but no figures will be\n    inserted.  This is usually useful with the ``:context:`` option.\n\n``:caption:`` : str\n    If specified, the option's argument will be used as a caption for the\n    figure. This overwrites the caption given in the content, when the plot\n    is generated from a file.\n\nAdditionally, this directive supports all the options of the `image directive\n<https://docutils.sourceforge.io/docs/ref/rst/directives.html#image>`_,\nexcept for ``:target:`` (since plot will add its own target).  These include\n``:alt:``, ``:height:``, ``:width:``, ``:scale:``, ``:align:`` and ``:class:``.\n\nConfiguration options\n---------------------\n\nThe plot directive has the following configuration options:\n\nplot_include_source\n    Default value for the include-source option (default: False).\n\nplot_html_show_source_link\n    Whether to show a link to the source in HTML (default: True).\n\nplot_pre_code\n    Code that should be executed before each plot. If None (the default),\n    it will default to a string containing::\n\n        import numpy as np\n        from matplotlib import pyplot as plt\n\nplot_basedir\n    Base directory, to which ``plot::`` file names are relative to.\n    If None or empty (the default), file names are relative to the\n    directory where the file containing the directive is.\n\nplot_formats\n    File formats to generate (default: ['png', 'hires.png', 'pdf']).\n    List of tuples or strings::\n\n        [(suffix, dpi), suffix, ...]\n\n    that determine the file format and the DPI. For entries whose\n    DPI was omitted, sensible defaults are chosen. When passing from\n    the command line through sphinx_build the list should be passed as\n    suffix:dpi,suffix:dpi, ...\n\nplot_html_show_formats\n    Whether to show links to the files in HTML (default: True).\n\nplot_rcparams\n    A dictionary containing any non-standard rcParams that should\n    be applied before each plot (default: {}).\n\nplot_apply_rcparams\n    By default, rcParams are applied when ``:context:`` option is not used\n    in a plot directive.  If set, this configuration option overrides this\n    behavior and applies rcParams before each plot.\n\nplot_working_directory\n    By default, the working directory will be changed to the directory of\n    the example, so the code can get at its data files, if any.  Also its\n    path will be added to `sys.path` so it can import any helper modules\n    sitting beside it.  This configuration option can be used to specify\n    a central directory (also added to `sys.path`) where data files and\n    helper modules for all code are located.\n\nplot_template\n    Provide a customized template for preparing restructured text.\n\nplot_srcset\n    Allow the srcset image option for responsive image resolutions. List of\n    strings with the multiplicative factors followed by an \"x\".\n    e.g. [\"2.0x\", \"1.5x\"].  \"2.0x\" will create a png with the default \"png\"\n    resolution from plot_formats, multiplied by 2. If plot_srcset is\n    specified, the plot directive uses the\n    :doc:`/api/sphinxext_figmpl_directive_api` (instead of the usual figure\n    directive) in the intermediary rst file that is generated.\n    The plot_srcset option is incompatible with *singlehtml* builds, and an\n    error will be raised.\n\nNotes on how it works\n---------------------\n\nThe plot directive runs the code it is given, either in the source file or the\ncode under the directive. The figure created (if any) is saved in the sphinx\nbuild directory under a subdirectory named ``plot_directive``.  It then creates\nan intermediate rst file that calls a ``.. figure:`` directive (or\n``.. figmpl::`` directive if ``plot_srcset`` is being used) and has links to\nthe ``*.png`` files in the ``plot_directive`` directory.  These translations can\nbe customized by changing the *plot_template*.  See the source of\n:doc:`/api/sphinxext_plot_directive_api` for the templates defined in *TEMPLATE*\nand *TEMPLATE_SRCSET*.\n\"\"\"",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 0,
                "end_index": 6360,
                "start_line": 1,
                "end_line": 612,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "import contextlib\nimport doctest\nfrom io import StringIO\nimport itertools\nimport os\nfrom os.path import relpath\nfrom pathlib import Path\nimport re\nimport shutil\nimport sys\nimport textwrap\nimport traceback\n\nfrom docutils.parsers.rst import directives, Directive\nfrom docutils.parsers.rst.directives.images import Image\nimport jinja2  # Sphinx dependency.\n\nfrom sphinx.errors import ExtensionError\n\nimport matplotlib\nfrom matplotlib.backend_bases import FigureManagerBase\nimport matplotlib.pyplot as plt\nfrom matplotlib import _pylab_helpers, cbook\n\nmatplotlib.use(\"agg\")\n\n__version__ = 2\n\n\n# -----------------------------------------------------------------------------\n# Registration hook\n# -----------------------------------------------------------------------------\n\n\ndef _option_boolean(arg):\n    if not arg or not arg.strip():\n        # no argument given, assume used as a flag\n        return True\n    elif arg.strip().lower() in ('no', '0', 'false'):\n        return False\n    elif arg.strip().lower() in ('yes', '1', 'true'):\n        return True\n    else:\n        raise ValueError(f'{arg!r} unknown boolean')\n\n\ndef _option_context(arg):\n    if arg in [None, 'reset', 'close-figs']:\n        return arg\n    raise ValueError(\"Argument should be None or 'reset' or 'close-figs'\")\n\n\ndef _option_format(arg):\n    return directives.choice(arg, ('python', 'doctest'))\n\n\ndef mark_plot_labels(app, document):\n    \"\"\"\n    To make plots referenceable, we need to move the reference from the\n    \"htmlonly\" (or \"latexonly\") node to the actual figure node itself.\n    \"\"\"\n    for name, explicit in document.nametypes.items():\n        if not explicit:\n            continue\n        labelid = document.nameids[name]\n        if labelid is None:\n            continue\n        node = document.ids[labelid]\n        if node.tagname in ('html_only', 'latex_only'):\n            for n in node:\n                if n.tagname == 'figure':\n                    sectname = name\n                    for c in n:\n                        if c.tagname == 'caption':\n                            sectname = c.astext()\n                            break\n\n                    node['ids'].remove(labelid)\n                    node['names'].remove(name)\n                    n['ids'].append(labelid)\n                    n['names'].append(name)\n                    document.settings.env.labels[name] = \\\n                        document.settings.env.docname, labelid, sectname\n                    break",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 6362,
                "end_index": 8823,
                "start_line": 168,
                "end_line": 649,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if 'format' in options:\n        if options['format'] == 'python':\n            is_doctest = False\n        else:\n            is_doctest = True\n\n    # determine output directory name fragment\n    source_rel_name = relpath(source_file_name, setup.confdir)\n    source_rel_dir = os.path.dirname(source_rel_name).lstrip(os.path.sep)\n\n    # build_dir: where to place output files (temporarily)\n    build_dir = os.path.join(os.path.dirname(setup.app.doctreedir),\n                             'plot_directive',\n                             source_rel_dir)\n    # get rid of .. in paths, also changes pathsep\n    # see note in Python docs for warning about symbolic links on Windows.\n    # need to compare source and dest paths at end\n    build_dir = os.path.normpath(build_dir)\n    os.makedirs(build_dir, exist_ok=True)\n\n    # how to link to files from the RST file\n    try:\n        build_dir_link = relpath(build_dir, rst_dir).replace(os.path.sep, '/')\n    except ValueError:\n        # on Windows, relpath raises ValueError when path and start are on\n        # different mounts/drives\n        build_dir_link = build_dir\n\n    # get list of included rst files so that the output is updated when any\n    # plots in the included files change. These attributes are modified by the\n    # include directive (see the docutils.parsers.rst.directives.misc module).\n    try:\n        source_file_includes = [os.path.join(os.getcwd(), t[0])\n                                for t in state.document.include_log]\n    except AttributeError:\n        # the document.include_log attribute only exists in docutils >=0.17,\n        # before that we need to inspect the state machine\n        possible_sources = {os.path.join(setup.confdir, t[0])\n                            for t in state_machine.input_lines.items}\n        source_file_includes = [f for f in possible_sources\n                                if os.path.isfile(f)]\n    # remove the source file itself from the includes\n    try:\n        source_file_includes.remove(source_file_name)\n    except ValueError:\n        pass\n\n    # save script (if necessary)\n    if options['show-source-link']:\n        Path(build_dir, output_base + source_ext).write_text(\n            doctest.script_from_examples(code)\n            if source_file_name == rst_file and is_doctest\n            else code,\n            encoding='utf-8')\n\n    # make figures",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 27115,
                "end_index": 29474,
                "start_line": 800,
                "end_line": 855,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "document = state_machine.document\n    config = document.settings.env.config\n    nofigs = 'nofigs' in options\n\n    if config.plot_srcset and setup.app.builder.name == 'singlehtml':\n        raise ExtensionError(\n            'plot_srcset option not compatible with single HTML writer')\n\n    formats = get_plot_formats(config)\n    default_fmt = formats[0][0]\n\n    options.setdefault('include-source', config.plot_include_source)\n    options.setdefault('show-source-link', config.plot_html_show_source_link)\n\n    if 'class' in options:\n        # classes are parsed into a list of string, and output by simply\n        # printing the list, abusing the fact that RST guarantees to strip\n        # non-conforming characters\n        options['class'] = ['plot-directive'] + options['class']\n    else:\n        options.setdefault('class', ['plot-directive'])\n    keep_context = 'context' in options\n    context_opt = None if not keep_context else options['context']\n\n    rst_file = document.attributes['source']\n    rst_dir = os.path.dirname(rst_file)\n\n    if len(arguments):\n        if not config.plot_basedir:\n            source_file_name = os.path.join(setup.app.builder.srcdir,\n                                            directives.uri(arguments[0]))\n        else:\n            source_file_name = os.path.join(setup.confdir, config.plot_basedir,\n                                            directives.uri(arguments[0]))\n        # If there is content, it will be passed as a caption.\n        caption = '\\n'.join(content)\n\n        # Enforce unambiguous use of captions.\n        if \"caption\" in options:\n            if caption:\n                raise ValueError(\n                    'Caption specified in both content and options.'\n                    ' Please remove ambiguity.'\n                )\n            # Use caption option\n            caption = options[\"caption\"]\n\n        # If the optional function name is provided, use it\n        if len(arguments) == 2:\n            function_name = arguments[1]\n        else:\n            function_name = None\n\n        code = Path(source_file_name).read_text(encoding='utf-8')\n        output_base = os.path.basename(source_file_name)\n    else:\n        source_file_name = rst_file\n        code = textwrap.dedent(\"\\n\".join(map(str, content)))\n        counter = document.attributes.get('_plot_counter', 0) + 1\n        document.attributes['_plot_counter'] = counter\n        base, ext = os.path.splitext(os.path.basename(source_file_name))\n        output_base = '%s-%d.py' % (base, counter)\n        function_name = None\n        caption = options.get('caption', '')\n\n    base, source_ext = os.path.splitext(output_base)\n    if source_ext in ('.py', '.rst', '.txt'):\n        output_base = base\n    else:\n        source_ext = ''\n\n    # ensure that LaTeX includegraphics doesn't choke in foo.bar.pdf filenames\n    output_base = output_base.replace('.', '-')\n\n    # is it in doctest format?\n    is_doctest = contains_doctest(code)",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 24160,
                "end_index": 27110,
                "start_line": 724,
                "end_line": 799,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "/*\n * plot_directive.css\n * ~~~~~~~~~~~~\n *\n * Stylesheet controlling images created using the `plot` directive within\n * Sphinx.\n *\n * :copyright: Copyright 2020-* by the Matplotlib development team.\n * :license: Matplotlib, see LICENSE for details.\n *\n */\n\nimg.plot-directive {\n    border: 0;\n    max-width: 100%;\n}",
                "filename": "lib/matplotlib/mpl-data/plot_directive/plot_directive.css",
                "start_index": 0,
                "end_index": 317,
                "start_line": 1,
                "end_line": 16,
                "max_line": 16,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "try:\n        results = render_figures(code=code,\n                                 code_path=source_file_name,\n                                 output_dir=build_dir,\n                                 output_base=output_base,\n                                 context=keep_context,\n                                 function_name=function_name,\n                                 config=config,\n                                 context_reset=context_opt == 'reset',\n                                 close_figs=context_opt == 'close-figs',\n                                 code_includes=source_file_includes)\n        errors = []\n    except PlotError as err:\n        reporter = state.memo.reporter\n        sm = reporter.system_message(\n            2, \"Exception occurred in plotting {}\\n from {}:\\n{}\".format(\n                output_base, source_file_name, err),\n            line=lineno)\n        results = [(code, [])]\n        errors = [sm]\n\n    # Properly indent the caption\n    if caption and config.plot_srcset:\n        caption = f':caption: {caption}'\n    elif caption:\n        caption = '\\n' + '\\n'.join('      ' + line.strip()\n                                   for line in caption.split('\\n'))\n    # generate output restructuredtext\n    total_lines = []\n    for j, (code_piece, images) in enumerate(results):\n        if options['include-source']:\n            if is_doctest:\n                lines = ['', *code_piece.splitlines()]\n            else:\n                lines = ['.. code-block:: python', '',\n                         *textwrap.indent(code_piece, '    ').splitlines()]\n            source_code = \"\\n\".join(lines)\n        else:\n            source_code = \"\"\n\n        if nofigs:\n            images = []\n\n        opts = [\n            f':{key}: {val}' for key, val in options.items()\n            if key in ('alt', 'height', 'width', 'scale', 'align', 'class')]\n\n        # Not-None src_name signals the need for a source download in the\n        # generated html\n        if j == 0 and options['show-source-link']:\n            src_name = output_base + source_ext\n        else:\n            src_name = None\n        if config.plot_srcset:\n            srcset = [*_parse_srcset(config.plot_srcset).values()]\n            template = TEMPLATE_SRCSET\n        else:\n            srcset = None\n            template = TEMPLATE\n\n        result = jinja2.Template(config.plot_template or template).render(\n            default_fmt=default_fmt,\n            build_dir=build_dir_link,\n            src_name=src_name,\n            multi_image=len(images) > 1,\n            options=opts,\n            srcset=srcset,\n            images=images,\n            source_code=source_code,\n            html_show_formats=config.plot_html_show_formats and len(images),\n            caption=caption)\n        total_lines.extend(result.split(\"\\n\"))\n        total_lines.extend(\"\\n\")\n\n    if total_lines:\n        state_machine.insert_input(total_lines, source=source_file_name)\n\n    return errors",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 29479,
                "end_index": 32429,
                "start_line": 278,
                "end_line": 933,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "for i, code_piece in enumerate(code_pieces):\n\n        if not context or config.plot_apply_rcparams:\n            clear_state(config.plot_rcparams, close_figs)\n        elif close_figs:\n            plt.close('all')\n\n        _run_code(doctest.script_from_examples(code_piece) if is_doctest\n                  else code_piece,\n                  code_path, ns, function_name)\n\n        images = []\n        fig_managers = _pylab_helpers.Gcf.get_all_fig_managers()\n        for j, figman in enumerate(fig_managers):\n            if len(fig_managers) == 1 and len(code_pieces) == 1:\n                img = ImageFile(output_base, output_dir)\n            elif len(code_pieces) == 1:\n                img = ImageFile(\"%s_%02d\" % (output_base, j), output_dir)\n            else:\n                img = ImageFile(\"%s_%02d_%02d\" % (output_base, i, j),\n                                output_dir)\n            images.append(img)\n\n            for fmt, dpi in formats:\n                try:\n                    figman.canvas.figure.savefig(img.filename(fmt), dpi=dpi)\n                    if fmt == formats[0][0] and config.plot_srcset:\n                        # save a 2x, 3x etc version of the default...\n                        srcset = _parse_srcset(config.plot_srcset)\n                        for mult, suffix in srcset.items():\n                            fm = f'{suffix}.{fmt}'\n                            img.formats.append(fm)\n                            figman.canvas.figure.savefig(img.filename(fm),\n                                                         dpi=int(dpi * mult))\n                except Exception as err:\n                    raise PlotError(traceback.format_exc()) from err\n                img.formats.append(fmt)\n\n        results.append((code_piece, images))\n\n    if not context or config.plot_apply_rcparams:\n        clear_state(config.plot_rcparams, close=not context)\n\n    return results",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 22198,
                "end_index": 24085,
                "start_line": 637,
                "end_line": 720,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class PlotDirective(Directive):\n    \"\"\"The ``.. plot::`` directive, as documented in the module's docstring.\"\"\"\n\n    has_content = True\n    required_arguments = 0\n    optional_arguments = 2\n    final_argument_whitespace = False\n    option_spec = {\n        'alt': directives.unchanged,\n        'height': directives.length_or_unitless,\n        'width': directives.length_or_percentage_or_unitless,\n        'scale': directives.nonnegative_int,\n        'align': Image.align,\n        'class': directives.class_option,\n        'include-source': _option_boolean,\n        'show-source-link': _option_boolean,\n        'format': _option_format,\n        'context': _option_context,\n        'nofigs': directives.flag,\n        'caption': directives.unchanged,\n        }\n\n    def run(self):\n        \"\"\"Run the plot directive.\"\"\"\n        try:\n            return run(self.arguments, self.content, self.options,\n                       self.state_machine, self.state, self.lineno)\n        except Exception as e:\n            raise self.error(str(e))\n\n\ndef _copy_css_file(app, exc):\n    if exc is None and app.builder.format == 'html':\n        src = cbook._get_data_path('plot_directive/plot_directive.css')\n        dst = app.outdir / Path('_static')\n        dst.mkdir(exist_ok=True)\n        # Use copyfile because we do not want to copy src's permissions.\n        shutil.copyfile(src, dst / Path('plot_directive.css'))\n\n\ndef setup(app):\n    setup.app = app\n    setup.config = app.config\n    setup.confdir = app.confdir\n    app.add_directive('plot', PlotDirective)\n    app.add_config_value('plot_pre_code', None, True)\n    app.add_config_value('plot_include_source', False, True)\n    app.add_config_value('plot_html_show_source_link', True, True)\n    app.add_config_value('plot_formats', ['png', 'hires.png', 'pdf'], True)\n    app.add_config_value('plot_basedir', None, True)\n    app.add_config_value('plot_html_show_formats', True, True)\n    app.add_config_value('plot_rcparams', {}, True)\n    app.add_config_value('plot_apply_rcparams', False, True)\n    app.add_config_value('plot_working_directory', None, True)\n    app.add_config_value('plot_template', None, True)\n    app.add_config_value('plot_srcset', [], True)\n    app.connect('doctree-read', mark_plot_labels)\n    app.add_css_file('plot_directive.css')\n    app.connect('build-finished', _copy_css_file)\n    metadata = {'parallel_read_safe': True, 'parallel_write_safe': True,\n                'version': matplotlib.__version__}\n    return metadata\n\n\n# -----------------------------------------------------------------------------\n# Doctest handling\n# -----------------------------------------------------------------------------\n\n\ndef contains_doctest(text):\n    try:\n        # check if it's valid Python as-is\n        compile(text, '<string>', 'exec')\n        return False\n    except SyntaxError:\n        pass\n    r = re.compile(r'^\\s*>>>', re.M)\n    m = r.search(text)\n    return bool(m)",
                "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                "start_index": 8826,
                "end_index": 11753,
                "start_line": 254,
                "end_line": 332,
                "max_line": 933,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# In order for a legend or other artist to *not* steal space\n# from the subplot layout, we can ``leg.set_in_layout(False)``.\n# Of course this can mean the legend ends up\n# cropped, but can be useful if the plot is subsequently called\n# with ``fig.savefig('outname.png', bbox_inches='tight')``.  Note,\n# however, that the legend's ``get_in_layout`` status will have to be\n# toggled again to make the saved file work, and we must manually\n# trigger a draw if we want *constrained layout* to adjust the size\n# of the Axes before printing.\n\nfig, axs = plt.subplots(1, 2, figsize=(4, 2), layout=\"constrained\")\n\naxs[0].plot(np.arange(10))\naxs[1].plot(np.arange(10), label='This is a plot')\nleg = axs[1].legend(loc='center left', bbox_to_anchor=(0.8, 0.5))\nleg.set_in_layout(False)\n# trigger a draw so that constrained layout is executed once\n# before we turn it off when printing....\nfig.canvas.draw()\n# we want the legend included in the bbox_inches='tight' calcs.\nleg.set_in_layout(True)\n# we don't want the layout to change at this point.\nfig.set_layout_engine('none')\ntry:\n    fig.savefig('../../../doc/_static/constrained_layout_1b.png',\n                bbox_inches='tight', dpi=100)\nexcept FileNotFoundError:\n    # this allows the script to keep going if run interactively and\n    # the directory above doesn't exist\n    pass\n\n# %%\n# The saved file looks like:\n#\n# .. image:: /_static/constrained_layout_1b.png\n#    :align: center\n#\n# A better way to get around this awkwardness is to simply\n# use the legend method provided by `.Figure.legend`:\nfig, axs = plt.subplots(1, 2, figsize=(4, 2), layout=\"constrained\")\naxs[0].plot(np.arange(10))\nlines = axs[1].plot(np.arange(10), label='This is a plot')\nlabels = [l.get_label() for l in lines]\nleg = fig.legend(lines, labels, loc='center left',\n                 bbox_to_anchor=(0.8, 0.5), bbox_transform=axs[1].transAxes)\ntry:\n    fig.savefig('../../../doc/_static/constrained_layout_2b.png',\n                bbox_inches='tight', dpi=100)\nexcept FileNotFoundError:\n    # this allows the script to keep going if run interactively and\n    # the directory above doesn't exist\n    pass\n\n\n# %%\n# The saved file looks like:\n#\n# .. image:: /_static/constrained_layout_2b.png\n#    :align: center\n#\n\n# %%\n# Padding and spacing\n# ===================\n#\n# Padding between Axes is controlled in the horizontal by *w_pad* and\n# *wspace*, and vertical by *h_pad* and *hspace*.  These can be edited\n# via `~.layout_engine.ConstrainedLayoutEngine.set`.  *w/h_pad* are\n# the minimum space around the Axes in units of inches:\n\nfig, axs = plt.subplots(2, 2, layout=\"constrained\")\nfor ax in axs.flat:\n    example_plot(ax, hide_labels=True)\nfig.get_layout_engine().set(w_pad=4 / 72, h_pad=4 / 72, hspace=0,\n                            wspace=0)\n\n# %%\n# Spacing between subplots is further set by *wspace* and *hspace*. These\n# are specified as a fraction of the size of the subplot group as a whole.",
                "filename": "galleries/users_explain/axes/constrainedlayout_guide.py",
                "start_index": 5946,
                "end_index": 8869,
                "start_line": 187,
                "end_line": 265,
                "max_line": 734,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.4",
                "sha": "",
                "context_relevance": 0.0
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "lib/matplotlib/sphinxext/plot_directive.py": [
                {
                    "chunk": {
                        "code": "TEMPLATE = _SOURCECODE + \"\"\"\n\n   {% for img in images %}\n   .. figure:: {{ build_dir }}/{{ img.basename }}.{{ default_fmt }}\n      {% for option in options -%}\n      {{ option }}\n      {% endfor %}\n\n      {% if html_show_formats and multi_image -%}\n        (\n        {%- for fmt in img.formats -%}\n        {%- if not loop.first -%}, {% endif -%}\n        :download:`{{ fmt }} <{{ build_dir }}/{{ img.basename }}.{{ fmt }}>`\n        {%- endfor -%}\n        )\n      {%- endif -%}\n\n      {{ caption }}  {# appropriate leading whitespace added beforehand #}\n   {% endfor %}\n\n.. only:: not html\n\n   {% for img in images %}\n   .. figure:: {{ build_dir }}/{{ img.basename }}.*\n      {% for option in options -%}\n      {{ option }}\n      {% endfor -%}\n\n      {{ caption }}  {# appropriate leading whitespace added beforehand #}\n   {% endfor %}\n\n\"\"\"\n\nexception_template = \"\"\"\n.. only:: html\n\n   [`source code <%(linkdir)s/%(basename)s.py>`__]\n\nException occurred rendering plot.\n\n\"\"\"\n\n# the context of the plot for all directives specified with the\n# :context: option\nplot_context = dict()\n\n\nclass ImageFile:\n    def __init__(self, basename, dirname):\n        self.basename = basename\n        self.dirname = dirname\n        self.formats = []\n\n    def filename(self, format):\n        return os.path.join(self.dirname, f\"{self.basename}.{format}\")\n\n    def filenames(self):\n        return [self.filename(fmt) for fmt in self.formats]\n\n\ndef out_of_date(original, derived, includes=None):\n    \"\"\"\n    Return whether *derived* is out-of-date relative to *original* or any of\n    the RST files included in it using the RST include directive (*includes*).\n    *derived* and *original* are full paths, and *includes* is optionally a\n    list of full paths which may have been included in the *original*.\n    \"\"\"\n    if not os.path.exists(derived):\n        return True\n\n    if includes is None:\n        includes = []\n    files_to_check = [original, *includes]\n\n    def out_of_date_one(original, derived_mtime):\n        return (os.path.exists(original) and\n                derived_mtime < os.stat(original).st_mtime)\n\n    derived_mtime = os.stat(derived).st_mtime\n    return any(out_of_date_one(f, derived_mtime) for f in files_to_check)\n\n\nclass PlotError(RuntimeError):\n    pass",
                        "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                        "start_index": 14277,
                        "end_index": 16535,
                        "start_line": 424,
                        "end_line": 845,
                        "max_line": 933,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.4",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'out_of_date' function which is central to the issue described, as it determines whether a plot is considered out of date. The issue is that this function does not account for changes in included files via the RST 'include' directive."
                },
                {
                    "chunk": {
                        "code": "try:\n        results = render_figures(code=code,\n                                 code_path=source_file_name,\n                                 output_dir=build_dir,\n                                 output_base=output_base,\n                                 context=keep_context,\n                                 function_name=function_name,\n                                 config=config,\n                                 context_reset=context_opt == 'reset',\n                                 close_figs=context_opt == 'close-figs',\n                                 code_includes=source_file_includes)\n        errors = []\n    except PlotError as err:\n        reporter = state.memo.reporter\n        sm = reporter.system_message(\n            2, \"Exception occurred in plotting {}\\n from {}:\\n{}\".format(\n                output_base, source_file_name, err),\n            line=lineno)\n        results = [(code, [])]\n        errors = [sm]\n\n    # Properly indent the caption\n    if caption and config.plot_srcset:\n        caption = f':caption: {caption}'\n    elif caption:\n        caption = '\\n' + '\\n'.join('      ' + line.strip()\n                                   for line in caption.split('\\n'))\n    # generate output restructuredtext\n    total_lines = []\n    for j, (code_piece, images) in enumerate(results):\n        if options['include-source']:\n            if is_doctest:\n                lines = ['', *code_piece.splitlines()]\n            else:\n                lines = ['.. code-block:: python', '',\n                         *textwrap.indent(code_piece, '    ').splitlines()]\n            source_code = \"\\n\".join(lines)\n        else:\n            source_code = \"\"\n\n        if nofigs:\n            images = []\n\n        opts = [\n            f':{key}: {val}' for key, val in options.items()\n            if key in ('alt', 'height', 'width', 'scale', 'align', 'class')]\n\n        # Not-None src_name signals the need for a source download in the\n        # generated html\n        if j == 0 and options['show-source-link']:\n            src_name = output_base + source_ext\n        else:\n            src_name = None\n        if config.plot_srcset:\n            srcset = [*_parse_srcset(config.plot_srcset).values()]\n            template = TEMPLATE_SRCSET\n        else:\n            srcset = None\n            template = TEMPLATE\n\n        result = jinja2.Template(config.plot_template or template).render(\n            default_fmt=default_fmt,\n            build_dir=build_dir_link,\n            src_name=src_name,\n            multi_image=len(images) > 1,\n            options=opts,\n            srcset=srcset,\n            images=images,\n            source_code=source_code,\n            html_show_formats=config.plot_html_show_formats and len(images),\n            caption=caption)\n        total_lines.extend(result.split(\"\\n\"))\n        total_lines.extend(\"\\n\")\n\n    if total_lines:\n        state_machine.insert_input(total_lines, source=source_file_name)\n\n    return errors",
                        "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                        "start_index": 29479,
                        "end_index": 32429,
                        "start_line": 278,
                        "end_line": 933,
                        "max_line": 933,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.4",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the 'render_figures' function call, which is where the 'out_of_date' function's result is used to decide if a plot should be re-rendered. It is relevant to understand how the context and out-of-date checks are applied to the plot rendering process."
                },
                {
                    "chunk": {
                        "code": "if 'format' in options:\n        if options['format'] == 'python':\n            is_doctest = False\n        else:\n            is_doctest = True\n\n    # determine output directory name fragment\n    source_rel_name = relpath(source_file_name, setup.confdir)\n    source_rel_dir = os.path.dirname(source_rel_name).lstrip(os.path.sep)\n\n    # build_dir: where to place output files (temporarily)\n    build_dir = os.path.join(os.path.dirname(setup.app.doctreedir),\n                             'plot_directive',\n                             source_rel_dir)\n    # get rid of .. in paths, also changes pathsep\n    # see note in Python docs for warning about symbolic links on Windows.\n    # need to compare source and dest paths at end\n    build_dir = os.path.normpath(build_dir)\n    os.makedirs(build_dir, exist_ok=True)\n\n    # how to link to files from the RST file\n    try:\n        build_dir_link = relpath(build_dir, rst_dir).replace(os.path.sep, '/')\n    except ValueError:\n        # on Windows, relpath raises ValueError when path and start are on\n        # different mounts/drives\n        build_dir_link = build_dir\n\n    # get list of included rst files so that the output is updated when any\n    # plots in the included files change. These attributes are modified by the\n    # include directive (see the docutils.parsers.rst.directives.misc module).\n    try:\n        source_file_includes = [os.path.join(os.getcwd(), t[0])\n                                for t in state.document.include_log]\n    except AttributeError:\n        # the document.include_log attribute only exists in docutils >=0.17,\n        # before that we need to inspect the state machine\n        possible_sources = {os.path.join(setup.confdir, t[0])\n                            for t in state_machine.input_lines.items}\n        source_file_includes = [f for f in possible_sources\n                                if os.path.isfile(f)]\n    # remove the source file itself from the includes\n    try:\n        source_file_includes.remove(source_file_name)\n    except ValueError:\n        pass\n\n    # save script (if necessary)\n    if options['show-source-link']:\n        Path(build_dir, output_base + source_ext).write_text(\n            doctest.script_from_examples(code)\n            if source_file_name == rst_file and is_doctest\n            else code,\n            encoding='utf-8')\n\n    # make figures",
                        "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                        "start_index": 27115,
                        "end_index": 29474,
                        "start_line": 800,
                        "end_line": 855,
                        "max_line": 933,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.4",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet deals with the handling of included RST files and how they are processed in relation to the plot directive. It is relevant because the issue involves the 'include' directive and how changes to included files are not triggering a recompilation of plots."
                },
                {
                    "chunk": {
                        "code": "document = state_machine.document\n    config = document.settings.env.config\n    nofigs = 'nofigs' in options\n\n    if config.plot_srcset and setup.app.builder.name == 'singlehtml':\n        raise ExtensionError(\n            'plot_srcset option not compatible with single HTML writer')\n\n    formats = get_plot_formats(config)\n    default_fmt = formats[0][0]\n\n    options.setdefault('include-source', config.plot_include_source)\n    options.setdefault('show-source-link', config.plot_html_show_source_link)\n\n    if 'class' in options:\n        # classes are parsed into a list of string, and output by simply\n        # printing the list, abusing the fact that RST guarantees to strip\n        # non-conforming characters\n        options['class'] = ['plot-directive'] + options['class']\n    else:\n        options.setdefault('class', ['plot-directive'])\n    keep_context = 'context' in options\n    context_opt = None if not keep_context else options['context']\n\n    rst_file = document.attributes['source']\n    rst_dir = os.path.dirname(rst_file)\n\n    if len(arguments):\n        if not config.plot_basedir:\n            source_file_name = os.path.join(setup.app.builder.srcdir,\n                                            directives.uri(arguments[0]))\n        else:\n            source_file_name = os.path.join(setup.confdir, config.plot_basedir,\n                                            directives.uri(arguments[0]))\n        # If there is content, it will be passed as a caption.\n        caption = '\\n'.join(content)\n\n        # Enforce unambiguous use of captions.\n        if \"caption\" in options:\n            if caption:\n                raise ValueError(\n                    'Caption specified in both content and options.'\n                    ' Please remove ambiguity.'\n                )\n            # Use caption option\n            caption = options[\"caption\"]\n\n        # If the optional function name is provided, use it\n        if len(arguments) == 2:\n            function_name = arguments[1]\n        else:\n            function_name = None\n\n        code = Path(source_file_name).read_text(encoding='utf-8')\n        output_base = os.path.basename(source_file_name)\n    else:\n        source_file_name = rst_file\n        code = textwrap.dedent(\"\\n\".join(map(str, content)))\n        counter = document.attributes.get('_plot_counter', 0) + 1\n        document.attributes['_plot_counter'] = counter\n        base, ext = os.path.splitext(os.path.basename(source_file_name))\n        output_base = '%s-%d.py' % (base, counter)\n        function_name = None\n        caption = options.get('caption', '')\n\n    base, source_ext = os.path.splitext(output_base)\n    if source_ext in ('.py', '.rst', '.txt'):\n        output_base = base\n    else:\n        source_ext = ''\n\n    # ensure that LaTeX includegraphics doesn't choke in foo.bar.pdf filenames\n    output_base = output_base.replace('.', '-')\n\n    # is it in doctest format?\n    is_doctest = contains_doctest(code)",
                        "filename": "lib/matplotlib/sphinxext/plot_directive.py",
                        "start_index": 24160,
                        "end_index": 27110,
                        "start_line": 724,
                        "end_line": 799,
                        "max_line": 933,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.4",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the setup for plot options and handling of the 'context' option within the plot directive. It is relevant because the issue specifically mentions problems with the ':context:' option."
                }
            ]
        },
        "solution_task": "To address the issue where the `plot_directive` is not marking `a.rst` as out of date when only `b.rst` is modified, and the `:context:` option in plot directives is not functioning correctly when files are included, consider the following solution:\n\n- Modify the `out_of_date` function in `plot_directive.py` to account for the context dependency of the plots. If a plot is context-dependent, the modification time of the context files should also be checked.\n- Update the `out_of_date` function to accept a new parameter that indicates whether the plot is context-dependent.\n- In the `run` method of the `PlotDirective` class, determine if the plot is context-dependent by checking for the `:context:` option.\n- Pass the context dependency information to the `out_of_date` function when it is called.\n\nHere is a code snippet that implements the solution:\n\n```python\n# In plot_directive.py\n\ndef out_of_date(original, derived, includes=None, context_dependent=False):\n    \"\"\"\n    Return whether *derived* is out-of-date relative to *original* or any of\n    the RST files included in it using the RST include directive (*includes*).\n    If context_dependent is True, also check the modification time of context\n    files.\n    *derived* and *original* are full paths, and *includes* is optionally a\n    list of full paths which may have been included in the *original*.\n    \"\"\"\n    if not os.path.exists(derived):\n        return True\n\n    if includes is None:\n        includes = []\n    files_to_check = [original, *includes]\n\n    if context_dependent:\n        # Add context files to the list of files to check\n        context_files = plot_context.get('_context_files', [])\n        files_to_check.extend(context_files)\n\n    def out_of_date_one(original, derived_mtime):\n        return (os.path.exists(original) and\n                derived_mtime < os.stat(original).st_mtime)\n\n    derived_mtime = os.stat(derived).st_mtime\n    return any(out_of_date_one(f, derived_mtime) for f in files_to_check)\n\n# In the run method of the PlotDirective class, determine if the plot is context-dependent\ncontext_dependent = 'context' in options\n\n# When calling out_of_date, pass the context_dependent flag\nif out_of_date(source_file_name, path_to_output_file, source_file_includes, context_dependent):\n    # The file is out of date and needs to be recompiled\n    pass\n```\n\nMake sure to update the call to `out_of_date` in the `run` method of the `PlotDirective` class to include the new `context_dependent` parameter. Additionally, ensure that the `plot_context` dictionary is properly maintained to include the filenames of the context files when the `:context:` option is used.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described bug to facilitate its resolution.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the issue described in the PROMPT. It suggests modifying the 'out_of_date' function in 'plot_directive.py' to account for context dependency and to check the modification time of context files. The RESPONSE also includes a code snippet that demonstrates how to implement the proposed changes, which is directly relevant to the issue at hand. The RESPONSE further advises updating the call to 'out_of_date' in the 'PlotDirective' class to include the new 'context_dependent' parameter and to ensure that the 'plot_context' dictionary is properly maintained. Additionally, the RESPONSE provides links to the relevant code snippets in the matplotlib repository, which is helpful for locating the sections of code that need to be modified. The RESPONSE is comprehensive and addresses the main issue of the 'plot_directive' not considering 'a.rst' out of date when 'b.rst' is modified and the problems with the ':context:' option.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711698969.792043,
        "result": "To address the issue where the `plot_directive` is not marking `a.rst` as out of date when only `b.rst` is modified, and the `:context:` option in plot directives is not functioning correctly when files are included, consider the following solution:\n\n- Modify the `out_of_date` function in `plot_directive.py` to account for the context dependency of the plots. If a plot is context-dependent, the modification time of the context files should also be checked.\n- Update the `out_of_date` function to accept a new parameter that indicates whether the plot is context-dependent.\n- In the `run` method of the `PlotDirective` class, determine if the plot is context-dependent by checking for the `:context:` option.\n- Pass the context dependency information to the `out_of_date` function when it is called.\n\nHere is a code snippet that implements the solution:\n\n```python\n# In plot_directive.py\n\ndef out_of_date(original, derived, includes=None, context_dependent=False):\n    \"\"\"\n    Return whether *derived* is out-of-date relative to *original* or any of\n    the RST files included in it using the RST include directive (*includes*).\n    If context_dependent is True, also check the modification time of context\n    files.\n    *derived* and *original* are full paths, and *includes* is optionally a\n    list of full paths which may have been included in the *original*.\n    \"\"\"\n    if not os.path.exists(derived):\n        return True\n\n    if includes is None:\n        includes = []\n    files_to_check = [original, *includes]\n\n    if context_dependent:\n        # Add context files to the list of files to check\n        context_files = plot_context.get('_context_files', [])\n        files_to_check.extend(context_files)\n\n    def out_of_date_one(original, derived_mtime):\n        return (os.path.exists(original) and\n                derived_mtime < os.stat(original).st_mtime)\n\n    derived_mtime = os.stat(derived).st_mtime\n    return any(out_of_date_one(f, derived_mtime) for f in files_to_check)\n\n# In the run method of the PlotDirective class, determine if the plot is context-dependent\ncontext_dependent = 'context' in options\n\n# When calling out_of_date, pass the context_dependent flag\nif out_of_date(source_file_name, path_to_output_file, source_file_includes, context_dependent):\n    # The file is out of date and needs to be recompiled\n    pass\n```\n\nMake sure to update the call to `out_of_date` in the `run` method of the `PlotDirective` class to include the new `context_dependent` parameter. Additionally, ensure that the `plot_context` dictionary is properly maintained to include the filenames of the context files when the `:context:` option is used.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.4/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.4/tree//lib/matplotlib) \u2192 [sphinxext](https://github.com/testbed/matplotlib__matplotlib__3.4/tree//lib/matplotlib/sphinxext)- [Lines 424 - 845](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L424-L845)\n\n This snippet contains the 'out_of_date' function which is central to the issue described, as it determines whether a plot is considered out of date. The issue is that this function does not account for changes in included files via the RST 'include' directive. \n\n\n   - [Lines 278 - 933](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L278-L933)\n\n This snippet includes the 'render_figures' function call, which is where the 'out_of_date' function's result is used to decide if a plot should be re-rendered. It is relevant to understand how the context and out-of-date checks are applied to the plot rendering process. \n\n\n   - [Lines 800 - 855](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L800-L855)\n\n This snippet deals with the handling of included RST files and how they are processed in relation to the plot directive. It is relevant because the issue involves the 'include' directive and how changes to included files are not triggering a recompilation of plots. \n\n\n   - [Lines 724 - 799](https://github.com/testbed/matplotlib__matplotlib__3.4/blob//lib/matplotlib/sphinxext/plot_directive.py#L724-L799)\n\n This snippet shows the setup for plot options and handling of the 'context' option within the plot directive. It is relevant because the issue specifically mentions problems with the ':context:' option.",
        "context_relevance": 0.31,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant and answers the entire PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation and a proposed solution to the issue described in the PROMPT, which is the confusion caused by the `plot_directive` when dealing with the `:context:` option and the RST `include` directive. It addresses the bug summary, the reproduction steps, the actual outcome, and the expected outcome by suggesting modifications to the `out_of_date` function and the handling of context-dependent plots. The RESPONSE also includes a code snippet that could potentially resolve the issue, demonstrating a complete understanding of the problem and offering a relevant solution. Additionally, the RESPONSE provides links to the relevant sections of the code in the matplotlib repository, which are directly related to the issue at hand. This RESPONSE is fully relevant to the entire PROMPT and provides a comprehensive answer, meriting a score of 10."
        },
        "qa_relevance": 1.0
    }
}