{
    "id": "sympy__sympy-18198",
    "repo_name": "testbed/sympy__sympy__1.6",
    "task_id": 1603385968354363483,
    "title": "Suggestion on `core.evaluate` module",
    "body": "As I understand, `core.evaluate` module is first developed to handle the global value of `evaluate` parameter. Then, it is extended to handle `distribute` parameter as well.\r\nSince more global parameters might appear in the future, I think this module can be renamed to `core.parameters` for clarity.\r\n\r\nBesides that, if more parameters are added, it will be annoying to have all `global_foo[0]`, `global_bar[0]`, and so on. I am thinking of a dict-like handler named `global_parameters` to manage every global parameters. It will behave like this:\r\n\r\n1. Its `__getitem__()` method returns `global_foo` object.\r\n```\r\n>>> global_parameters\r\n{'evaluate': [True], 'distribute': [True]}\r\n>>> global_parameters['evaluate']\r\n[True]\r\n```\r\n\r\n2. It has `foo` property that returns or sets the value of global `foo`.\r\n```\r\n>>> global_parameters.evaluate\r\nTrue\r\n>>> global_parameters.evaluate = False\r\n>>> global_parameters.evaluate\r\nFalse\r\n>>> global_parameters\r\n{'evaluate': [False], 'distribute': [True]}\r\n```\r\n\r\n3. Its properties are not `bool` - They are callable new classes so that they can be used as context manager.\r\n```\r\n>>> from sympy.abc import x\r\n>>> with global_parameters.evaluate(False):\r\n         print(x + x)\r\nx + x\r\n```\r\n\r\nI have already written a code which satisfies suggestion 1 and 2. It seems to be working well. How does everyone think about it?\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sympy__sympy__1.6.git",
    "requested_commit": "",
    "mayil_response": "To implement the requested feature in the `core.evaluate` module (which should be renamed to `core.parameters`), you can follow these steps:\n\n- Rename the `core.evaluate` module to `core.parameters`.\n- Refactor the `_global_parameters` class to use a dictionary for storing global parameters.\n- Implement the `__getitem__` method to retrieve the value of a parameter.\n- Implement properties for each parameter that act as getters and setters.\n- Implement context manager functionality for each parameter.\n\nHere is a high-level overview of the changes to be made in `sympy/core/parameters.py`:\n\n```python\n# sympy/core/parameters.py\n\n# Rename the class to reflect the new module name\nclass _GlobalParameters(local):\n    def __init__(self, **kwargs):\n        self._parameters = kwargs\n\n    def __getitem__(self, name):\n        return self._parameters[name]\n\n    def __setattr__(self, name, value):\n        if name == \"_parameters\":\n            super().__setattr__(name, value)\n        else:\n            if self._parameters[name] != value:\n                clear_cache()\n            self._parameters[name] = value\n\n    def __getattr__(self, name):\n        return self._parameters[name]\n\n    # Create a property for each global parameter\n    @property\n    def evaluate(self):\n        return self._parameters['evaluate'][0]\n\n    @evaluate.setter\n    def evaluate(self, value):\n        self.__setattr__('evaluate', [value])\n\n    # ... Repeat for other parameters like 'distribute'\n\n    # Implement context manager functionality\n    @contextmanager\n    def evaluate(self, value):\n        old_value = self._parameters['evaluate']\n        self._parameters['evaluate'] = [value]\n        try:\n            yield\n        finally:\n            self._parameters['evaluate'] = old_value\n\n# ... Repeat context manager for other parameters like 'distribute'\n\n# Instantiate the global parameters object\nglobal_parameters = _GlobalParameters(evaluate=[True], distribute=[True])\n```\n\n- Update all references to `global_parameters.evaluate` and `global_parameters.distribute` throughout the codebase to use the new dictionary-based access.\n- Update the `evaluate` and `distribute` context managers to use the new `global_parameters` object and its context manager methods.\n\nRemember to update the module imports in other files, such as `sympy/simplify/simplify.py` and `sympy/core/__init__.py`, to reflect the new module name `core.parameters`.\n\nThis is a high-level overview, and the actual implementation may require additional refactoring to ensure thread safety and proper interaction with the SymPy cache system.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.6/tree//sympy) \u2192 [core](https://github.com/testbed/sympy__sympy__1.6/tree//sympy/core)- [Lines 1 - 99](https://github.com/testbed/sympy__sympy__1.6/blob//sympy/core/parameters.py#L1-L99)\n\n This snippet defines the _global_parameters class and the global_parameters instance, which are directly related to the issue's suggestion of renaming the module and using a dict-like handler for global parameters. \n\n\n   - [Lines 70 - 128](https://github.com/testbed/sympy__sympy__1.6/blob//sympy/core/parameters.py#L70-L128)\n\n This snippet shows the use of the global_parameters instance for controlling the 'distribute' parameter, which is relevant to the issue's discussion about handling multiple global parameters.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00031,
        "snippet_processor": 0.06655,
        "issue_star_creation": 0.02579,
        "issue_star_solver": 0.07651000000000001,
        "bouncer": 0.02152
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711746038.50253,
        "relevant_snippets": [
            {
                "code": "\"\"\"Thread-safe global parameters\"\"\"\n\nfrom .cache import clear_cache\nfrom contextlib import contextmanager\nfrom threading import local\n\nclass _global_parameters(local):\n    \"\"\"\n    Thread-local global parameters.\n\n    Explanation\n    ===========\n\n    This class generates thread-local container for SymPy's global parameters.\n    Every global parameters must be passed as keyword argument when generating\n    its instance.\n    A variable, `global_parameters` is provided as default instance for this class.\n\n    WARNING! Although the global parameters are thread-local, SymPy's cache is not\n    by now.\n    This may lead to undesired result in multi-threading operations.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.core.cache import clear_cache\n    >>> from sympy.core.parameters import global_parameters as gp\n\n    >>> gp.evaluate\n    True\n    >>> x+x\n    2*x\n\n    >>> log = []\n    >>> def f():\n    ...     clear_cache()\n    ...     gp.evaluate = False\n    ...     log.append(x+x)\n    ...     clear_cache()\n    >>> import threading\n    >>> thread = threading.Thread(target=f)\n    >>> thread.start()\n    >>> thread.join()\n\n    >>> print(log)\n    [x + x]\n\n    >>> gp.evaluate\n    True\n    >>> x+x\n    2*x\n\n    References\n    ==========\n\n    .. [1] https://docs.python.org/3/library/threading.html\n\n    \"\"\"\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n\n    def __setattr__(self, name, value):\n        if getattr(self, name) != value:\n            clear_cache()\n        return super().__setattr__(name, value)\n\nglobal_parameters = _global_parameters(evaluate=True, distribute=True)\n\n@contextmanager\ndef evaluate(x):\n    \"\"\" Control automatic evaluation\n\n    This context manager controls whether or not all SymPy functions evaluate\n    by default.\n\n    Note that much of SymPy expects evaluated expressions.  This functionality\n    is experimental and is unlikely to function as intended on large\n    expressions.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.core.parameters import evaluate\n    >>> print(x + x)\n    2*x\n    >>> with evaluate(False):\n    ...     print(x + x)\n    x + x\n    \"\"\"\n\n    old = global_parameters.evaluate\n\n    try:\n        global_parameters.evaluate = x\n        yield\n    finally:\n        global_parameters.evaluate = old",
                "filename": "sympy/core/parameters.py",
                "start_index": 0,
                "end_index": 2338,
                "start_line": 1,
                "end_line": 99,
                "max_line": 128,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "@contextmanager\ndef distribute(x):\n    \"\"\" Control automatic distribution of Number over Add\n\n    This context manager controls whether or not Mul distribute Number over\n    Add. Plan is to avoid distributing Number over Add in all of sympy. Once\n    that is done, this contextmanager will be removed.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.core.parameters import distribute\n    >>> print(2*(x + 1))\n    2*x + 2\n    >>> with distribute(False):\n    ...     print(2*(x + 1))\n    2*(x + 1)\n    \"\"\"\n\n    old = global_parameters.distribute\n\n    try:\n        global_parameters.distribute = x\n        yield\n    finally:\n        global_parameters.distribute = old",
                "filename": "sympy/core/parameters.py",
                "start_index": 2341,
                "end_index": 3036,
                "start_line": 70,
                "end_line": 128,
                "max_line": 128,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.8
            },
            {
                "code": "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core import (Basic, S, Add, Mul, Pow, Symbol, sympify,\n                        expand_func, Function, Dummy, Expr, factor_terms,\n                        expand_power_exp, Eq)\nfrom sympy.core.compatibility import iterable, ordered, as_int\nfrom sympy.core.parameters import global_parameters\nfrom sympy.core.function import (expand_log, count_ops, _mexpand, _coeff_isneg,\n    nfloat, expand_mul)\nfrom sympy.core.numbers import Float, I, pi, Rational, Integer\nfrom sympy.core.relational import Relational\nfrom sympy.core.rules import Transform\nfrom sympy.core.sympify import _sympify\nfrom sympy.functions import gamma, exp, sqrt, log, exp_polar, re\nfrom sympy.functions.combinatorial.factorials import CombinatorialFunction\nfrom sympy.functions.elementary.complexes import unpolarify\nfrom sympy.functions.elementary.exponential import ExpBase\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions.elementary.integers import ceiling\nfrom sympy.functions.elementary.piecewise import Piecewise, piecewise_fold\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely\nfrom sympy.functions.special.tensor_functions import KroneckerDelta\nfrom sympy.polys import together, cancel, factor\nfrom sympy.simplify.combsimp import combsimp\nfrom sympy.simplify.cse_opts import sub_pre, sub_post\nfrom sympy.simplify.powsimp import powsimp\nfrom sympy.simplify.radsimp import radsimp, fraction, collect_abs\nfrom sympy.simplify.sqrtdenest import sqrtdenest\nfrom sympy.simplify.trigsimp import trigsimp, exptrigsimp\nfrom sympy.utilities.iterables import has_variety, sift\n\n\nimport mpmath",
                "filename": "sympy/simplify/simplify.py",
                "start_index": 0,
                "end_index": 1797,
                "start_line": 1,
                "end_line": 36,
                "max_line": 2130,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Core module. Provides the basic operations needed in sympy.\n\"\"\"\n\nfrom .sympify import sympify, SympifyError\nfrom .cache import cacheit\nfrom .assumptions import assumptions, check_assumptions, failing_assumptions, common_assumptions\nfrom .basic import Basic, Atom, preorder_traversal\nfrom .singleton import S\nfrom .expr import Expr, AtomicExpr, UnevaluatedExpr\nfrom .symbol import Symbol, Wild, Dummy, symbols, var\nfrom .numbers import Number, Float, Rational, Integer, NumberSymbol, \\\n    RealNumber, igcd, ilcm, seterr, E, I, nan, oo, pi, zoo, \\\n    AlgebraicNumber, comp, mod_inverse\nfrom .power import Pow, integer_nthroot, integer_log\nfrom .mul import Mul, prod\nfrom .add import Add\nfrom .mod import Mod\nfrom .relational import ( Rel, Eq, Ne, Lt, Le, Gt, Ge,\n    Equality, GreaterThan, LessThan, Unequality, StrictGreaterThan,\n    StrictLessThan )\nfrom .multidimensional import vectorize\nfrom .function import Lambda, WildFunction, Derivative, diff, FunctionClass, \\\n    Function, Subs, expand, PoleError, count_ops, \\\n    expand_mul, expand_log, expand_func, \\\n    expand_trig, expand_complex, expand_multinomial, nfloat, \\\n    expand_power_base, expand_power_exp, arity\nfrom .evalf import PrecisionExhausted, N\nfrom .containers import Tuple, Dict\nfrom .exprtools import gcd_terms, factor_terms, factor_nc\nfrom .parameters import evaluate\n\n# expose singletons\nCatalan = S.Catalan\nEulerGamma = S.EulerGamma\nGoldenRatio = S.GoldenRatio\nTribonacciConstant = S.TribonacciConstant\n\n__all__ = [\n    'sympify', 'SympifyError',\n\n    'cacheit',\n\n    'assumptions', 'check_assumptions', 'failing_assumptions',\n    'common_assumptions',\n\n    'Basic', 'Atom', 'preorder_traversal',\n\n    'S',\n\n    'Expr', 'AtomicExpr', 'UnevaluatedExpr',\n\n    'Symbol', 'Wild', 'Dummy', 'symbols', 'var',\n\n    'Number', 'Float', 'Rational', 'Integer', 'NumberSymbol', 'RealNumber',\n    'igcd', 'ilcm', 'seterr', 'E', 'I', 'nan', 'oo', 'pi', 'zoo',\n    'AlgebraicNumber', 'comp', 'mod_inverse',\n\n    'Pow', 'integer_nthroot', 'integer_log',\n\n    'Mul', 'prod',\n\n    'Add',\n\n    'Mod',\n\n    'Rel', 'Eq', 'Ne', 'Lt', 'Le', 'Gt', 'Ge', 'Equality', 'GreaterThan',\n    'LessThan', 'Unequality', 'StrictGreaterThan', 'StrictLessThan',\n\n    'vectorize',\n\n    'Lambda', 'WildFunction', 'Derivative', 'diff', 'FunctionClass',\n    'Function', 'Subs', 'expand', 'PoleError', 'count_ops', 'expand_mul',\n    'expand_log', 'expand_func', 'expand_trig', 'expand_complex',\n    'expand_multinomial', 'nfloat', 'expand_power_base', 'expand_power_exp',\n    'arity',\n\n    'PrecisionExhausted', 'N',\n\n    'evalf', # The module?\n\n    'Tuple', 'Dict',\n\n    'gcd_terms', 'factor_terms', 'factor_nc',\n\n    'evaluate',\n\n    'Catalan',\n    'EulerGamma',\n    'GoldenRatio',\n    'TribonacciConstant',\n]",
                "filename": "sympy/core/__init__.py",
                "start_index": 0,
                "end_index": 2751,
                "start_line": 1,
                "end_line": 91,
                "max_line": 91,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy import SYMPY_DEBUG\n\nfrom sympy.core import expand_power_base, sympify, Add, S, Mul, Derivative, Pow, symbols, expand_mul\nfrom sympy.core.add import _unevaluated_Add\nfrom sympy.core.compatibility import iterable, ordered, default_sort_key\nfrom sympy.core.parameters import global_parameters\nfrom sympy.core.exprtools import Factors, gcd_terms\nfrom sympy.core.function import _mexpand\nfrom sympy.core.mul import _keep_coeff, _unevaluated_Mul\nfrom sympy.core.numbers import Rational\nfrom sympy.functions import exp, sqrt, log\nfrom sympy.functions.elementary.complexes import Abs\nfrom sympy.polys import gcd\nfrom sympy.simplify.sqrtdenest import sqrtdenest",
                "filename": "sympy/simplify/radsimp.py",
                "start_index": 0,
                "end_index": 749,
                "start_line": 1,
                "end_line": 18,
                "max_line": 1195,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "elif func_name == \"evaluate\":\n                expr = self.getValue(ch.expr(0))\n                l = []\n                x = (ch.getChildCount()-4)//2\n                for i in range(x):\n                    index = 1 + i\n                    child = ch.expr(index)\n                    l.append(self.getValue(child.getChild(0)) + \":\" +\n                             self.getValue(child.getChild(2)))\n\n                if ch.expr(0) in self.matrix_expr or (expr in self.type.keys() and self.type[expr] == \"matrix\"):\n                    self.matrix_expr.append(ctx)\n                    self.setValue(ctx, \"sm.Matrix([i.subs({\" + \",\".join(l) + \"}) for i in \" +\n                                  expr + \"])\" +\n                                  \".reshape((\" + expr + \").shape[0], \" + \"(\" + expr + \").shape[1])\")\n                else:\n                    if self.explicit:\n                        explicit_list = []\n                        for i in self.explicit.keys():\n                            explicit_list.append(i + \":\" + self.explicit[i])\n                        self.setValue(ctx, \"(\" + expr + \")\" + \".subs({\" + \",\".join(explicit_list) +\n                                      \"}).subs({\" + \",\".join(l) + \"})\")\n                    else:\n                        self.setValue(ctx, \"(\" + expr + \")\" + \".subs({\" + \",\".join(l) + \"})\")\n\n            # Polynomial([a, b, c], x)\n            elif func_name == \"polynomial\":\n                self.setValue(ctx, \"sm.Poly(\" + self.getValue(ch.expr(0)) + \", \" +\n                              self.getValue(ch.expr(1)) + \")\")\n\n            # Roots(Poly, x, 2)\n            # Roots([1; 2; 3; 4])\n            elif func_name == \"roots\":\n                self.matrix_expr.append(ctx)\n                expr = self.getValue(ch.expr(0))\n                if ch.expr(0) in self.matrix_expr or (expr in self.type.keys() and self.type[expr] == \"matrix\"):\n                    self.setValue(ctx, \"[i.evalf() for i in \" + \"sm.solve(\" +\n                                  \"sm.Poly(\" + expr + \", \" + \"x),x)]\")\n                else:\n                    self.setValue(ctx, \"[i.evalf() for i in \" + \"sm.solve(\" +\n                                  expr + \", \" + self.getValue(ch.expr(1)) + \")]\")\n\n            # Transpose(A), Inv(A)\n            elif func_name in (\"transpose\", \"inv\", \"inverse\"):\n                self.matrix_expr.append(ctx)\n                if func_name == \"transpose\":\n                    e = \".T\"\n                elif func_name in (\"inv\", \"inverse\"):\n                    e = \"**(-1)\"\n                self.setValue(ctx, \"(\" + self.getValue(ch.expr(0)) + \")\" + e)\n\n            # Eig(A)\n            elif func_name == \"eig\":\n                # \"sm.Matrix([i.evalf() for i in \" +\n                self.setValue(ctx, \"sm.Matrix([i.evalf() for i in (\" +\n                              self.getValue(ch.expr(0)) + \").eigenvals().keys()])\")\n\n            # Diagmat(n, m, x)\n            # Diagmat(3, 1)",
                "filename": "sympy/parsing/autolev/_listener_autolev_antlr.py",
                "start_index": 37228,
                "end_index": 40137,
                "start_line": 811,
                "end_line": 869,
                "max_line": 2083,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _create_evalf_table():\n    global evalf_table\n    from sympy.functions.combinatorial.numbers import bernoulli\n    from sympy.concrete.products import Product\n    from sympy.concrete.summations import Sum\n    from sympy.core.add import Add\n    from sympy.core.mul import Mul\n    from sympy.core.numbers import Exp1, Float, Half, ImaginaryUnit, Integer, NaN, NegativeOne, One, Pi, Rational, Zero\n    from sympy.core.power import Pow\n    from sympy.core.symbol import Dummy, Symbol\n    from sympy.functions.elementary.complexes import Abs, im, re\n    from sympy.functions.elementary.exponential import exp, log\n    from sympy.functions.elementary.integers import ceiling, floor\n    from sympy.functions.elementary.piecewise import Piecewise\n    from sympy.functions.elementary.trigonometric import atan, cos, sin\n    from sympy.integrals.integrals import Integral\n    evalf_table = {\n        Symbol: evalf_symbol,\n        Dummy: evalf_symbol,\n        Float: lambda x, prec, options: (x._mpf_, None, prec, None),\n        Rational: lambda x, prec, options: (from_rational(x.p, x.q, prec), None, prec, None),\n        Integer: lambda x, prec, options: (from_int(x.p, prec), None, prec, None),\n        Zero: lambda x, prec, options: (None, None, prec, None),\n        One: lambda x, prec, options: (fone, None, prec, None),\n        Half: lambda x, prec, options: (fhalf, None, prec, None),\n        Pi: lambda x, prec, options: (mpf_pi(prec), None, prec, None),\n        Exp1: lambda x, prec, options: (mpf_e(prec), None, prec, None),\n        ImaginaryUnit: lambda x, prec, options: (None, fone, None, prec),\n        NegativeOne: lambda x, prec, options: (fnone, None, prec, None),\n        NaN: lambda x, prec, options: (fnan, None, prec, None),\n\n        exp: lambda x, prec, options: evalf_pow(\n            Pow(S.Exp1, x.args[0], evaluate=False), prec, options),\n\n        cos: evalf_trig,\n        sin: evalf_trig,\n\n        Add: evalf_add,\n        Mul: evalf_mul,\n        Pow: evalf_pow,\n\n        log: evalf_log,\n        atan: evalf_atan,\n        Abs: evalf_abs,\n\n        re: evalf_re,\n        im: evalf_im,\n        floor: evalf_floor,\n        ceiling: evalf_ceiling,\n\n        Integral: evalf_integral,\n        Sum: evalf_sum,\n        Product: evalf_prod,\n        Piecewise: evalf_piecewise,\n\n        bernoulli: evalf_bernoulli,\n    }",
                "filename": "sympy/core/evalf.py",
                "start_index": 42226,
                "end_index": 44553,
                "start_line": 1250,
                "end_line": 1306,
                "max_line": 1560,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from sympy.core.symbol import Symbol\n\n    # If the user hasn't specified any modules, use what is available.\n    if modules is None:\n        try:\n            _import(\"scipy\")\n        except ImportError:\n            try:\n                _import(\"numpy\")\n            except ImportError:\n                # Use either numpy (if available) or python.math where possible.\n                # XXX: This leads to different behaviour on different systems and\n                #      might be the reason for irreproducible errors.\n                modules = [\"math\", \"mpmath\", \"sympy\"]\n            else:\n                modules = [\"numpy\"]\n        else:\n            modules = [\"numpy\", \"scipy\"]\n\n    # Get the needed namespaces.\n    namespaces = []\n    # First find any function implementations\n    if use_imps:\n        namespaces.append(_imp_namespace(expr))\n    # Check for dict before iterating\n    if isinstance(modules, (dict, str)) or not hasattr(modules, '__iter__'):\n        namespaces.append(modules)\n    else:\n        # consistency check\n        if _module_present('numexpr', modules) and len(modules) > 1:\n            raise TypeError(\"numexpr must be the only item in 'modules'\")\n        namespaces += list(modules)\n    # fill namespace with first having highest priority\n    namespace = {}\n    for m in namespaces[::-1]:\n        buf = _get_namespace(m)\n        namespace.update(buf)\n\n    if hasattr(expr, \"atoms\"):\n        #Try if you can extract symbols from the expression.\n        #Move on if expr.atoms in not implemented.\n        syms = expr.atoms(Symbol)\n        for term in syms:\n            namespace.update({str(term): term})\n\n    if printer is None:\n        if _module_present('mpmath', namespaces):\n            from sympy.printing.pycode import MpmathPrinter as Printer\n        elif _module_present('scipy', namespaces):\n            from sympy.printing.pycode import SciPyPrinter as Printer\n        elif _module_present('numpy', namespaces):\n            from sympy.printing.pycode import NumPyPrinter as Printer\n        elif _module_present('numexpr', namespaces):\n            from sympy.printing.lambdarepr import NumExprPrinter as Printer\n        elif _module_present('tensorflow', namespaces):\n            from sympy.printing.tensorflow import TensorflowPrinter as Printer\n        elif _module_present('sympy', namespaces):\n            from sympy.printing.pycode import SymPyPrinter as Printer\n        else:\n            from sympy.printing.pycode import PythonCodePrinter as Printer\n        user_functions = {}\n        for m in namespaces[::-1]:\n            if isinstance(m, dict):\n                for k in m:\n                    user_functions[k] = k\n        printer = Printer({'fully_qualified_modules': False, 'inline': True,\n                           'allow_unknown_functions': True,\n                           'user_functions': user_functions})\n\n    # Get the names of the args, for creating a docstring\n    if not iterable(args):\n        args = (args,)\n    names = []",
                "filename": "sympy/utilities/lambdify.py",
                "start_index": 26462,
                "end_index": 29448,
                "start_line": 734,
                "end_line": 806,
                "max_line": 1314,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\nSandbox module of SymPy.\n\nThis module contains experimental code, use at your own risk!\n\nThere is no warranty that this code will still be located here in future\nversions of SymPy.\n\"\"\"",
                "filename": "sympy/sandbox/__init__.py",
                "start_index": 0,
                "end_index": 188,
                "start_line": 1,
                "end_line": 8,
                "max_line": 8,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def __call__(f, *values):\n        if 0 < len(values) <= f.field.ngens:\n            return f.evaluate(list(zip(f.field.gens, values)))\n        else:\n            raise ValueError(\"expected at least 1 and at most %s values, got %s\" % (f.field.ngens, len(values)))\n\n    def evaluate(f, x, a=None):\n        if isinstance(x, list) and a is None:\n            x = [ (X.to_poly(), a) for X, a in x ]\n            numer, denom = f.numer.evaluate(x), f.denom.evaluate(x)\n        else:\n            x = x.to_poly()\n            numer, denom = f.numer.evaluate(x, a), f.denom.evaluate(x, a)\n\n        field = numer.ring.to_field()\n        return field.new(numer, denom)\n\n    def subs(f, x, a=None):\n        if isinstance(x, list) and a is None:\n            x = [ (X.to_poly(), a) for X, a in x ]\n            numer, denom = f.numer.subs(x), f.denom.subs(x)\n        else:\n            x = x.to_poly()\n            numer, denom = f.numer.subs(x, a), f.denom.subs(x, a)\n\n        return f.new(numer, denom)\n\n    def compose(f, x, a=None):\n        raise NotImplementedError",
                "filename": "sympy/polys/fields.py",
                "start_index": 19340,
                "end_index": 20388,
                "start_line": 585,
                "end_line": 613,
                "max_line": 613,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.6",
                "sha": "",
                "context_relevance": 0.1
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "sympy/core/parameters.py": [
                {
                    "chunk": {
                        "code": "\"\"\"Thread-safe global parameters\"\"\"\n\nfrom .cache import clear_cache\nfrom contextlib import contextmanager\nfrom threading import local\n\nclass _global_parameters(local):\n    \"\"\"\n    Thread-local global parameters.\n\n    Explanation\n    ===========\n\n    This class generates thread-local container for SymPy's global parameters.\n    Every global parameters must be passed as keyword argument when generating\n    its instance.\n    A variable, `global_parameters` is provided as default instance for this class.\n\n    WARNING! Although the global parameters are thread-local, SymPy's cache is not\n    by now.\n    This may lead to undesired result in multi-threading operations.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.core.cache import clear_cache\n    >>> from sympy.core.parameters import global_parameters as gp\n\n    >>> gp.evaluate\n    True\n    >>> x+x\n    2*x\n\n    >>> log = []\n    >>> def f():\n    ...     clear_cache()\n    ...     gp.evaluate = False\n    ...     log.append(x+x)\n    ...     clear_cache()\n    >>> import threading\n    >>> thread = threading.Thread(target=f)\n    >>> thread.start()\n    >>> thread.join()\n\n    >>> print(log)\n    [x + x]\n\n    >>> gp.evaluate\n    True\n    >>> x+x\n    2*x\n\n    References\n    ==========\n\n    .. [1] https://docs.python.org/3/library/threading.html\n\n    \"\"\"\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n\n    def __setattr__(self, name, value):\n        if getattr(self, name) != value:\n            clear_cache()\n        return super().__setattr__(name, value)\n\nglobal_parameters = _global_parameters(evaluate=True, distribute=True)\n\n@contextmanager\ndef evaluate(x):\n    \"\"\" Control automatic evaluation\n\n    This context manager controls whether or not all SymPy functions evaluate\n    by default.\n\n    Note that much of SymPy expects evaluated expressions.  This functionality\n    is experimental and is unlikely to function as intended on large\n    expressions.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.core.parameters import evaluate\n    >>> print(x + x)\n    2*x\n    >>> with evaluate(False):\n    ...     print(x + x)\n    x + x\n    \"\"\"\n\n    old = global_parameters.evaluate\n\n    try:\n        global_parameters.evaluate = x\n        yield\n    finally:\n        global_parameters.evaluate = old",
                        "filename": "sympy/core/parameters.py",
                        "start_index": 0,
                        "end_index": 2338,
                        "start_line": 1,
                        "end_line": 99,
                        "max_line": 128,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the _global_parameters class and the global_parameters instance, which are directly related to the issue's suggestion of renaming the module and using a dict-like handler for global parameters."
                },
                {
                    "chunk": {
                        "code": "@contextmanager\ndef distribute(x):\n    \"\"\" Control automatic distribution of Number over Add\n\n    This context manager controls whether or not Mul distribute Number over\n    Add. Plan is to avoid distributing Number over Add in all of sympy. Once\n    that is done, this contextmanager will be removed.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.core.parameters import distribute\n    >>> print(2*(x + 1))\n    2*x + 2\n    >>> with distribute(False):\n    ...     print(2*(x + 1))\n    2*(x + 1)\n    \"\"\"\n\n    old = global_parameters.distribute\n\n    try:\n        global_parameters.distribute = x\n        yield\n    finally:\n        global_parameters.distribute = old",
                        "filename": "sympy/core/parameters.py",
                        "start_index": 2341,
                        "end_index": 3036,
                        "start_line": 70,
                        "end_line": 128,
                        "max_line": 128,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.6",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the use of the global_parameters instance for controlling the 'distribute' parameter, which is relevant to the issue's discussion about handling multiple global parameters."
                }
            ]
        },
        "solution_task": "To implement the requested feature in the `core.evaluate` module (which should be renamed to `core.parameters`), you can follow these steps:\n\n- Rename the `core.evaluate` module to `core.parameters`.\n- Refactor the `_global_parameters` class to use a dictionary for storing global parameters.\n- Implement the `__getitem__` method to retrieve the value of a parameter.\n- Implement properties for each parameter that act as getters and setters.\n- Implement context manager functionality for each parameter.\n\nHere is a high-level overview of the changes to be made in `sympy/core/parameters.py`:\n\n```python\n# sympy/core/parameters.py\n\n# Rename the class to reflect the new module name\nclass _GlobalParameters(local):\n    def __init__(self, **kwargs):\n        self._parameters = kwargs\n\n    def __getitem__(self, name):\n        return self._parameters[name]\n\n    def __setattr__(self, name, value):\n        if name == \"_parameters\":\n            super().__setattr__(name, value)\n        else:\n            if self._parameters[name] != value:\n                clear_cache()\n            self._parameters[name] = value\n\n    def __getattr__(self, name):\n        return self._parameters[name]\n\n    # Create a property for each global parameter\n    @property\n    def evaluate(self):\n        return self._parameters['evaluate'][0]\n\n    @evaluate.setter\n    def evaluate(self, value):\n        self.__setattr__('evaluate', [value])\n\n    # ... Repeat for other parameters like 'distribute'\n\n    # Implement context manager functionality\n    @contextmanager\n    def evaluate(self, value):\n        old_value = self._parameters['evaluate']\n        self._parameters['evaluate'] = [value]\n        try:\n            yield\n        finally:\n            self._parameters['evaluate'] = old_value\n\n# ... Repeat context manager for other parameters like 'distribute'\n\n# Instantiate the global parameters object\nglobal_parameters = _GlobalParameters(evaluate=[True], distribute=[True])\n```\n\n- Update all references to `global_parameters.evaluate` and `global_parameters.distribute` throughout the codebase to use the new dictionary-based access.\n- Update the `evaluate` and `distribute` context managers to use the new `global_parameters` object and its context manager methods.\n\nRemember to update the module imports in other files, such as `sympy/simplify/simplify.py` and `sympy/core/__init__.py`, to reflect the new module name `core.parameters`.\n\nThis is a high-level overview, and the actual implementation may require additional refactoring to ensure thread safety and proper interaction with the SymPy cache system.",
        "bouncer_response": {
            "score": 7,
            "criteria": "RESPONSES that are highly relevant, offering clear and comprehensive suggestions or solutions for the described feature request, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable plan for implementing the feature request, including renaming the module, refactoring the class, and implementing the requested methods and properties. It also includes a high-level overview of the code changes and context manager functionality, which is directly relevant to the feature request. The RESPONSE addresses the renaming of the module, the dictionary-based storage of parameters, and the implementation of the __getitem__ method, properties, and context manager functionality. However, it does not fully address thread safety and proper interaction with the SymPy cache system, which are mentioned but not elaborated upon. This lack of complete detail on these aspects prevents the RESPONSE from scoring higher.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711746170.956737,
        "result": "To implement the requested feature in the `core.evaluate` module (which should be renamed to `core.parameters`), you can follow these steps:\n\n- Rename the `core.evaluate` module to `core.parameters`.\n- Refactor the `_global_parameters` class to use a dictionary for storing global parameters.\n- Implement the `__getitem__` method to retrieve the value of a parameter.\n- Implement properties for each parameter that act as getters and setters.\n- Implement context manager functionality for each parameter.\n\nHere is a high-level overview of the changes to be made in `sympy/core/parameters.py`:\n\n```python\n# sympy/core/parameters.py\n\n# Rename the class to reflect the new module name\nclass _GlobalParameters(local):\n    def __init__(self, **kwargs):\n        self._parameters = kwargs\n\n    def __getitem__(self, name):\n        return self._parameters[name]\n\n    def __setattr__(self, name, value):\n        if name == \"_parameters\":\n            super().__setattr__(name, value)\n        else:\n            if self._parameters[name] != value:\n                clear_cache()\n            self._parameters[name] = value\n\n    def __getattr__(self, name):\n        return self._parameters[name]\n\n    # Create a property for each global parameter\n    @property\n    def evaluate(self):\n        return self._parameters['evaluate'][0]\n\n    @evaluate.setter\n    def evaluate(self, value):\n        self.__setattr__('evaluate', [value])\n\n    # ... Repeat for other parameters like 'distribute'\n\n    # Implement context manager functionality\n    @contextmanager\n    def evaluate(self, value):\n        old_value = self._parameters['evaluate']\n        self._parameters['evaluate'] = [value]\n        try:\n            yield\n        finally:\n            self._parameters['evaluate'] = old_value\n\n# ... Repeat context manager for other parameters like 'distribute'\n\n# Instantiate the global parameters object\nglobal_parameters = _GlobalParameters(evaluate=[True], distribute=[True])\n```\n\n- Update all references to `global_parameters.evaluate` and `global_parameters.distribute` throughout the codebase to use the new dictionary-based access.\n- Update the `evaluate` and `distribute` context managers to use the new `global_parameters` object and its context manager methods.\n\nRemember to update the module imports in other files, such as `sympy/simplify/simplify.py` and `sympy/core/__init__.py`, to reflect the new module name `core.parameters`.\n\nThis is a high-level overview, and the actual implementation may require additional refactoring to ensure thread safety and proper interaction with the SymPy cache system.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.6/tree//sympy) \u2192 [core](https://github.com/testbed/sympy__sympy__1.6/tree//sympy/core)- [Lines 1 - 99](https://github.com/testbed/sympy__sympy__1.6/blob//sympy/core/parameters.py#L1-L99)\n\n This snippet defines the _global_parameters class and the global_parameters instance, which are directly related to the issue's suggestion of renaming the module and using a dict-like handler for global parameters. \n\n\n   - [Lines 70 - 128](https://github.com/testbed/sympy__sympy__1.6/blob//sympy/core/parameters.py#L70-L128)\n\n This snippet shows the use of the global_parameters instance for controlling the 'distribute' parameter, which is relevant to the issue's discussion about handling multiple global parameters.",
        "context_relevance": 0.32000000000000006,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers it completely.\nSupporting Evidence: The RESPONSE provides a detailed plan for implementing the suggested changes to the `core.evaluate` module, including renaming it to `core.parameters`, refactoring the class to use a dictionary, implementing the `__getitem__` method, properties for parameters, and context manager functionality. It also includes a high-level overview of the changes in code format, which directly addresses the suggestions made in the PROMPT. The RESPONSE is thorough and provides relevant context to all parts of the PROMPT, thus fulfilling the criteria for a score of 10."
        },
        "qa_relevance": 1.0
    }
}