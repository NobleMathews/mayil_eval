{
    "id": "pydata__xarray-4758",
    "repo_name": "testbed/pydata__xarray__0.12",
    "task_id": 175999417623856514,
    "title": "CFTime offsets missing for milli- and micro-seconds",
    "body": "<!-- A short summary of the issue, if appropriate -->\r\nThe smallest cftime offset defined in `xarray.coding.cftime_offsets.py` is \"second\" (S), but the precision of cftime objects goes down to the millisecond  (L) and microsecond (U). They should be easily added.\r\n\r\nPR #4033 adds a `xr.infer_freq` that supports the two, but they are currently untested as `xr.cftime_range` cannot generate an index.\r\n\r\n#### MCVE Code Sample\r\n<!-- In order for the maintainers to efficiently understand and prioritize issues, we ask you post a \"Minimal, Complete and Verifiable Example\" (MCVE): http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports -->\r\n\r\n```python\r\nxr.cftime_range(\"2000-01-01\", periods=3, freq='10L')\r\n```\r\n\r\n#### Expected Output\r\n```\r\nCFTimeIndex([2000-01-01 00:00:00, 2000-01-01 00:00:00.010000,\r\n             2000-01-01 00:00:00.020000],\r\n            dtype='object')\r\n```\r\n\r\n#### Problem Description\r\n<!-- this should explain why the current behavior is a problem and why the expected output is a better solution -->\r\nAn error gets raised : `ValueError: Invalid frequency string provided `.\r\n\r\n#### Versions\r\n\r\n<details><summary>Output of <tt>xr.show_versions()</tt></summary>\r\n\r\n<!-- Paste the output here xr.show_versions() here -->\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit: None\r\npython: 3.8.2 | packaged by conda-forge | (default, Apr 24 2020, 08:20:52) \r\n[GCC 7.3.0]\r\npython-bits: 64\r\nOS: Linux\r\nOS-release: 5.6.13-arch1-1\r\nmachine: x86_64\r\nprocessor: \r\nbyteorder: little\r\nLC_ALL: None\r\nLANG: fr_CA.utf8\r\nLOCALE: fr_CA.UTF-8\r\nlibhdf5: 1.10.5\r\nlibnetcdf: 4.7.4\r\n\r\nxarray: 0.15.2.dev9+g6378a711.d20200505\r\npandas: 1.0.3\r\nnumpy: 1.18.4\r\nscipy: 1.4.1\r\nnetCDF4: 1.5.3\r\npydap: None\r\nh5netcdf: None\r\nh5py: 2.10.0\r\nNio: None\r\nzarr: None\r\ncftime: 1.1.1.2\r\nnc_time_axis: 1.2.0\r\nPseudoNetCDF: None\r\nrasterio: None\r\ncfgrib: None\r\niris: None\r\nbottleneck: 1.3.2\r\ndask: 2.16.0\r\ndistributed: 2.16.0\r\nmatplotlib: 3.2.1\r\ncartopy: None\r\nseaborn: None\r\nnumbagg: None\r\npint: 0.11\r\nsetuptools: 46.1.3.post20200325\r\npip: 20.0.2\r\nconda: None\r\npytest: 5.4.1\r\nIPython: 7.13.0\r\nsphinx: 3.0.2\r\n\r\n</details>\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pydata__xarray__0.12.git",
    "requested_commit": "",
    "mayil_response": "To resolve the issue with `xarray` not being able to handle \"L\" and \"U\" frequency strings in `cftime_range` and `infer_freq`, follow these steps:\n\n- Ensure that the `Millisecond` and `Microsecond` classes are properly defined in `xarray/coding/cftime_offsets.py` with the `_freqstr` attributes set to \"L\" and \"U\" respectively.\n- Verify that the `_FREQUENCIES` dictionary in `xarray/coding/cftime_offsets.py` includes entries for \"L\" and \"U\" that map to the `Millisecond` and `Microsecond` classes.\n- Update the `cftime_range` function in `xarray/coding/cftime_offsets.py` to handle \"L\" and \"U\" frequency strings by using the `_FREQUENCIES` dictionary to map the frequency string to the correct offset class.\n- Implement error handling in `cftime_range` to raise a `ValueError` with a clear message when an invalid frequency string is provided.\n- Add tests for `cftime_range` and `infer_freq` to ensure that they correctly handle \"L\" and \"U\" frequency strings and that they raise the appropriate errors for invalid frequency strings.\n- Ensure that the `to_offset` function in `xarray/coding/cftime_offsets.py` can parse \"L\" and \"U\" frequency strings and return the correct `Millisecond` or `Microsecond` offset instance.\n- Update the `_CFTimeFrequencyInferer` class in `xarray/coding/frequencies.py` to support inferring millisecond and microsecond frequencies.\n- Add tests for the `_CFTimeFrequencyInferer` class to ensure it correctly infers \"L\" and \"U\" frequencies from `CFTimeIndex` objects.\n\nBy making these changes, `xarray` will be able to handle millisecond and microsecond frequency strings in `cftime_range` and `infer_freq`, and it will provide clear error messages when invalid frequency strings are used.\n\n### Code snippets to check\n\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 659 - 734](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L659-L734)\n\n This snippet contains the frequency definitions for cftime offsets, including the missing millisecond (L) and microsecond (U) frequencies that need to be supported. \n\n\n   - [Lines 737 - 1322](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L737-L1322)\n\n This snippet includes the 'to_offset' function which converts frequency strings to offset objects. It is relevant because it handles the interpretation of frequency strings, which must now include millisecond and microsecond frequencies. \n\n\n   - [Lines 1 - 75](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L1-L75)\n\n This snippet is the header of the cftime_offsets.py file, which is relevant because the issue is related to the offsets defined in this file.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 510 - 584](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftimeindex.py#L510-L584)\n\n This snippet contains the 'shift' method of CFTimeIndex, which is relevant because it needs to handle shifting by new millisecond and microsecond frequencies. \n\n\n   - [Lines 1 - 85](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftimeindex.py#L1-L85)\n\n This snippet defines the CFTimeIndex class, which is relevant because the issue pertains to the generation of CFTimeIndex objects with millisecond and microsecond frequencies.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005495,
        "snippet_processor": 0.06112,
        "issue_star_creation": 0.025959999999999997,
        "issue_star_solver": 0.08023,
        "bouncer": 0.027180000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711759330.892234,
        "relevant_snippets": [
            {
                "code": "\"\"\"Time offset classes for use with cftime.datetime objects\"\"\"\n# The offset classes and mechanisms for generating time ranges defined in\n# this module were copied/adapted from those defined in pandas.  See in\n# particular the objects and methods defined in pandas.tseries.offsets\n# and pandas.core.indexes.datetimes.\n\n# For reference, here is a copy of the pandas copyright notice:\n\n# (c) 2011-2012, Lambda Foundry, Inc. and PyData Development Team\n# All rights reserved.\n\n# Copyright (c) 2008-2011 AQR Capital Management, LLC\n# All rights reserved.\n\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n\n#     * Redistributions of source code must retain the above copyright\n#        notice, this list of conditions and the following disclaimer.\n\n#     * Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials provided\n#        with the distribution.\n\n#     * Neither the name of the copyright holder nor the names of any\n#        contributors may be used to endorse or promote products derived\n#        from this software without specific prior written permission.\n\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nfrom __future__ import annotations\n\nimport re\nfrom datetime import datetime, timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING, ClassVar\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.cftimeindex import CFTimeIndex, _parse_iso8601_with_reso\nfrom xarray.coding.times import (\n    _is_standard_calendar,\n    _should_cftime_be_used,\n    convert_time_or_go_back,\n    format_cftime_datetime,\n)\nfrom xarray.core.common import _contains_datetime_like_objects, is_np_datetime_like\nfrom xarray.core.pdcompat import (\n    NoDefault,\n    count_not_none,\n    nanosecond_precision_timestamp,\n    no_default,\n)\nfrom xarray.core.utils import emit_user_level_warning\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\n\nif TYPE_CHECKING:\n    from xarray.core.types import InclusiveOptions, SideOptions",
                "filename": "xarray/coding/cftime_offsets.py",
                "start_index": 0,
                "end_index": 2906,
                "start_line": 1,
                "end_line": 75,
                "max_line": 1322,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "_FREQUENCIES = {\n    \"A\": YearEnd,\n    \"AS\": YearBegin,\n    \"Y\": YearEnd,\n    \"YS\": YearBegin,\n    \"Q\": partial(QuarterEnd, month=12),\n    \"QS\": partial(QuarterBegin, month=1),\n    \"M\": MonthEnd,\n    \"MS\": MonthBegin,\n    \"D\": Day,\n    \"H\": Hour,\n    \"T\": Minute,\n    \"min\": Minute,\n    \"S\": Second,\n    \"L\": Millisecond,\n    \"ms\": Millisecond,\n    \"U\": Microsecond,\n    \"us\": Microsecond,\n    \"AS-JAN\": partial(YearBegin, month=1),\n    \"AS-FEB\": partial(YearBegin, month=2),\n    \"AS-MAR\": partial(YearBegin, month=3),\n    \"AS-APR\": partial(YearBegin, month=4),\n    \"AS-MAY\": partial(YearBegin, month=5),\n    \"AS-JUN\": partial(YearBegin, month=6),\n    \"AS-JUL\": partial(YearBegin, month=7),\n    \"AS-AUG\": partial(YearBegin, month=8),\n    \"AS-SEP\": partial(YearBegin, month=9),\n    \"AS-OCT\": partial(YearBegin, month=10),\n    \"AS-NOV\": partial(YearBegin, month=11),\n    \"AS-DEC\": partial(YearBegin, month=12),\n    \"A-JAN\": partial(YearEnd, month=1),\n    \"A-FEB\": partial(YearEnd, month=2),\n    \"A-MAR\": partial(YearEnd, month=3),\n    \"A-APR\": partial(YearEnd, month=4),\n    \"A-MAY\": partial(YearEnd, month=5),\n    \"A-JUN\": partial(YearEnd, month=6),\n    \"A-JUL\": partial(YearEnd, month=7),\n    \"A-AUG\": partial(YearEnd, month=8),\n    \"A-SEP\": partial(YearEnd, month=9),\n    \"A-OCT\": partial(YearEnd, month=10),\n    \"A-NOV\": partial(YearEnd, month=11),\n    \"A-DEC\": partial(YearEnd, month=12),\n    \"QS-JAN\": partial(QuarterBegin, month=1),\n    \"QS-FEB\": partial(QuarterBegin, month=2),\n    \"QS-MAR\": partial(QuarterBegin, month=3),\n    \"QS-APR\": partial(QuarterBegin, month=4),\n    \"QS-MAY\": partial(QuarterBegin, month=5),\n    \"QS-JUN\": partial(QuarterBegin, month=6),\n    \"QS-JUL\": partial(QuarterBegin, month=7),\n    \"QS-AUG\": partial(QuarterBegin, month=8),\n    \"QS-SEP\": partial(QuarterBegin, month=9),\n    \"QS-OCT\": partial(QuarterBegin, month=10),\n    \"QS-NOV\": partial(QuarterBegin, month=11),\n    \"QS-DEC\": partial(QuarterBegin, month=12),\n    \"Q-JAN\": partial(QuarterEnd, month=1),\n    \"Q-FEB\": partial(QuarterEnd, month=2),\n    \"Q-MAR\": partial(QuarterEnd, month=3),\n    \"Q-APR\": partial(QuarterEnd, month=4),\n    \"Q-MAY\": partial(QuarterEnd, month=5),\n    \"Q-JUN\": partial(QuarterEnd, month=6),\n    \"Q-JUL\": partial(QuarterEnd, month=7),\n    \"Q-AUG\": partial(QuarterEnd, month=8),\n    \"Q-SEP\": partial(QuarterEnd, month=9),\n    \"Q-OCT\": partial(QuarterEnd, month=10),\n    \"Q-NOV\": partial(QuarterEnd, month=11),\n    \"Q-DEC\": partial(QuarterEnd, month=12),\n}\n\n\n_FREQUENCY_CONDITION = \"|\".join(_FREQUENCIES.keys())\n_PATTERN = rf\"^((?P<multiple>\\d+)|())(?P<freq>({_FREQUENCY_CONDITION}))$\"\n\n\n# pandas defines these offsets as \"Tick\" objects, which for instance have\n# distinct behavior from monthly or longer frequencies in resample.\nCFTIME_TICKS = (Day, Hour, Minute, Second)",
                "filename": "xarray/coding/cftime_offsets.py",
                "start_index": 20803,
                "end_index": 23586,
                "start_line": 659,
                "end_line": 734,
                "max_line": 1322,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "\"\"\"FrequencyInferer analog for cftime.datetime objects\"\"\"\n# The infer_freq method and the _CFTimeFrequencyInferer\n# subclass defined here were copied and adapted for\n# use with cftime.datetime objects based on the source code in\n# pandas.tseries.Frequencies._FrequencyInferer\n\n# For reference, here is a copy of the pandas copyright notice:\n\n# (c) 2011-2012, Lambda Foundry, Inc. and PyData Development Team\n# All rights reserved.\n\n# Copyright (c) 2008-2011 AQR Capital Management, LLC\n# All rights reserved.\n\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n\n#     * Redistributions of source code must retain the above copyright\n#        notice, this list of conditions and the following disclaimer.\n\n#     * Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials provided\n#        with the distribution.\n\n#     * Neither the name of the copyright holder nor the names of any\n#        contributors may be used to endorse or promote products derived\n#        from this software without specific prior written permission.\n\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nfrom __future__ import annotations\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.cftime_offsets import _MONTH_ABBREVIATIONS\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.common import _contains_datetime_like_objects\n\n_ONE_MICRO = 1\n_ONE_MILLI = _ONE_MICRO * 1000\n_ONE_SECOND = _ONE_MILLI * 1000\n_ONE_MINUTE = 60 * _ONE_SECOND\n_ONE_HOUR = 60 * _ONE_MINUTE\n_ONE_DAY = 24 * _ONE_HOUR",
                "filename": "xarray/coding/frequencies.py",
                "start_index": 0,
                "end_index": 2448,
                "start_line": 1,
                "end_line": 56,
                "max_line": 273,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Resampling for CFTimeIndex. Does not support non-integer freq.\"\"\"\n# The mechanisms for resampling CFTimeIndex was copied and adapted from\n# the source code defined in pandas.core.resample\n#\n# For reference, here is a copy of the pandas copyright notice:\n#\n# BSD 3-Clause License\n#\n# Copyright (c) 2008-2012, AQR Capital Management, LLC, Lambda Foundry, Inc.\n# and PyData Development Team\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of the copyright holder nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\nfrom __future__ import annotations\n\nimport datetime\nimport typing\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.cftime_offsets import (\n    BaseCFTimeOffset,\n    Day,\n    MonthEnd,\n    QuarterEnd,\n    Tick,\n    YearEnd,\n    cftime_range,\n    normalize_date,\n    to_offset,\n)\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.types import SideOptions\n\nif typing.TYPE_CHECKING:\n    from xarray.core.types import CFTimeDatetime",
                "filename": "xarray/core/resample_cftime.py",
                "start_index": 0,
                "end_index": 2352,
                "start_line": 1,
                "end_line": 61,
                "max_line": 514,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"DatetimeIndex analog for cftime.datetime objects\"\"\"\n# The pandas.Index subclass defined here was copied and adapted for\n# use with cftime.datetime objects based on the source code defining\n# pandas.DatetimeIndex.\n\n# For reference, here is a copy of the pandas copyright notice:\n\n# (c) 2011-2012, Lambda Foundry, Inc. and PyData Development Team\n# All rights reserved.\n\n# Copyright (c) 2008-2011 AQR Capital Management, LLC\n# All rights reserved.\n\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n\n#     * Redistributions of source code must retain the above copyright\n#        notice, this list of conditions and the following disclaimer.\n\n#     * Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials provided\n#        with the distribution.\n\n#     * Neither the name of the copyright holder nor the names of any\n#        contributors may be used to endorse or promote products derived\n#        from this software without specific prior written permission.\n\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nfrom __future__ import annotations\n\nimport math\nimport re\nimport warnings\nfrom datetime import timedelta\n\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\n\nfrom xarray.coding.times import (\n    _STANDARD_CALENDARS,\n    cftime_to_nptime,\n    infer_calendar_name,\n)\nfrom xarray.core.common import _contains_cftime_datetimes\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_scalar\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\n\n# constants for cftimeindex.repr\nCFTIME_REPR_LENGTH = 19\nITEMS_IN_REPR_MAX_ELSE_ELLIPSIS = 100\nREPR_ELLIPSIS_SHOW_ITEMS_FRONT_END = 10\n\n\nOUT_OF_BOUNDS_TIMEDELTA_ERRORS: tuple[type[Exception], ...]\ntry:\n    OUT_OF_BOUNDS_TIMEDELTA_ERRORS = (pd.errors.OutOfBoundsTimedelta, OverflowError)\nexcept AttributeError:\n    OUT_OF_BOUNDS_TIMEDELTA_ERRORS = (OverflowError,)\n\n\ndef named(name, pattern):\n    return \"(?P<\" + name + \">\" + pattern + \")\"\n\n\ndef optional(x):\n    return \"(?:\" + x + \")?\"",
                "filename": "xarray/coding/cftimeindex.py",
                "start_index": 0,
                "end_index": 2952,
                "start_line": 1,
                "end_line": 85,
                "max_line": 859,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def contains(self, key):\n        \"\"\"Needed for .loc based partial-string indexing\"\"\"\n        return self.__contains__(key)\n\n    def shift(self, n: int | float, freq: str | timedelta):\n        \"\"\"Shift the CFTimeIndex a multiple of the given frequency.\n\n        See the documentation for :py:func:`~xarray.cftime_range` for a\n        complete listing of valid frequency strings.\n\n        Parameters\n        ----------\n        n : int, float if freq of days or below\n            Periods to shift by\n        freq : str or datetime.timedelta\n            A frequency string or datetime.timedelta object to shift by\n\n        Returns\n        -------\n        CFTimeIndex\n\n        See Also\n        --------\n        pandas.DatetimeIndex.shift\n\n        Examples\n        --------\n        >>> index = xr.cftime_range(\"2000\", periods=1, freq=\"M\")\n        >>> index\n        CFTimeIndex([2000-01-31 00:00:00],\n                    dtype='object', length=1, calendar='standard', freq=None)\n        >>> index.shift(1, \"M\")\n        CFTimeIndex([2000-02-29 00:00:00],\n                    dtype='object', length=1, calendar='standard', freq=None)\n        >>> index.shift(1.5, \"D\")\n        CFTimeIndex([2000-02-01 12:00:00],\n                    dtype='object', length=1, calendar='standard', freq=None)\n        \"\"\"\n        if isinstance(freq, timedelta):\n            return self + n * freq\n        elif isinstance(freq, str):\n            from xarray.coding.cftime_offsets import to_offset\n\n            return self + n * to_offset(freq)\n        else:\n            raise TypeError(\n                \"'freq' must be of type \"\n                \"str or datetime.timedelta, got {}.\".format(freq)\n            )\n\n    def __add__(self, other):\n        if isinstance(other, pd.TimedeltaIndex):\n            other = other.to_pytimedelta()\n        return CFTimeIndex(np.array(self) + other)\n\n    def __radd__(self, other):\n        if isinstance(other, pd.TimedeltaIndex):\n            other = other.to_pytimedelta()\n        return CFTimeIndex(other + np.array(self))\n\n    def __sub__(self, other):\n        if _contains_datetime_timedeltas(other):\n            return CFTimeIndex(np.array(self) - other)\n        elif isinstance(other, pd.TimedeltaIndex):\n            return CFTimeIndex(np.array(self) - other.to_pytimedelta())\n        elif _contains_cftime_datetimes(np.array(other)):\n            try:\n                return pd.TimedeltaIndex(np.array(self) - np.array(other))\n            except OUT_OF_BOUNDS_TIMEDELTA_ERRORS:\n                raise ValueError(\n                    \"The time difference exceeds the range of values \"\n                    \"that can be expressed at the nanosecond resolution.\"\n                )\n        else:\n            return NotImplemented",
                "filename": "xarray/coding/cftimeindex.py",
                "start_index": 18084,
                "end_index": 20814,
                "start_line": 510,
                "end_line": 584,
                "max_line": 859,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def to_offset(freq):\n    \"\"\"Convert a frequency string to the appropriate subclass of\n    BaseCFTimeOffset.\"\"\"\n    if isinstance(freq, BaseCFTimeOffset):\n        return freq\n    else:\n        try:\n            freq_data = re.match(_PATTERN, freq).groupdict()\n        except AttributeError:\n            raise ValueError(\"Invalid frequency string provided\")\n\n    freq = freq_data[\"freq\"]\n    multiples = freq_data[\"multiple\"]\n    multiples = 1 if multiples is None else int(multiples)\n    return _FREQUENCIES[freq](n=multiples)\n\n\ndef to_cftime_datetime(date_str_or_date, calendar=None):\n    if cftime is None:\n        raise ModuleNotFoundError(\"No module named 'cftime'\")\n\n    if isinstance(date_str_or_date, str):\n        if calendar is None:\n            raise ValueError(\n                \"If converting a string to a cftime.datetime object, \"\n                \"a calendar type must be provided\"\n            )\n        date, _ = _parse_iso8601_with_reso(get_date_type(calendar), date_str_or_date)\n        return date\n    elif isinstance(date_str_or_date, cftime.datetime):\n        return date_str_or_date\n    elif isinstance(date_str_or_date, (datetime, pd.Timestamp)):\n        return cftime.DatetimeProlepticGregorian(*date_str_or_date.timetuple())\n    else:\n        raise TypeError(\n            \"date_str_or_date must be a string or a \"\n            \"subclass of cftime.datetime. Instead got \"\n            \"{!r}.\".format(date_str_or_date)\n        )\n\n\ndef normalize_date(date):\n    \"\"\"Round datetime down to midnight.\"\"\"\n    return date.replace(hour=0, minute=0, second=0, microsecond=0)\n\n\ndef _maybe_normalize_date(date, normalize):\n    \"\"\"Round datetime down to midnight if normalize is True.\"\"\"\n    if normalize:\n        return normalize_date(date)\n    else:\n        return date\n\n\ndef _generate_linear_range(start, end, periods):\n    \"\"\"Generate an equally-spaced sequence of cftime.datetime objects between\n    and including two dates (whose length equals the number of periods).\"\"\"\n    if cftime is None:\n        raise ModuleNotFoundError(\"No module named 'cftime'\")\n\n    total_seconds = (end - start).total_seconds()\n    values = np.linspace(0.0, total_seconds, periods, endpoint=True)\n    units = f\"seconds since {format_cftime_datetime(start)}\"\n    calendar = start.calendar\n    return cftime.num2date(\n        values, units=units, calendar=calendar, only_use_cftime_datetimes=True\n    )",
                "filename": "xarray/coding/cftime_offsets.py",
                "start_index": 23589,
                "end_index": 25980,
                "start_line": 737,
                "end_line": 1322,
                "max_line": 1322,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class CFTimeIndex(pd.Index):",
                "filename": "xarray/coding/cftimeindex.py",
                "start_index": 9392,
                "end_index": 9420,
                "start_line": 284,
                "end_line": 284,
                "max_line": 859,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class QuarterEnd(QuarterOffset):\n    # When converting a string to an offset, pandas converts\n    # 'Q' to a QuarterEnd offset starting in the month of\n    # December.  When creating a QuarterEnd offset directly\n    # from the constructor, however, the default month is March.\n    # We follow that behavior here.\n    _default_month = 3\n    _freq = \"Q\"\n    _day_option = \"end\"\n\n    def rollforward(self, date):\n        \"\"\"Roll date forward to nearest end of quarter\"\"\"\n        if self.onOffset(date):\n            return date\n        else:\n            return date + QuarterEnd(month=self.month)\n\n    def rollback(self, date):\n        \"\"\"Roll date backward to nearest end of quarter\"\"\"\n        if self.onOffset(date):\n            return date\n        else:\n            return date - QuarterEnd(month=self.month)\n\n\nclass YearOffset(BaseCFTimeOffset):\n    _freq: ClassVar[str]\n    _day_option: ClassVar[str]\n    _default_month: ClassVar[int]\n\n    def __init__(self, n=1, month=None):\n        BaseCFTimeOffset.__init__(self, n)\n        self.month = _validate_month(month, self._default_month)\n\n    def __apply__(self, other):\n        reference_day = _get_day_of_month(other, self._day_option)\n        years = _adjust_n_years(other, self.n, self.month, reference_day)\n        months = years * 12 + (self.month - other.month)\n        return _shift_month(other, months, self._day_option)\n\n    def __sub__(self, other):\n        if cftime is None:\n            raise ModuleNotFoundError(\"No module named 'cftime'\")\n\n        if isinstance(other, cftime.datetime):\n            raise TypeError(\"Cannot subtract cftime.datetime from offset.\")\n        elif type(other) == type(self) and other.month == self.month:\n            return type(self)(self.n - other.n, month=self.month)\n        else:\n            return NotImplemented\n\n    def __mul__(self, other):\n        if isinstance(other, float):\n            return NotImplemented\n        return type(self)(n=other * self.n, month=self.month)\n\n    def rule_code(self):\n        return f\"{self._freq}-{_MONTH_ABBREVIATIONS[self.month]}\"\n\n    def __str__(self):\n        return f\"<{type(self).__name__}: n={self.n}, month={self.month}>\"\n\n\nclass YearBegin(YearOffset):\n    _freq = \"AS\"\n    _day_option = \"start\"\n    _default_month = 1\n\n    def onOffset(self, date):\n        \"\"\"Check if the given date is in the set of possible dates created\n        using a length-one version of this offset class.\"\"\"\n        return date.day == 1 and date.month == self.month\n\n    def rollforward(self, date):\n        \"\"\"Roll date forward to nearest start of year\"\"\"\n        if self.onOffset(date):\n            return date\n        else:\n            return date + YearBegin(month=self.month)\n\n    def rollback(self, date):\n        \"\"\"Roll date backward to nearest start of year\"\"\"\n        if self.onOffset(date):\n            return date\n        else:\n            return date - YearBegin(month=self.month)",
                "filename": "xarray/coding/cftime_offsets.py",
                "start_index": 16018,
                "end_index": 18930,
                "start_line": 486,
                "end_line": 571,
                "max_line": 1322,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "from __future__ import annotations\n\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime, timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING, Callable, Union\n\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime, OutOfBoundsTimedelta\n\nfrom xarray.coding.variables import (\n    SerializationWarning,\n    VariableCoder,\n    lazy_elemwise_func,\n    pop_to,\n    safe_setitem,\n    unpack_for_decoding,\n    unpack_for_encoding,\n)\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes, is_np_datetime_like\nfrom xarray.core.formatting import first_n_items, format_timestamp, last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.pycompat import is_duck_dask_array\nfrom xarray.core.variable import Variable\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\nif TYPE_CHECKING:\n    from xarray.core.types import CFCalendar\n\n    T_Name = Union[Hashable, None]\n\n# standard calendars recognized by cftime\n_STANDARD_CALENDARS = {\"standard\", \"gregorian\", \"proleptic_gregorian\"}\n\n_NS_PER_TIME_DELTA = {\n    \"ns\": 1,\n    \"us\": int(1e3),\n    \"ms\": int(1e6),\n    \"s\": int(1e9),\n    \"m\": int(1e9) * 60,\n    \"h\": int(1e9) * 60 * 60,\n    \"D\": int(1e9) * 60 * 60 * 24,\n}\n\n_US_PER_TIME_DELTA = {\n    \"microseconds\": 1,\n    \"milliseconds\": 1_000,\n    \"seconds\": 1_000_000,\n    \"minutes\": 60 * 1_000_000,\n    \"hours\": 60 * 60 * 1_000_000,\n    \"days\": 24 * 60 * 60 * 1_000_000,\n}\n\n_NETCDF_TIME_UNITS_CFTIME = [\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"milliseconds\",\n    \"microseconds\",\n]\n\n_NETCDF_TIME_UNITS_NUMPY = _NETCDF_TIME_UNITS_CFTIME + [\"nanoseconds\"]\n\nTIME_UNITS = frozenset(\n    [\n        \"days\",\n        \"hours\",\n        \"minutes\",\n        \"seconds\",\n        \"milliseconds\",\n        \"microseconds\",\n        \"nanoseconds\",\n    ]\n)\n\n\ndef _is_standard_calendar(calendar: str) -> bool:\n    return calendar.lower() in _STANDARD_CALENDARS\n\n\ndef _is_numpy_compatible_time_range(times):\n    if is_np_datetime_like(times.dtype):\n        return True\n    # times array contains cftime objects\n    times = np.asarray(times)\n    tmin = times.min()\n    tmax = times.max()\n    try:\n        convert_time_or_go_back(tmin, pd.Timestamp)\n        convert_time_or_go_back(tmax, pd.Timestamp)\n    except pd.errors.OutOfBoundsDatetime:\n        return False\n    except ValueError as err:\n        if err.args[0] == \"year 0 is out of range\":\n            return False\n        raise\n    else:\n        return True\n\n\ndef _netcdf_to_numpy_timeunit(units: str) -> str:\n    units = units.lower()\n    if not units.endswith(\"s\"):\n        units = f\"{units}s\"\n    return {\n        \"nanoseconds\": \"ns\",\n        \"microseconds\": \"us\",\n        \"milliseconds\": \"ms\",\n        \"seconds\": \"s\",\n        \"minutes\": \"m\",\n        \"hours\": \"h\",\n        \"days\": \"D\",\n    }[units]",
                "filename": "xarray/coding/times.py",
                "start_index": 0,
                "end_index": 2910,
                "start_line": 1,
                "end_line": 122,
                "max_line": 762,
                "git_instance": "github",
                "repo_name": "testbed/pydata__xarray__0.12",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "xarray/coding/cftime_offsets.py": [
                {
                    "chunk": {
                        "code": "_FREQUENCIES = {\n    \"A\": YearEnd,\n    \"AS\": YearBegin,\n    \"Y\": YearEnd,\n    \"YS\": YearBegin,\n    \"Q\": partial(QuarterEnd, month=12),\n    \"QS\": partial(QuarterBegin, month=1),\n    \"M\": MonthEnd,\n    \"MS\": MonthBegin,\n    \"D\": Day,\n    \"H\": Hour,\n    \"T\": Minute,\n    \"min\": Minute,\n    \"S\": Second,\n    \"L\": Millisecond,\n    \"ms\": Millisecond,\n    \"U\": Microsecond,\n    \"us\": Microsecond,\n    \"AS-JAN\": partial(YearBegin, month=1),\n    \"AS-FEB\": partial(YearBegin, month=2),\n    \"AS-MAR\": partial(YearBegin, month=3),\n    \"AS-APR\": partial(YearBegin, month=4),\n    \"AS-MAY\": partial(YearBegin, month=5),\n    \"AS-JUN\": partial(YearBegin, month=6),\n    \"AS-JUL\": partial(YearBegin, month=7),\n    \"AS-AUG\": partial(YearBegin, month=8),\n    \"AS-SEP\": partial(YearBegin, month=9),\n    \"AS-OCT\": partial(YearBegin, month=10),\n    \"AS-NOV\": partial(YearBegin, month=11),\n    \"AS-DEC\": partial(YearBegin, month=12),\n    \"A-JAN\": partial(YearEnd, month=1),\n    \"A-FEB\": partial(YearEnd, month=2),\n    \"A-MAR\": partial(YearEnd, month=3),\n    \"A-APR\": partial(YearEnd, month=4),\n    \"A-MAY\": partial(YearEnd, month=5),\n    \"A-JUN\": partial(YearEnd, month=6),\n    \"A-JUL\": partial(YearEnd, month=7),\n    \"A-AUG\": partial(YearEnd, month=8),\n    \"A-SEP\": partial(YearEnd, month=9),\n    \"A-OCT\": partial(YearEnd, month=10),\n    \"A-NOV\": partial(YearEnd, month=11),\n    \"A-DEC\": partial(YearEnd, month=12),\n    \"QS-JAN\": partial(QuarterBegin, month=1),\n    \"QS-FEB\": partial(QuarterBegin, month=2),\n    \"QS-MAR\": partial(QuarterBegin, month=3),\n    \"QS-APR\": partial(QuarterBegin, month=4),\n    \"QS-MAY\": partial(QuarterBegin, month=5),\n    \"QS-JUN\": partial(QuarterBegin, month=6),\n    \"QS-JUL\": partial(QuarterBegin, month=7),\n    \"QS-AUG\": partial(QuarterBegin, month=8),\n    \"QS-SEP\": partial(QuarterBegin, month=9),\n    \"QS-OCT\": partial(QuarterBegin, month=10),\n    \"QS-NOV\": partial(QuarterBegin, month=11),\n    \"QS-DEC\": partial(QuarterBegin, month=12),\n    \"Q-JAN\": partial(QuarterEnd, month=1),\n    \"Q-FEB\": partial(QuarterEnd, month=2),\n    \"Q-MAR\": partial(QuarterEnd, month=3),\n    \"Q-APR\": partial(QuarterEnd, month=4),\n    \"Q-MAY\": partial(QuarterEnd, month=5),\n    \"Q-JUN\": partial(QuarterEnd, month=6),\n    \"Q-JUL\": partial(QuarterEnd, month=7),\n    \"Q-AUG\": partial(QuarterEnd, month=8),\n    \"Q-SEP\": partial(QuarterEnd, month=9),\n    \"Q-OCT\": partial(QuarterEnd, month=10),\n    \"Q-NOV\": partial(QuarterEnd, month=11),\n    \"Q-DEC\": partial(QuarterEnd, month=12),\n}\n\n\n_FREQUENCY_CONDITION = \"|\".join(_FREQUENCIES.keys())\n_PATTERN = rf\"^((?P<multiple>\\d+)|())(?P<freq>({_FREQUENCY_CONDITION}))$\"\n\n\n# pandas defines these offsets as \"Tick\" objects, which for instance have\n# distinct behavior from monthly or longer frequencies in resample.\nCFTIME_TICKS = (Day, Hour, Minute, Second)",
                        "filename": "xarray/coding/cftime_offsets.py",
                        "start_index": 20803,
                        "end_index": 23586,
                        "start_line": 659,
                        "end_line": 734,
                        "max_line": 1322,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the frequency definitions for cftime offsets, including the missing millisecond (L) and microsecond (U) frequencies that need to be supported."
                },
                {
                    "chunk": {
                        "code": "def to_offset(freq):\n    \"\"\"Convert a frequency string to the appropriate subclass of\n    BaseCFTimeOffset.\"\"\"\n    if isinstance(freq, BaseCFTimeOffset):\n        return freq\n    else:\n        try:\n            freq_data = re.match(_PATTERN, freq).groupdict()\n        except AttributeError:\n            raise ValueError(\"Invalid frequency string provided\")\n\n    freq = freq_data[\"freq\"]\n    multiples = freq_data[\"multiple\"]\n    multiples = 1 if multiples is None else int(multiples)\n    return _FREQUENCIES[freq](n=multiples)\n\n\ndef to_cftime_datetime(date_str_or_date, calendar=None):\n    if cftime is None:\n        raise ModuleNotFoundError(\"No module named 'cftime'\")\n\n    if isinstance(date_str_or_date, str):\n        if calendar is None:\n            raise ValueError(\n                \"If converting a string to a cftime.datetime object, \"\n                \"a calendar type must be provided\"\n            )\n        date, _ = _parse_iso8601_with_reso(get_date_type(calendar), date_str_or_date)\n        return date\n    elif isinstance(date_str_or_date, cftime.datetime):\n        return date_str_or_date\n    elif isinstance(date_str_or_date, (datetime, pd.Timestamp)):\n        return cftime.DatetimeProlepticGregorian(*date_str_or_date.timetuple())\n    else:\n        raise TypeError(\n            \"date_str_or_date must be a string or a \"\n            \"subclass of cftime.datetime. Instead got \"\n            \"{!r}.\".format(date_str_or_date)\n        )\n\n\ndef normalize_date(date):\n    \"\"\"Round datetime down to midnight.\"\"\"\n    return date.replace(hour=0, minute=0, second=0, microsecond=0)\n\n\ndef _maybe_normalize_date(date, normalize):\n    \"\"\"Round datetime down to midnight if normalize is True.\"\"\"\n    if normalize:\n        return normalize_date(date)\n    else:\n        return date\n\n\ndef _generate_linear_range(start, end, periods):\n    \"\"\"Generate an equally-spaced sequence of cftime.datetime objects between\n    and including two dates (whose length equals the number of periods).\"\"\"\n    if cftime is None:\n        raise ModuleNotFoundError(\"No module named 'cftime'\")\n\n    total_seconds = (end - start).total_seconds()\n    values = np.linspace(0.0, total_seconds, periods, endpoint=True)\n    units = f\"seconds since {format_cftime_datetime(start)}\"\n    calendar = start.calendar\n    return cftime.num2date(\n        values, units=units, calendar=calendar, only_use_cftime_datetimes=True\n    )",
                        "filename": "xarray/coding/cftime_offsets.py",
                        "start_index": 23589,
                        "end_index": 25980,
                        "start_line": 737,
                        "end_line": 1322,
                        "max_line": 1322,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the 'to_offset' function which converts frequency strings to offset objects. It is relevant because it handles the interpretation of frequency strings, which must now include millisecond and microsecond frequencies."
                },
                {
                    "chunk": {
                        "code": "\"\"\"Time offset classes for use with cftime.datetime objects\"\"\"\n# The offset classes and mechanisms for generating time ranges defined in\n# this module were copied/adapted from those defined in pandas.  See in\n# particular the objects and methods defined in pandas.tseries.offsets\n# and pandas.core.indexes.datetimes.\n\n# For reference, here is a copy of the pandas copyright notice:\n\n# (c) 2011-2012, Lambda Foundry, Inc. and PyData Development Team\n# All rights reserved.\n\n# Copyright (c) 2008-2011 AQR Capital Management, LLC\n# All rights reserved.\n\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n\n#     * Redistributions of source code must retain the above copyright\n#        notice, this list of conditions and the following disclaimer.\n\n#     * Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials provided\n#        with the distribution.\n\n#     * Neither the name of the copyright holder nor the names of any\n#        contributors may be used to endorse or promote products derived\n#        from this software without specific prior written permission.\n\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nfrom __future__ import annotations\n\nimport re\nfrom datetime import datetime, timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING, ClassVar\n\nimport numpy as np\nimport pandas as pd\n\nfrom xarray.coding.cftimeindex import CFTimeIndex, _parse_iso8601_with_reso\nfrom xarray.coding.times import (\n    _is_standard_calendar,\n    _should_cftime_be_used,\n    convert_time_or_go_back,\n    format_cftime_datetime,\n)\nfrom xarray.core.common import _contains_datetime_like_objects, is_np_datetime_like\nfrom xarray.core.pdcompat import (\n    NoDefault,\n    count_not_none,\n    nanosecond_precision_timestamp,\n    no_default,\n)\nfrom xarray.core.utils import emit_user_level_warning\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\n\nif TYPE_CHECKING:\n    from xarray.core.types import InclusiveOptions, SideOptions",
                        "filename": "xarray/coding/cftime_offsets.py",
                        "start_index": 0,
                        "end_index": 2906,
                        "start_line": 1,
                        "end_line": 75,
                        "max_line": 1322,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is the header of the cftime_offsets.py file, which is relevant because the issue is related to the offsets defined in this file."
                }
            ],
            "xarray/coding/cftimeindex.py": [
                {
                    "chunk": {
                        "code": "def contains(self, key):\n        \"\"\"Needed for .loc based partial-string indexing\"\"\"\n        return self.__contains__(key)\n\n    def shift(self, n: int | float, freq: str | timedelta):\n        \"\"\"Shift the CFTimeIndex a multiple of the given frequency.\n\n        See the documentation for :py:func:`~xarray.cftime_range` for a\n        complete listing of valid frequency strings.\n\n        Parameters\n        ----------\n        n : int, float if freq of days or below\n            Periods to shift by\n        freq : str or datetime.timedelta\n            A frequency string or datetime.timedelta object to shift by\n\n        Returns\n        -------\n        CFTimeIndex\n\n        See Also\n        --------\n        pandas.DatetimeIndex.shift\n\n        Examples\n        --------\n        >>> index = xr.cftime_range(\"2000\", periods=1, freq=\"M\")\n        >>> index\n        CFTimeIndex([2000-01-31 00:00:00],\n                    dtype='object', length=1, calendar='standard', freq=None)\n        >>> index.shift(1, \"M\")\n        CFTimeIndex([2000-02-29 00:00:00],\n                    dtype='object', length=1, calendar='standard', freq=None)\n        >>> index.shift(1.5, \"D\")\n        CFTimeIndex([2000-02-01 12:00:00],\n                    dtype='object', length=1, calendar='standard', freq=None)\n        \"\"\"\n        if isinstance(freq, timedelta):\n            return self + n * freq\n        elif isinstance(freq, str):\n            from xarray.coding.cftime_offsets import to_offset\n\n            return self + n * to_offset(freq)\n        else:\n            raise TypeError(\n                \"'freq' must be of type \"\n                \"str or datetime.timedelta, got {}.\".format(freq)\n            )\n\n    def __add__(self, other):\n        if isinstance(other, pd.TimedeltaIndex):\n            other = other.to_pytimedelta()\n        return CFTimeIndex(np.array(self) + other)\n\n    def __radd__(self, other):\n        if isinstance(other, pd.TimedeltaIndex):\n            other = other.to_pytimedelta()\n        return CFTimeIndex(other + np.array(self))\n\n    def __sub__(self, other):\n        if _contains_datetime_timedeltas(other):\n            return CFTimeIndex(np.array(self) - other)\n        elif isinstance(other, pd.TimedeltaIndex):\n            return CFTimeIndex(np.array(self) - other.to_pytimedelta())\n        elif _contains_cftime_datetimes(np.array(other)):\n            try:\n                return pd.TimedeltaIndex(np.array(self) - np.array(other))\n            except OUT_OF_BOUNDS_TIMEDELTA_ERRORS:\n                raise ValueError(\n                    \"The time difference exceeds the range of values \"\n                    \"that can be expressed at the nanosecond resolution.\"\n                )\n        else:\n            return NotImplemented",
                        "filename": "xarray/coding/cftimeindex.py",
                        "start_index": 18084,
                        "end_index": 20814,
                        "start_line": 510,
                        "end_line": 584,
                        "max_line": 859,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'shift' method of CFTimeIndex, which is relevant because it needs to handle shifting by new millisecond and microsecond frequencies."
                },
                {
                    "chunk": {
                        "code": "\"\"\"DatetimeIndex analog for cftime.datetime objects\"\"\"\n# The pandas.Index subclass defined here was copied and adapted for\n# use with cftime.datetime objects based on the source code defining\n# pandas.DatetimeIndex.\n\n# For reference, here is a copy of the pandas copyright notice:\n\n# (c) 2011-2012, Lambda Foundry, Inc. and PyData Development Team\n# All rights reserved.\n\n# Copyright (c) 2008-2011 AQR Capital Management, LLC\n# All rights reserved.\n\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n\n#     * Redistributions of source code must retain the above copyright\n#        notice, this list of conditions and the following disclaimer.\n\n#     * Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials provided\n#        with the distribution.\n\n#     * Neither the name of the copyright holder nor the names of any\n#        contributors may be used to endorse or promote products derived\n#        from this software without specific prior written permission.\n\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nfrom __future__ import annotations\n\nimport math\nimport re\nimport warnings\nfrom datetime import timedelta\n\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\n\nfrom xarray.coding.times import (\n    _STANDARD_CALENDARS,\n    cftime_to_nptime,\n    infer_calendar_name,\n)\nfrom xarray.core.common import _contains_cftime_datetimes\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_scalar\n\ntry:\n    import cftime\nexcept ImportError:\n    cftime = None\n\n\n# constants for cftimeindex.repr\nCFTIME_REPR_LENGTH = 19\nITEMS_IN_REPR_MAX_ELSE_ELLIPSIS = 100\nREPR_ELLIPSIS_SHOW_ITEMS_FRONT_END = 10\n\n\nOUT_OF_BOUNDS_TIMEDELTA_ERRORS: tuple[type[Exception], ...]\ntry:\n    OUT_OF_BOUNDS_TIMEDELTA_ERRORS = (pd.errors.OutOfBoundsTimedelta, OverflowError)\nexcept AttributeError:\n    OUT_OF_BOUNDS_TIMEDELTA_ERRORS = (OverflowError,)\n\n\ndef named(name, pattern):\n    return \"(?P<\" + name + \">\" + pattern + \")\"\n\n\ndef optional(x):\n    return \"(?:\" + x + \")?\"",
                        "filename": "xarray/coding/cftimeindex.py",
                        "start_index": 0,
                        "end_index": 2952,
                        "start_line": 1,
                        "end_line": 85,
                        "max_line": 859,
                        "git_instance": "github",
                        "repo_name": "testbed/pydata__xarray__0.12",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the CFTimeIndex class, which is relevant because the issue pertains to the generation of CFTimeIndex objects with millisecond and microsecond frequencies."
                }
            ]
        },
        "solution_task": "To resolve the issue with `xarray` not being able to handle \"L\" and \"U\" frequency strings in `cftime_range` and `infer_freq`, follow these steps:\n\n- Ensure that the `Millisecond` and `Microsecond` classes are properly defined in `xarray/coding/cftime_offsets.py` with the `_freqstr` attributes set to \"L\" and \"U\" respectively.\n- Verify that the `_FREQUENCIES` dictionary in `xarray/coding/cftime_offsets.py` includes entries for \"L\" and \"U\" that map to the `Millisecond` and `Microsecond` classes.\n- Update the `cftime_range` function in `xarray/coding/cftime_offsets.py` to handle \"L\" and \"U\" frequency strings by using the `_FREQUENCIES` dictionary to map the frequency string to the correct offset class.\n- Implement error handling in `cftime_range` to raise a `ValueError` with a clear message when an invalid frequency string is provided.\n- Add tests for `cftime_range` and `infer_freq` to ensure that they correctly handle \"L\" and \"U\" frequency strings and that they raise the appropriate errors for invalid frequency strings.\n- Ensure that the `to_offset` function in `xarray/coding/cftime_offsets.py` can parse \"L\" and \"U\" frequency strings and return the correct `Millisecond` or `Microsecond` offset instance.\n- Update the `_CFTimeFrequencyInferer` class in `xarray/coding/frequencies.py` to support inferring millisecond and microsecond frequencies.\n- Add tests for the `_CFTimeFrequencyInferer` class to ensure it correctly infers \"L\" and \"U\" frequencies from `CFTimeIndex` objects.\n\nBy making these changes, `xarray` will be able to handle millisecond and microsecond frequency strings in `cftime_range` and `infer_freq`, and it will provide clear error messages when invalid frequency strings are used.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described bug to facilitate its resolution.",
            "supporting_evidence": "The RESPONSE provides a comprehensive and actionable list of steps to address the issue with `xarray` not handling millisecond and microsecond frequency strings. It suggests specific modifications to the `xarray/coding/cftime_offsets.py` file, including the definition of `Millisecond` and `Microsecond` classes, updating the `_FREQUENCIES` dictionary, and modifying the `cftime_range` function. Additionally, it recommends adding tests for `cftime_range` and `infer_freq`, updating the `to_offset` function, and enhancing the `_CFTimeFrequencyInferer` class. The RESPONSE also includes relevant code snippets to check, which is helpful for locating the areas of the codebase that need attention. The RESPONSE is well-structured and directly addresses the bug described in the PROMPT, providing clear guidance for developers to follow.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711759466.599584,
        "result": "To resolve the issue with `xarray` not being able to handle \"L\" and \"U\" frequency strings in `cftime_range` and `infer_freq`, follow these steps:\n\n- Ensure that the `Millisecond` and `Microsecond` classes are properly defined in `xarray/coding/cftime_offsets.py` with the `_freqstr` attributes set to \"L\" and \"U\" respectively.\n- Verify that the `_FREQUENCIES` dictionary in `xarray/coding/cftime_offsets.py` includes entries for \"L\" and \"U\" that map to the `Millisecond` and `Microsecond` classes.\n- Update the `cftime_range` function in `xarray/coding/cftime_offsets.py` to handle \"L\" and \"U\" frequency strings by using the `_FREQUENCIES` dictionary to map the frequency string to the correct offset class.\n- Implement error handling in `cftime_range` to raise a `ValueError` with a clear message when an invalid frequency string is provided.\n- Add tests for `cftime_range` and `infer_freq` to ensure that they correctly handle \"L\" and \"U\" frequency strings and that they raise the appropriate errors for invalid frequency strings.\n- Ensure that the `to_offset` function in `xarray/coding/cftime_offsets.py` can parse \"L\" and \"U\" frequency strings and return the correct `Millisecond` or `Microsecond` offset instance.\n- Update the `_CFTimeFrequencyInferer` class in `xarray/coding/frequencies.py` to support inferring millisecond and microsecond frequencies.\n- Add tests for the `_CFTimeFrequencyInferer` class to ensure it correctly infers \"L\" and \"U\" frequencies from `CFTimeIndex` objects.\n\nBy making these changes, `xarray` will be able to handle millisecond and microsecond frequency strings in `cftime_range` and `infer_freq`, and it will provide clear error messages when invalid frequency strings are used.\n\n### Code snippets to check\n\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 659 - 734](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L659-L734)\n\n This snippet contains the frequency definitions for cftime offsets, including the missing millisecond (L) and microsecond (U) frequencies that need to be supported. \n\n\n   - [Lines 737 - 1322](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L737-L1322)\n\n This snippet includes the 'to_offset' function which converts frequency strings to offset objects. It is relevant because it handles the interpretation of frequency strings, which must now include millisecond and microsecond frequencies. \n\n\n   - [Lines 1 - 75](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftime_offsets.py#L1-L75)\n\n This snippet is the header of the cftime_offsets.py file, which is relevant because the issue is related to the offsets defined in this file.\n-  \u2192 [xarray](https://github.com/testbed/pydata__xarray__0.12/tree//xarray) \u2192 [coding](https://github.com/testbed/pydata__xarray__0.12/tree//xarray/coding)- [Lines 510 - 584](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftimeindex.py#L510-L584)\n\n This snippet contains the 'shift' method of CFTimeIndex, which is relevant because it needs to handle shifting by new millisecond and microsecond frequencies. \n\n\n   - [Lines 1 - 85](https://github.com/testbed/pydata__xarray__0.12/blob//xarray/coding/cftimeindex.py#L1-L85)\n\n This snippet defines the CFTimeIndex class, which is relevant because the issue pertains to the generation of CFTimeIndex objects with millisecond and microsecond frequencies.",
        "context_relevance": 0.26000000000000006,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed step-by-step solution to the issue described in the PROMPT, addressing the problem with `xarray` not handling \"L\" and \"U\" frequency strings. It also includes a list of code snippets to check, which directly relates to the code and files mentioned in the PROMPT. The RESPONSE is comprehensive and directly addresses the expected output, problem description, and the context of the issue with relevant solutions, thus fulfilling the criteria for a score of 10."
        },
        "qa_relevance": 1.0
    }
}