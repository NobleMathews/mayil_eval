{
    "id": "sphinx-doc__sphinx-9467",
    "repo_name": "testbed/sphinx-doc__sphinx__4.1",
    "task_id": 6523300218452740023,
    "title": "github linkcheck anchor change in 4.1.0 break some usage",
    "body": "### Describe the bug\n\nGiven a link like:\r\n\r\n```rst\r\n.. _`OpenSSL's test vectors`: https://github.com/openssl/openssl/blob/97cf1f6c2854a3a955fd7dd3a1f113deba00c9ef/crypto/evp/evptests.txt#L232 \r\n```\r\n\r\nin a github doc, with release 4.1.0 this will fail with linkcheck, while previously it worked.\n\n### How to Reproduce\n\n```\r\n$ git clone https://github.com/pyca/cryptography\r\n$ cd cryptography\r\n$ tox -e docs-linkcheck\r\n```\r\n\n\n### Expected behavior\n\nIt passes.\n\n### Your project\n\nhttps://github.com/pyca/cryptography\n\n### Screenshots\n\n_No response_\n\n### OS\n\nLinux\n\n### Python version\n\n3.9.5\n\n### Sphinx version\n\n4.1.0\n\n### Sphinx extensions\n\n_No response_\n\n### Extra tools\n\n_No response_\n\n### Additional context\n\nThe relevant change happened in https://github.com/sphinx-doc/sphinx/commit/92335bd6e67dec9d8cadfdfb6d441a440e8dc87e\r\n\r\nFailing test logs: https://github.com/pyca/cryptography/runs/3046691393\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sphinx-doc__sphinx__4.1.git",
    "requested_commit": "",
    "mayil_response": "- The issue is with the `linkcheck` builder in Sphinx `4.1.0` failing to verify a specific link to the OpenSSL repository on GitHub.\n- The error message indicates that the linkcheck builder is unable to find the anchor in the given URL.\n- The relevant code snippet is the reStructuredText link to OpenSSL's test vectors.\n- The `linkcheck` builder is defined in `sphinx/builders/linkcheck.py`.\n- The `rewrite_github_anchor` function in `sphinx/builders/linkcheck.py` is commented out, which is relevant because GitHub uses `user-content-` prefix for anchors.\n\n**Solution:**\n\n- Uncomment the `rewrite_github_anchor` function in `sphinx/builders/linkcheck.py` to enable rewriting of GitHub anchors.\n  ```python\n  # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n  ```\n  Change to:\n  ```python\n  app.connect('linkcheck-process-uri', rewrite_github_anchor)\n  ```\n- Ensure that the `linkcheck` builder is configured to check anchors (`linkcheck_anchors` set to `True`).\n- If the issue persists after uncommenting, verify that the `rewrite_github_anchor` function correctly rewrites the anchor for the failing URL. If necessary, update the function to match the current GitHub anchor format.\n- If the link is correct but still fails due to network issues or GitHub rate limiting, consider adding the URL to `linkcheck_ignore` or adjusting the `linkcheck_rate_limit_timeout` configuration.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx) \u2192 [builders](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx/builders)- [Lines 493 - 559](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L493-L559)\n\n This snippet contains the 'rewrite_github_anchor' function which is directly related to the issue of GitHub anchor changes causing linkcheck failures. \n\n\n   - [Lines 562 - 592](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L562-L592)\n\n This snippet shows the setup function where the 'rewrite_github_anchor' function is commented out, which could be the cause of the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0003915,
        "snippet_processor": 0.0699,
        "issue_star_creation": 0.02797,
        "issue_star_solver": 0.06796,
        "bouncer": 0.02326
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711702428.626448,
        "relevant_snippets": [
            {
                "code": "class HyperlinkCollector(SphinxPostTransform):\n    builders = ('linkcheck',)\n    default_priority = 800\n\n    def run(self, **kwargs: Any) -> None:\n        builder = cast(CheckExternalLinksBuilder, self.app.builder)\n        hyperlinks = builder.hyperlinks\n\n        def add_uri(uri: str, node: nodes.Element) -> None:\n            newuri = self.app.emit_firstresult('linkcheck-process-uri', uri)\n            if newuri:\n                uri = newuri\n\n            try:\n                lineno = get_node_line(node)\n            except ValueError:\n                lineno = None\n            uri_info = Hyperlink(uri, self.env.docname, lineno)\n            if uri not in hyperlinks:\n                hyperlinks[uri] = uri_info\n\n        # reference nodes\n        for refnode in self.document.findall(nodes.reference):\n            if 'refuri' not in refnode:\n                continue\n            uri = refnode['refuri']\n            add_uri(uri, refnode)\n\n        # image nodes\n        for imgnode in self.document.findall(nodes.image):\n            uri = imgnode['candidates'].get('?')\n            if uri and '://' in uri:\n                add_uri(uri, imgnode)\n\n        # raw nodes\n        for rawnode in self.document.findall(nodes.raw):\n            uri = rawnode.get('source')\n            if uri and '://' in uri:\n                add_uri(uri, rawnode)\n\n\ndef rewrite_github_anchor(app: Sphinx, uri: str) -> str | None:\n    \"\"\"Rewrite anchor name of the hyperlink to github.com\n\n    The hyperlink anchors in github.com are dynamically generated.  This rewrites\n    them before checking and makes them comparable.\n    \"\"\"\n    parsed = urlparse(uri)\n    if parsed.hostname == \"github.com\" and parsed.fragment:\n        prefixed = parsed.fragment.startswith('user-content-')\n        if not prefixed:\n            fragment = f'user-content-{parsed.fragment}'\n            return urlunparse(parsed._replace(fragment=fragment))\n    return None\n\n\ndef compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -> None:\n    \"\"\"Compile patterns in linkcheck_allowed_redirects to the regexp objects.\"\"\"\n    for url, pattern in list(app.config.linkcheck_allowed_redirects.items()):\n        try:\n            app.config.linkcheck_allowed_redirects[re.compile(url)] = re.compile(pattern)\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects: %r %s'),\n                           exc.pattern, exc.msg)\n        finally:\n            # Remove the original regexp-string\n            app.config.linkcheck_allowed_redirects.pop(url)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 19389,
                "end_index": 21951,
                "start_line": 493,
                "end_line": 559,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.9
            },
            {
                "code": "\"\"\"\n    Checks for broken external links.\n    \"\"\"\n    name = 'linkcheck'\n    epilog = __('Look for any errors in the above output or in '\n                '%(outdir)s/output.txt')\n\n    def init(self) -> None:\n        self.broken_hyperlinks = 0\n        self.hyperlinks: dict[str, Hyperlink] = {}\n        # set a timeout for non-responding servers\n        socket.setdefaulttimeout(5.0)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 3091,
                "end_index": 3473,
                "start_line": 1,
                "end_line": 120,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "try:\n                if anchor and self.config.linkcheck_anchors:\n                    # Read the whole document and see if #anchor exists\n                    with requests.get(req_url, stream=True, config=self.config, auth=auth_info,\n                                      **kwargs) as response:\n                        response.raise_for_status()\n                        found = check_anchor(response, unquote(anchor))\n\n                    if not found:\n                        raise Exception(__(\"Anchor '%s' not found\") % anchor)\n                else:\n                    try:\n                        # try a HEAD request first, which should be easier on\n                        # the server and the network\n                        with requests.head(req_url, allow_redirects=True, config=self.config,\n                                           auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n                    # Servers drop the connection on HEAD requests, causing\n                    # ConnectionError.\n                    except (ConnectionError, HTTPError, TooManyRedirects) as err:\n                        if isinstance(err, HTTPError) and err.response.status_code == 429:\n                            raise\n                        # retry with GET request if that fails, some servers\n                        # don't like HEAD requests.\n                        with requests.get(req_url, stream=True, config=self.config,\n                                          auth=auth_info, **kwargs) as response:\n                            response.raise_for_status()\n            except HTTPError as err:\n                if err.response.status_code == 401:\n                    # We'll take \"Unauthorized\" as working.\n                    return 'working', ' - unauthorized', 0\n                elif err.response.status_code == 429:\n                    next_check = self.limit_rate(err.response)\n                    if next_check is not None:\n                        self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                        return 'rate-limited', '', 0\n                    return 'broken', str(err), 0\n                elif err.response.status_code == 503:\n                    # We'll take \"Service Unavailable\" as ignored.\n                    return 'ignored', str(err), 0\n                else:\n                    return 'broken', str(err), 0\n            except Exception as err:\n                return 'broken', str(err), 0\n            else:\n                netloc = urlparse(req_url).netloc\n                try:\n                    del self.rate_limits[netloc]\n                except KeyError:\n                    pass",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 11520,
                "end_index": 14211,
                "start_line": 156,
                "end_line": 468,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "name: Bug report\ndescription: Something is not working correctly.\nlabels: \"bug\"\n\nbody:\n  - type: textarea\n    attributes:\n      label: Describe the bug\n      description: >-\n        A clear and concise description of what the bug is, including the \n        expected behaviour and what has gone wrong.\n        \n        Please include screenshots, if applicable.\n    validations:\n      required: true\n\n  - type: textarea\n    attributes:\n      label: How to Reproduce\n      description: >-\n        Please provide steps to reproduce this bug, with the smallest possible\n        set of source files. For normal bugs this should ideally be one \n        ``index.rst`` file, and for ``sphinx.ext.autodoc`` bugs, this should\n        ideally be a single ``index.rst`` file, and a single example Python \n        module.\n      placeholder: |\n        Minimal method (you can also paste the contents of ``index.rst`` and\n        ``conf.py`` into this report):\n        ```bash\n        $ echo \"Content demonstrating the bug...\" > index.rst\n        $ echo \"\" > conf.py\n        $ sphinx-build -M html . _build\n        $ # open _build/html/index and see bla bla\n        ```\n        \n        ``git clone`` method (this is advised against, to help the Sphinx team):\n        ```bash\n        $ git clone https://github.com/.../some_project\n        $ cd some_project\n        $ pip install -r requirements.txt\n        $ cd docs\n        $ make html SPHINXOPTS=\"-D language=de\"\n        $ # open _build/html/index and see bla bla\n        ```\n    validations:\n      required: true\n\n  - type: markdown\n    attributes:\n      value: |\n        ## Environment info\n\n  - type: textarea\n    attributes:\n      label: Environment Information\n      render: text\n      description: >-\n        Install the latest Sphinx \n        ``pip install -U \"sphinx>=5.3\"``\n        then run ``sphinx-build --bug-report`` or ``python -m sphinx --bug-report``.\n        and paste the output here.\n    validations:\n      required: true\n  - type: textarea\n    attributes:\n      label: Sphinx extensions\n      render: python\n      description: >-\n        Attempt to reproduce your error with the smallest set of extensions possible.\n        This makes it easier to determine where the problem you are encountering is.\n        \n        e.g. ``[\"sphinx.ext.autodoc\", \"recommonmark\"]``\n    validations:\n      required: false\n  - type: textarea\n    attributes:\n      label: Additional context\n      description: >-\n        Add any other context about the problem here, for example:\n        \n        * Any other tools used (Browser, TeX, etc) with versions\n        * Reference to another issue or pull request\n        * URL to some external resource",
                "filename": ".github/ISSUE_TEMPLATE/bug-report.yml",
                "start_index": 0,
                "end_index": 2685,
                "start_line": 1,
                "end_line": 83,
                "max_line": 83,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.9
            },
            {
                "code": "def process_result(self, result: CheckResult) -> None:\n        filename = self.env.doc2path(result.docname, False)\n\n        linkstat = {\"filename\": filename, \"lineno\": result.lineno,\n                    \"status\": result.status, \"code\": result.code, \"uri\": result.uri,\n                    \"info\": result.message}\n        self.write_linkstat(linkstat)\n\n        if result.status == 'unchecked':\n            return\n        if result.status == 'working' and result.message == 'old':\n            return\n        if result.lineno:\n            logger.info('(%16s: line %4d) ', result.docname, result.lineno, nonl=True)\n        if result.status == 'ignored':\n            if result.message:\n                logger.info(darkgray('-ignored- ') + result.uri + ': ' + result.message)\n            else:\n                logger.info(darkgray('-ignored- ') + result.uri)\n        elif result.status == 'local':\n            logger.info(darkgray('-local-   ') + result.uri)\n            self.write_entry('local', result.docname, filename, result.lineno, result.uri)\n        elif result.status == 'working':\n            logger.info(darkgreen('ok        ') + result.uri + result.message)\n        elif result.status == 'broken':\n            if self.app.quiet or self.app.warningiserror:\n                logger.warning(__('broken link: %s (%s)'), result.uri, result.message,\n                               location=(result.docname, result.lineno))\n            else:\n                logger.info(red('broken    ') + result.uri + red(' - ' + result.message))\n            self.write_entry('broken', result.docname, filename, result.lineno,\n                             result.uri + ': ' + result.message)\n            self.broken_hyperlinks += 1\n        elif result.status == 'redirected':\n            try:\n                text, color = {\n                    301: ('permanently', purple),\n                    302: ('with Found', purple),\n                    303: ('with See Other', purple),\n                    307: ('temporarily', turquoise),\n                    308: ('permanently', purple),\n                }[result.code]\n            except KeyError:\n                text, color = ('with unknown code', purple)\n            linkstat['text'] = text\n            if self.config.linkcheck_allowed_redirects:\n                logger.warning('redirect  ' + result.uri + ' - ' + text + ' to ' +\n                               result.message, location=(result.docname, result.lineno))\n            else:\n                logger.info(color('redirect  ') + result.uri +\n                            color(' - ' + text + ' to ' + result.message))\n            self.write_entry('redirected ' + text, result.docname, filename,\n                             result.lineno, result.uri + ' to ' + result.message)\n        else:\n            raise ValueError(\"Unknown status %s.\" % result.status)",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 3479,
                "end_index": 6320,
                "start_line": 122,
                "end_line": 176,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def allowed_redirect(url: str, new_url: str) -> bool:\n            return any(\n                from_url.match(url) and to_url.match(new_url)\n                for from_url, to_url\n                in self.config.linkcheck_allowed_redirects.items()\n            )\n\n        def check(docname: str) -> tuple[str, str, int]:\n            # check for various conditions without bothering the network\n\n            for doc_matcher in self.documents_exclude:\n                if doc_matcher.match(docname):\n                    info = (\n                        f'{docname} matched {doc_matcher.pattern} from '\n                        'linkcheck_exclude_documents'\n                    )\n                    return 'ignored', info, 0\n\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                if uri_re.match(uri):\n                    # non supported URI schemes (ex. ftp)\n                    return 'unchecked', '', 0\n                else:\n                    srcdir = path.dirname(self.env.doc2path(docname))\n                    if path.exists(path.join(srcdir, uri)):\n                        return 'working', '', 0\n                    else:\n                        return 'broken', '', 0\n\n            # need to actually check the URI\n            for _ in range(self.config.linkcheck_retries):\n                status, info, code = check_uri()\n                if status != \"broken\":\n                    break\n\n            return (status, info, code)\n\n        while True:\n            check_request = self.wqueue.get()\n            next_check, hyperlink = check_request\n            if hyperlink is None:\n                break\n\n            uri, docname, lineno = hyperlink\n\n            if uri is None:\n                break\n            netloc = urlparse(uri).netloc\n            try:\n                # Refresh rate limit.\n                # When there are many links in the queue, workers are all stuck waiting\n                # for responses, but the builder keeps queuing. Links in the queue may\n                # have been queued before rate limits were discovered.\n                next_check = self.rate_limits[netloc].next_check\n            except KeyError:\n                pass\n            if next_check > time.time():\n                # Sleep before putting message back in the queue to avoid\n                # waking up other threads.\n                time.sleep(QUEUE_POLL_SECS)\n                self.wqueue.put(CheckRequest(next_check, hyperlink), False)\n                self.wqueue.task_done()\n                continue\n            status, info, code = check(docname)\n            if status == 'rate-limited':\n                logger.info(darkgray('-rate limited-   ') + uri + darkgray(' | sleeping...'))\n            else:\n                self.rqueue.put(CheckResult(uri, docname, lineno, status, info, code))\n            self.wqueue.task_done()",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 14844,
                "end_index": 17804,
                "start_line": 382,
                "end_line": 452,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"The CheckExternalLinksBuilder class.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport re\nimport socket\nimport time\nfrom copy import deepcopy\nfrom datetime import datetime, timezone\nfrom email.utils import parsedate_to_datetime\nfrom html.parser import HTMLParser\nfrom os import path\nfrom queue import PriorityQueue, Queue\nfrom threading import Thread\nfrom typing import Any, Generator, NamedTuple, Tuple, Union, cast\nfrom urllib.parse import unquote, urlparse, urlunparse\n\nfrom docutils import nodes\nfrom requests import Response\nfrom requests.exceptions import ConnectionError, HTTPError, TooManyRedirects\n\nfrom sphinx.application import Sphinx\nfrom sphinx.builders.dummy import DummyBuilder\nfrom sphinx.config import Config\nfrom sphinx.environment import BuildEnvironment\nfrom sphinx.locale import __\nfrom sphinx.transforms.post_transforms import SphinxPostTransform\nfrom sphinx.util import encode_uri, logging, requests\nfrom sphinx.util.console import darkgray, darkgreen, purple, red, turquoise  # type: ignore\nfrom sphinx.util.nodes import get_node_line\n\nlogger = logging.getLogger(__name__)\n\nuri_re = re.compile('([a-z]+:)?//')  # matches to foo:// and // (a protocol relative URL)\n\n\nclass Hyperlink(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int | None\n\n\nclass CheckRequest(NamedTuple):\n    next_check: float\n    hyperlink: Hyperlink | None\n\n\nclass CheckResult(NamedTuple):\n    uri: str\n    docname: str\n    lineno: int\n    status: str\n    message: str\n    code: int\n\n\nclass RateLimit(NamedTuple):\n    delay: float\n    next_check: float\n\n\n# Tuple is old styled CheckRequest\nCheckRequestType = Union[CheckRequest, Tuple[float, str, str, int]]\n\nDEFAULT_REQUEST_HEADERS = {\n    'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',\n}\nCHECK_IMMEDIATELY = 0\nQUEUE_POLL_SECS = 1\nDEFAULT_DELAY = 60.0\n\n\nclass AnchorCheckParser(HTMLParser):\n    \"\"\"Specialized HTML parser that looks for a specific anchor.\"\"\"\n\n    def __init__(self, search_anchor: str) -> None:\n        super().__init__()\n\n        self.search_anchor = search_anchor\n        self.found = False\n\n    def handle_starttag(self, tag: Any, attrs: Any) -> None:\n        for key, value in attrs:\n            if key in ('id', 'name') and value == self.search_anchor:\n                self.found = True\n                break",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 0,
                "end_index": 2310,
                "start_line": 1,
                "end_line": 430,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    app.add_builder(CheckExternalLinksBuilder)\n    app.add_post_transform(HyperlinkCollector)\n\n    app.add_config_value('linkcheck_ignore', [], False)\n    app.add_config_value('linkcheck_exclude_documents', [], False)\n    app.add_config_value('linkcheck_allowed_redirects', {}, False)\n    app.add_config_value('linkcheck_auth', [], False)\n    app.add_config_value('linkcheck_request_headers', {}, False)\n    app.add_config_value('linkcheck_retries', 1, False)\n    app.add_config_value('linkcheck_timeout', None, False, [int, float])\n    app.add_config_value('linkcheck_workers', 5, False)\n    app.add_config_value('linkcheck_anchors', True, False)\n    # Anchors starting with ! are ignored since they are\n    # commonly used for dynamic pages\n    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], False)\n    app.add_config_value('linkcheck_rate_limit_timeout', 300.0, False)\n\n    app.add_event('linkcheck-process-uri')\n\n    app.connect('config-inited', compile_linkcheck_allowed_redirects, priority=800)\n\n    # FIXME: Disable URL rewrite handler for github.com temporarily.\n    # ref: https://github.com/sphinx-doc/sphinx/issues/9435\n    # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 21954,
                "end_index": 23325,
                "start_line": 562,
                "end_line": 592,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "class CheckExternalLinksBuilder(DummyBuilder):",
                "filename": "sphinx/builders/linkcheck.py",
                "start_index": 3040,
                "end_index": 3086,
                "start_line": 108,
                "end_line": 108,
                "max_line": 592,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "name: CI (LaTeX)\n\non: [push, pull_request]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    name: Test on LaTeX image\n    container:\n      image: ghcr.io/sphinx-doc/sphinx-ci\n    env:\n      DO_EPUBCHECK: \"1\"\n    steps:\n    - name: Alias python3 to python\n      run: ln -s /usr/bin/python3 /usr/bin/python\n    - uses: actions/checkout@v3\n    - name: Check Python version\n      run: python --version\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        python -m pip install .[test]\n    - name: Test with pytest\n      run: >\n        python\n        -X dev\n        -X warn_default_encoding\n        -m pytest\n        -vv\n        --color yes\n        --durations 25",
                "filename": ".github/workflows/latex.yml",
                "start_index": 0,
                "end_index": 844,
                "start_line": 1,
                "end_line": 38,
                "max_line": 38,
                "git_instance": "github",
                "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                "sha": "",
                "context_relevance": 0.1
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sphinx/builders/linkcheck.py": [
                {
                    "chunk": {
                        "code": "class HyperlinkCollector(SphinxPostTransform):\n    builders = ('linkcheck',)\n    default_priority = 800\n\n    def run(self, **kwargs: Any) -> None:\n        builder = cast(CheckExternalLinksBuilder, self.app.builder)\n        hyperlinks = builder.hyperlinks\n\n        def add_uri(uri: str, node: nodes.Element) -> None:\n            newuri = self.app.emit_firstresult('linkcheck-process-uri', uri)\n            if newuri:\n                uri = newuri\n\n            try:\n                lineno = get_node_line(node)\n            except ValueError:\n                lineno = None\n            uri_info = Hyperlink(uri, self.env.docname, lineno)\n            if uri not in hyperlinks:\n                hyperlinks[uri] = uri_info\n\n        # reference nodes\n        for refnode in self.document.findall(nodes.reference):\n            if 'refuri' not in refnode:\n                continue\n            uri = refnode['refuri']\n            add_uri(uri, refnode)\n\n        # image nodes\n        for imgnode in self.document.findall(nodes.image):\n            uri = imgnode['candidates'].get('?')\n            if uri and '://' in uri:\n                add_uri(uri, imgnode)\n\n        # raw nodes\n        for rawnode in self.document.findall(nodes.raw):\n            uri = rawnode.get('source')\n            if uri and '://' in uri:\n                add_uri(uri, rawnode)\n\n\ndef rewrite_github_anchor(app: Sphinx, uri: str) -> str | None:\n    \"\"\"Rewrite anchor name of the hyperlink to github.com\n\n    The hyperlink anchors in github.com are dynamically generated.  This rewrites\n    them before checking and makes them comparable.\n    \"\"\"\n    parsed = urlparse(uri)\n    if parsed.hostname == \"github.com\" and parsed.fragment:\n        prefixed = parsed.fragment.startswith('user-content-')\n        if not prefixed:\n            fragment = f'user-content-{parsed.fragment}'\n            return urlunparse(parsed._replace(fragment=fragment))\n    return None\n\n\ndef compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -> None:\n    \"\"\"Compile patterns in linkcheck_allowed_redirects to the regexp objects.\"\"\"\n    for url, pattern in list(app.config.linkcheck_allowed_redirects.items()):\n        try:\n            app.config.linkcheck_allowed_redirects[re.compile(url)] = re.compile(pattern)\n        except re.error as exc:\n            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects: %r %s'),\n                           exc.pattern, exc.msg)\n        finally:\n            # Remove the original regexp-string\n            app.config.linkcheck_allowed_redirects.pop(url)",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 19389,
                        "end_index": 21951,
                        "start_line": 493,
                        "end_line": 559,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'rewrite_github_anchor' function which is directly related to the issue of GitHub anchor changes causing linkcheck failures."
                },
                {
                    "chunk": {
                        "code": "def setup(app: Sphinx) -> dict[str, Any]:\n    app.add_builder(CheckExternalLinksBuilder)\n    app.add_post_transform(HyperlinkCollector)\n\n    app.add_config_value('linkcheck_ignore', [], False)\n    app.add_config_value('linkcheck_exclude_documents', [], False)\n    app.add_config_value('linkcheck_allowed_redirects', {}, False)\n    app.add_config_value('linkcheck_auth', [], False)\n    app.add_config_value('linkcheck_request_headers', {}, False)\n    app.add_config_value('linkcheck_retries', 1, False)\n    app.add_config_value('linkcheck_timeout', None, False, [int, float])\n    app.add_config_value('linkcheck_workers', 5, False)\n    app.add_config_value('linkcheck_anchors', True, False)\n    # Anchors starting with ! are ignored since they are\n    # commonly used for dynamic pages\n    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], False)\n    app.add_config_value('linkcheck_rate_limit_timeout', 300.0, False)\n\n    app.add_event('linkcheck-process-uri')\n\n    app.connect('config-inited', compile_linkcheck_allowed_redirects, priority=800)\n\n    # FIXME: Disable URL rewrite handler for github.com temporarily.\n    # ref: https://github.com/sphinx-doc/sphinx/issues/9435\n    # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }",
                        "filename": "sphinx/builders/linkcheck.py",
                        "start_index": 21954,
                        "end_index": 23325,
                        "start_line": 562,
                        "end_line": 592,
                        "max_line": 592,
                        "git_instance": "github",
                        "repo_name": "testbed/sphinx-doc__sphinx__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the setup function where the 'rewrite_github_anchor' function is commented out, which could be the cause of the issue."
                }
            ]
        },
        "solution_task": "- The issue is with the `linkcheck` builder in Sphinx `4.1.0` failing to verify a specific link to the OpenSSL repository on GitHub.\n- The error message indicates that the linkcheck builder is unable to find the anchor in the given URL.\n- The relevant code snippet is the reStructuredText link to OpenSSL's test vectors.\n- The `linkcheck` builder is defined in `sphinx/builders/linkcheck.py`.\n- The `rewrite_github_anchor` function in `sphinx/builders/linkcheck.py` is commented out, which is relevant because GitHub uses `user-content-` prefix for anchors.\n\n**Solution:**\n\n- Uncomment the `rewrite_github_anchor` function in `sphinx/builders/linkcheck.py` to enable rewriting of GitHub anchors.\n  ```python\n  # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n  ```\n  Change to:\n  ```python\n  app.connect('linkcheck-process-uri', rewrite_github_anchor)\n  ```\n- Ensure that the `linkcheck` builder is configured to check anchors (`linkcheck_anchors` set to `True`).\n- If the issue persists after uncommenting, verify that the `rewrite_github_anchor` function correctly rewrites the anchor for the failing URL. If necessary, update the function to match the current GitHub anchor format.\n- If the link is correct but still fails due to network issues or GitHub rate limiting, consider adding the URL to `linkcheck_ignore` or adjusting the `linkcheck_rate_limit_timeout` configuration.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE accurately identifies the issue with the `linkcheck` builder in Sphinx `4.1.0` and provides a detailed solution to the problem. It correctly points out that the `rewrite_github_anchor` function in `sphinx/builders/linkcheck.py` is commented out and suggests uncommenting it to resolve the issue. The RESPONSE also advises ensuring that the `linkcheck` builder is configured to check anchors and provides additional troubleshooting steps if the problem persists, such as verifying the function's correctness or adjusting the `linkcheck_ignore` and `linkcheck_rate_limit_timeout` configurations. Furthermore, the RESPONSE includes direct links to the relevant code snippets, which is extremely helpful for someone trying to fix the bug.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711702547.462421,
        "result": "- The issue is with the `linkcheck` builder in Sphinx `4.1.0` failing to verify a specific link to the OpenSSL repository on GitHub.\n- The error message indicates that the linkcheck builder is unable to find the anchor in the given URL.\n- The relevant code snippet is the reStructuredText link to OpenSSL's test vectors.\n- The `linkcheck` builder is defined in `sphinx/builders/linkcheck.py`.\n- The `rewrite_github_anchor` function in `sphinx/builders/linkcheck.py` is commented out, which is relevant because GitHub uses `user-content-` prefix for anchors.\n\n**Solution:**\n\n- Uncomment the `rewrite_github_anchor` function in `sphinx/builders/linkcheck.py` to enable rewriting of GitHub anchors.\n  ```python\n  # app.connect('linkcheck-process-uri', rewrite_github_anchor)\n  ```\n  Change to:\n  ```python\n  app.connect('linkcheck-process-uri', rewrite_github_anchor)\n  ```\n- Ensure that the `linkcheck` builder is configured to check anchors (`linkcheck_anchors` set to `True`).\n- If the issue persists after uncommenting, verify that the `rewrite_github_anchor` function correctly rewrites the anchor for the failing URL. If necessary, update the function to match the current GitHub anchor format.\n- If the link is correct but still fails due to network issues or GitHub rate limiting, consider adding the URL to `linkcheck_ignore` or adjusting the `linkcheck_rate_limit_timeout` configuration.\n\n### Code snippets to check\n\n-  \u2192 [sphinx](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx) \u2192 [builders](https://github.com/testbed/sphinx-doc__sphinx__4.1/tree//sphinx/builders)- [Lines 493 - 559](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L493-L559)\n\n This snippet contains the 'rewrite_github_anchor' function which is directly related to the issue of GitHub anchor changes causing linkcheck failures. \n\n\n   - [Lines 562 - 592](https://github.com/testbed/sphinx-doc__sphinx__4.1/blob//sphinx/builders/linkcheck.py#L562-L592)\n\n This snippet shows the setup function where the 'rewrite_github_anchor' function is commented out, which could be the cause of the issue.",
        "context_relevance": 0.45999999999999996,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation of the bug encountered with the `linkcheck` builder in Sphinx `4.1.0`, how to reproduce it, the expected behavior, and the project affected. It also includes a solution to the problem, referencing the relevant code snippets and the commit that caused the issue. The RESPONSE addresses all aspects of the PROMPT, including the description of the bug, steps to reproduce, expected behavior, and additional context linking to the failing test logs and the relevant change in the Sphinx repository."
        },
        "qa_relevance": 1.0
    }
}