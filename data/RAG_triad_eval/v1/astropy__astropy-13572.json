{
    "id": "astropy__astropy-13572",
    "repo_name": "testbed/astropy__astropy__5.0",
    "task_id": 1514669391213302433,
    "title": "Problem in function nutation_matrix in earth_orientation.py",
    "body": "Recently, when I try to call function nutation_matrix in astropy.coordinates.earth_orientation, error occurs with following info:\r\n\r\nastropy.units.core.UnitTypeError: Angle instances require units equivalent to 'rad', so cannot set it to '0'.\r\n\r\nThen, I checked the code of def nutation_matrix as follows:\r\n```\r\ndef nutation_matrix(epoch):\r\n    \"\"\"\r\n    Nutation matrix generated from nutation components.\r\n\r\n    Matrix converts from mean coordinate to true coordinate as\r\n    r_true = M * r_mean\r\n    \"\"\"\r\n    # TODO: implement higher precision 2006/2000A model if requested/needed\r\n    epsa, dpsi, deps = nutation_components2000B(epoch.jd)  # all in radians\r\n\r\n    return matrix_product(rotation_matrix(-(epsa + deps), 'x', False),\r\n                          rotation_matrix(-dpsi, 'z', False),\r\n                          rotation_matrix(epsa, 'x', False))\r\n```\r\nIn its return sentence, the third argument of 'rotation_matrix' should be units.radian, rather than False.\r\n\r\nAny response?\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/astropy__astropy__5.0.git",
    "requested_commit": "",
    "mayil_response": "- Identify the location in the code where the `nutation_matrix` function is defined.\n- Replace the incorrect `False` argument in the `rotation_matrix` function call with `units.radian`.\n- Ensure that all calls to `rotation_matrix` within `nutation_matrix` pass angles with the correct unit, which should be radians.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.0/tree//astropy) \u2192 [coordinates](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/coordinates)- [Lines 141 - 223](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/coordinates/earth_orientation.py#L141-L223)\n\n This snippet contains the definition of the 'nutation_matrix' function where the reported issue is located. The third argument in the 'rotation_matrix' function call within 'nutation_matrix' should be 'units.radian' instead of 'False' as per the issue description.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0020169999999999997,
        "snippet_processor": 0.10021000000000001,
        "issue_star_creation": 0.02848,
        "issue_star_solver": 0.06717000000000001,
        "bouncer": 0.03083
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711736378.879895,
        "relevant_snippets": [
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\"\"\"\nThis module contains standard functions for earth orientation, such as\nprecession and nutation.\n\nThis module is (currently) not intended to be part of the public API, but\nis instead primarily for internal use in `coordinates`\n\"\"\"\n\n\nimport erfa\nimport numpy as np\n\nfrom astropy.time import Time\n\nfrom .builtin_frames.utils import get_jd12\nfrom .matrix_utilities import matrix_transpose, rotation_matrix\n\njd1950 = Time(\"B1950\").jd\njd2000 = Time(\"J2000\").jd\n\n\ndef eccentricity(jd):\n    \"\"\"\n    Eccentricity of the Earth's orbit at the requested Julian Date.\n\n    Parameters\n    ----------\n    jd : scalar or array-like\n        Julian date at which to compute the eccentricity\n\n    Returns\n    -------\n    eccentricity : scalar or array\n        The eccentricity (or array of eccentricities)\n\n    References\n    ----------\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    T = (jd - jd1950) / 36525.0\n\n    p = (-0.000000126, -0.00004193, 0.01673011)\n\n    return np.polyval(p, T)\n\n\ndef mean_lon_of_perigee(jd):\n    \"\"\"\n    Computes the mean longitude of perigee of the Earth's orbit at the\n    requested Julian Date.\n\n    Parameters\n    ----------\n    jd : scalar or array-like\n        Julian date at which to compute the mean longitude of perigee\n\n    Returns\n    -------\n    mean_lon_of_perigee : scalar or array\n        Mean longitude of perigee in degrees (or array of mean longitudes)\n\n    References\n    ----------\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    T = (jd - jd1950) / 36525.0\n\n    p = (0.012, 1.65, 6190.67, 1015489.951)\n\n    return np.polyval(p, T) / 3600.0",
                "filename": "astropy/coordinates/earth_orientation.py",
                "start_index": 0,
                "end_index": 1818,
                "start_line": 1,
                "end_line": 74,
                "max_line": 223,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _precession_matrix_besselian(epoch1, epoch2):\n    \"\"\"\n    Computes the precession matrix from one Besselian epoch to another using\n    Newcomb's method.\n\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\n    \"\"\"\n    # tropical years\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n\n    zeta1 = 23035.545 + t1 * 139.720 + 0.060 * t1 * t1\n    zeta2 = 30.240 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n\n    z1 = 23035.545 + t1 * 139.720 + 0.060 * t1 * t1\n    z2 = 109.480 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n\n    return (\n        rotation_matrix(-z, \"z\")\n        @ rotation_matrix(theta, \"y\")\n        @ rotation_matrix(-zeta, \"z\")\n    )\n\n\ndef nutation_components2000B(jd):\n    \"\"\"\n    Computes nutation components following the IAU 2000B specification.\n\n    Parameters\n    ----------\n    jd : scalar\n        Julian date (TT) at which to compute the nutation components\n\n    Returns\n    -------\n    eps : float\n        epsilon in radians\n    dpsi : float\n        dpsi in radians\n    deps : float\n        depsilon in raidans\n    \"\"\"\n    dpsi, deps, epsa, _, _, _, _, _ = erfa.pn00b(jd, 0)\n    return epsa, dpsi, deps\n\n\ndef nutation_matrix(epoch):\n    \"\"\"\n    Nutation matrix generated from nutation components, IAU 2000B model.\n\n    Matrix converts from mean coordinate to true coordinate as\n    r_true = M * r_mean\n\n    Parameters\n    ----------\n    epoch : `~astropy.time.Time`\n        The epoch at which to compute the nutation matrix\n\n    Returns\n    -------\n    nmatrix : 3x3 array\n        Nutation matrix for the specified epoch\n\n    References\n    ----------\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    # TODO: implement higher precision 2006/2000A model if requested/needed\n    return erfa.num00b(*get_jd12(epoch, \"tt\"))",
                "filename": "astropy/coordinates/earth_orientation.py",
                "start_index": 4024,
                "end_index": 6199,
                "start_line": 141,
                "end_line": 223,
                "max_line": 223,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "# Has no effect if matrix is identity matrix, in which case gives GCRS ppr.\n    pi = erfa.rxp(astrom[\"bpn\"], ppr)\n\n    # CIRS (GCRS) RA, Dec\n    ri, di = erfa.c2s(pi)\n    return erfa.anp(ri), di",
                "filename": "astropy/coordinates/builtin_frames/utils.py",
                "start_index": 11154,
                "end_index": 11348,
                "start_line": 323,
                "end_line": 328,
                "max_line": 422,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\"\"\"\nContains the transformation functions for getting to/from ecliptic systems.\n\"\"\"\nimport erfa\n\nfrom astropy import units as u\nfrom astropy.coordinates.baseframe import frame_transform_graph\nfrom astropy.coordinates.errors import UnitsError\nfrom astropy.coordinates.matrix_utilities import matrix_transpose, rotation_matrix\nfrom astropy.coordinates.transformations import (\n    AffineTransform,\n    DynamicMatrixTransform,\n    FunctionTransformWithFiniteDifference,\n)\n\nfrom .ecliptic import (\n    BarycentricMeanEcliptic,\n    BarycentricTrueEcliptic,\n    CustomBarycentricEcliptic,\n    GeocentricMeanEcliptic,\n    GeocentricTrueEcliptic,\n    HeliocentricEclipticIAU76,\n    HeliocentricMeanEcliptic,\n    HeliocentricTrueEcliptic,\n)\nfrom .gcrs import GCRS\nfrom .icrs import ICRS\nfrom .utils import EQUINOX_J2000, get_jd12, get_offset_sun_from_barycenter\n\n\ndef _mean_ecliptic_rotation_matrix(equinox):\n    # This code just calls ecm06, which uses the precession matrix according to the\n    # IAU 2006 model, but leaves out nutation. This brings the results closer to what\n    # other libraries give (see https://github.com/astropy/astropy/pull/6508).\n    return erfa.ecm06(*get_jd12(equinox, \"tt\"))\n\n\ndef _true_ecliptic_rotation_matrix(equinox):\n    # This code calls the same routines as done in pnm06a from ERFA, which\n    # retrieves the precession matrix (including frame bias) according to\n    # the IAU 2006 model, and including the nutation.\n    # This family of systems is less popular\n    # (see https://github.com/astropy/astropy/pull/6508).\n    jd1, jd2 = get_jd12(equinox, \"tt\")\n    # Here, we call the three routines from erfa.pnm06a separately,\n    # so that we can keep the nutation for calculating the true obliquity\n    # (which is a fairly expensive operation); see gh-11000.\n    # pnm06a: Fukushima-Williams angles for frame bias and precession.\n    # (ERFA names short for F-W's gamma_bar, phi_bar, psi_bar and epsilon_A).\n    gamb, phib, psib, epsa = erfa.pfw06(jd1, jd2)\n    # pnm06a: Nutation components (in longitude and obliquity).\n    dpsi, deps = erfa.nut06a(jd1, jd2)\n    # pnm06a: Equinox based nutation x precession x bias matrix.\n    rnpb = erfa.fw2m(gamb, phib, psib + dpsi, epsa + deps)\n    # calculate the true obliquity of the ecliptic\n    obl = erfa.obl06(jd1, jd2) + deps\n    return rotation_matrix(obl << u.radian, \"x\") @ rnpb\n\n\ndef _obliquity_only_rotation_matrix(\n    obl=erfa.obl80(EQUINOX_J2000.jd1, EQUINOX_J2000.jd2) * u.radian\n):\n    # This code only accounts for the obliquity,\n    # which can be passed explicitly.\n    # The default value is the IAU 1980 value for J2000,\n    # which is computed using obl80 from ERFA:\n    #\n    # obl = erfa.obl80(EQUINOX_J2000.jd1, EQUINOX_J2000.jd2) * u.radian\n    return rotation_matrix(obl, \"x\")\n\n\n# MeanEcliptic frames",
                "filename": "astropy/coordinates/builtin_frames/ecliptic_transforms.py",
                "start_index": 0,
                "end_index": 2866,
                "start_line": 1,
                "end_line": 73,
                "max_line": 297,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n    One or more angular value(s) with units equivalent to radians or degrees.\n\n    An angle can be specified either as an array, scalar, tuple (see\n    below), string, `~astropy.units.Quantity` or another\n    :class:`~astropy.coordinates.Angle`.\n\n    The input parser is flexible and supports a variety of formats.\n    The examples below illustrate common ways of initializing an\n    `~astropy.coordinates.Angle` object. First some imports::\n\n      >>> from astropy.coordinates import Angle\n      >>> from astropy import units as u\n\n    The angle values can now be provided::\n\n      >>> Angle('10.2345d')\n      <Angle 10.2345 deg>\n      >>> Angle(['10.2345d', '-20d'])\n      <Angle [ 10.2345, -20.    ] deg>\n      >>> Angle('1:2:30.43 degrees')\n      <Angle 1.04178611 deg>\n      >>> Angle('1 2 0 hours')\n      <Angle 1.03333333 hourangle>\n      >>> Angle(np.arange(1, 8), unit=u.deg)\n      <Angle [1., 2., 3., 4., 5., 6., 7.] deg>\n      >>> Angle('1\u00b02\u20323\u2033')\n      <Angle 1.03416667 deg>\n      >>> Angle('1\u00b02\u20323\u2033N')\n      <Angle 1.03416667 deg>\n      >>> Angle('1d2m3.4s')\n      <Angle 1.03427778 deg>\n      >>> Angle('1d2m3.4sS')\n      <Angle -1.03427778 deg>\n      >>> Angle('-1h2m3s')\n      <Angle -1.03416667 hourangle>\n      >>> Angle('-1h2m3sE')\n      <Angle -1.03416667 hourangle>\n      >>> Angle('-1h2.5m')\n      <Angle -1.04166667 hourangle>\n      >>> Angle('-1h2.5mW')\n      <Angle 1.04166667 hourangle>\n      >>> Angle('-1:2.5', unit=u.deg)\n      <Angle -1.04166667 deg>\n      >>> Angle(10.2345 * u.deg)\n      <Angle 10.2345 deg>\n      >>> Angle(Angle(10.2345 * u.deg))\n      <Angle 10.2345 deg>\n\n    Parameters\n    ----------\n    angle : `~numpy.array`, scalar, `~astropy.units.Quantity`, `~astropy.coordinates.Angle`\n        The angle value. If a tuple, will be interpreted as ``(h, m,\n        s)`` or ``(d, m, s)`` depending on ``unit``. If a string, it\n        will be interpreted following the rules described above.\n\n        If ``angle`` is a sequence or array of strings, the resulting\n        values will be in the given ``unit``, or if `None` is provided,\n        the unit will be taken from the first given value.\n\n    unit : unit-like, optional\n        The unit of the value specified for the angle.  This may be\n        any string that `~astropy.units.Unit` understands, but it is\n        better to give an actual unit object.  Must be an angular\n        unit.\n\n    dtype : `~numpy.dtype`, optional\n        See `~astropy.units.Quantity`.\n\n    copy : bool, optional\n        See `~astropy.units.Quantity`.\n\n    Raises\n    ------\n    `~astropy.units.UnitsError`\n        If a unit is not provided or it is not an angular unit.\n    \"\"\"\n\n    _equivalent_unit = u.radian\n    _include_easy_conversion_members = True\n\n    def",
                "filename": "astropy/coordinates/angles.py",
                "start_index": 666,
                "end_index": 3407,
                "start_line": 3,
                "end_line": 686,
                "max_line": 688,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.4
            },
            {
                "code": "import erfa\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates.baseframe import frame_transform_graph\nfrom astropy.coordinates.matrix_utilities import matrix_transpose, rotation_matrix\nfrom astropy.coordinates.representation import CartesianRepresentation\nfrom astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n\nfrom .altaz import AltAz\nfrom .hadec import HADec\nfrom .itrs import ITRS\n\n# Minimum cos(alt) and sin(alt) for refraction purposes\nCELMIN = 1e-6\nSELMIN = 0.05\n# Latitude of the north pole.\nNORTH_POLE = 90.0 * u.deg\n\n\ndef itrs_to_altaz_mat(lon, lat):\n    # form ITRS to AltAz matrix\n    # AltAz frame is left handed\n    minus_x = np.eye(3)\n    minus_x[0][0] = -1.0\n    mat = minus_x @ rotation_matrix(NORTH_POLE - lat, \"y\") @ rotation_matrix(lon, \"z\")\n    return mat\n\n\ndef itrs_to_hadec_mat(lon):\n    # form ITRS to HADec matrix\n    # HADec frame is left handed\n    minus_y = np.eye(3)\n    minus_y[1][1] = -1.0\n    mat = minus_y @ rotation_matrix(lon, \"z\")\n    return mat\n\n\ndef altaz_to_hadec_mat(lat):\n    # form AltAz to HADec matrix\n    z180 = np.eye(3)\n    z180[0][0] = -1.0\n    z180[1][1] = -1.0\n    mat = z180 @ rotation_matrix(NORTH_POLE - lat, \"y\")\n    return mat\n\n\ndef add_refraction(aa_crepr, observed_frame):\n    # add refraction to AltAz cartesian representation\n    refa, refb = erfa.refco(\n        observed_frame.pressure.to_value(u.hPa),\n        observed_frame.temperature.to_value(u.deg_C),\n        observed_frame.relative_humidity.value,\n        observed_frame.obswl.to_value(u.micron),\n    )\n    # reference: erfa.atioq()\n    norm, uv = erfa.pn(aa_crepr.get_xyz(xyz_axis=-1).to_value())\n    # Cosine and sine of altitude, with precautions.\n    sel = np.maximum(uv[..., 2], SELMIN)\n    cel = np.maximum(np.sqrt(uv[..., 0] ** 2 + uv[..., 1] ** 2), CELMIN)\n    # A*tan(z)+B*tan^3(z) model, with Newton-Raphson correction.\n    tan_z = cel / sel\n    w = refb * tan_z**2\n    delta_el = (refa + w) * tan_z / (1.0 + (refa + 3.0 * w) / (sel**2))\n    # Apply the change, giving observed vector\n    cosdel = 1.0 - 0.5 * delta_el**2\n    f = cosdel - delta_el * sel / cel\n    uv[..., 0] *= f\n    uv[..., 1] *= f\n    uv[..., 2] = cosdel * uv[..., 2] + delta_el * cel\n    # Need to renormalize to get agreement with CIRS->Observed on distance\n    norm2, uv = erfa.pn(uv)\n    uv = erfa.sxp(norm, uv)\n    return CartesianRepresentation(uv, xyz_axis=-1, unit=aa_crepr.x.unit, copy=False)",
                "filename": "astropy/coordinates/builtin_frames/itrs_observed_transforms.py",
                "start_index": 0,
                "end_index": 2453,
                "start_line": 1,
                "end_line": 98,
                "max_line": 147,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@frame_transform_graph.transform(\n    FunctionTransformWithFiniteDifference,\n    GCRS,\n    GeocentricMeanEcliptic,\n    finite_difference_frameattr_name=\"equinox\",\n)\ndef gcrs_to_geoecliptic(gcrs_coo, to_frame):\n    # first get us to a 0 pos/vel GCRS at the target equinox\n    gcrs_coo2 = gcrs_coo.transform_to(GCRS(obstime=to_frame.obstime))\n\n    rmat = _mean_ecliptic_rotation_matrix(to_frame.equinox)\n    newrepr = gcrs_coo2.cartesian.transform(rmat)\n    return to_frame.realize_frame(newrepr)\n\n\n@frame_transform_graph.transform(\n    FunctionTransformWithFiniteDifference, GeocentricMeanEcliptic, GCRS\n)\ndef geoecliptic_to_gcrs(from_coo, gcrs_frame):\n    rmat = _mean_ecliptic_rotation_matrix(from_coo.equinox)\n    newrepr = from_coo.cartesian.transform(matrix_transpose(rmat))\n    gcrs = GCRS(newrepr, obstime=from_coo.obstime)\n\n    # now do any needed offsets (no-op if same obstime and 0 pos/vel)\n    return gcrs.transform_to(gcrs_frame)\n\n\n@frame_transform_graph.transform(DynamicMatrixTransform, ICRS, BarycentricMeanEcliptic)\ndef icrs_to_baryecliptic(from_coo, to_frame):\n    return _mean_ecliptic_rotation_matrix(to_frame.equinox)\n\n\n@frame_transform_graph.transform(DynamicMatrixTransform, BarycentricMeanEcliptic, ICRS)\ndef baryecliptic_to_icrs(from_coo, to_frame):\n    return matrix_transpose(icrs_to_baryecliptic(to_frame, from_coo))\n\n\n_NEED_ORIGIN_HINT = (\n    \"The input {0} coordinates do not have length units. This probably means you\"\n    \" created coordinates with lat/lon but no distance.  Heliocentric<->ICRS transforms\"\n    \" cannot function in this case because there is an origin shift.\"\n)\n\n\n@frame_transform_graph.transform(AffineTransform, ICRS, HeliocentricMeanEcliptic)\ndef icrs_to_helioecliptic(from_coo, to_frame):\n    if not u.m.is_equivalent(from_coo.cartesian.x.unit):\n        raise UnitsError(_NEED_ORIGIN_HINT.format(from_coo.__class__.__name__))\n\n    # get the offset of the barycenter from the Sun\n    ssb_from_sun = get_offset_sun_from_barycenter(\n        to_frame.obstime,\n        reverse=True,\n        include_velocity=bool(from_coo.data.differentials),\n    )\n\n    # now compute the matrix to precess to the right orientation\n    rmat = _mean_ecliptic_rotation_matrix(to_frame.equinox)\n\n    return rmat, ssb_from_sun.transform(rmat)\n\n\n@frame_transform_graph.transform(AffineTransform, HeliocentricMeanEcliptic, ICRS)\ndef helioecliptic_to_icrs(from_coo, to_frame):\n    if not u.m.is_equivalent(from_coo.cartesian.x.unit):\n        raise UnitsError(_NEED_ORIGIN_HINT.format(from_coo.__class__.__name__))\n\n    # first un-precess from ecliptic to ICRS orientation\n    rmat = _mean_ecliptic_rotation_matrix(from_coo.equinox)\n\n    # now offset back to barycentric, which is the correct center for ICRS\n    sun_from_ssb = get_offset_sun_from_barycenter(\n        from_coo.obstime, include_velocity=bool(from_coo.data.differentials)\n    )\n\n    return matrix_transpose(rmat), sun_from_ssb\n\n\n# TrueEcliptic frames",
                "filename": "astropy/coordinates/builtin_frames/ecliptic_transforms.py",
                "start_index": 2869,
                "end_index": 5807,
                "start_line": 76,
                "end_line": 154,
                "max_line": 297,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\"\"\"Implements rotations, including spherical rotations as defined in WCS Paper II [1]_.\n\n`RotateNative2Celestial` and `RotateCelestial2Native` follow the convention in\nWCS Paper II to rotate to/from a native sphere and the celestial sphere.\n\nThe implementation uses `EulerAngleRotation`. The model parameters are\nthree angles: the longitude (``lon``) and latitude (``lat``) of the fiducial point\nin the celestial system (``CRVAL`` keywords in FITS), and the longitude of the celestial\npole in the native system (``lon_pole``). The Euler angles are ``lon+90``, ``90-lat``\nand ``-(lon_pole-90)``.\n\n\nReferences\n----------\n.. [1] Calabretta, M.R., Greisen, E.W., 2002, A&A, 395, 1077 (Paper II)\n\"\"\"\n# pylint: disable=invalid-name, too-many-arguments, no-member\n\nimport math\nfrom functools import reduce\n\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates.matrix_utilities import rotation_matrix\n\nfrom .core import Model\nfrom .parameters import Parameter\nfrom .utils import _to_orig_unit, _to_radian\n\n__all__ = [\n    \"RotateCelestial2Native\",\n    \"RotateNative2Celestial\",\n    \"Rotation2D\",\n    \"EulerAngleRotation\",\n    \"RotationSequence3D\",\n    \"SphericalRotationSequence\",\n]\n\n\ndef _create_matrix(angles, axes_order):\n    matrices = []\n    for angle, axis in zip(angles, axes_order):\n        if isinstance(angle, u.Quantity):\n            angle = angle.value\n        angle = angle.item()\n        matrices.append(rotation_matrix(angle, axis, unit=u.rad))\n    return reduce(np.matmul, matrices[::-1])\n\n\ndef spherical2cartesian(alpha, delta):\n    alpha = np.deg2rad(alpha)\n    delta = np.deg2rad(delta)\n    x = np.cos(alpha) * np.cos(delta)\n    y = np.cos(delta) * np.sin(alpha)\n    z = np.sin(delta)\n    return np.array([x, y, z])\n\n\ndef cartesian2spherical(x, y, z):\n    h = np.hypot(x, y)\n    alpha = np.rad2deg(np.arctan2(y, x))\n    delta = np.rad2deg(np.arctan2(z, h))\n    return alpha, delta",
                "filename": "astropy/modeling/rotations.py",
                "start_index": 0,
                "end_index": 1979,
                "start_line": 1,
                "end_line": 324,
                "max_line": 561,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\"\"\"\nThis module contains functions/values used repeatedly in different modules of\nthe ``builtin_frames`` package.\n\"\"\"\n\nimport warnings\n\nimport erfa\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.coordinates.earth import EarthLocation\nfrom astropy.coordinates.representation import CartesianDifferential\nfrom astropy.time import Time\nfrom astropy.utils import iers\nfrom astropy.utils.exceptions import AstropyWarning\n\n# We use tt as the time scale for this equinoxes, primarily because it is the\n# convention for J2000 (it is unclear if there is any \"right answer\" for B1950)\n# while #8600 makes this the default behavior, we show it here to ensure it's\n# clear which is used here\nEQUINOX_J2000 = Time(\"J2000\", scale=\"tt\")\nEQUINOX_B1950 = Time(\"B1950\", scale=\"tt\")\n\n# This is a time object that is the default \"obstime\" when such an attribute is\n# necessary.  Currently, we use J2000.\nDEFAULT_OBSTIME = Time(\"J2000\", scale=\"tt\")\n\n# This is an EarthLocation that is the default \"location\" when such an attribute is\n# necessary. It is the centre of the Earth.\nEARTH_CENTER = EarthLocation(0 * u.km, 0 * u.km, 0 * u.km)\n\nPIOVER2 = np.pi / 2.0\n\n# comes from the mean of the 1962-2014 IERS B data\n_DEFAULT_PM = (0.035, 0.29) * u.arcsec\n\n\ndef get_polar_motion(time):\n    \"\"\"\n    gets the two polar motion components in radians for use with apio.\n    \"\"\"\n    # Get the polar motion from the IERS table\n    iers_table = iers.earth_orientation_table.get()\n    xp, yp, status = iers_table.pm_xy(time, return_status=True)\n\n    wmsg = (\n        \"Tried to get polar motions for times {} IERS data is \"\n        \"valid. Defaulting to polar motion from the 50-yr mean for those. \"\n        \"This may affect precision at the arcsec level. Please check your \"\n        \"astropy.utils.iers.conf.iers_auto_url and point it to a newer \"\n        \"version if necessary.\"\n    )\n    if np.any(status == iers.TIME_BEFORE_IERS_RANGE):\n        xp[status == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[0]\n        yp[status == iers.TIME_BEFORE_IERS_RANGE] = _DEFAULT_PM[1]\n\n        warnings.warn(wmsg.format(\"before\"), AstropyWarning)\n\n    if np.any(status == iers.TIME_BEYOND_IERS_RANGE):\n        xp[status == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[0]\n        yp[status == iers.TIME_BEYOND_IERS_RANGE] = _DEFAULT_PM[1]\n\n        warnings.warn(wmsg.format(\"after\"), AstropyWarning)\n\n    return xp.to_value(u.radian), yp.to_value(u.radian)\n\n\ndef _warn_iers(ierserr):\n    \"\"\"\n    Generate a warning for an IERSRangeerror.\n\n    Parameters\n    ----------\n    ierserr : An `~astropy.utils.iers.IERSRangeError`\n    \"\"\"\n    msg = \"{0} Assuming UT1-UTC=0 for coordinate transformations.\"\n    warnings.warn(msg.format(ierserr.args[0]), AstropyWarning)",
                "filename": "astropy/coordinates/builtin_frames/utils.py",
                "start_index": 0,
                "end_index": 2792,
                "start_line": 1,
                "end_line": 79,
                "max_line": 422,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\"\"\"\nThis module contains a helper function to fill erfa.astrom struct and a\nScienceState, which allows to speed up coordinate transformations at the\nexpense of accuracy.\n\"\"\"\nimport warnings\n\nimport erfa\nimport numpy as np\n\nimport astropy.units as u\nfrom astropy.time import Time\nfrom astropy.utils.exceptions import AstropyWarning\nfrom astropy.utils.state import ScienceState\n\nfrom .builtin_frames.utils import (\n    get_cip,\n    get_jd12,\n    get_polar_motion,\n    pav2pv,\n    prepare_earth_position_vel,\n)\nfrom .matrix_utilities import rotation_matrix\n\n__all__ = []",
                "filename": "astropy/coordinates/erfa_astrom.py",
                "start_index": 0,
                "end_index": 631,
                "start_line": 1,
                "end_line": 26,
                "max_line": 428,
                "git_instance": "github",
                "repo_name": "testbed/astropy__astropy__5.0",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "astropy/coordinates/earth_orientation.py": [
                {
                    "chunk": {
                        "code": "def _precession_matrix_besselian(epoch1, epoch2):\n    \"\"\"\n    Computes the precession matrix from one Besselian epoch to another using\n    Newcomb's method.\n\n    ``epoch1`` and ``epoch2`` are in Besselian year numbers.\n    \"\"\"\n    # tropical years\n    t1 = (epoch1 - 1850.0) / 1000.0\n    t2 = (epoch2 - 1850.0) / 1000.0\n    dt = t2 - t1\n\n    zeta1 = 23035.545 + t1 * 139.720 + 0.060 * t1 * t1\n    zeta2 = 30.240 - 0.27 * t1\n    zeta3 = 17.995\n    pzeta = (zeta3, zeta2, zeta1, 0)\n    zeta = np.polyval(pzeta, dt) / 3600\n\n    z1 = 23035.545 + t1 * 139.720 + 0.060 * t1 * t1\n    z2 = 109.480 + 0.39 * t1\n    z3 = 18.325\n    pz = (z3, z2, z1, 0)\n    z = np.polyval(pz, dt) / 3600\n\n    theta1 = 20051.12 - 85.29 * t1 - 0.37 * t1 * t1\n    theta2 = -42.65 - 0.37 * t1\n    theta3 = -41.8\n    ptheta = (theta3, theta2, theta1, 0)\n    theta = np.polyval(ptheta, dt) / 3600\n\n    return (\n        rotation_matrix(-z, \"z\")\n        @ rotation_matrix(theta, \"y\")\n        @ rotation_matrix(-zeta, \"z\")\n    )\n\n\ndef nutation_components2000B(jd):\n    \"\"\"\n    Computes nutation components following the IAU 2000B specification.\n\n    Parameters\n    ----------\n    jd : scalar\n        Julian date (TT) at which to compute the nutation components\n\n    Returns\n    -------\n    eps : float\n        epsilon in radians\n    dpsi : float\n        dpsi in radians\n    deps : float\n        depsilon in raidans\n    \"\"\"\n    dpsi, deps, epsa, _, _, _, _, _ = erfa.pn00b(jd, 0)\n    return epsa, dpsi, deps\n\n\ndef nutation_matrix(epoch):\n    \"\"\"\n    Nutation matrix generated from nutation components, IAU 2000B model.\n\n    Matrix converts from mean coordinate to true coordinate as\n    r_true = M * r_mean\n\n    Parameters\n    ----------\n    epoch : `~astropy.time.Time`\n        The epoch at which to compute the nutation matrix\n\n    Returns\n    -------\n    nmatrix : 3x3 array\n        Nutation matrix for the specified epoch\n\n    References\n    ----------\n    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth\n      Seidelmann (ed), University Science Books (1992).\n    \"\"\"\n    # TODO: implement higher precision 2006/2000A model if requested/needed\n    return erfa.num00b(*get_jd12(epoch, \"tt\"))",
                        "filename": "astropy/coordinates/earth_orientation.py",
                        "start_index": 4024,
                        "end_index": 6199,
                        "start_line": 141,
                        "end_line": 223,
                        "max_line": 223,
                        "git_instance": "github",
                        "repo_name": "testbed/astropy__astropy__5.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the definition of the 'nutation_matrix' function where the reported issue is located. The third argument in the 'rotation_matrix' function call within 'nutation_matrix' should be 'units.radian' instead of 'False' as per the issue description."
                }
            ]
        },
        "solution_task": "- Identify the location in the code where the `nutation_matrix` function is defined.\n- Replace the incorrect `False` argument in the `rotation_matrix` function call with `units.radian`.\n- Ensure that all calls to `rotation_matrix` within `nutation_matrix` pass angles with the correct unit, which should be radians.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE accurately identifies the location of the bug within the 'nutation_matrix' function and provides a clear and actionable solution by instructing to replace the incorrect 'False' argument with 'units.radian'. It also advises ensuring that all calls to 'rotation_matrix' within 'nutation_matrix' pass angles with the correct unit, which is radians. This directly addresses the issue described in the PROMPT. The inclusion of a link to the code snippet where the issue is located is helpful, although not necessary for fixing the bug. The RESPONSE does not address all aspects of the bug, such as testing the fix or considering any potential side effects, which is why it does not score a perfect 10.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711736538.08443,
        "result": "- Identify the location in the code where the `nutation_matrix` function is defined.\n- Replace the incorrect `False` argument in the `rotation_matrix` function call with `units.radian`.\n- Ensure that all calls to `rotation_matrix` within `nutation_matrix` pass angles with the correct unit, which should be radians.\n\n### Code snippets to check\n\n-  \u2192 [astropy](https://github.com/testbed/astropy__astropy__5.0/tree//astropy) \u2192 [coordinates](https://github.com/testbed/astropy__astropy__5.0/tree//astropy/coordinates)- [Lines 141 - 223](https://github.com/testbed/astropy__astropy__5.0/blob//astropy/coordinates/earth_orientation.py#L141-L223)\n\n This snippet contains the definition of the 'nutation_matrix' function where the reported issue is located. The third argument in the 'rotation_matrix' function call within 'nutation_matrix' should be 'units.radian' instead of 'False' as per the issue description.",
        "context_relevance": 0.2800000000000001,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT to get a score of 10.\nSupporting Evidence: The RESPONSE addresses the error in the code and provides a solution to fix the `nutation_matrix` function by replacing the incorrect argument. However, it does not directly address the specific error message provided in the PROMPT, which is about Angle instances requiring units equivalent to 'rad'. The RESPONSE also includes a section with \"Code snippets to check\" and a template that is not relevant to the user's issue. Therefore, the RESPONSE is only partially relevant to the PROMPT."
        },
        "qa_relevance": 0.2
    }
}