{
    "id": "matplotlib__matplotlib-23288",
    "repo_name": "testbed/matplotlib__matplotlib__3.5",
    "task_id": 8366649413646202105,
    "title": "[Bug]: URL-area not rotated in PDFs",
    "body": "### Bug summary\n\nThe URL-sensitive area is not rotated in the PDF output\n\n### Code for reproduction\n\n```python\nimport matplotlib.pyplot as plt\r\n\r\nplt.text(0.5, 0.5, \"Long text with link\", rotation=45, url=\"https://matplotlib.org\")\r\nplt.savefig(\"link.pdf\")\n```\n\n\n### Actual outcome\n\nNote that the link area is still the horizontal part as if the text was not rotated (this makes sense from reading the code).\n\n### Expected outcome\n\nClicking on the text, not where the non-rotated text would have been would activate the URL.\n\n### Additional information\n\nIn https://opensource.adobe.com/dc-acrobat-sdk-docs/pdfstandards/PDF32000_2008.pdf this is described in 12.5.6.5\r\n\r\nFrom PDF version 1.6 it is possible to specify a \"QuadPoints\", i.e. a \"rectangle\" with four corners rather than just x, y, height, width as the current Rect has.\r\n\r\nHowever it says:\r\n\r\n> If this entry is not present or the conforming reader does not recognize\r\nit, the region specified by the Rect entry should be used. QuadPoints\r\nshall be ignored if any coordinate in the array lies outside the region\r\nspecified by Rect.\r\n\r\nSo one would also need to provide a larger Rect, which, for viewers not supporting QuadPoints will lead to that the total rectangle outlined by the rotated text will be clickable.\r\n\r\nThis also holds for mathtexts.\n\n### Operating system\n\n_No response_\n\n### Matplotlib Version\n\nmain\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n_No response_\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\ngit checkout\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/matplotlib__matplotlib__3.5.git",
    "requested_commit": "",
    "mayil_response": "To address the issue of the URL-sensitive area not being rotated in the PDF output, you should modify the `_get_link_annotation` function in the `backend_pdf.py` file to correctly calculate the \"QuadPoints\" for the rotated text. The \"QuadPoints\" should be a list of x,y pairs, which specify the quadrilateral region in which the hyperlink should be active.\n\nHere is a solution:\n\n- Modify the `_get_link_annotation` function in `backend_pdf.py` to ensure that the \"QuadPoints\" are correctly calculated for rotated text.\n- Ensure that the \"QuadPoints\" are calculated in the correct order as per the PDF specification (Section 12.5.6.5 of \"PDF32000_2008.pdf\").\n- The \"QuadPoints\" should be calculated using the `_calculate_quad_point_coordinates` function, which should be updated if necessary to return the coordinates in the correct order.\n- The \"Rect\" should be calculated to encompass the \"QuadPoints\" correctly, even after rotation.\n- Make sure that the \"QuadPoints\" are included in the link annotation dictionary only if the PDF version supports it (PDF version 1.6 or higher).\n- If the PDF version does not support \"QuadPoints\", implement a fallback behavior to ensure that the clickable area is still functional, albeit without rotation.\n\nHere's a code snippet that can be used to update the `_get_link_annotation` function:\n\n```python\ndef _get_link_annotation(gc, x, y, width, height, angle=0):\n    \"\"\"\n    Create a link annotation object for embedding URLs.\n    \"\"\"\n    quadpoints, rect = _get_coordinates_of_block(x, y, width, height, angle)\n    link_annotation = {\n        'Type': Name('Annot'),\n        'Subtype': Name('Link'),\n        'Rect': rect,\n        'Border': [0, 0, 0],\n        'A': {\n            'S': Name('URI'),\n            'URI': gc.get_url(),\n        },\n    }\n    if angle % 90:\n        # Add QuadPoints only if the PDF version supports it\n        if pdf_version_supports_quadpoints:\n            link_annotation['QuadPoints'] = quadpoints\n        else:\n            # Fallback behavior for older PDF versions\n            # Implement as needed\n            pass\n    return link_annotation\n```\n\nMake sure to define `pdf_version_supports_quadpoints` based on the PDF version being used. If the PDF version is 1.6 or higher, set it to `True`. Otherwise, set it to `False` and implement the appropriate fallback behavior.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib/backends)- [Lines 2189 - 2429](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_pdf.py#L2189-L2429)\n\n This snippet contains the method 'draw_mathtext' which is responsible for drawing text with math expressions in PDFs. It includes handling of URLs and rotation, which is directly related to the issue. \n\n\n   - [Lines 205 - 297](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_pdf.py#L205-L297)\n\n This snippet includes the '_get_link_annotation' function which creates link annotations for URLs in PDFs. It handles the rotation of the clickable area, which is relevant to the issue. \n\n\n   - [Lines 1 - 81](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_pdf.py#L1-L81)\n\n This snippet provides an overview of the PDF backend and might contain useful context for understanding how text and URLs are handled in PDFs.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002185,
        "snippet_processor": 0.048850000000000005,
        "issue_star_creation": 0.02826,
        "issue_star_solver": 0.08288999999999999,
        "bouncer": 0.026330000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711698040.8346229,
        "relevant_snippets": [
            {
                "code": "def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width, height, angle))\n\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        unsupported_chars = []\n\n        self.file.output(Op.begin_text)\n        for font, fontsize, num, ox, oy in glyphs:\n            self.file._character_tracker.track_glyph(font, num)\n            fontname = font.fname\n            if not _font_supports_glyph(fonttype, num):\n                # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in\n                # Type 42) must be emitted separately (below).\n                unsupported_chars.append((font, fontsize, ox, oy, num))\n            else:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        for font, fontsize, ox, oy, num in unsupported_chars:\n            self._draw_xobject_glyph(\n                font, fontsize, font.get_char_index(num), ox, oy)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)",
                "filename": "lib/matplotlib/backends/backend_pdf.py",
                "start_index": 81399,
                "end_index": 83673,
                "start_line": 2189,
                "end_line": 2429,
                "max_line": 2827,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "\"\"\"\n==============================\nText Rotation Relative To Line\n==============================\n\nText objects in matplotlib are normally rotated with respect to the\nscreen coordinate system (i.e., 45 degrees rotation plots text along a\nline that is in between horizontal and vertical no matter how the axes\nare changed).  However, at times one wants to rotate text with respect\nto something on the plot.  In this case, the correct angle won't be\nthe angle of that object in the plot coordinate system, but the angle\nthat that object APPEARS in the screen coordinate system.  This angle\ncan be determined automatically by setting the parameter\n*transform_rotates_text*, as shown in the example below.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\n# Plot diagonal line (45 degrees)\nh = ax.plot(range(0, 10), range(0, 10))\n\n# set limits so that it no longer looks on screen to be 45 degrees\nax.set_xlim([-10, 20])\n\n# Locations to plot text\nl1 = np.array((1, 1))\nl2 = np.array((5, 5))\n\n# Rotate angle\nangle = 45\n\n# Plot text\nth1 = ax.text(*l1, 'text not rotated correctly', fontsize=16,\n              rotation=angle, rotation_mode='anchor')\nth2 = ax.text(*l2, 'text rotated correctly', fontsize=16,\n              rotation=angle, rotation_mode='anchor',\n              transform_rotates_text=True)\n\nplt.show()",
                "filename": "galleries/examples/text_labels_and_annotations/text_rotation_relative_to_line.py",
                "start_index": 0,
                "end_index": 1341,
                "start_line": 1,
                "end_line": 42,
                "max_line": 42,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "r\"\"\"\n==================\nText Rotation Mode\n==================\n\nThis example illustrates the effect of ``rotation_mode`` on the positioning\nof rotated text.\n\nRotated `.Text`\\s are created by passing the parameter ``rotation`` to\nthe constructor or the axes' method `~.axes.Axes.text`.\n\nThe actual positioning depends on the additional parameters\n``horizontalalignment``, ``verticalalignment`` and ``rotation_mode``.\n``rotation_mode`` determines the order of rotation and alignment:\n\n- ``rotation_mode='default'`` (or None) first rotates the text and then aligns\n  the bounding box of the rotated text.\n- ``rotation_mode='anchor'`` aligns the unrotated text and then rotates the\n  text around the point of alignment.\n\n.. redirect-from:: /gallery/text_labels_and_annotations/text_rotation\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef test_rotation_mode(fig, mode):\n    ha_list = [\"left\", \"center\", \"right\"]\n    va_list = [\"top\", \"center\", \"baseline\", \"bottom\"]\n    axs = fig.subplots(len(va_list), len(ha_list), sharex=True, sharey=True,\n                       subplot_kw=dict(aspect=1),\n                       gridspec_kw=dict(hspace=0, wspace=0))\n\n    # labels and title\n    for ha, ax in zip(ha_list, axs[-1, :]):\n        ax.set_xlabel(ha)\n    for va, ax in zip(va_list, axs[:, 0]):\n        ax.set_ylabel(va)\n    axs[0, 1].set_title(f\"rotation_mode='{mode}'\", size=\"large\")\n\n    kw = (\n        {} if mode == \"default\" else\n        {\"bbox\": dict(boxstyle=\"square,pad=0.\", ec=\"none\", fc=\"C1\", alpha=0.3)}\n    )\n\n    texts = {}\n\n    # use a different text alignment in each axes\n    for i, va in enumerate(va_list):\n        for j, ha in enumerate(ha_list):\n            ax = axs[i, j]\n            # prepare axes layout\n            ax.set(xticks=[], yticks=[])\n            ax.axvline(0.5, color=\"skyblue\", zorder=0)\n            ax.axhline(0.5, color=\"skyblue\", zorder=0)\n            ax.plot(0.5, 0.5, color=\"C0\", marker=\"o\", zorder=1)\n            # add text with rotation and alignment settings\n            tx = ax.text(0.5, 0.5, \"Tpg\",\n                         size=\"x-large\", rotation=40,\n                         horizontalalignment=ha, verticalalignment=va,\n                         rotation_mode=mode, **kw)\n            texts[ax] = tx\n\n    if mode == \"default\":\n        # highlight bbox\n        fig.canvas.draw()\n        for ax, text in texts.items():\n            bb = text.get_window_extent().transformed(ax.transData.inverted())\n            rect = plt.Rectangle((bb.x0, bb.y0), bb.width, bb.height,\n                                 facecolor=\"C1\", alpha=0.3, zorder=2)\n            ax.add_patch(rect)\n\n\nfig = plt.figure(figsize=(8, 5))\nsubfigs = fig.subfigures(1, 2)\ntest_rotation_mode(subfigs[0], \"default\")\ntest_rotation_mode(subfigs[1], \"anchor\")\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.text` / `matplotlib.pyplot.text`",
                "filename": "galleries/examples/text_labels_and_annotations/demo_text_rotation_mode.py",
                "start_index": 0,
                "end_index": 2964,
                "start_line": 1,
                "end_line": 88,
                "max_line": 88,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "name: Bug Report\ndescription: Report a bug or issue with Matplotlib.\ntitle: \"[Bug]: \"\nbody:\n  - type: textarea\n    id: summary\n    attributes:\n      label: Bug summary\n      description:  Describe the bug in 1-2 short sentences\n      placeholder:\n      value:\n    validations:\n      required: true\n  - type: textarea\n    id: reproduction\n    attributes:\n      label: Code for reproduction\n      description: |\n        If possible, please provide a minimum self-contained example.\n      placeholder: Paste your code here. This field is automatically formatted as Python code.\n      render: python\n    validations:\n      required: true\n  - type: textarea\n    id: actual\n    attributes:\n      label: Actual outcome\n      description: |\n        Paste the output produced by the code provided above, e.g.\n        console output, images/videos produced by the code, any relevant screenshots/screencasts, etc.\n    validations:\n      required: true\n  - type: textarea\n    id: expected\n    attributes:\n      label: Expected outcome\n      description: Describe (or provide a visual example of) the expected outcome from the code snippet.\n    validations:\n      required: true\n  - type: textarea\n    id: details\n    attributes:\n      label: Additional information\n      description: |\n        - What are the conditions under which this bug happens? input parameters, edge cases, etc?\n        - Has this worked in earlier versions?\n        - Do you know why this bug is happening?\n        - Do you maybe even know a fix?\n  - type: input\n    id: operating-system\n    attributes:\n      label: Operating system\n      description: Windows, OS/X, Arch, Debian, Ubuntu, etc.\n  - type: input\n    id: matplotlib-version\n    attributes:\n      label: Matplotlib Version\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.__version__)`\"\n    validations:\n      required: true\n  - type: input\n    id: matplotlib-backend\n    attributes:\n      label: Matplotlib Backend\n      description: \"From Python prompt: `import matplotlib; print(matplotlib.get_backend())`\"\n  - type: input\n    id: python-version\n    attributes:\n      label: Python version\n      description: \"In console: `python --version`\"\n  - type: input\n    id: jupyter-version\n    attributes:\n      label: Jupyter version\n      description: \"In console: `jupyter notebook --version` or `jupyter lab --version`\"\n  - type: dropdown\n    id: install\n    attributes:\n      label: Installation\n      description: How did you install matplotlib?\n      options:\n        - pip\n        - conda\n        - Linux package manager\n        - from source (.tar.gz)\n        - git checkout",
                "filename": ".github/ISSUE_TEMPLATE/bug_report.yml",
                "start_index": 0,
                "end_index": 2631,
                "start_line": 1,
                "end_line": 86,
                "max_line": 86,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "\"\"\"\nA PDF Matplotlib backend.\n\nAuthor: Jouni K Sepp\u00e4nen <jks@iki.fi> and others.\n\"\"\"\n\nimport codecs\nfrom datetime import timezone\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import total_ordering\nfrom io import BytesIO\nimport itertools\nimport logging\nimport math\nimport os\nimport string\nimport struct\nimport sys\nimport time\nimport types\nimport warnings\nimport zlib\n\nimport numpy as np\nfrom PIL import Image\n\nimport matplotlib as mpl\nfrom matplotlib import _api, _text_helpers, _type1font, cbook, dviread\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase, GraphicsContextBase,\n    RendererBase)\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\nfrom matplotlib.figure import Figure\nfrom matplotlib.font_manager import get_font, fontManager as _fontManager\nfrom matplotlib._afm import AFM\nfrom matplotlib.ft2font import (FIXED_WIDTH, ITALIC, LOAD_NO_SCALE,\n                                LOAD_NO_HINTING, KERNING_UNFITTED, FT2Font)\nfrom matplotlib.transforms import Affine2D, BboxBase\nfrom matplotlib.path import Path\nfrom matplotlib.dates import UTC\nfrom matplotlib import _path\nfrom . import _backend_pdf_ps\n\n_log = logging.getLogger(__name__)\n\n# Overview\n#\n# The low-level knowledge about pdf syntax lies mainly in the pdfRepr\n# function and the classes Reference, Name, Operator, and Stream.  The\n# PdfFile class knows about the overall structure of pdf documents.\n# It provides a \"write\" method for writing arbitrary strings in the\n# file, and an \"output\" method that passes objects through the pdfRepr\n# function before writing them in the file.  The output method is\n# called by the RendererPdf class, which contains the various draw_foo\n# methods.  RendererPdf contains a GraphicsContextPdf instance, and\n# each draw_foo calls self.check_gc before outputting commands.  This\n# method checks whether the pdf graphics state needs to be modified\n# and outputs the necessary commands.  GraphicsContextPdf represents\n# the graphics state, and its \"delta\" method returns the commands that\n# modify the state.\n\n# Add \"pdf.use14corefonts: True\" in your configuration file to use only\n# the 14 PDF core fonts. These fonts do not need to be embedded; every\n# PDF viewing application is required to have them. This results in very\n# light PDF files you can use directly in LaTeX or ConTeXt documents\n# generated with pdfTeX, without any conversion.\n\n# These fonts are: Helvetica, Helvetica-Bold, Helvetica-Oblique,\n# Helvetica-BoldOblique, Courier, Courier-Bold, Courier-Oblique,\n# Courier-BoldOblique, Times-Roman, Times-Bold, Times-Italic,\n# Times-BoldItalic, Symbol, ZapfDingbats.\n#\n# Some tricky points:\n#\n# 1. The clip path can only be widened by popping from the state\n# stack.  Thus the state must be pushed onto the stack before narrowing\n# the clip path.  This is taken care of by GraphicsContextPdf.\n#\n# 2. Sometimes it is necessary to refer to something (e.g., font,",
                "filename": "lib/matplotlib/backends/backend_pdf.py",
                "start_index": 0,
                "end_index": 2991,
                "start_line": 1,
                "end_line": 81,
                "max_line": 2827,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "else:\n            # List of (ft_object, start_x, [prev_kern, char, char, ...]),\n            # w/o zero kerns.\n            singlebyte_chunks = []\n            # List of (ft_object, start_x, glyph_index).\n            multibyte_glyphs = []\n            prev_was_multibyte = True\n            prev_font = font\n            for item in _text_helpers.layout(\n                    s, font, kern_mode=KERNING_UNFITTED):\n                if _font_supports_glyph(fonttype, ord(item.char)):\n                    if prev_was_multibyte or item.ft_object != prev_font:\n                        singlebyte_chunks.append((item.ft_object, item.x, []))\n                        prev_font = item.ft_object\n                    if item.prev_kern:\n                        singlebyte_chunks[-1][2].append(item.prev_kern)\n                    singlebyte_chunks[-1][2].append(item.char)\n                    prev_was_multibyte = False\n                else:\n                    multibyte_glyphs.append(\n                        (item.ft_object, item.x, item.glyph_idx)\n                    )\n                    prev_was_multibyte = True\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n\n            self.file.output(Op.begin_text)\n            prev_start_x = 0\n            for ft_object, start_x, kerns_or_chars in singlebyte_chunks:\n                ft_name = self.file.fontName(ft_object.fname)\n                self.file.output(ft_name, fontsize, Op.selectfont)\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(\n                    # See pdf spec \"Text space details\" for the 1000/fontsize\n                    # (aka. 1000/T_fs) factor.\n                    [-1000 * next(group) / fontsize if tp == float  # a kern\n                     else self.encode_string(\"\".join(group), fonttype)\n                     for tp, group in itertools.groupby(kerns_or_chars, type)],\n                    Op.showkern)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for ft_object, start_x, glyph_idx in multibyte_glyphs:\n                self._draw_xobject_glyph(\n                    ft_object, fontsize, glyph_idx, start_x, 0\n                )\n            self.file.output(Op.grestore)",
                "filename": "lib/matplotlib/backends/backend_pdf.py",
                "start_index": 89550,
                "end_index": 92208,
                "start_line": 110,
                "end_line": 2429,
                "max_line": 2827,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _datetime_to_pdf(d):\n    \"\"\"\n    Convert a datetime to a PDF string representing it.\n\n    Used for PDF and PGF.\n    \"\"\"\n    r = d.strftime('D:%Y%m%d%H%M%S')\n    z = d.utcoffset()\n    if z is not None:\n        z = z.seconds\n    else:\n        if time.daylight:\n            z = time.altzone\n        else:\n            z = time.timezone\n    if z == 0:\n        r += 'Z'\n    elif z < 0:\n        r += \"+%02d'%02d'\" % ((-z) // 3600, (-z) % 3600)\n    else:\n        r += \"-%02d'%02d'\" % (z // 3600, z % 3600)\n    return r\n\n\ndef _calculate_quad_point_coordinates(x, y, width, height, angle=0):\n    \"\"\"\n    Calculate the coordinates of rectangle when rotated by angle around x, y\n    \"\"\"\n\n    angle = math.radians(-angle)\n    sin_angle = math.sin(angle)\n    cos_angle = math.cos(angle)\n    a = x + height * sin_angle\n    b = y + height * cos_angle\n    c = x + width * cos_angle + height * sin_angle\n    d = y - width * sin_angle + height * cos_angle\n    e = x + width * cos_angle\n    f = y - width * sin_angle\n    return ((x, y), (e, f), (c, d), (a, b))\n\n\ndef _get_coordinates_of_block(x, y, width, height, angle=0):\n    \"\"\"\n    Get the coordinates of rotated rectangle and rectangle that covers the\n    rotated rectangle.\n    \"\"\"\n\n    vertices = _calculate_quad_point_coordinates(x, y, width,\n                                                 height, angle)\n\n    # Find min and max values for rectangle\n    # adjust so that QuadPoints is inside Rect\n    # PDF docs says that QuadPoints should be ignored if any point lies\n    # outside Rect, but for Acrobat it is enough that QuadPoints is on the\n    # border of Rect.\n\n    pad = 0.00001 if angle % 90 else 0\n    min_x = min(v[0] for v in vertices) - pad\n    min_y = min(v[1] for v in vertices) - pad\n    max_x = max(v[0] for v in vertices) + pad\n    max_y = max(v[1] for v in vertices) + pad\n    return (tuple(itertools.chain.from_iterable(vertices)),\n            (min_x, min_y, max_x, max_y))\n\n\ndef _get_link_annotation(gc, x, y, width, height, angle=0):\n    \"\"\"\n    Create a link annotation object for embedding URLs.\n    \"\"\"\n    quadpoints, rect = _get_coordinates_of_block(x, y, width, height, angle)\n    link_annotation = {\n        'Type': Name('Annot'),\n        'Subtype': Name('Link'),\n        'Rect': rect,\n        'Border': [0, 0, 0],\n        'A': {\n            'S': Name('URI'),\n            'URI': gc.get_url(),\n        },\n    }\n    if angle % 90:\n        # Add QuadPoints\n        link_annotation['QuadPoints'] = quadpoints\n    return link_annotation\n\n\n# PDF strings are supposed to be able to include any eight-bit data, except\n# that unbalanced parens and backslashes must be escaped by a backslash.\n# However, sf bug #2708559 shows that the carriage return character may get\n# read as a newline; these characters correspond to \\gamma and \\Omega in TeX's\n# math font encoding. Escaping them fixes the bug.\n_str_escapes = str.maketrans({\n    '\\\\': '\\\\\\\\', '(': '\\\\(', ')': '\\\\)', '\\n': '\\\\n', '\\r': '\\\\r'})",
                "filename": "lib/matplotlib/backends/backend_pdf.py",
                "start_index": 7184,
                "end_index": 10143,
                "start_line": 205,
                "end_line": 297,
                "max_line": 2827,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n==========\nHyperlinks\n==========\n\nThis example demonstrates how to set a hyperlinks on various kinds of elements.\n\nThis currently only works with the SVG backend.\n\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\n\n# %%\n\nfig = plt.figure()\ns = plt.scatter([1, 2, 3], [4, 5, 6])\ns.set_urls(['https://www.bbc.com/news', 'https://www.google.com/', None])\nfig.savefig('scatter.svg')\n\n# %%\n\nfig = plt.figure()\ndelta = 0.025\nx = y = np.arange(-3.0, 3.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nim = plt.imshow(Z, interpolation='bilinear', cmap=cm.gray,\n                origin='lower', extent=(-3, 3, -3, 3))\n\nim.set_url('https://www.google.com/')\nfig.savefig('image.svg')",
                "filename": "galleries/examples/misc/hyperlinks_sgskip.py",
                "start_index": 0,
                "end_index": 779,
                "start_line": 1,
                "end_line": 39,
                "max_line": 39,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n%%LanguageLevel: 3\n{dsc_comments}\n{get_bbox_header(bbox)[0]}\n%%EndComments\n%%BeginProlog\n/mpldict {len(_psDefs)} dict def\nmpldict begin\n{\"\".join(_psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n0 0 {_nums_to_str(width*72, height*72)} rectclip\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps or papertype == 'figure':\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                if papertype == 'auto':\n                    _api.warn_deprecated(\"3.8\", name=\"papertype='auto'\",\n                                         addendum=\"Pass an explicit paper type, or \"\n                                         \"omit the *papertype* argument entirely.\")\n                    papertype = _get_papertype(width, height)\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmppath, outfile)",
                "filename": "lib/matplotlib/backends/backend_ps.py",
                "start_index": 36196,
                "end_index": 38415,
                "start_line": 215,
                "end_line": 1081,
                "max_line": 1346,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\n\n.. redirect-from:: /tutorials/text/text_intro\n\n.. _text_intro:\n\n========================\nText in Matplotlib Plots\n========================\n\nIntroduction to plotting and working with text in Matplotlib.\n\nMatplotlib has extensive text support, including support for\nmathematical expressions, truetype support for raster and\nvector outputs, newline separated text with arbitrary\nrotations, and Unicode support.\n\nBecause it embeds fonts directly in output documents, e.g., for postscript\nor PDF, what you see on the screen is what you get in the hardcopy.\n`FreeType <https://www.freetype.org/>`_ support\nproduces very nice, antialiased fonts, that look good even at small\nraster sizes.  Matplotlib includes its own\n:mod:`matplotlib.font_manager` (thanks to Paul Barrett), which\nimplements a cross platform, `W3C <https://www.w3.org/>`_\ncompliant font finding algorithm.\n\nThe user has a great deal of control over text properties (font size, font\nweight, text location and color, etc.) with sensible defaults set in\nthe :ref:`rc file <customizing>`.\nAnd significantly, for those interested in mathematical\nor scientific figures, Matplotlib implements a large number of TeX\nmath symbols and commands, supporting :ref:`mathematical expressions\n<mathtext>` anywhere in your figure.\n\n\nBasic text commands\n===================\n\nThe following commands are used to create text in the implicit and explicit\ninterfaces (see :ref:`api_interfaces` for an explanation of the tradeoffs):\n\n=================== =================== ======================================\nimplicit API        explicit API        description\n=================== =================== ======================================\n`~.pyplot.text`     `~.Axes.text`       Add text at an arbitrary location of\n                                        the `~matplotlib.axes.Axes`.\n\n`~.pyplot.annotate` `~.Axes.annotate`   Add an annotation, with an optional\n                                        arrow, at an arbitrary location of the\n                                        `~matplotlib.axes.Axes`.\n\n`~.pyplot.xlabel`   `~.Axes.set_xlabel` Add a label to the\n                                        `~matplotlib.axes.Axes`\\\\'s x-axis.\n\n`~.pyplot.ylabel`   `~.Axes.set_ylabel` Add a label to the\n                                        `~matplotlib.axes.Axes`\\\\'s y-axis.\n\n`~.pyplot.title`    `~.Axes.set_title`  Add a title to the\n                                        `~matplotlib.axes.Axes`.\n\n`~.pyplot.figtext`  `~.Figure.text`     Add text at an arbitrary location of\n                                        the `.Figure`.\n\n`~.pyplot.suptitle` `~.Figure.suptitle` Add a title to the `.Figure`.\n=================== =================== ======================================\n\nAll of these functions create and return a `.Text` instance, which can be\nconfigured with a variety of font and other properties.  The example below\nshows all of these commands in action, and more detail is provided in the\nsections that follow.\n\n\"\"\"",
                "filename": "galleries/users_explain/text/text_intro.py",
                "start_index": 0,
                "end_index": 2982,
                "start_line": 1,
                "end_line": 365,
                "max_line": 429,
                "git_instance": "github",
                "repo_name": "testbed/matplotlib__matplotlib__3.5",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "lib/matplotlib/backends/backend_pdf.py": [
                {
                    "chunk": {
                        "code": "def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width, height, angle))\n\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        unsupported_chars = []\n\n        self.file.output(Op.begin_text)\n        for font, fontsize, num, ox, oy in glyphs:\n            self.file._character_tracker.track_glyph(font, num)\n            fontname = font.fname\n            if not _font_supports_glyph(fonttype, num):\n                # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in\n                # Type 42) must be emitted separately (below).\n                unsupported_chars.append((font, fontsize, ox, oy, num))\n            else:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        for font, fontsize, ox, oy, num in unsupported_chars:\n            self._draw_xobject_glyph(\n                font, fontsize, font.get_char_index(num), ox, oy)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)",
                        "filename": "lib/matplotlib/backends/backend_pdf.py",
                        "start_index": 81399,
                        "end_index": 83673,
                        "start_line": 2189,
                        "end_line": 2429,
                        "max_line": 2827,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the method 'draw_mathtext' which is responsible for drawing text with math expressions in PDFs. It includes handling of URLs and rotation, which is directly related to the issue."
                },
                {
                    "chunk": {
                        "code": "def _datetime_to_pdf(d):\n    \"\"\"\n    Convert a datetime to a PDF string representing it.\n\n    Used for PDF and PGF.\n    \"\"\"\n    r = d.strftime('D:%Y%m%d%H%M%S')\n    z = d.utcoffset()\n    if z is not None:\n        z = z.seconds\n    else:\n        if time.daylight:\n            z = time.altzone\n        else:\n            z = time.timezone\n    if z == 0:\n        r += 'Z'\n    elif z < 0:\n        r += \"+%02d'%02d'\" % ((-z) // 3600, (-z) % 3600)\n    else:\n        r += \"-%02d'%02d'\" % (z // 3600, z % 3600)\n    return r\n\n\ndef _calculate_quad_point_coordinates(x, y, width, height, angle=0):\n    \"\"\"\n    Calculate the coordinates of rectangle when rotated by angle around x, y\n    \"\"\"\n\n    angle = math.radians(-angle)\n    sin_angle = math.sin(angle)\n    cos_angle = math.cos(angle)\n    a = x + height * sin_angle\n    b = y + height * cos_angle\n    c = x + width * cos_angle + height * sin_angle\n    d = y - width * sin_angle + height * cos_angle\n    e = x + width * cos_angle\n    f = y - width * sin_angle\n    return ((x, y), (e, f), (c, d), (a, b))\n\n\ndef _get_coordinates_of_block(x, y, width, height, angle=0):\n    \"\"\"\n    Get the coordinates of rotated rectangle and rectangle that covers the\n    rotated rectangle.\n    \"\"\"\n\n    vertices = _calculate_quad_point_coordinates(x, y, width,\n                                                 height, angle)\n\n    # Find min and max values for rectangle\n    # adjust so that QuadPoints is inside Rect\n    # PDF docs says that QuadPoints should be ignored if any point lies\n    # outside Rect, but for Acrobat it is enough that QuadPoints is on the\n    # border of Rect.\n\n    pad = 0.00001 if angle % 90 else 0\n    min_x = min(v[0] for v in vertices) - pad\n    min_y = min(v[1] for v in vertices) - pad\n    max_x = max(v[0] for v in vertices) + pad\n    max_y = max(v[1] for v in vertices) + pad\n    return (tuple(itertools.chain.from_iterable(vertices)),\n            (min_x, min_y, max_x, max_y))\n\n\ndef _get_link_annotation(gc, x, y, width, height, angle=0):\n    \"\"\"\n    Create a link annotation object for embedding URLs.\n    \"\"\"\n    quadpoints, rect = _get_coordinates_of_block(x, y, width, height, angle)\n    link_annotation = {\n        'Type': Name('Annot'),\n        'Subtype': Name('Link'),\n        'Rect': rect,\n        'Border': [0, 0, 0],\n        'A': {\n            'S': Name('URI'),\n            'URI': gc.get_url(),\n        },\n    }\n    if angle % 90:\n        # Add QuadPoints\n        link_annotation['QuadPoints'] = quadpoints\n    return link_annotation\n\n\n# PDF strings are supposed to be able to include any eight-bit data, except\n# that unbalanced parens and backslashes must be escaped by a backslash.\n# However, sf bug #2708559 shows that the carriage return character may get\n# read as a newline; these characters correspond to \\gamma and \\Omega in TeX's\n# math font encoding. Escaping them fixes the bug.\n_str_escapes = str.maketrans({\n    '\\\\': '\\\\\\\\', '(': '\\\\(', ')': '\\\\)', '\\n': '\\\\n', '\\r': '\\\\r'})",
                        "filename": "lib/matplotlib/backends/backend_pdf.py",
                        "start_index": 7184,
                        "end_index": 10143,
                        "start_line": 205,
                        "end_line": 297,
                        "max_line": 2827,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the '_get_link_annotation' function which creates link annotations for URLs in PDFs. It handles the rotation of the clickable area, which is relevant to the issue."
                },
                {
                    "chunk": {
                        "code": "\"\"\"\nA PDF Matplotlib backend.\n\nAuthor: Jouni K Sepp\u00e4nen <jks@iki.fi> and others.\n\"\"\"\n\nimport codecs\nfrom datetime import timezone\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import total_ordering\nfrom io import BytesIO\nimport itertools\nimport logging\nimport math\nimport os\nimport string\nimport struct\nimport sys\nimport time\nimport types\nimport warnings\nimport zlib\n\nimport numpy as np\nfrom PIL import Image\n\nimport matplotlib as mpl\nfrom matplotlib import _api, _text_helpers, _type1font, cbook, dviread\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase, GraphicsContextBase,\n    RendererBase)\nfrom matplotlib.backends.backend_mixed import MixedModeRenderer\nfrom matplotlib.figure import Figure\nfrom matplotlib.font_manager import get_font, fontManager as _fontManager\nfrom matplotlib._afm import AFM\nfrom matplotlib.ft2font import (FIXED_WIDTH, ITALIC, LOAD_NO_SCALE,\n                                LOAD_NO_HINTING, KERNING_UNFITTED, FT2Font)\nfrom matplotlib.transforms import Affine2D, BboxBase\nfrom matplotlib.path import Path\nfrom matplotlib.dates import UTC\nfrom matplotlib import _path\nfrom . import _backend_pdf_ps\n\n_log = logging.getLogger(__name__)\n\n# Overview\n#\n# The low-level knowledge about pdf syntax lies mainly in the pdfRepr\n# function and the classes Reference, Name, Operator, and Stream.  The\n# PdfFile class knows about the overall structure of pdf documents.\n# It provides a \"write\" method for writing arbitrary strings in the\n# file, and an \"output\" method that passes objects through the pdfRepr\n# function before writing them in the file.  The output method is\n# called by the RendererPdf class, which contains the various draw_foo\n# methods.  RendererPdf contains a GraphicsContextPdf instance, and\n# each draw_foo calls self.check_gc before outputting commands.  This\n# method checks whether the pdf graphics state needs to be modified\n# and outputs the necessary commands.  GraphicsContextPdf represents\n# the graphics state, and its \"delta\" method returns the commands that\n# modify the state.\n\n# Add \"pdf.use14corefonts: True\" in your configuration file to use only\n# the 14 PDF core fonts. These fonts do not need to be embedded; every\n# PDF viewing application is required to have them. This results in very\n# light PDF files you can use directly in LaTeX or ConTeXt documents\n# generated with pdfTeX, without any conversion.\n\n# These fonts are: Helvetica, Helvetica-Bold, Helvetica-Oblique,\n# Helvetica-BoldOblique, Courier, Courier-Bold, Courier-Oblique,\n# Courier-BoldOblique, Times-Roman, Times-Bold, Times-Italic,\n# Times-BoldItalic, Symbol, ZapfDingbats.\n#\n# Some tricky points:\n#\n# 1. The clip path can only be widened by popping from the state\n# stack.  Thus the state must be pushed onto the stack before narrowing\n# the clip path.  This is taken care of by GraphicsContextPdf.\n#\n# 2. Sometimes it is necessary to refer to something (e.g., font,",
                        "filename": "lib/matplotlib/backends/backend_pdf.py",
                        "start_index": 0,
                        "end_index": 2991,
                        "start_line": 1,
                        "end_line": 81,
                        "max_line": 2827,
                        "git_instance": "github",
                        "repo_name": "testbed/matplotlib__matplotlib__3.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet provides an overview of the PDF backend and might contain useful context for understanding how text and URLs are handled in PDFs."
                }
            ]
        },
        "solution_task": "To address the issue of the URL-sensitive area not being rotated in the PDF output, you should modify the `_get_link_annotation` function in the `backend_pdf.py` file to correctly calculate the \"QuadPoints\" for the rotated text. The \"QuadPoints\" should be a list of x,y pairs, which specify the quadrilateral region in which the hyperlink should be active.\n\nHere is a solution:\n\n- Modify the `_get_link_annotation` function in `backend_pdf.py` to ensure that the \"QuadPoints\" are correctly calculated for rotated text.\n- Ensure that the \"QuadPoints\" are calculated in the correct order as per the PDF specification (Section 12.5.6.5 of \"PDF32000_2008.pdf\").\n- The \"QuadPoints\" should be calculated using the `_calculate_quad_point_coordinates` function, which should be updated if necessary to return the coordinates in the correct order.\n- The \"Rect\" should be calculated to encompass the \"QuadPoints\" correctly, even after rotation.\n- Make sure that the \"QuadPoints\" are included in the link annotation dictionary only if the PDF version supports it (PDF version 1.6 or higher).\n- If the PDF version does not support \"QuadPoints\", implement a fallback behavior to ensure that the clickable area is still functional, albeit without rotation.\n\nHere's a code snippet that can be used to update the `_get_link_annotation` function:\n\n```python\ndef _get_link_annotation(gc, x, y, width, height, angle=0):\n    \"\"\"\n    Create a link annotation object for embedding URLs.\n    \"\"\"\n    quadpoints, rect = _get_coordinates_of_block(x, y, width, height, angle)\n    link_annotation = {\n        'Type': Name('Annot'),\n        'Subtype': Name('Link'),\n        'Rect': rect,\n        'Border': [0, 0, 0],\n        'A': {\n            'S': Name('URI'),\n            'URI': gc.get_url(),\n        },\n    }\n    if angle % 90:\n        # Add QuadPoints only if the PDF version supports it\n        if pdf_version_supports_quadpoints:\n            link_annotation['QuadPoints'] = quadpoints\n        else:\n            # Fallback behavior for older PDF versions\n            # Implement as needed\n            pass\n    return link_annotation\n```\n\nMake sure to define `pdf_version_supports_quadpoints` based on the PDF version being used. If the PDF version is 1.6 or higher, set it to `True`. Otherwise, set it to `False` and implement the appropriate fallback behavior.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the problem of the URL-sensitive area not rotating with the text in PDFs generated by Matplotlib. It suggests modifying the '_get_link_annotation' function in the 'backend_pdf.py' file to correctly calculate the 'QuadPoints' for the rotated text, which is directly relevant to the issue described in the PROMPT. The RESPONSE also includes a code snippet that outlines how to update the function, which is helpful for implementation. Additionally, it addresses the need to check for PDF version compatibility and provides a fallback for older versions, which shows a comprehensive understanding of the problem. The RESPONSE also references specific lines of code in the Matplotlib repository, which could be useful for developers looking to implement the fix.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711698175.4076831,
        "result": "To address the issue of the URL-sensitive area not being rotated in the PDF output, you should modify the `_get_link_annotation` function in the `backend_pdf.py` file to correctly calculate the \"QuadPoints\" for the rotated text. The \"QuadPoints\" should be a list of x,y pairs, which specify the quadrilateral region in which the hyperlink should be active.\n\nHere is a solution:\n\n- Modify the `_get_link_annotation` function in `backend_pdf.py` to ensure that the \"QuadPoints\" are correctly calculated for rotated text.\n- Ensure that the \"QuadPoints\" are calculated in the correct order as per the PDF specification (Section 12.5.6.5 of \"PDF32000_2008.pdf\").\n- The \"QuadPoints\" should be calculated using the `_calculate_quad_point_coordinates` function, which should be updated if necessary to return the coordinates in the correct order.\n- The \"Rect\" should be calculated to encompass the \"QuadPoints\" correctly, even after rotation.\n- Make sure that the \"QuadPoints\" are included in the link annotation dictionary only if the PDF version supports it (PDF version 1.6 or higher).\n- If the PDF version does not support \"QuadPoints\", implement a fallback behavior to ensure that the clickable area is still functional, albeit without rotation.\n\nHere's a code snippet that can be used to update the `_get_link_annotation` function:\n\n```python\ndef _get_link_annotation(gc, x, y, width, height, angle=0):\n    \"\"\"\n    Create a link annotation object for embedding URLs.\n    \"\"\"\n    quadpoints, rect = _get_coordinates_of_block(x, y, width, height, angle)\n    link_annotation = {\n        'Type': Name('Annot'),\n        'Subtype': Name('Link'),\n        'Rect': rect,\n        'Border': [0, 0, 0],\n        'A': {\n            'S': Name('URI'),\n            'URI': gc.get_url(),\n        },\n    }\n    if angle % 90:\n        # Add QuadPoints only if the PDF version supports it\n        if pdf_version_supports_quadpoints:\n            link_annotation['QuadPoints'] = quadpoints\n        else:\n            # Fallback behavior for older PDF versions\n            # Implement as needed\n            pass\n    return link_annotation\n```\n\nMake sure to define `pdf_version_supports_quadpoints` based on the PDF version being used. If the PDF version is 1.6 or higher, set it to `True`. Otherwise, set it to `False` and implement the appropriate fallback behavior.\n\n### Code snippets to check\n\n-  \u2192 [lib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib) \u2192 [matplotlib](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib) \u2192 [backends](https://github.com/testbed/matplotlib__matplotlib__3.5/tree//lib/matplotlib/backends)- [Lines 2189 - 2429](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_pdf.py#L2189-L2429)\n\n This snippet contains the method 'draw_mathtext' which is responsible for drawing text with math expressions in PDFs. It includes handling of URLs and rotation, which is directly related to the issue. \n\n\n   - [Lines 205 - 297](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_pdf.py#L205-L297)\n\n This snippet includes the '_get_link_annotation' function which creates link annotations for URLs in PDFs. It handles the rotation of the clickable area, which is relevant to the issue. \n\n\n   - [Lines 1 - 81](https://github.com/testbed/matplotlib__matplotlib__3.5/blob//lib/matplotlib/backends/backend_pdf.py#L1-L81)\n\n This snippet provides an overview of the PDF backend and might contain useful context for understanding how text and URLs are handled in PDFs.",
        "context_relevance": 0.38,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant and answers the entire PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation and a potential solution to the reported bug regarding the URL-sensitive area not rotating in PDFs. It addresses the technical aspects of the problem, references the appropriate section of the PDF specification, and suggests modifications to the code that would likely resolve the issue. The RESPONSE also includes a code snippet that is directly relevant to the problem described in the PROMPT. Additionally, it provides guidance on handling different PDF versions with respect to the \"QuadPoints\" feature. The RESPONSE is comprehensive and directly addresses all parts of the PROMPT, including the bug summary, expected outcome, and additional information provided."
        },
        "qa_relevance": 1.0
    }
}