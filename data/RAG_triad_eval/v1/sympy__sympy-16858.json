{
    "id": "sympy__sympy-16858",
    "repo_name": "testbed/sympy__sympy__1.5",
    "task_id": 5980699327265498784,
    "title": "Added missing checks and attributes to sympy.stats",
    "body": "<!-- Your title above should be a short description of what\r\nwas changed. Do not include the issue number in the title. -->\r\n\r\n#### References to other Issues or PRs\r\n<!-- If this pull request fixes an issue, write \"Fixes #NNNN\" in that exact\r\nformat, e.g. \"Fixes #1234\". See\r\nhttps://github.com/blog/1506-closing-issues-via-pull-requests . Please also\r\nwrite a comment on that issue linking back to this pull request once it is\r\nopen. -->\r\nN/A\r\n\r\n\r\n#### Brief description of what is fixed or changed\r\nMissing checks for parameters and set\r\nattributes have been added to various\r\ndistributions to enhance consistency\r\nand correctness.\r\n\r\n\r\n#### Other comments\r\nThese changes are made for enhancement of the code. This PR is made for receiving regular feedback on the code additions.\r\nStatus - Work In Progress\r\nPlease discuss with me on the changes I have made, so that I can present my view if I haven't made satisfactory changes. \r\n\r\n#### Release Notes\r\n\r\n<!-- Write the release notes for this release below. See\r\nhttps://github.com/sympy/sympy/wiki/Writing-Release-Notes for more information\r\non how to write release notes. The bot will check your release notes\r\nautomatically to see if they are formatted correctly. -->\r\n\r\n<!-- BEGIN RELEASE NOTES -->\r\n* stats\r\n  * missing checks and attributes added to sympy.stats for distributions.\r\n<!-- END RELEASE NOTES -->\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/sympy__sympy__1.5.git",
    "requested_commit": "",
    "mayil_response": "- Add parameter checks in the `__init__` methods of distribution classes in `sympy/stats/crv_types.py` and `sympy/stats/drv.py` using the `_value_check` function.\n- Ensure that the `check` static method of each distribution class is called within the `__init__` method to validate parameters.\n- For distributions that do not have a `check` method, implement one based on the constraints of the distribution's parameters.\n- For distributions that have attributes set outside of the `__init__` method, ensure that these attributes are set within the `__init__` method and that they are consistent with the distribution's properties.\n\nFor example, for the `BetaPrimeDistribution` class in `sympy/stats/crv_types.py`:\n```python\nclass BetaPrimeDistribution(SingleContinuousDistribution):\n    _argnames = ('alpha', 'beta')\n\n    @staticmethod\n    def check(alpha, beta):\n        _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n        _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n\n    def __init__(self, alpha, beta):\n        super(BetaPrimeDistribution, self).__init__(alpha, beta)\n        self.alpha, self.beta = alpha, beta\n        BetaPrimeDistribution.check(alpha, beta)\n\n    set = Interval(0, oo)\n```\n\nRepeat this process for other distributions, ensuring that the `check` method is called and that attributes are set correctly within the `__init__` method.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 1 - 151](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L1-L151)\n\n This snippet contains the definition of ContinuousDistributionHandmade and the check method which ensures the pdf is correct on the given set. Since the issue mentions adding missing checks, this snippet is directly relevant. \n\n\n   - [Lines 546 - 638](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L546-L638)\n\n This snippet defines the BetaPrimeDistribution class and its check method, which validates the parameters of the distribution. It is relevant as the issue involves adding missing checks to distributions. \n\n\n   - [Lines 1475 - 1740](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L1475-L1740)\n\n This snippet includes the FisherZ distribution and its check method, which is relevant to the issue as it pertains to adding missing checks for distribution parameters.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 80 - 158](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/joint_rv_types.py#L80-L158)\n\n This snippet contains the MultivariateNormalDistribution class with its check method that validates the mean vector and covariance matrix, which is relevant to the issue of adding missing checks.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 149 - 250](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv.py#L149-L250)\n\n This snippet from crv.py includes methods related to continuous distributions, such as pdf, cdf, and sampling. It is relevant as the issue mentions adding attributes to distributions, and these methods may need to be reviewed or updated.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000271,
        "snippet_processor": 0.10691000000000002,
        "issue_star_creation": 0.026869999999999998,
        "issue_star_solver": 0.07077,
        "bouncer": 0.020270000000000003
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711746988.718388,
        "relevant_snippets": [
            {
                "code": "\"\"\"\nSymPy statistics module\n\nIntroduces a random variable type into the SymPy language.\n\nRandom variables may be declared using prebuilt functions such as\nNormal, Exponential, Coin, Die, etc...  or built with functions like FiniteRV.\n\nQueries on random expressions can be made using the functions\n\n========================= =============================\n    Expression                    Meaning\n------------------------- -----------------------------\n ``P(condition)``          Probability\n ``E(expression)``         Expected value\n ``H(expression)``         Entropy\n ``variance(expression)``  Variance\n ``density(expression)``   Probability Density Function\n ``sample(expression)``    Produce a realization\n ``where(condition)``      Where the condition is true\n========================= =============================\n\nExamples\n========\n\n>>> from sympy.stats import P, E, variance, Die, Normal\n>>> from sympy import Eq, simplify\n>>> X, Y = Die('X', 6), Die('Y', 6) # Define two six sided dice\n>>> Z = Normal('Z', 0, 1) # Declare a Normal random variable with mean 0, std 1\n>>> P(X>3) # Probability X is greater than 3\n1/2\n>>> E(X+Y) # Expectation of the sum of two dice\n7\n>>> variance(X+Y) # Variance of the sum of two dice\n35/6\n>>> simplify(P(Z>1)) # Probability of Z being greater than 1\n1/2 - erf(sqrt(2)/2)/2\n\n\nOne could also create custom distribution and define custom random variables\nas follows:\n\n1. If the you want to create a Continuous Random Variable:\n\n>>> from sympy.stats import ContinuousRV, P, E\n>>> from sympy import exp, Symbol, Interval, oo\n>>> x = Symbol('x')\n>>> pdf = exp(-x) # pdf of the Continuous Distribution\n>>> Z = ContinuousRV(x, pdf, set=Interval(0, oo))\n>>> E(Z)\n1\n>>> P(Z > 5)\nexp(-5)\n\n1.1 To create an instance of Continuous Distribution:\n\n>>> from sympy.stats import ContinuousDistributionHandmade\n>>> from sympy import Lambda\n>>> dist = ContinuousDistributionHandmade(Lambda(x, pdf), set=Interval(0, oo))\n>>> dist.pdf(x)\nexp(-x)\n\n2. If you want to create a Discrete Random Variable:\n\n>>> from sympy.stats import DiscreteRV, P, E\n>>> from sympy import Symbol, S\n>>> p = S(1)/2\n>>> x = Symbol('x', integer=True, positive=True)\n>>> pdf = p*(1 - p)**(x - 1)\n>>> D = DiscreteRV(x, pdf, set=S.Naturals)\n>>> E(D)\n2\n>>> P(D > 3)\n1/8\n\n2.1 To create an instance of Discrete Distribution:\n\n>>> from sympy.stats import DiscreteDistributionHandmade\n>>> from sympy import Lambda\n>>> dist = DiscreteDistributionHandmade(Lambda(x, pdf), set=S.Naturals)\n>>> dist.pdf(x)\n2**(1 - x)/2\n\n3. If the you want to create a Finite Random Variable:\n\n>>> from sympy.stats import FiniteRV, P, E\n>>> from sympy import Rational\n>>> pmf = {1: Rational(1, 3), 2: Rational(1, 6), 3: Rational(1, 4), 4: Rational(1, 4)}\n>>> X = FiniteRV('X', pmf)\n>>> E(X)\n29/12\n>>> P(X > 3)\n1/4\n\n3.1 To create an instance of Finite Distribution:\n\n>>> from sympy.stats import FiniteDistributionHandmade\n>>> dist = FiniteDistributionHandmade(pmf)\n>>> dist.pmf(x)\nLambda(x, Piecewise((1/3, Eq(x, 1)), (1/6, Eq(x, 2)), (1/4, Eq(x, 3) | Eq(x, 4)), (0, True)))\n\"\"\"",
                "filename": "sympy/stats/__init__.py",
                "start_index": 0,
                "end_index": 3043,
                "start_line": 1,
                "end_line": 101,
                "max_line": 186,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# https://github.com/sympy/sympy/pull/12854",
                "filename": "sympy/matrices/matrices.py",
                "start_index": 21142,
                "end_index": 21185,
                "start_line": 587,
                "end_line": 587,
                "max_line": 2310,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "\"\"\"\nContinuous Random Variables - Prebuilt variables\n\nContains\n========\nArcsin\nBenini\nBeta\nBetaNoncentral\nBetaPrime\nCauchy\nChi\nChiNoncentral\nChiSquared\nDagum\nErlang\nExGaussian\nExponential\nExponentialPower\nFDistribution\nFisherZ\nFrechet\nGamma\nGammaInverse\nGumbel\nGompertz\nKumaraswamy\nLaplace\nLevy\nLogistic\nLogLogistic\nLogNormal\nMaxwell\nMoyal\nNakagami\nNormal\nPareto\nPowerFunction\nQuadraticU\nRaisedCosine\nRayleigh\nReciprocal\nShiftedGompertz\nStudentT\nTrapezoidal\nTriangular\nUniform\nUniformSum\nVonMises\nWald\nWeibull\nWignerSemicircle\n\"\"\"\n\nfrom __future__ import print_function, division\n\nimport random\n\nfrom sympy import beta as beta_fn\nfrom sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk\nfrom sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma, sign,\n                   Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,\n                   Lambda, Basic, lowergamma, erf, erfc, erfi, erfinv, I, asin,\n                   hyper, uppergamma, sinh, Ne, expint, Rational, integrate)\nfrom sympy.external import import_module\nfrom sympy.matrices import MatrixBase, MatrixExpr\nfrom sympy.stats.crv import SingleContinuousPSpace, SingleContinuousDistribution\nfrom sympy.stats.joint_rv import JointPSpace, CompoundDistribution\nfrom sympy.stats.joint_rv_types import multivariate_rv\nfrom sympy.stats.rv import _value_check, RandomSymbol\n\noo = S.Infinity\n\n__all__ = ['ContinuousRV',\n'Arcsin',\n'Benini',\n'Beta',\n'BetaNoncentral',\n'BetaPrime',\n'Cauchy',\n'Chi',\n'ChiNoncentral',\n'ChiSquared',\n'Dagum',\n'Erlang',\n'ExGaussian',\n'Exponential',\n'ExponentialPower',\n'FDistribution',\n'FisherZ',\n'Frechet',\n'Gamma',\n'GammaInverse',\n'Gompertz',\n'Gumbel',\n'Kumaraswamy',\n'Laplace',\n'Levy',\n'Logistic',\n'LogLogistic',\n'LogNormal',\n'Maxwell',\n'Moyal',\n'Nakagami',\n'Normal',\n'GaussianInverse',\n'Pareto',\n'PowerFunction',\n'QuadraticU',\n'RaisedCosine',\n'Rayleigh',\n'Reciprocal',\n'StudentT',\n'ShiftedGompertz',\n'Trapezoidal',\n'Triangular',\n'Uniform',\n'UniformSum',\n'VonMises',\n'Wald',\n'Weibull',\n'WignerSemicircle',\n]\n\n\n\ndef rv(symbol, cls, args):\n    args = list(map(sympify, args))\n    dist = cls(*args)\n    dist.check(*args)\n    pspace = SingleContinuousPSpace(symbol, dist)\n    if any(isinstance(arg, RandomSymbol) for arg in args):\n        pspace = JointPSpace(symbol, CompoundDistribution(dist))\n    return pspace.value\n\n\nclass ContinuousDistributionHandmade(SingleContinuousDistribution):\n    _argnames = ('pdf',)\n\n    def __new__(cls, pdf, set=Interval(-oo, oo)):\n        return Basic.__new__(cls, pdf, set)\n\n    @property\n    def set(self):\n        return self.args[1]\n\n    @staticmethod\n    def check(pdf, set):\n        x = Dummy('x')\n        val = integrate(pdf(x), (x, set))\n        _value_check(val == S.One, \"The pdf on the given set is incorrect.\")",
                "filename": "sympy/stats/crv_types.py",
                "start_index": 0,
                "end_index": 2765,
                "start_line": 1,
                "end_line": 151,
                "max_line": 4247,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "class BetaPrimeDistribution(SingleContinuousDistribution):\n    _argnames = ('alpha', 'beta')\n\n    @staticmethod\n    def check(alpha, beta):\n        _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n        _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n\n    set = Interval(0, oo)\n\n    def pdf(self, x):\n        alpha, beta = self.alpha, self.beta\n        return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)\n\ndef BetaPrime(name, alpha, beta):\n    r\"\"\"\n    Create a continuous random variable with a Beta prime distribution.\n\n    The density of the Beta prime distribution is given by\n\n    .. math::\n        f(x) := \\frac{x^{\\alpha-1} (1+x)^{-\\alpha -\\beta}}{B(\\alpha,\\beta)}\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    alpha : Real number, `\\alpha > 0`, a shape\n    beta : Real number, `\\beta > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import BetaPrime, density\n    >>> from sympy import Symbol, pprint\n\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = BetaPrime(\"x\", alpha, beta)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n     alpha - 1        -alpha - beta\n    z         *(z + 1)\n    -------------------------------\n             B(alpha, beta)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution\n    .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html\n\n    \"\"\"\n\n    return rv(name, BetaPrimeDistribution, (alpha, beta))\n\n#-------------------------------------------------------------------------------\n# Cauchy distribution ----------------------------------------------------------\n\n\nclass CauchyDistribution(SingleContinuousDistribution):\n    _argnames = ('x0', 'gamma')\n\n    @staticmethod\n    def check(x0, gamma):\n        _value_check(gamma > 0, \"Scale parameter Gamma must be positive.\")\n        _value_check(x0.is_real, \"Location parameter must be real.\")\n\n    def pdf(self, x):\n        return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))\n\n    def _cdf(self, x):\n        x0, gamma = self.x0, self.gamma\n        return (1/pi)*atan((x - x0)/gamma) + S.Half\n\n    def _characteristic_function(self, t):\n        return exp(self.x0 * I * t -  self.gamma * Abs(t))\n\n    def _moment_generating_function(self, t):\n        raise NotImplementedError(\"The moment generating function for the \"\n                                  \"Cauchy distribution does not exist.\")\n\n    def _quantile(self, p):\n        return self.x0 + self.gamma*tan(pi*(p - S.Half))",
                "filename": "sympy/stats/crv_types.py",
                "start_index": 13788,
                "end_index": 16436,
                "start_line": 546,
                "end_line": 638,
                "max_line": 4247,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class MultivariateNormalDistribution(JointDistribution):\n    _argnames = ('mu', 'sigma')\n\n    is_Continuous=True\n\n    @property\n    def set(self):\n        k = self.mu.shape[0]\n        return S.Reals**k\n\n    @staticmethod\n    def check(mu, sigma):\n        _value_check(mu.shape[0] == sigma.shape[0],\n            \"Size of the mean vector and covariance matrix are incorrect.\")\n        #check if covariance matrix is positive definite or not.\n        if not isinstance(sigma, MatrixSymbol):\n            _value_check(sigma.is_positive_definite,\n            \"The covariance matrix must be positive definite. \")\n\n    def pdf(self, *args):\n        mu, sigma = self.mu, self.sigma\n        k = mu.shape[0]\n        args = ImmutableMatrix(args)\n        x = args - mu\n        return  S.One/sqrt((2*pi)**(k)*det(sigma))*exp(\n            Rational(-1, 2)*x.transpose()*(sigma.inv()*\\\n                x))[0]\n\n    def marginal_distribution(self, indices, sym):\n        sym = ImmutableMatrix([Indexed(sym, i) for i in indices])\n        _mu, _sigma = self.mu, self.sigma\n        k = self.mu.shape[0]\n        for i in range(k):\n            if i not in indices:\n                _mu = _mu.row_del(i)\n                _sigma = _sigma.col_del(i)\n                _sigma = _sigma.row_del(i)\n        return Lambda(tuple(sym), S.One/sqrt((2*pi)**(len(_mu))*det(_sigma))*exp(\n            Rational(-1, 2)*(_mu - sym).transpose()*(_sigma.inv()*\\\n                (_mu - sym)))[0])\n\n#-------------------------------------------------------------------------------\n# Multivariate Laplace distribution ---------------------------------------------------------\n\nclass MultivariateLaplaceDistribution(JointDistribution):\n    _argnames = ('mu', 'sigma')\n    is_Continuous=True\n\n    @property\n    def set(self):\n        k = self.mu.shape[0]\n        return S.Reals**k\n\n    @staticmethod\n    def check(mu, sigma):\n        _value_check(mu.shape[0] == sigma.shape[0],\n                     \"Size of the mean vector and covariance matrix are incorrect.\")\n        # check if covariance matrix is positive definite or not.\n        if not isinstance(sigma, MatrixSymbol):\n            _value_check(sigma.is_positive_definite,\n                         \"The covariance matrix must be positive definite. \")\n\n    def pdf(self, *args):\n        mu, sigma = self.mu, self.sigma\n        mu_T = mu.transpose()\n        k = S(mu.shape[0])\n        sigma_inv = sigma.inv()\n        args = ImmutableMatrix(args)\n        args_T = args.transpose()\n        x = (mu_T*sigma_inv*mu)[0]\n        y = (args_T*sigma_inv*args)[0]\n        v = 1 - k/2\n        return S(2)/((2*pi)**(S(k)/2)*sqrt(det(sigma)))\\\n        *(y/(2 + x))**(S(v)/2)*besselk(v, sqrt((2 + x)*(y)))\\\n        *exp((args_T*sigma_inv*mu)[0])\n\n\n#-------------------------------------------------------------------------------\n# Multivariate StudentT distribution ---------------------------------------------------------",
                "filename": "sympy/stats/joint_rv_types.py",
                "start_index": 2569,
                "end_index": 5479,
                "start_line": 80,
                "end_line": 158,
                "max_line": 753,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\" Continuous distribution of a single variable\n\n    Serves as superclass for Normal/Exponential/UniformDistribution etc....\n\n    Represented by parameters for each of the specific classes.  E.g\n    NormalDistribution is represented by a mean and standard deviation.\n\n    Provides methods for pdf, cdf, and sampling\n\n    See Also\n    ========\n\n    sympy.stats.crv_types.*\n    \"\"\"\n\n    set = Interval(-oo, oo)\n\n    def __new__(cls, *args):\n        args = list(map(sympify, args))\n        return Basic.__new__(cls, *args)\n\n    @staticmethod\n    def check(*args):\n        pass\n\n    def sample(self, size=()):\n        \"\"\" A random realization from the distribution \"\"\"\n        icdf = self._inverse_cdf_expression()\n        if not size:\n            return icdf(random.uniform(0, 1))\n        else:\n            return [icdf(random.uniform(0, 1))]*size\n\n    @cacheit\n    def _inverse_cdf_expression(self):\n        \"\"\" Inverse of the CDF\n\n        Used by sample\n        \"\"\"\n        x, z = symbols('x, z', positive=True, cls=Dummy)\n        # Invert CDF\n        try:\n            inverse_cdf = solveset(self.cdf(x) - z, x, S.Reals)\n            if isinstance(inverse_cdf, Intersection) and S.Reals in inverse_cdf.args:\n                inverse_cdf = list(inverse_cdf.args[1])\n        except NotImplementedError:\n            inverse_cdf = None\n        if not inverse_cdf or len(inverse_cdf) != 1:\n            raise NotImplementedError(\"Could not invert CDF\")\n\n        (icdf,) = inverse_cdf\n\n        return Lambda(z, icdf)\n\n    @cacheit\n    def compute_cdf(self, **kwargs):\n        \"\"\" Compute the CDF from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, z = symbols('x, z', real=True, cls=Dummy)\n        left_bound = self.set.start\n\n        # CDF is integral of PDF from left bound to z\n        pdf = self.pdf(x)\n        cdf = integrate(pdf.doit(), (x, left_bound, z), **kwargs)\n        # CDF Ensure that CDF left of left_bound is zero\n        cdf = Piecewise((cdf, z >= left_bound), (0, True))\n        return Lambda(z, cdf)\n\n    def _cdf(self, x):\n        return None\n\n    def cdf(self, x, **kwargs):\n        \"\"\" Cumulative density function \"\"\"\n        if len(kwargs) == 0:\n            cdf = self._cdf(x)\n            if cdf is not None:\n                return cdf\n        return self.compute_cdf(**kwargs)(x)\n\n    @cacheit\n    def compute_characteristic_function(self, **kwargs):\n        \"\"\" Compute the characteristic function from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, t = symbols('x, t', real=True, cls=Dummy)\n        pdf = self.pdf(x)\n        cf = integrate(exp(I*t*x)*pdf, (x, -oo, oo))\n        return Lambda(t, cf)\n\n    def _characteristic_function(self, t):\n        return None\n\n    def characteristic_function(self, t, **kwargs):\n        \"\"\" Characteristic function \"\"\"\n        if len(kwargs) == 0:\n            cf = self._characteristic_function(t)\n            if cf is not None:\n                return cf\n        return self.compute_characteristic_function(**kwargs)(t)",
                "filename": "sympy/stats/crv.py",
                "start_index": 5432,
                "end_index": 8425,
                "start_line": 149,
                "end_line": 250,
                "max_line": 585,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "def FisherZ(name, d1, d2):\n    r\"\"\"\n    Create a Continuous Random Variable with an Fisher's Z distribution.\n\n    The density of the Fisher's Z distribution is given by\n\n    .. math::\n        f(x) := \\frac{2d_1^{d_1/2} d_2^{d_2/2}} {\\mathrm{B}(d_1/2, d_2/2)}\n                \\frac{e^{d_1z}}{\\left(d_1e^{2z}+d_2\\right)^{\\left(d_1+d_2\\right)/2}}\n\n\n    .. TODO - What is the difference between these degrees of freedom?\n\n    Parameters\n    ==========\n\n    d1 : `d_1 > 0`, degree of freedom\n    d2 : `d_2 > 0`, degree of freedom\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import FisherZ, density\n    >>> from sympy import Symbol, simplify, pprint\n\n    >>> d1 = Symbol(\"d1\", positive=True)\n    >>> d2 = Symbol(\"d2\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = FisherZ(\"x\", d1, d2)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                                d1   d2\n        d1   d2               - -- - --\n        --   --                 2    2\n        2    2  /    2*z     \\           d1*z\n    2*d1  *d2  *\\d1*e    + d2/         *e\n    -----------------------------------------\n                     /d1  d2\\\n                    B|--, --|\n                     \\2   2 /\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution\n    .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html\n\n    \"\"\"\n\n    return rv(name, FisherZDistribution, (d1, d2))\n\n#-------------------------------------------------------------------------------\n# Frechet distribution ---------------------------------------------------------\n\nclass FrechetDistribution(SingleContinuousDistribution):\n    _argnames = ('a', 's', 'm')\n\n    set = Interval(0, oo)\n\n    @staticmethod\n    def check(a, s, m):\n        _value_check(a > 0, \"Shape parameter alpha must be positive.\")\n        _value_check(s > 0, \"Scale parameter s must be positive.\")\n\n    def __new__(cls, a, s=1, m=0):\n        a, s, m = list(map(sympify, (a, s, m)))\n        return Basic.__new__(cls, a, s, m)\n\n    def pdf(self, x):\n        a, s, m = self.a, self.s, self.m\n        return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))\n\n    def _cdf(self, x):\n        a, s, m = self.a, self.s, self.m\n        return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),\n                        (S.Zero, True))",
                "filename": "sympy/stats/crv_types.py",
                "start_index": 38500,
                "end_index": 40848,
                "start_line": 1475,
                "end_line": 1740,
                "max_line": 4247,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from __future__ import print_function, division\n\nfrom sympy import (Matrix, MatrixSymbol, S, Indexed, Basic,\n                   Set, And, Eq, FiniteSet, ImmutableMatrix,\n                   Lambda, Mul, Dummy, IndexedBase, Add,\n                   linsolve, eye, Or, Not, Intersection,\n                   Union, Expr, Function, exp, cacheit,\n                   Ge, Piecewise, Symbol, NonSquareMatrixError)\nfrom sympy.core.relational import Relational\nfrom sympy.logic.boolalg import Boolean\nfrom sympy.stats.joint_rv import JointDistributionHandmade, JointDistribution\nfrom sympy.stats.rv import (RandomIndexedSymbol, random_symbols, RandomSymbol,\n                            _symbol_converter, _value_check, pspace, given,\n                           dependent)\nfrom sympy.stats.stochastic_process import StochasticPSpace\nfrom sympy.stats.symbolic_probability import Probability, Expectation\nfrom sympy.stats.frv_types import Bernoulli, BernoulliDistribution\nfrom sympy.core.sympify import _sympify\n\n__all__ = [\n    'StochasticProcess',\n    'DiscreteTimeStochasticProcess',\n    'DiscreteMarkovChain',\n    'TransitionMatrixOf',\n    'StochasticStateSpaceOf',\n    'GeneratorMatrixOf',\n    'ContinuousMarkovChain',\n    'BernoulliProcess'\n]\n\ndef _set_converter(itr):\n    \"\"\"\n    Helper function for converting list/tuple/set to Set.\n    If parameter is not an instance of list/tuple/set then\n    no operation is performed.\n\n    Returns\n    =======\n\n    Set\n        The argument converted to Set.\n\n\n    Raises\n    ======\n\n    TypeError\n        If the argument is not an instance of list/tuple/set.\n    \"\"\"\n    if isinstance(itr, (list, tuple, set)):\n        itr = FiniteSet(*itr)\n    if not isinstance(itr, Set):\n        raise TypeError(\"%s is not an instance of list/tuple/set.\"%(itr))\n    return itr\n\ndef _sym_sympify(arg):\n    \"\"\"\n    Converts an arbitrary expression to a type that can be used inside SymPy.\n    As generally strings are unwise to use in the expressions,\n    it returns the Symbol of argument if the string type argument is passed.\n\n    Parameters\n    =========\n\n    arg: The parameter to be converted to be used in Sympy.\n\n    Returns\n    =======\n\n    The converted parameter.\n\n    \"\"\"\n    if isinstance(arg, str):\n        return Symbol(arg)\n    else:\n        return _sympify(arg)\n\ndef _matrix_checks(matrix):\n    if not isinstance(matrix, (Matrix, MatrixSymbol, ImmutableMatrix)):\n        raise TypeError(\"Transition probabilities either should \"\n                            \"be a Matrix or a MatrixSymbol.\")\n    if matrix.shape[0] != matrix.shape[1]:\n        raise NonSquareMatrixError(\"%s is not a square matrix\"%(matrix))\n    if isinstance(matrix, Matrix):\n        matrix = ImmutableMatrix(matrix.tolist())\n    return matrix",
                "filename": "sympy/stats/stochastic_process_types.py",
                "start_index": 0,
                "end_index": 2741,
                "start_line": 1,
                "end_line": 86,
                "max_line": 998,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\" Discrete distribution of a single variable\n\n    Serves as superclass for PoissonDistribution etc....\n\n    Provides methods for pdf, cdf, and sampling\n\n    See Also:\n        sympy.stats.crv_types.*\n    \"\"\"\n\n    set = S.Integers\n\n    def __new__(cls, *args):\n        args = list(map(sympify, args))\n        return Basic.__new__(cls, *args)\n\n    @staticmethod\n    def check(*args):\n        pass\n\n    def sample(self, size=()):\n        \"\"\" A random realization from the distribution\"\"\"\n        if getattr(self,'_sample_scipy', None) and import_module('scipy'):\n            return self._sample_scipy(size)\n        icdf = self._inverse_cdf_expression()\n        samp_list = []\n        while True:\n            sample_ = floor(list(icdf(random.uniform(0, 1)))[0])\n            if sample_ >= self.set.inf:\n                if not size:\n                    return sample_\n                else:\n                    samp_list.append(sample_)\n            if len(samp_list) == size:\n                return samp_list\n\n    @cacheit\n    def _inverse_cdf_expression(self):\n        \"\"\" Inverse of the CDF\n\n        Used by sample\n        \"\"\"\n        x = Dummy('x', positive=True, integer=True)\n        z = Dummy('z', positive=True)\n        cdf_temp = self.cdf(x)\n        # Invert CDF\n        try:\n            inverse_cdf = solveset(cdf_temp - z, x, domain=S.Reals)\n        except NotImplementedError:\n            inverse_cdf = None\n        if not inverse_cdf or len(inverse_cdf.free_symbols) != 1:\n            raise NotImplementedError(\"Could not invert CDF\")\n        return Lambda(z, inverse_cdf)\n\n    @cacheit\n    def compute_cdf(self, **kwargs):\n        \"\"\" Compute the CDF from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, z = symbols('x, z', integer=True, cls=Dummy)\n        left_bound = self.set.inf\n\n        # CDF is integral of PDF from left bound to z\n        pdf = self.pdf(x)\n        cdf = summation(pdf, (x, left_bound, z), **kwargs)\n        # CDF Ensure that CDF left of left_bound is zero\n        cdf = Piecewise((cdf, z >= left_bound), (0, True))\n        return Lambda(z, cdf)\n\n    def _cdf(self, x):\n        return None\n\n    def cdf(self, x, **kwargs):\n        \"\"\" Cumulative density function \"\"\"\n        if not kwargs:\n            cdf = self._cdf(x)\n            if cdf is not None:\n                return cdf\n        return self.compute_cdf(**kwargs)(x)\n\n    @cacheit\n    def compute_characteristic_function(self, **kwargs):\n        \"\"\" Compute the characteristic function from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, t = symbols('x, t', real=True, cls=Dummy)\n        pdf = self.pdf(x)\n        cf = summation(exp(I*t*x)*pdf, (x, self.set.inf, self.set.sup))\n        return Lambda(t, cf)\n\n    def _characteristic_function(self, t):\n        return None",
                "filename": "sympy/stats/drv.py",
                "start_index": 1136,
                "end_index": 3913,
                "start_line": 30,
                "end_line": 166,
                "max_line": 376,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "from .crv_types import (ContinuousRV, Arcsin, Benini, Beta, BetaNoncentral,\n        BetaPrime, Cauchy, Chi, ChiNoncentral, ChiSquared, Dagum, Erlang,\n        ExGaussian, Exponential, ExponentialPower, FDistribution, FisherZ,\n        Frechet, Gamma, GammaInverse, Gompertz, Gumbel, Kumaraswamy, Laplace,\n        Levy, Logistic, LogLogistic, LogNormal, Maxwell, Moyal, Nakagami, Normal,\n        GaussianInverse, Pareto, QuadraticU, RaisedCosine, Rayleigh, Reciprocal, StudentT,\n        PowerFunction, ShiftedGompertz, Trapezoidal, Triangular, Uniform, UniformSum,\n        VonMises, Wald, Weibull, WignerSemicircle, ContinuousDistributionHandmade)\n\nfrom .drv_types import (Geometric, Hermite, Logarithmic, NegativeBinomial, Poisson,\n        Skellam, YuleSimon, Zeta, DiscreteRV, DiscreteDistributionHandmade)\n\nfrom .joint_rv_types import (JointRV, Dirichlet,\n        GeneralizedMultivariateLogGamma, GeneralizedMultivariateLogGammaOmega,\n        Multinomial, MultivariateBeta, MultivariateEwens, MultivariateT,\n        NegativeMultinomial, NormalGamma)\n\nfrom .stochastic_process_types import (StochasticProcess,\n        DiscreteTimeStochasticProcess, DiscreteMarkovChain,\n        TransitionMatrixOf, StochasticStateSpaceOf, GeneratorMatrixOf,\n        ContinuousMarkovChain, BernoulliProcess)\n\nfrom .random_matrix_models import (CircularEnsemble, CircularUnitaryEnsemble,\n        CircularOrthogonalEnsemble, CircularSymplecticEnsemble,\n        GaussianEnsemble, GaussianUnitaryEnsemble, GaussianOrthogonalEnsemble,\n        GaussianSymplecticEnsemble, joint_eigen_distribution,\n        JointEigenDistribution, level_spacing_distribution)\n\nfrom .symbolic_probability import (Probability, Expectation, Variance,\n        Covariance)",
                "filename": "sympy/stats/__init__.py",
                "start_index": 5847,
                "end_index": 7571,
                "start_line": 157,
                "end_line": 186,
                "max_line": 186,
                "git_instance": "github",
                "repo_name": "testbed/sympy__sympy__1.5",
                "sha": "",
                "context_relevance": 0.1
            }
        ],
        "classification": "other",
        "snippet_processor_task": {
            "sympy/stats/crv_types.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\nContinuous Random Variables - Prebuilt variables\n\nContains\n========\nArcsin\nBenini\nBeta\nBetaNoncentral\nBetaPrime\nCauchy\nChi\nChiNoncentral\nChiSquared\nDagum\nErlang\nExGaussian\nExponential\nExponentialPower\nFDistribution\nFisherZ\nFrechet\nGamma\nGammaInverse\nGumbel\nGompertz\nKumaraswamy\nLaplace\nLevy\nLogistic\nLogLogistic\nLogNormal\nMaxwell\nMoyal\nNakagami\nNormal\nPareto\nPowerFunction\nQuadraticU\nRaisedCosine\nRayleigh\nReciprocal\nShiftedGompertz\nStudentT\nTrapezoidal\nTriangular\nUniform\nUniformSum\nVonMises\nWald\nWeibull\nWignerSemicircle\n\"\"\"\n\nfrom __future__ import print_function, division\n\nimport random\n\nfrom sympy import beta as beta_fn\nfrom sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk\nfrom sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma, sign,\n                   Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,\n                   Lambda, Basic, lowergamma, erf, erfc, erfi, erfinv, I, asin,\n                   hyper, uppergamma, sinh, Ne, expint, Rational, integrate)\nfrom sympy.external import import_module\nfrom sympy.matrices import MatrixBase, MatrixExpr\nfrom sympy.stats.crv import SingleContinuousPSpace, SingleContinuousDistribution\nfrom sympy.stats.joint_rv import JointPSpace, CompoundDistribution\nfrom sympy.stats.joint_rv_types import multivariate_rv\nfrom sympy.stats.rv import _value_check, RandomSymbol\n\noo = S.Infinity\n\n__all__ = ['ContinuousRV',\n'Arcsin',\n'Benini',\n'Beta',\n'BetaNoncentral',\n'BetaPrime',\n'Cauchy',\n'Chi',\n'ChiNoncentral',\n'ChiSquared',\n'Dagum',\n'Erlang',\n'ExGaussian',\n'Exponential',\n'ExponentialPower',\n'FDistribution',\n'FisherZ',\n'Frechet',\n'Gamma',\n'GammaInverse',\n'Gompertz',\n'Gumbel',\n'Kumaraswamy',\n'Laplace',\n'Levy',\n'Logistic',\n'LogLogistic',\n'LogNormal',\n'Maxwell',\n'Moyal',\n'Nakagami',\n'Normal',\n'GaussianInverse',\n'Pareto',\n'PowerFunction',\n'QuadraticU',\n'RaisedCosine',\n'Rayleigh',\n'Reciprocal',\n'StudentT',\n'ShiftedGompertz',\n'Trapezoidal',\n'Triangular',\n'Uniform',\n'UniformSum',\n'VonMises',\n'Wald',\n'Weibull',\n'WignerSemicircle',\n]\n\n\n\ndef rv(symbol, cls, args):\n    args = list(map(sympify, args))\n    dist = cls(*args)\n    dist.check(*args)\n    pspace = SingleContinuousPSpace(symbol, dist)\n    if any(isinstance(arg, RandomSymbol) for arg in args):\n        pspace = JointPSpace(symbol, CompoundDistribution(dist))\n    return pspace.value\n\n\nclass ContinuousDistributionHandmade(SingleContinuousDistribution):\n    _argnames = ('pdf',)\n\n    def __new__(cls, pdf, set=Interval(-oo, oo)):\n        return Basic.__new__(cls, pdf, set)\n\n    @property\n    def set(self):\n        return self.args[1]\n\n    @staticmethod\n    def check(pdf, set):\n        x = Dummy('x')\n        val = integrate(pdf(x), (x, set))\n        _value_check(val == S.One, \"The pdf on the given set is incorrect.\")",
                        "filename": "sympy/stats/crv_types.py",
                        "start_index": 0,
                        "end_index": 2765,
                        "start_line": 1,
                        "end_line": 151,
                        "max_line": 4247,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the definition of ContinuousDistributionHandmade and the check method which ensures the pdf is correct on the given set. Since the issue mentions adding missing checks, this snippet is directly relevant."
                },
                {
                    "chunk": {
                        "code": "class BetaPrimeDistribution(SingleContinuousDistribution):\n    _argnames = ('alpha', 'beta')\n\n    @staticmethod\n    def check(alpha, beta):\n        _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n        _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n\n    set = Interval(0, oo)\n\n    def pdf(self, x):\n        alpha, beta = self.alpha, self.beta\n        return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)\n\ndef BetaPrime(name, alpha, beta):\n    r\"\"\"\n    Create a continuous random variable with a Beta prime distribution.\n\n    The density of the Beta prime distribution is given by\n\n    .. math::\n        f(x) := \\frac{x^{\\alpha-1} (1+x)^{-\\alpha -\\beta}}{B(\\alpha,\\beta)}\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    alpha : Real number, `\\alpha > 0`, a shape\n    beta : Real number, `\\beta > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import BetaPrime, density\n    >>> from sympy import Symbol, pprint\n\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = BetaPrime(\"x\", alpha, beta)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n     alpha - 1        -alpha - beta\n    z         *(z + 1)\n    -------------------------------\n             B(alpha, beta)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution\n    .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html\n\n    \"\"\"\n\n    return rv(name, BetaPrimeDistribution, (alpha, beta))\n\n#-------------------------------------------------------------------------------\n# Cauchy distribution ----------------------------------------------------------\n\n\nclass CauchyDistribution(SingleContinuousDistribution):\n    _argnames = ('x0', 'gamma')\n\n    @staticmethod\n    def check(x0, gamma):\n        _value_check(gamma > 0, \"Scale parameter Gamma must be positive.\")\n        _value_check(x0.is_real, \"Location parameter must be real.\")\n\n    def pdf(self, x):\n        return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))\n\n    def _cdf(self, x):\n        x0, gamma = self.x0, self.gamma\n        return (1/pi)*atan((x - x0)/gamma) + S.Half\n\n    def _characteristic_function(self, t):\n        return exp(self.x0 * I * t -  self.gamma * Abs(t))\n\n    def _moment_generating_function(self, t):\n        raise NotImplementedError(\"The moment generating function for the \"\n                                  \"Cauchy distribution does not exist.\")\n\n    def _quantile(self, p):\n        return self.x0 + self.gamma*tan(pi*(p - S.Half))",
                        "filename": "sympy/stats/crv_types.py",
                        "start_index": 13788,
                        "end_index": 16436,
                        "start_line": 546,
                        "end_line": 638,
                        "max_line": 4247,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the BetaPrimeDistribution class and its check method, which validates the parameters of the distribution. It is relevant as the issue involves adding missing checks to distributions."
                },
                {
                    "chunk": {
                        "code": "def FisherZ(name, d1, d2):\n    r\"\"\"\n    Create a Continuous Random Variable with an Fisher's Z distribution.\n\n    The density of the Fisher's Z distribution is given by\n\n    .. math::\n        f(x) := \\frac{2d_1^{d_1/2} d_2^{d_2/2}} {\\mathrm{B}(d_1/2, d_2/2)}\n                \\frac{e^{d_1z}}{\\left(d_1e^{2z}+d_2\\right)^{\\left(d_1+d_2\\right)/2}}\n\n\n    .. TODO - What is the difference between these degrees of freedom?\n\n    Parameters\n    ==========\n\n    d1 : `d_1 > 0`, degree of freedom\n    d2 : `d_2 > 0`, degree of freedom\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import FisherZ, density\n    >>> from sympy import Symbol, simplify, pprint\n\n    >>> d1 = Symbol(\"d1\", positive=True)\n    >>> d2 = Symbol(\"d2\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = FisherZ(\"x\", d1, d2)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                                d1   d2\n        d1   d2               - -- - --\n        --   --                 2    2\n        2    2  /    2*z     \\           d1*z\n    2*d1  *d2  *\\d1*e    + d2/         *e\n    -----------------------------------------\n                     /d1  d2\\\n                    B|--, --|\n                     \\2   2 /\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution\n    .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html\n\n    \"\"\"\n\n    return rv(name, FisherZDistribution, (d1, d2))\n\n#-------------------------------------------------------------------------------\n# Frechet distribution ---------------------------------------------------------\n\nclass FrechetDistribution(SingleContinuousDistribution):\n    _argnames = ('a', 's', 'm')\n\n    set = Interval(0, oo)\n\n    @staticmethod\n    def check(a, s, m):\n        _value_check(a > 0, \"Shape parameter alpha must be positive.\")\n        _value_check(s > 0, \"Scale parameter s must be positive.\")\n\n    def __new__(cls, a, s=1, m=0):\n        a, s, m = list(map(sympify, (a, s, m)))\n        return Basic.__new__(cls, a, s, m)\n\n    def pdf(self, x):\n        a, s, m = self.a, self.s, self.m\n        return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))\n\n    def _cdf(self, x):\n        a, s, m = self.a, self.s, self.m\n        return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),\n                        (S.Zero, True))",
                        "filename": "sympy/stats/crv_types.py",
                        "start_index": 38500,
                        "end_index": 40848,
                        "start_line": 1475,
                        "end_line": 1740,
                        "max_line": 4247,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the FisherZ distribution and its check method, which is relevant to the issue as it pertains to adding missing checks for distribution parameters."
                }
            ],
            "sympy/stats/joint_rv_types.py": [
                {
                    "chunk": {
                        "code": "class MultivariateNormalDistribution(JointDistribution):\n    _argnames = ('mu', 'sigma')\n\n    is_Continuous=True\n\n    @property\n    def set(self):\n        k = self.mu.shape[0]\n        return S.Reals**k\n\n    @staticmethod\n    def check(mu, sigma):\n        _value_check(mu.shape[0] == sigma.shape[0],\n            \"Size of the mean vector and covariance matrix are incorrect.\")\n        #check if covariance matrix is positive definite or not.\n        if not isinstance(sigma, MatrixSymbol):\n            _value_check(sigma.is_positive_definite,\n            \"The covariance matrix must be positive definite. \")\n\n    def pdf(self, *args):\n        mu, sigma = self.mu, self.sigma\n        k = mu.shape[0]\n        args = ImmutableMatrix(args)\n        x = args - mu\n        return  S.One/sqrt((2*pi)**(k)*det(sigma))*exp(\n            Rational(-1, 2)*x.transpose()*(sigma.inv()*\\\n                x))[0]\n\n    def marginal_distribution(self, indices, sym):\n        sym = ImmutableMatrix([Indexed(sym, i) for i in indices])\n        _mu, _sigma = self.mu, self.sigma\n        k = self.mu.shape[0]\n        for i in range(k):\n            if i not in indices:\n                _mu = _mu.row_del(i)\n                _sigma = _sigma.col_del(i)\n                _sigma = _sigma.row_del(i)\n        return Lambda(tuple(sym), S.One/sqrt((2*pi)**(len(_mu))*det(_sigma))*exp(\n            Rational(-1, 2)*(_mu - sym).transpose()*(_sigma.inv()*\\\n                (_mu - sym)))[0])\n\n#-------------------------------------------------------------------------------\n# Multivariate Laplace distribution ---------------------------------------------------------\n\nclass MultivariateLaplaceDistribution(JointDistribution):\n    _argnames = ('mu', 'sigma')\n    is_Continuous=True\n\n    @property\n    def set(self):\n        k = self.mu.shape[0]\n        return S.Reals**k\n\n    @staticmethod\n    def check(mu, sigma):\n        _value_check(mu.shape[0] == sigma.shape[0],\n                     \"Size of the mean vector and covariance matrix are incorrect.\")\n        # check if covariance matrix is positive definite or not.\n        if not isinstance(sigma, MatrixSymbol):\n            _value_check(sigma.is_positive_definite,\n                         \"The covariance matrix must be positive definite. \")\n\n    def pdf(self, *args):\n        mu, sigma = self.mu, self.sigma\n        mu_T = mu.transpose()\n        k = S(mu.shape[0])\n        sigma_inv = sigma.inv()\n        args = ImmutableMatrix(args)\n        args_T = args.transpose()\n        x = (mu_T*sigma_inv*mu)[0]\n        y = (args_T*sigma_inv*args)[0]\n        v = 1 - k/2\n        return S(2)/((2*pi)**(S(k)/2)*sqrt(det(sigma)))\\\n        *(y/(2 + x))**(S(v)/2)*besselk(v, sqrt((2 + x)*(y)))\\\n        *exp((args_T*sigma_inv*mu)[0])\n\n\n#-------------------------------------------------------------------------------\n# Multivariate StudentT distribution ---------------------------------------------------------",
                        "filename": "sympy/stats/joint_rv_types.py",
                        "start_index": 2569,
                        "end_index": 5479,
                        "start_line": 80,
                        "end_line": 158,
                        "max_line": 753,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the MultivariateNormalDistribution class with its check method that validates the mean vector and covariance matrix, which is relevant to the issue of adding missing checks."
                }
            ],
            "sympy/stats/crv.py": [
                {
                    "chunk": {
                        "code": "\"\"\" Continuous distribution of a single variable\n\n    Serves as superclass for Normal/Exponential/UniformDistribution etc....\n\n    Represented by parameters for each of the specific classes.  E.g\n    NormalDistribution is represented by a mean and standard deviation.\n\n    Provides methods for pdf, cdf, and sampling\n\n    See Also\n    ========\n\n    sympy.stats.crv_types.*\n    \"\"\"\n\n    set = Interval(-oo, oo)\n\n    def __new__(cls, *args):\n        args = list(map(sympify, args))\n        return Basic.__new__(cls, *args)\n\n    @staticmethod\n    def check(*args):\n        pass\n\n    def sample(self, size=()):\n        \"\"\" A random realization from the distribution \"\"\"\n        icdf = self._inverse_cdf_expression()\n        if not size:\n            return icdf(random.uniform(0, 1))\n        else:\n            return [icdf(random.uniform(0, 1))]*size\n\n    @cacheit\n    def _inverse_cdf_expression(self):\n        \"\"\" Inverse of the CDF\n\n        Used by sample\n        \"\"\"\n        x, z = symbols('x, z', positive=True, cls=Dummy)\n        # Invert CDF\n        try:\n            inverse_cdf = solveset(self.cdf(x) - z, x, S.Reals)\n            if isinstance(inverse_cdf, Intersection) and S.Reals in inverse_cdf.args:\n                inverse_cdf = list(inverse_cdf.args[1])\n        except NotImplementedError:\n            inverse_cdf = None\n        if not inverse_cdf or len(inverse_cdf) != 1:\n            raise NotImplementedError(\"Could not invert CDF\")\n\n        (icdf,) = inverse_cdf\n\n        return Lambda(z, icdf)\n\n    @cacheit\n    def compute_cdf(self, **kwargs):\n        \"\"\" Compute the CDF from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, z = symbols('x, z', real=True, cls=Dummy)\n        left_bound = self.set.start\n\n        # CDF is integral of PDF from left bound to z\n        pdf = self.pdf(x)\n        cdf = integrate(pdf.doit(), (x, left_bound, z), **kwargs)\n        # CDF Ensure that CDF left of left_bound is zero\n        cdf = Piecewise((cdf, z >= left_bound), (0, True))\n        return Lambda(z, cdf)\n\n    def _cdf(self, x):\n        return None\n\n    def cdf(self, x, **kwargs):\n        \"\"\" Cumulative density function \"\"\"\n        if len(kwargs) == 0:\n            cdf = self._cdf(x)\n            if cdf is not None:\n                return cdf\n        return self.compute_cdf(**kwargs)(x)\n\n    @cacheit\n    def compute_characteristic_function(self, **kwargs):\n        \"\"\" Compute the characteristic function from the PDF\n\n        Returns a Lambda\n        \"\"\"\n        x, t = symbols('x, t', real=True, cls=Dummy)\n        pdf = self.pdf(x)\n        cf = integrate(exp(I*t*x)*pdf, (x, -oo, oo))\n        return Lambda(t, cf)\n\n    def _characteristic_function(self, t):\n        return None\n\n    def characteristic_function(self, t, **kwargs):\n        \"\"\" Characteristic function \"\"\"\n        if len(kwargs) == 0:\n            cf = self._characteristic_function(t)\n            if cf is not None:\n                return cf\n        return self.compute_characteristic_function(**kwargs)(t)",
                        "filename": "sympy/stats/crv.py",
                        "start_index": 5432,
                        "end_index": 8425,
                        "start_line": 149,
                        "end_line": 250,
                        "max_line": 585,
                        "git_instance": "github",
                        "repo_name": "testbed/sympy__sympy__1.5",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet from crv.py includes methods related to continuous distributions, such as pdf, cdf, and sampling. It is relevant as the issue mentions adding attributes to distributions, and these methods may need to be reviewed or updated."
                }
            ]
        },
        "solution_task": "- Add parameter checks in the `__init__` methods of distribution classes in `sympy/stats/crv_types.py` and `sympy/stats/drv.py` using the `_value_check` function.\n- Ensure that the `check` static method of each distribution class is called within the `__init__` method to validate parameters.\n- For distributions that do not have a `check` method, implement one based on the constraints of the distribution's parameters.\n- For distributions that have attributes set outside of the `__init__` method, ensure that these attributes are set within the `__init__` method and that they are consistent with the distribution's properties.\n\nFor example, for the `BetaPrimeDistribution` class in `sympy/stats/crv_types.py`:\n```python\nclass BetaPrimeDistribution(SingleContinuousDistribution):\n    _argnames = ('alpha', 'beta')\n\n    @staticmethod\n    def check(alpha, beta):\n        _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n        _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n\n    def __init__(self, alpha, beta):\n        super(BetaPrimeDistribution, self).__init__(alpha, beta)\n        self.alpha, self.beta = alpha, beta\n        BetaPrimeDistribution.check(alpha, beta)\n\n    set = Interval(0, oo)\n```\n\nRepeat this process for other distributions, ensuring that the `check` method is called and that attributes are set correctly within the `__init__` method.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable plan for adding missing checks and attributes to the sympy.stats distributions, which is the core issue described in the PROMPT. It suggests adding parameter checks in the `__init__` methods using the `_value_check` function, ensuring that the `check` method is called within the `__init__` method, and setting attributes within the `__init__` method. The RESPONSE also includes an example implementation for the `BetaPrimeDistribution` class, which demonstrates how to apply these changes in practice. Additionally, the RESPONSE provides links to relevant code snippets that need to be reviewed or updated, which is extremely helpful for locating the parts of the codebase that require attention. The only reason it does not score a 10 is that it does not explicitly mention updating the release notes to reflect the changes made, which is a minor part of the PROMPT's instructions.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711747195.879842,
        "result": "- Add parameter checks in the `__init__` methods of distribution classes in `sympy/stats/crv_types.py` and `sympy/stats/drv.py` using the `_value_check` function.\n- Ensure that the `check` static method of each distribution class is called within the `__init__` method to validate parameters.\n- For distributions that do not have a `check` method, implement one based on the constraints of the distribution's parameters.\n- For distributions that have attributes set outside of the `__init__` method, ensure that these attributes are set within the `__init__` method and that they are consistent with the distribution's properties.\n\nFor example, for the `BetaPrimeDistribution` class in `sympy/stats/crv_types.py`:\n```python\nclass BetaPrimeDistribution(SingleContinuousDistribution):\n    _argnames = ('alpha', 'beta')\n\n    @staticmethod\n    def check(alpha, beta):\n        _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n        _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n\n    def __init__(self, alpha, beta):\n        super(BetaPrimeDistribution, self).__init__(alpha, beta)\n        self.alpha, self.beta = alpha, beta\n        BetaPrimeDistribution.check(alpha, beta)\n\n    set = Interval(0, oo)\n```\n\nRepeat this process for other distributions, ensuring that the `check` method is called and that attributes are set correctly within the `__init__` method.\n\n### Code snippets to check\n\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 1 - 151](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L1-L151)\n\n This snippet contains the definition of ContinuousDistributionHandmade and the check method which ensures the pdf is correct on the given set. Since the issue mentions adding missing checks, this snippet is directly relevant. \n\n\n   - [Lines 546 - 638](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L546-L638)\n\n This snippet defines the BetaPrimeDistribution class and its check method, which validates the parameters of the distribution. It is relevant as the issue involves adding missing checks to distributions. \n\n\n   - [Lines 1475 - 1740](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv_types.py#L1475-L1740)\n\n This snippet includes the FisherZ distribution and its check method, which is relevant to the issue as it pertains to adding missing checks for distribution parameters.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 80 - 158](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/joint_rv_types.py#L80-L158)\n\n This snippet contains the MultivariateNormalDistribution class with its check method that validates the mean vector and covariance matrix, which is relevant to the issue of adding missing checks.\n-  \u2192 [sympy](https://github.com/testbed/sympy__sympy__1.5/tree//sympy) \u2192 [stats](https://github.com/testbed/sympy__sympy__1.5/tree//sympy/stats)- [Lines 149 - 250](https://github.com/testbed/sympy__sympy__1.5/blob//sympy/stats/crv.py#L149-L250)\n\n This snippet from crv.py includes methods related to continuous distributions, such as pdf, cdf, and sampling. It is relevant as the issue mentions adding attributes to distributions, and these methods may need to be reviewed or updated.",
        "context_relevance": 0.3,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation of how to add missing checks and attributes to sympy.stats, which is exactly what the PROMPT is about. It outlines the steps to be taken, such as adding parameter checks in the `__init__` methods, ensuring the `check` method is called, and setting attributes within the `__init__` method. It also provides a specific example with the `BetaPrimeDistribution` class, which demonstrates understanding and relevance to the task described in the PROMPT. The RESPONSE is comprehensive and directly addresses the entire PROMPT, thus earning a score of 10."
        },
        "qa_relevance": 1.0
    }
}