{
    "id": "scikit-learn__scikit-learn-14125",
    "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
    "task_id": 5196268176084849851,
    "title": "[MRG] Fix 'SparseSeries deprecated: scipy-dev failing on travis' #14002",
    "body": "<!--\r\nThanks for contributing a pull request! Please ensure you have taken a look at\r\nthe contribution guidelines: https://github.com/scikit-learn/scikit-learn/blob/master/CONTRIBUTING.md#pull-request-checklist\r\n-->\r\n\r\n#### Reference Issues/PRs\r\nFixes #14002\r\nIssue: SparseSeries deprecated: scipy-dev failing on travis\r\n<!--\r\nExample: Fixes #1234. See also #3456.\r\nPlease use keywords (e.g., Fixes) to create link to the issues or pull requests\r\nyou resolved, so that they will automatically be closed when your pull request\r\nis merged. See https://github.com/blog/1506-closing-issues-via-pull-requests\r\n-->\r\n\r\n\r\n#### What does this implement/fix? Explain your changes.\r\nUse a Series with sparse values instead instead of `SparseSeries`.\r\n\r\n#### Any other comments?\r\n\r\n\r\n<!--\r\nPlease be aware that we are a loose team of volunteers so patience is\r\nnecessary; assistance handling other issues is very welcome. We value\r\nall user contributions, no matter how minor they are. If we are slow to\r\nreview, either the pull request needs some benchmarking, tinkering,\r\nconvincing, etc. or more likely the reviewers are simply busy. In either\r\ncase, we ask for your understanding during the review process.\r\nFor more information, see our FAQ on this topic:\r\nhttp://scikit-learn.org/dev/faq.html#why-is-my-pull-request-not-getting-any-attention.\r\n\r\nThanks for contributing!\r\n-->\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/scikit-learn__scikit-learn__0.22.git",
    "requested_commit": "",
    "mayil_response": "- Search the codebase for occurrences of `SparseSeries` and replace them with `Series` with sparse values.\n- Update the test cases that use `SparseSeries` to use `Series` with sparse values.\n- Check the Travis CI configuration and logs related to `scipy-dev` to ensure that the issue is resolved after making the changes.\n- Ensure that the changes fix the issue mentioned in #14002.\n- If `SparseSeries` is found in any deprecated function or method, remove or update the deprecated code accordingly.\n- After making changes, run the test suite to ensure that all tests pass, especially those that previously failed on Travis CI due to the `SparseSeries` deprecation.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/utils)- [Lines 1025 - 1093](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/estimator_checks.py#L1025-L1093)\n\n This snippet is relevant because it includes code that handles sparse data and may need to be updated to avoid using deprecated SparseSeries.\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/utils)- [Lines 534 - 581](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/validation.py#L534-L581)\n\n This snippet is relevant as it contains logic for handling sparse matrices and may need to be reviewed to ensure compatibility with the new Series with sparse values. \n\n\n   - [Lines 882 - 2278](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/validation.py#L882-L2278)\n\n This snippet is relevant because it includes a function that ensures the sparse format of an array, which might be related to the deprecation of SparseSeries. \n\n\n   - [Lines 460 - 2272](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/validation.py#L460-L2272)\n\n This snippet is relevant as it defines the function '_ensure_sparse_format' which is directly involved in handling sparse data formats and may need to be updated in light of the SparseSeries deprecation.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0009725,
        "snippet_processor": 0.08512000000000002,
        "issue_star_creation": 0.049199999999999994,
        "issue_star_solver": 0.054560000000000004,
        "bouncer": 0.02766
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711739001.1267252,
        "relevant_snippets": [
            {
                "code": "def check_array_api_input_and_values(\n    name,\n    estimator_orig,\n    array_namespace,\n    device=None,\n    dtype=\"float64\",\n):\n    return check_array_api_input(\n        name,\n        estimator_orig,\n        array_namespace=array_namespace,\n        device=device,\n        dtype=dtype,\n        check_values=True,\n    )\n\n\ndef check_estimator_sparse_data(name, estimator_orig):\n    rng = np.random.RandomState(0)\n    X = rng.uniform(size=(40, 3))\n    X[X < 0.8] = 0\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    X_csr = sparse.csr_matrix(X)\n    y = (4 * rng.uniform(size=40)).astype(int)\n    # catch deprecation warnings\n    with ignore_warnings(category=FutureWarning):\n        estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n    tags = _safe_tags(estimator_orig)\n    for matrix_format, X in _generate_sparse_matrix(X_csr):\n        # catch deprecation warnings\n        with ignore_warnings(category=FutureWarning):\n            estimator = clone(estimator_orig)\n            if name in [\"Scaler\", \"StandardScaler\"]:\n                estimator.set_params(with_mean=False)\n        # fit and predict\n        if \"64\" in matrix_format:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to support {matrix_format} \"\n                \"matrix, and is not failing gracefully, e.g. by using \"\n                \"check_array(X, accept_large_sparse=False)\"\n            )\n        else:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to fail gracefully on sparse \"\n                \"data: error message should state explicitly that sparse \"\n                \"input is not supported if this is not the case.\"\n            )\n        with raises(\n            (TypeError, ValueError),\n            match=[\"sparse\", \"Sparse\"],\n            may_pass=True,\n            err_msg=err_msg,\n        ):\n            with ignore_warnings(category=FutureWarning):\n                estimator.fit(X, y)\n            if hasattr(estimator, \"predict\"):\n                pred = estimator.predict(X)\n                if tags[\"multioutput_only\"]:\n                    assert pred.shape == (X.shape[0], 1)\n                else:\n                    assert pred.shape == (X.shape[0],)\n            if hasattr(estimator, \"predict_proba\"):\n                probs = estimator.predict_proba(X)\n                if tags[\"binary_only\"]:\n                    expected_probs_shape = (X.shape[0], 2)\n                else:\n                    expected_probs_shape = (X.shape[0], 4)\n                assert probs.shape == expected_probs_shape",
                "filename": "sklearn/utils/estimator_checks.py",
                "start_index": 36016,
                "end_index": 38577,
                "start_line": 1025,
                "end_line": 1093,
                "max_line": 4639,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Compatibility fixes for older version of python, numpy and scipy\n\nIf you add content to this file, please give the version of the package\nat which the fix is no longer needed.\n\"\"\"\n# Authors: Emmanuelle Gouillart <emmanuelle.gouillart@normalesup.org>\n#          Gael Varoquaux <gael.varoquaux@normalesup.org>\n#          Fabian Pedregosa <fpedregosa@acm.org>\n#          Lars Buitinck\n#\n# License: BSD 3 clause\n\nimport sys\nfrom importlib import resources\n\nimport numpy as np\nimport scipy\nimport scipy.stats\nimport threadpoolctl\n\nimport sklearn\n\nfrom ..externals._packaging.version import parse as parse_version\nfrom .deprecation import deprecated\n\nnp_version = parse_version(np.__version__)\nsp_version = parse_version(scipy.__version__)\nsp_base_version = parse_version(sp_version.base_version)\n\n\ntry:\n    from scipy.optimize._linesearch import line_search_wolfe1, line_search_wolfe2\nexcept ImportError:  # SciPy < 1.8\n    from scipy.optimize.linesearch import line_search_wolfe2, line_search_wolfe1  # type: ignore  # noqa\n\n\ndef _object_dtype_isnan(X):\n    return X != X\n\n\n# Rename the `method` kwarg to `interpolation` for NumPy < 1.22, because\n# `interpolation` kwarg was deprecated in favor of `method` in NumPy >= 1.22.\ndef _percentile(a, q, *, method=\"linear\", **kwargs):\n    return np.percentile(a, q, interpolation=method, **kwargs)\n\n\nif np_version < parse_version(\"1.22\"):\n    percentile = _percentile\nelse:  # >= 1.22\n    from numpy import percentile  # type: ignore  # noqa\n\n\n# compatibility fix for threadpoolctl >= 3.0.0\n# since version 3 it's possible to setup a global threadpool controller to avoid\n# looping through all loaded shared libraries each time.\n# the global controller is created during the first call to threadpoolctl.\ndef _get_threadpool_controller():\n    if not hasattr(threadpoolctl, \"ThreadpoolController\"):\n        return None\n\n    if not hasattr(sklearn, \"_sklearn_threadpool_controller\"):\n        sklearn._sklearn_threadpool_controller = threadpoolctl.ThreadpoolController()\n\n    return sklearn._sklearn_threadpool_controller\n\n\ndef threadpool_limits(limits=None, user_api=None):\n    controller = _get_threadpool_controller()\n    if controller is not None:\n        return controller.limit(limits=limits, user_api=user_api)\n    else:\n        return threadpoolctl.threadpool_limits(limits=limits, user_api=user_api)\n\n\nthreadpool_limits.__doc__ = threadpoolctl.threadpool_limits.__doc__\n\n\ndef threadpool_info():\n    controller = _get_threadpool_controller()\n    if controller is not None:\n        return controller.info()\n    else:\n        return threadpoolctl.threadpool_info()\n\n\nthreadpool_info.__doc__ = threadpoolctl.threadpool_info.__doc__\n\n\n@deprecated(\n    \"The function `delayed` has been moved from `sklearn.utils.fixes` to \"\n    \"`sklearn.utils.parallel`. This import path will be removed in 1.5.\"\n)\ndef delayed(function):\n    from sklearn.utils.parallel import delayed\n\n    return delayed(function)",
                "filename": "sklearn/utils/fixes.py",
                "start_index": 0,
                "end_index": 2939,
                "start_line": 1,
                "end_line": 96,
                "max_line": 160,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if accept_sparse is False:\n        raise TypeError(\n            \"A sparse matrix was passed, but dense \"\n            \"data is required. Use X.toarray() to \"\n            \"convert to a dense numpy array.\"\n        )\n    elif isinstance(accept_sparse, (list, tuple)):\n        if len(accept_sparse) == 0:\n            raise ValueError(\n                \"When providing 'accept_sparse' \"\n                \"as a tuple or list, it must contain at \"\n                \"least one string value.\"\n            )\n        # ensure correct sparse format\n        if spmatrix.format not in accept_sparse:\n            # create new with correct sparse\n            spmatrix = spmatrix.asformat(accept_sparse[0])\n            changed_format = True\n    elif accept_sparse is not True:\n        # any other type\n        raise ValueError(\n            \"Parameter 'accept_sparse' should be a string, \"\n            \"boolean or list of strings. You provided \"\n            \"'accept_sparse={}'.\".format(accept_sparse)\n        )\n\n    if dtype != spmatrix.dtype:\n        # convert dtype\n        spmatrix = spmatrix.astype(dtype)\n    elif copy and not changed_format:\n        # force copy\n        spmatrix = spmatrix.copy()\n\n    if force_all_finite:\n        if not hasattr(spmatrix, \"data\"):\n            warnings.warn(\n                \"Can't check %s sparse matrix for nan or inf.\" % spmatrix.format,\n                stacklevel=2,\n            )\n        else:\n            _assert_all_finite(\n                spmatrix.data,\n                allow_nan=force_all_finite == \"allow-nan\",\n                estimator_name=estimator_name,\n                input_name=input_name,\n            )\n\n    return spmatrix",
                "filename": "sklearn/utils/validation.py",
                "start_index": 17856,
                "end_index": 19516,
                "start_line": 534,
                "end_line": 581,
                "max_line": 2282,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# combinations of dense and sparse inputs on float32 and float64 datasets, except\n# the sparse-dense and dense-sparse combinations for the Euclidean and Squared\n# Euclidean Distance metrics.\n# A detailed list of the impacted estimators can be found in the\n# :ref:`changelog <changes_1_2>`.",
                "filename": "examples/release_highlights/plot_release_highlights_1_2_0.py",
                "start_index": 5985,
                "end_index": 6274,
                "start_line": 162,
                "end_line": 166,
                "max_line": 166,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# Authors: Manoj Kumar <manojkumarsivaraj334@gmail.com>\n#          Alexandre Gramfort <alexandre.gramfort@telecom-paristech.fr>\n#          Joel Nothman <joel.nothman@gmail.com>\n# License: BSD 3 clause\n\nimport warnings\nfrom math import sqrt\nfrom numbers import Integral, Real\n\nimport numpy as np\nfrom scipy import sparse\n\nfrom .._config import config_context\nfrom ..base import (\n    BaseEstimator,\n    ClassNamePrefixFeaturesOutMixin,\n    ClusterMixin,\n    TransformerMixin,\n    _fit_context,\n)\nfrom ..exceptions import ConvergenceWarning\nfrom ..metrics import pairwise_distances_argmin\nfrom ..metrics.pairwise import euclidean_distances\nfrom ..utils._param_validation import Interval\nfrom ..utils.extmath import row_norms\nfrom ..utils.validation import check_is_fitted\nfrom . import AgglomerativeClustering\n\n\ndef _iterate_sparse_X(X):\n    \"\"\"This little hack returns a densified row when iterating over a sparse\n    matrix, instead of constructing a sparse matrix for every row that is\n    expensive.\n    \"\"\"\n    n_samples = X.shape[0]\n    X_indices = X.indices\n    X_data = X.data\n    X_indptr = X.indptr\n\n    for i in range(n_samples):\n        row = np.zeros(X.shape[1])\n        startptr, endptr = X_indptr[i], X_indptr[i + 1]\n        nonzero_indices = X_indices[startptr:endptr]\n        row[nonzero_indices] = X_data[startptr:endptr]\n        yield row",
                "filename": "sklearn/cluster/_birch.py",
                "start_index": 0,
                "end_index": 1355,
                "start_line": 1,
                "end_line": 45,
                "max_line": 741,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# flake8: noqa\n\"\"\"\n=======================================\nRelease Highlights for scikit-learn 1.0\n=======================================\n\n.. currentmodule:: sklearn\n\nWe are very pleased to announce the release of scikit-learn 1.0! The library\nhas been stable for quite some time, releasing version 1.0 is recognizing that\nand signalling it to our users. This release does not include any breaking\nchanges apart from the usual two-release deprecation cycle. For the future, we\ndo our best to keep this pattern.\n\nThis release includes some new key features as well as many improvements and\nbug fixes. We detail below a few of the major features of this release. **For\nan exhaustive list of all the changes**, please refer to the :ref:`release\nnotes <changes_1_0>`.\n\nTo install the latest version (with pip)::\n\n    pip install --upgrade scikit-learn\n\nor with conda::\n\n    conda install -c conda-forge scikit-learn\n\n\"\"\"\n\n##############################################################################\n# Keyword and positional arguments\n# ---------------------------------------------------------\n# The scikit-learn API exposes many functions and methods which have many input\n# parameters. For example, before this release, one could instantiate a\n# :class:`~ensemble.HistGradientBoostingRegressor` as::\n#\n#         HistGradientBoostingRegressor(\"squared_error\", 0.1, 100, 31, None,\n#             20, 0.0, 255, None, None, False, \"auto\", \"loss\", 0.1, 10, 1e-7,\n#             0, None)\n#\n# Understanding the above code requires the reader to go to the API\n# documentation and to check each and every parameter for its position and\n# its meaning. To improve the readability of code written based on scikit-learn,\n# now users have to provide most parameters with their names, as keyword\n# arguments, instead of positional arguments. For example, the above code would\n# be::\n#\n#     HistGradientBoostingRegressor(\n#         loss=\"squared_error\",\n#         learning_rate=0.1,\n#         max_iter=100,\n#         max_leaf_nodes=31,\n#         max_depth=None,\n#         min_samples_leaf=20,\n#         l2_regularization=0.0,\n#         max_bins=255,\n#         categorical_features=None,\n#         monotonic_cst=None,\n#         warm_start=False,\n#         early_stopping=\"auto\",\n#         scoring=\"loss\",\n#         validation_fraction=0.1,\n#         n_iter_no_change=10,\n#         tol=1e-7,\n#         verbose=0,\n#         random_state=None,\n#     )\n#\n# which is much more readable. Positional arguments have been deprecated since\n# version 0.23 and will now raise a ``TypeError``. A limited number of\n# positional arguments are still allowed in some cases, for example in\n# :class:`~decomposition.PCA`, where ``PCA(10)`` is still allowed, but ``PCA(10,\n# False)`` is not allowed.\n\n##############################################################################\n# Spline Transformers\n# ---------------------------------------------------------\n# One way to add nonlinear terms to a dataset's feature set is to generate",
                "filename": "examples/release_highlights/plot_release_highlights_1_0_0.py",
                "start_index": 0,
                "end_index": 2999,
                "start_line": 1,
                "end_line": 78,
                "max_line": 241,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from sklearn.pipeline import make_pipeline\n\nX, y = make_classification(random_state=0)\n\nwith TemporaryDirectory(prefix=\"sklearn_cache_\") as tmpdir:\n    estimator = make_pipeline(\n        KNeighborsTransformer(n_neighbors=10, mode=\"distance\"),\n        Isomap(n_neighbors=10, metric=\"precomputed\"),\n        memory=tmpdir,\n    )\n    estimator.fit(X)\n\n    # We can decrease the number of neighbors and the graph will not be\n    # recomputed.\n    estimator.set_params(isomap__n_neighbors=5)\n    estimator.fit(X)\n\n# %%\n# KNN Based Imputation\n# ------------------------------------\n# We now support imputation for completing missing values using k-Nearest\n# Neighbors.\n#\n# Each sample's missing values are imputed using the mean value from\n# ``n_neighbors`` nearest neighbors found in the training set. Two samples are\n# close if the features that neither is missing are close.\n# By default, a euclidean distance metric\n# that supports missing values,\n# :func:`~sklearn.metrics.pairwise.nan_euclidean_distances`, is used to find the nearest\n# neighbors.\n#\n# Read more in the :ref:`User Guide <knnimpute>`.\n\nfrom sklearn.impute import KNNImputer\n\nX = [[1, 2, np.nan], [3, 4, 3], [np.nan, 6, 5], [8, 8, 7]]\nimputer = KNNImputer(n_neighbors=2)\nprint(imputer.fit_transform(X))\n\n# %%\n# Tree pruning\n# ------------\n#\n# It is now possible to prune most tree-based estimators once the trees are\n# built. The pruning is based on minimal cost-complexity. Read more in the\n# :ref:`User Guide <minimal_cost_complexity_pruning>` for details.\n\nX, y = make_classification(random_state=0)\n\nrf = RandomForestClassifier(random_state=0, ccp_alpha=0).fit(X, y)\nprint(\n    \"Average number of nodes without pruning {:.1f}\".format(\n        np.mean([e.tree_.node_count for e in rf.estimators_])\n    )\n)\n\nrf = RandomForestClassifier(random_state=0, ccp_alpha=0.05).fit(X, y)\nprint(\n    \"Average number of nodes with pruning {:.1f}\".format(\n        np.mean([e.tree_.node_count for e in rf.estimators_])\n    )\n)\n\n# %%\n# Retrieve dataframes from OpenML\n# -------------------------------\n# :func:`datasets.fetch_openml` can now return pandas dataframe and thus\n# properly handle datasets with heterogeneous data:\n\nfrom sklearn.datasets import fetch_openml\n\ntitanic = fetch_openml(\"titanic\", version=1, as_frame=True, parser=\"pandas\")\nprint(titanic.data.head()[[\"pclass\", \"embarked\"]])\n\n# %%\n# Checking scikit-learn compatibility of an estimator\n# ---------------------------------------------------\n# Developers can check the compatibility of their scikit-learn compatible\n# estimators using :func:`~utils.estimator_checks.check_estimator`. For\n# instance, the ``check_estimator(LinearSVC())`` passes.\n#\n# We now provide a ``pytest`` specific decorator which allows ``pytest``\n# to run all checks independently and report the checks that are failing.\n#\n# ..note::\n#   This entry was slightly updated in version 0.24, where passing classes\n#   isn't supported anymore: pass instances instead.",
                "filename": "examples/release_highlights/plot_release_highlights_0_22_0.py",
                "start_index": 5945,
                "end_index": 8900,
                "start_line": 85,
                "end_line": 248,
                "max_line": 282,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "if sp.issparse(array):\n        _ensure_no_complex_data(array)\n        array = _ensure_sparse_format(\n            array,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            force_all_finite=force_all_finite,\n            accept_large_sparse=accept_large_sparse,\n            estimator_name=estimator_name,\n            input_name=input_name,\n        )",
                "filename": "sklearn/utils/validation.py",
                "start_index": 30833,
                "end_index": 31229,
                "start_line": 882,
                "end_line": 2278,
                "max_line": 2282,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.9
            },
            {
                "code": "# flake8: noqa\n\"\"\"\n=======================================\nRelease Highlights for scikit-learn 1.3\n=======================================\n\n.. currentmodule:: sklearn\n\nWe are pleased to announce the release of scikit-learn 1.3! Many bug fixes\nand improvements were added, as well as some new key features. We detail\nbelow a few of the major features of this release. **For an exhaustive list of\nall the changes**, please refer to the :ref:`release notes <changes_1_3>`.\n\nTo install the latest version (with pip)::\n\n    pip install --upgrade scikit-learn\n\nor with conda::\n\n    conda install -c conda-forge scikit-learn\n\n\"\"\"\n\n# %%\n# Metadata Routing\n# ----------------\n# We are in the process of introducing a new way to route metadata such as\n# ``sample_weight`` throughout the codebase, which would affect how\n# meta-estimators such as :class:`pipeline.Pipeline` and\n# :class:`model_selection.GridSearchCV` route metadata. While the\n# infrastructure for this feature is already included in this release, the work\n# is ongoing and not all meta-estimators support this new feature. You can read\n# more about this feature in the :ref:`Metadata Routing User Guide\n# <metadata_routing>`. Note that this feature is still under development and\n# not implemented for most meta-estimators.\n#\n# Third party developers can already start incorporating this into their\n# meta-estimators. For more details, see\n# :ref:`metadata routing developer guide\n# <sphx_glr_auto_examples_miscellaneous_plot_metadata_routing.py>`.\n\n# %%\n# HDBSCAN: hierarchical density-based clustering\n# ----------------------------------------------\n# Originally hosted in the scikit-learn-contrib repository, :class:`cluster.HDBSCAN`\n# has been adpoted into scikit-learn. It's missing a few features from the original\n# implementation which will be added in future releases.\n# By performing a modified version of :class:`cluster.DBSCAN` over multiple epsilon\n# values simultaneously, :class:`cluster.HDBSCAN` finds clusters of varying densities\n# making it more robust to parameter selection than :class:`cluster.DBSCAN`.\n# More details in the :ref:`User Guide <hdbscan>`.\nimport numpy as np\nfrom sklearn.cluster import HDBSCAN\nfrom sklearn.datasets import load_digits\nfrom sklearn.metrics import v_measure_score\n\nX, true_labels = load_digits(return_X_y=True)\nprint(f\"number of digits: {len(np.unique(true_labels))}\")\n\nhdbscan = HDBSCAN(min_cluster_size=15).fit(X)\nnon_noisy_labels = hdbscan.labels_[hdbscan.labels_ != -1]\nprint(f\"number of clusters found: {len(np.unique(non_noisy_labels))}\")\n\nprint(v_measure_score(true_labels[hdbscan.labels_ != -1], non_noisy_labels))\n\n# %%\n# TargetEncoder: a new category encoding strategy\n# -----------------------------------------------\n# Well suited for categorical features with high cardinality,\n# :class:`preprocessing.TargetEncoder` encodes the categories based on a shrunk\n# estimate of the average target values for observations belonging to that category.",
                "filename": "examples/release_highlights/plot_release_highlights_1_3_0.py",
                "start_index": 0,
                "end_index": 2965,
                "start_line": 1,
                "end_line": 71,
                "max_line": 156,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _ensure_sparse_format(\n    spmatrix,\n    accept_sparse,\n    dtype,\n    copy,\n    force_all_finite,\n    accept_large_sparse,\n    estimator_name=None,\n    input_name=\"\",\n):",
                "filename": "sklearn/utils/validation.py",
                "start_index": 15534,
                "end_index": 15708,
                "start_line": 460,
                "end_line": 2272,
                "max_line": 2282,
                "git_instance": "github",
                "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "sklearn/utils/estimator_checks.py": [
                {
                    "chunk": {
                        "code": "def check_array_api_input_and_values(\n    name,\n    estimator_orig,\n    array_namespace,\n    device=None,\n    dtype=\"float64\",\n):\n    return check_array_api_input(\n        name,\n        estimator_orig,\n        array_namespace=array_namespace,\n        device=device,\n        dtype=dtype,\n        check_values=True,\n    )\n\n\ndef check_estimator_sparse_data(name, estimator_orig):\n    rng = np.random.RandomState(0)\n    X = rng.uniform(size=(40, 3))\n    X[X < 0.8] = 0\n    X = _enforce_estimator_tags_X(estimator_orig, X)\n    X_csr = sparse.csr_matrix(X)\n    y = (4 * rng.uniform(size=40)).astype(int)\n    # catch deprecation warnings\n    with ignore_warnings(category=FutureWarning):\n        estimator = clone(estimator_orig)\n    y = _enforce_estimator_tags_y(estimator, y)\n    tags = _safe_tags(estimator_orig)\n    for matrix_format, X in _generate_sparse_matrix(X_csr):\n        # catch deprecation warnings\n        with ignore_warnings(category=FutureWarning):\n            estimator = clone(estimator_orig)\n            if name in [\"Scaler\", \"StandardScaler\"]:\n                estimator.set_params(with_mean=False)\n        # fit and predict\n        if \"64\" in matrix_format:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to support {matrix_format} \"\n                \"matrix, and is not failing gracefully, e.g. by using \"\n                \"check_array(X, accept_large_sparse=False)\"\n            )\n        else:\n            err_msg = (\n                f\"Estimator {name} doesn't seem to fail gracefully on sparse \"\n                \"data: error message should state explicitly that sparse \"\n                \"input is not supported if this is not the case.\"\n            )\n        with raises(\n            (TypeError, ValueError),\n            match=[\"sparse\", \"Sparse\"],\n            may_pass=True,\n            err_msg=err_msg,\n        ):\n            with ignore_warnings(category=FutureWarning):\n                estimator.fit(X, y)\n            if hasattr(estimator, \"predict\"):\n                pred = estimator.predict(X)\n                if tags[\"multioutput_only\"]:\n                    assert pred.shape == (X.shape[0], 1)\n                else:\n                    assert pred.shape == (X.shape[0],)\n            if hasattr(estimator, \"predict_proba\"):\n                probs = estimator.predict_proba(X)\n                if tags[\"binary_only\"]:\n                    expected_probs_shape = (X.shape[0], 2)\n                else:\n                    expected_probs_shape = (X.shape[0], 4)\n                assert probs.shape == expected_probs_shape",
                        "filename": "sklearn/utils/estimator_checks.py",
                        "start_index": 36016,
                        "end_index": 38577,
                        "start_line": 1025,
                        "end_line": 1093,
                        "max_line": 4639,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is relevant because it includes code that handles sparse data and may need to be updated to avoid using deprecated SparseSeries."
                }
            ],
            "sklearn/utils/validation.py": [
                {
                    "chunk": {
                        "code": "if accept_sparse is False:\n        raise TypeError(\n            \"A sparse matrix was passed, but dense \"\n            \"data is required. Use X.toarray() to \"\n            \"convert to a dense numpy array.\"\n        )\n    elif isinstance(accept_sparse, (list, tuple)):\n        if len(accept_sparse) == 0:\n            raise ValueError(\n                \"When providing 'accept_sparse' \"\n                \"as a tuple or list, it must contain at \"\n                \"least one string value.\"\n            )\n        # ensure correct sparse format\n        if spmatrix.format not in accept_sparse:\n            # create new with correct sparse\n            spmatrix = spmatrix.asformat(accept_sparse[0])\n            changed_format = True\n    elif accept_sparse is not True:\n        # any other type\n        raise ValueError(\n            \"Parameter 'accept_sparse' should be a string, \"\n            \"boolean or list of strings. You provided \"\n            \"'accept_sparse={}'.\".format(accept_sparse)\n        )\n\n    if dtype != spmatrix.dtype:\n        # convert dtype\n        spmatrix = spmatrix.astype(dtype)\n    elif copy and not changed_format:\n        # force copy\n        spmatrix = spmatrix.copy()\n\n    if force_all_finite:\n        if not hasattr(spmatrix, \"data\"):\n            warnings.warn(\n                \"Can't check %s sparse matrix for nan or inf.\" % spmatrix.format,\n                stacklevel=2,\n            )\n        else:\n            _assert_all_finite(\n                spmatrix.data,\n                allow_nan=force_all_finite == \"allow-nan\",\n                estimator_name=estimator_name,\n                input_name=input_name,\n            )\n\n    return spmatrix",
                        "filename": "sklearn/utils/validation.py",
                        "start_index": 17856,
                        "end_index": 19516,
                        "start_line": 534,
                        "end_line": 581,
                        "max_line": 2282,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is relevant as it contains logic for handling sparse matrices and may need to be reviewed to ensure compatibility with the new Series with sparse values."
                },
                {
                    "chunk": {
                        "code": "if sp.issparse(array):\n        _ensure_no_complex_data(array)\n        array = _ensure_sparse_format(\n            array,\n            accept_sparse=accept_sparse,\n            dtype=dtype,\n            copy=copy,\n            force_all_finite=force_all_finite,\n            accept_large_sparse=accept_large_sparse,\n            estimator_name=estimator_name,\n            input_name=input_name,\n        )",
                        "filename": "sklearn/utils/validation.py",
                        "start_index": 30833,
                        "end_index": 31229,
                        "start_line": 882,
                        "end_line": 2278,
                        "max_line": 2282,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is relevant because it includes a function that ensures the sparse format of an array, which might be related to the deprecation of SparseSeries."
                },
                {
                    "chunk": {
                        "code": "def _ensure_sparse_format(\n    spmatrix,\n    accept_sparse,\n    dtype,\n    copy,\n    force_all_finite,\n    accept_large_sparse,\n    estimator_name=None,\n    input_name=\"\",\n):",
                        "filename": "sklearn/utils/validation.py",
                        "start_index": 15534,
                        "end_index": 15708,
                        "start_line": 460,
                        "end_line": 2272,
                        "max_line": 2282,
                        "git_instance": "github",
                        "repo_name": "testbed/scikit-learn__scikit-learn__0.22",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is relevant as it defines the function '_ensure_sparse_format' which is directly involved in handling sparse data formats and may need to be updated in light of the SparseSeries deprecation."
                }
            ]
        },
        "solution_task": "- Search the codebase for occurrences of `SparseSeries` and replace them with `Series` with sparse values.\n- Update the test cases that use `SparseSeries` to use `Series` with sparse values.\n- Check the Travis CI configuration and logs related to `scipy-dev` to ensure that the issue is resolved after making the changes.\n- Ensure that the changes fix the issue mentioned in #14002.\n- If `SparseSeries` is found in any deprecated function or method, remove or update the deprecated code accordingly.\n- After making changes, run the test suite to ensure that all tests pass, especially those that previously failed on Travis CI due to the `SparseSeries` deprecation.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSE must provide precise, actionable guidance and directly address all aspects of the described bug to facilitate its resolution.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable plan to address the issue of the deprecated SparseSeries in the scikit-learn codebase. It suggests searching for occurrences of SparseSeries and replacing them with Series with sparse values, updating test cases, checking Travis CI configurations and logs, ensuring that the issue is resolved, removing or updating deprecated code, and running the test suite to confirm that all tests pass. Additionally, the RESPONSE provides specific code snippets to check, which is highly relevant and useful for the developer tasked with fixing the bug. The only reason it does not score a 10 is that it does not explicitly mention the need to ensure that the replacement of SparseSeries with Series with sparse values maintains the same functionality and performance, which is an implicit requirement of such a change.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711739690.818144,
        "result": "- Search the codebase for occurrences of `SparseSeries` and replace them with `Series` with sparse values.\n- Update the test cases that use `SparseSeries` to use `Series` with sparse values.\n- Check the Travis CI configuration and logs related to `scipy-dev` to ensure that the issue is resolved after making the changes.\n- Ensure that the changes fix the issue mentioned in #14002.\n- If `SparseSeries` is found in any deprecated function or method, remove or update the deprecated code accordingly.\n- After making changes, run the test suite to ensure that all tests pass, especially those that previously failed on Travis CI due to the `SparseSeries` deprecation.\n\n### Code snippets to check\n\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/utils)- [Lines 1025 - 1093](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/estimator_checks.py#L1025-L1093)\n\n This snippet is relevant because it includes code that handles sparse data and may need to be updated to avoid using deprecated SparseSeries.\n-  \u2192 [sklearn](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn) \u2192 [utils](https://github.com/testbed/scikit-learn__scikit-learn__0.22/tree//sklearn/utils)- [Lines 534 - 581](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/validation.py#L534-L581)\n\n This snippet is relevant as it contains logic for handling sparse matrices and may need to be reviewed to ensure compatibility with the new Series with sparse values. \n\n\n   - [Lines 882 - 2278](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/validation.py#L882-L2278)\n\n This snippet is relevant because it includes a function that ensures the sparse format of an array, which might be related to the deprecation of SparseSeries. \n\n\n   - [Lines 460 - 2272](https://github.com/testbed/scikit-learn__scikit-learn__0.22/blob//sklearn/utils/validation.py#L460-L2272)\n\n This snippet is relevant as it defines the function '_ensure_sparse_format' which is directly involved in handling sparse data formats and may need to be updated in light of the SparseSeries deprecation.",
        "context_relevance": 0.27,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT and answer it completely to get a score of 10.\nSupporting Evidence: The RESPONSE directly addresses the issue described in the PROMPT by providing a step-by-step solution to replace `SparseSeries` with `Series` with sparse values in the scikit-learn codebase. It also includes checking Travis CI to ensure the issue is resolved, updating test cases, and running the test suite to confirm that all tests pass. Additionally, the RESPONSE provides relevant code snippets that may need to be updated, which shows a thorough understanding of the task at hand. The RESPONSE is fully relevant to the PROMPT and answers it completely."
        },
        "qa_relevance": 1.0
    }
}