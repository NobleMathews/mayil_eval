{
    "id": "django__django-15774",
    "repo_name": "testbed/django__django__4.2",
    "task_id": 2550185767450022199,
    "title": "Django detects HTTP Accept-Language header in case-sensitive manner",
    "body": "Description\n\t\nThis issue was originally discussed in django-developers: \u200bhttps://groups.google.com/forum/#!topic/django-developers/1Y9LZSAOSnE\nPer \u200bw3c, \u200brfc2616 and \u200bbcp47, Language tags should be parsed in case-insensitive, however, I noticed that Django detects HTTP Accept-Language headers in case-sensitive manner.\nFor example, the following headers:\nChrome: Accept-Language: zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4\nFirefox: Accept-Language: zh-tw,zh;q=0.8,en-us;q=0.5,en;q=0.3\nDjango will correctly display Traditional Chinese for Chrome, but won't for Firefox because of lower-cased TW.\nThe fix contains two parts:\nFix potential case-sensitive places in code to follow case-insensitive (for example parse_accept_lang_header())\nFix \u200bdocumentation, correct the sentence \"Browsers send the names of the languages they accept in the Accept-Language HTTP header using this format. Examples: it, de-at, es, pt-br. Both the language and the country parts are in lower case. \", which obviously incorrect, Chrome uses tags like zh-TW, pt-BR.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__4.2.git",
    "requested_commit": "",
    "mayil_response": "To address the issue of case-sensitive handling of HTTP Accept-Language headers in Django, modify the `get_supported_language_variant` function in `django/utils/translation/trans_real.py`:\n\n- Update the function to normalize the language codes to a consistent case before comparison.\n- Use the `.lower()` method to convert both the input language code and the supported language codes to lowercase before comparison.\n\n```python\ndef get_supported_language_variant(lang_code, strict=False):\n    \"\"\"\n    Return the language code that's listed in supported languages, possibly\n    selecting a more generic variant. Raise LookupError if nothing is found.\n\n    If `strict` is False (the default), look for a country-specific variant\n    when neither the language code nor its generic variant is found.\n\n    lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n    as the provided language codes are taken from the HTTP request. See also\n    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n    \"\"\"\n    if lang_code:\n        lang_code = lang_code.lower()  # Normalize input language code to lowercase\n        # If 'zh-hant-tw' is not supported, try special fallback or subsequent\n        # language codes i.e. 'zh-hant' and 'zh'.\n        possible_lang_codes = [lang_code]\n        try:\n            possible_lang_codes.extend(LANG_INFO[lang_code][\"fallback\"])\n        except KeyError:\n            pass\n        i = None\n        while (i := lang_code.rfind(\"-\", 0, i)) > -1:\n            possible_lang_codes.append(lang_code[:i])\n        generic_lang_code = possible_lang_codes[-1]\n        supported_lang_codes = get_languages()\n\n        for code in possible_lang_codes:\n            if code in supported_lang_codes and check_for_language(code):\n                return code\n        if not strict:\n            # if fr-fr is not supported, try fr-ca.\n            for supported_code in supported_lang_codes:\n                if supported_code.startswith(generic_lang_code + \"-\"):\n                    return supported_code\n    raise LookupError(lang_code)\n```\n\nAdditionally, update the documentation to reflect that language tags are treated in a case-insensitive manner.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [utils](https://github.com/testbed/django__django__4.2/tree//django/utils) \u2192 [translation](https://github.com/testbed/django__django__4.2/tree//django/utils/translation)- [Lines 462 - 526](https://github.com/testbed/django__django__4.2/blob//django/utils/translation/trans_real.py#L462-L526)\n\n This snippet contains the get_supported_language_variant function which is responsible for selecting the language code that's listed in supported languages. It performs case-sensitive checks and is likely where the case-insensitive parsing should be implemented.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [middleware](https://github.com/testbed/django__django__4.2/tree//django/middleware)- [Lines 38 - 80](https://github.com/testbed/django__django__4.2/blob//django/middleware/locale.py#L38-L80)\n\n This snippet is part of the middleware that processes the response and sets the 'Content-Language' header. It may need to be reviewed to ensure that the language detection from the Accept-Language HTTP header is case-insensitive.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [core](https://github.com/testbed/django__django__4.2/tree//django/core) \u2192 [checks](https://github.com/testbed/django__django__4.2/tree//django/core/checks)- [Lines 1 - 66](https://github.com/testbed/django__django__4.2/blob//django/core/checks/translation.py#L1-L66)\n\n This snippet contains checks for the LANGUAGE_CODE setting and may be relevant to ensure that the language codes are treated in a case-insensitive manner throughout the system.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.00029299999999999997,
        "snippet_processor": 0.05661,
        "issue_star_solver": 0.05147000000000001,
        "issue_star_creation": 0.0343,
        "bouncer": 0.02192
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711716080.5230138,
        "relevant_snippets": [
            {
                "code": "import unicodedata\n\nfrom django import forms\nfrom django.contrib.auth import authenticate, get_user_model, password_validation\nfrom django.contrib.auth.hashers import UNUSABLE_PASSWORD_PREFIX, identify_hasher\nfrom django.contrib.auth.models import User\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.contrib.sites.shortcuts import get_current_site\nfrom django.core.exceptions import ValidationError\nfrom django.core.mail import EmailMultiAlternatives\nfrom django.template import loader\nfrom django.utils.encoding import force_bytes\nfrom django.utils.http import urlsafe_base64_encode\nfrom django.utils.text import capfirst\nfrom django.utils.translation import gettext\nfrom django.utils.translation import gettext_lazy as _\n\nUserModel = get_user_model()\n\n\ndef _unicode_ci_compare(s1, s2):\n    \"\"\"\n    Perform case-insensitive comparison of two identifiers, using the\n    recommended algorithm from Unicode Technical Report 36, section\n    2.11.2(B)(2).\n    \"\"\"\n    return (\n        unicodedata.normalize(\"NFKC\", s1).casefold()\n        == unicodedata.normalize(\"NFKC\", s2).casefold()\n    )\n\n\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = \"auth/widgets/read_only_password_hash.html\"\n    read_only = True\n\n    def get_context(self, name, value, attrs):\n        context = super().get_context(name, value, attrs)\n        summary = []\n        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n            summary.append({\"label\": gettext(\"No password set.\")})\n        else:\n            try:\n                hasher = identify_hasher(value)\n            except ValueError:\n                summary.append(\n                    {\n                        \"label\": gettext(\n                            \"Invalid password format or unknown hashing algorithm.\"\n                        )\n                    }\n                )\n            else:\n                for key, value_ in hasher.safe_summary(value).items():\n                    summary.append({\"label\": gettext(key), \"value\": value_})\n        context[\"summary\"] = summary\n        return context\n\n    def id_for_label(self, id_):\n        return None\n\n\nclass ReadOnlyPasswordHashField(forms.Field):\n    widget = ReadOnlyPasswordHashWidget\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(\"required\", False)\n        kwargs.setdefault(\"disabled\", True)\n        super().__init__(*args, **kwargs)\n\n\nclass UsernameField(forms.CharField):\n    def to_python(self, value):\n        return unicodedata.normalize(\"NFKC\", super().to_python(value))\n\n    def widget_attrs(self, widget):\n        return {\n            **super().widget_attrs(widget),\n            \"autocapitalize\": \"none\",\n            \"autocomplete\": \"username\",\n        }",
                "filename": "django/contrib/auth/forms.py",
                "start_index": 0,
                "end_index": 2738,
                "start_line": 1,
                "end_line": 367,
                "max_line": 510,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def process_response(self, request, response):\n        language = translation.get_language()\n        language_from_path = translation.get_language_from_path(request.path_info)\n        urlconf = getattr(request, \"urlconf\", settings.ROOT_URLCONF)\n        (\n            i18n_patterns_used,\n            prefixed_default_language,\n        ) = is_language_prefix_patterns_used(urlconf)\n\n        if (\n            response.status_code == 404\n            and not language_from_path\n            and i18n_patterns_used\n            and prefixed_default_language\n        ):\n            # Maybe the language code is missing in the URL? Try adding the\n            # language prefix and redirecting to that URL.\n            language_path = \"/%s%s\" % (language, request.path_info)\n            path_valid = is_valid_path(language_path, urlconf)\n            path_needs_slash = not path_valid and (\n                settings.APPEND_SLASH\n                and not language_path.endswith(\"/\")\n                and is_valid_path(\"%s/\" % language_path, urlconf)\n            )\n\n            if path_valid or path_needs_slash:\n                script_prefix = get_script_prefix()\n                # Insert language after the script prefix and before the\n                # rest of the URL\n                language_url = request.get_full_path(\n                    force_append_slash=path_needs_slash\n                ).replace(script_prefix, \"%s%s/\" % (script_prefix, language), 1)\n                # Redirect to the language-specific URL as detected by\n                # get_language_from_request(). HTTP caches may cache this\n                # redirect, so add the Vary header.\n                redirect = self.response_redirect_class(language_url)\n                patch_vary_headers(redirect, (\"Accept-Language\", \"Cookie\"))\n                return redirect\n\n        if not (i18n_patterns_used and language_from_path):\n            patch_vary_headers(response, (\"Accept-Language\",))\n        response.headers.setdefault(\"Content-Language\", language)\n        return response",
                "filename": "django/middleware/locale.py",
                "start_index": 1406,
                "end_index": 3441,
                "start_line": 38,
                "end_line": 80,
                "max_line": 80,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@functools.lru_cache(maxsize=1000)\ndef check_for_language(lang_code):\n    \"\"\"\n    Check whether there is a global language file for the given language\n    code. This is used to decide whether a user-provided language is\n    available.\n\n    lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n    as the provided language codes are taken from the HTTP request. See also\n    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n    \"\"\"\n    # First, a quick check to make sure lang_code is well-formed (#21458)\n    if lang_code is None or not language_code_re.search(lang_code):\n        return False\n    return any(\n        gettext_module.find(\"django\", path, [to_locale(lang_code)]) is not None\n        for path in all_locale_paths()\n    )\n\n\n@functools.lru_cache\ndef get_languages():\n    \"\"\"\n    Cache of settings.LANGUAGES in a dictionary for easy lookups by key.\n    Convert keys to lowercase as they should be treated as case-insensitive.\n    \"\"\"\n    return {key.lower(): value for key, value in dict(settings.LANGUAGES).items()}\n\n\n@functools.lru_cache(maxsize=1000)\ndef get_supported_language_variant(lang_code, strict=False):\n    \"\"\"\n    Return the language code that's listed in supported languages, possibly\n    selecting a more generic variant. Raise LookupError if nothing is found.\n\n    If `strict` is False (the default), look for a country-specific variant\n    when neither the language code nor its generic variant is found.\n\n    lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n    as the provided language codes are taken from the HTTP request. See also\n    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n    \"\"\"\n    if lang_code:\n        # If 'zh-hant-tw' is not supported, try special fallback or subsequent\n        # language codes i.e. 'zh-hant' and 'zh'.\n        possible_lang_codes = [lang_code]\n        try:\n            possible_lang_codes.extend(LANG_INFO[lang_code][\"fallback\"])\n        except KeyError:\n            pass\n        i = None\n        while (i := lang_code.rfind(\"-\", 0, i)) > -1:\n            possible_lang_codes.append(lang_code[:i])\n        generic_lang_code = possible_lang_codes[-1]\n        supported_lang_codes = get_languages()\n\n        for code in possible_lang_codes:\n            if code.lower() in supported_lang_codes and check_for_language(code):\n                return code\n        if not strict:\n            # if fr-fr is not supported, try fr-ca.\n            for supported_code in supported_lang_codes:\n                if supported_code.startswith(generic_lang_code + \"-\"):\n                    return supported_code\n    raise LookupError(lang_code)",
                "filename": "django/utils/translation/trans_real.py",
                "start_index": 15164,
                "end_index": 17840,
                "start_line": 462,
                "end_line": 526,
                "max_line": 639,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.9
            },
            {
                "code": "# This file is distributed under the same license as the Django package.\n#\n# The *_FORMAT strings use the Django date format syntax,\n# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATE_FORMAT = \"Y\u5e74n\u6708j\u65e5\"  # 2016\u5e749\u67085\u65e5\nTIME_FORMAT = \"H:i\"  # 20:45\nDATETIME_FORMAT = \"Y\u5e74n\u6708j\u65e5 H:i\"  # 2016\u5e749\u67085\u65e5 20:45\nYEAR_MONTH_FORMAT = \"Y\u5e74n\u6708\"  # 2016\u5e749\u6708\nMONTH_DAY_FORMAT = \"m\u6708j\u65e5\"  # 9\u67085\u65e5\nSHORT_DATE_FORMAT = \"Y\u5e74n\u6708j\u65e5\"  # 2016\u5e749\u67085\u65e5\nSHORT_DATETIME_FORMAT = \"Y\u5e74n\u6708j\u65e5 H:i\"  # 2016\u5e749\u67085\u65e5 20:45\nFIRST_DAY_OF_WEEK = 1  # \u661f\u671f\u4e00 (Monday)\n\n# The *_INPUT_FORMATS strings use the Python strftime format syntax,\n# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior\nDATE_INPUT_FORMATS = [\n    \"%Y/%m/%d\",  # '2016/09/05'\n    \"%Y-%m-%d\",  # '2016-09-05'\n    \"%Y\u5e74%n\u6708%j\u65e5\",  # '2016\u5e749\u67085\u65e5'\n]\n\nTIME_INPUT_FORMATS = [\n    \"%H:%M\",  # '20:45'\n    \"%H:%M:%S\",  # '20:45:29'\n    \"%H:%M:%S.%f\",  # '20:45:29.000200'\n]\n\nDATETIME_INPUT_FORMATS = [\n    \"%Y/%m/%d %H:%M\",  # '2016/09/05 20:45'\n    \"%Y-%m-%d %H:%M\",  # '2016-09-05 20:45'\n    \"%Y\u5e74%n\u6708%j\u65e5 %H:%M\",  # '2016\u5e749\u67085\u65e5 14:45'\n    \"%Y/%m/%d %H:%M:%S\",  # '2016/09/05 20:45:29'\n    \"%Y-%m-%d %H:%M:%S\",  # '2016-09-05 20:45:29'\n    \"%Y\u5e74%n\u6708%j\u65e5 %H:%M:%S\",  # '2016\u5e749\u67085\u65e5 20:45:29'\n    \"%Y/%m/%d %H:%M:%S.%f\",  # '2016/09/05 20:45:29.000200'\n    \"%Y-%m-%d %H:%M:%S.%f\",  # '2016-09-05 20:45:29.000200'\n    \"%Y\u5e74%n\u6708%j\u65e5 %H:%n:%S.%f\",  # '2016\u5e749\u67085\u65e5 20:45:29.000200'\n]\n\nDECIMAL_SEPARATOR = \".\"\nTHOUSAND_SEPARATOR = \"\"\nNUMBER_GROUPING = 4",
                "filename": "django/conf/locale/zh_Hans/formats.py",
                "start_index": 0,
                "end_index": 1479,
                "start_line": 1,
                "end_line": 42,
                "max_line": 42,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "# This file is distributed under the same license as the Django package.\n#\n# The *_FORMAT strings use the Django date format syntax,\n# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATE_FORMAT = \"Y\u5e74n\u6708j\u65e5\"  # 2016\u5e749\u67085\u65e5\nTIME_FORMAT = \"H:i\"  # 20:45\nDATETIME_FORMAT = \"Y\u5e74n\u6708j\u65e5 H:i\"  # 2016\u5e749\u67085\u65e5 20:45\nYEAR_MONTH_FORMAT = \"Y\u5e74n\u6708\"  # 2016\u5e749\u6708\nMONTH_DAY_FORMAT = \"m\u6708j\u65e5\"  # 9\u67085\u65e5\nSHORT_DATE_FORMAT = \"Y\u5e74n\u6708j\u65e5\"  # 2016\u5e749\u67085\u65e5\nSHORT_DATETIME_FORMAT = \"Y\u5e74n\u6708j\u65e5 H:i\"  # 2016\u5e749\u67085\u65e5 20:45\nFIRST_DAY_OF_WEEK = 1  # \u661f\u671f\u4e00 (Monday)\n\n# The *_INPUT_FORMATS strings use the Python strftime format syntax,\n# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior\nDATE_INPUT_FORMATS = [\n    \"%Y/%m/%d\",  # '2016/09/05'\n    \"%Y-%m-%d\",  # '2016-09-05'\n    \"%Y\u5e74%n\u6708%j\u65e5\",  # '2016\u5e749\u67085\u65e5'\n]\n\nTIME_INPUT_FORMATS = [\n    \"%H:%M\",  # '20:45'\n    \"%H:%M:%S\",  # '20:45:29'\n    \"%H:%M:%S.%f\",  # '20:45:29.000200'\n]\n\nDATETIME_INPUT_FORMATS = [\n    \"%Y/%m/%d %H:%M\",  # '2016/09/05 20:45'\n    \"%Y-%m-%d %H:%M\",  # '2016-09-05 20:45'\n    \"%Y\u5e74%n\u6708%j\u65e5 %H:%M\",  # '2016\u5e749\u67085\u65e5 14:45'\n    \"%Y/%m/%d %H:%M:%S\",  # '2016/09/05 20:45:29'\n    \"%Y-%m-%d %H:%M:%S\",  # '2016-09-05 20:45:29'\n    \"%Y\u5e74%n\u6708%j\u65e5 %H:%M:%S\",  # '2016\u5e749\u67085\u65e5 20:45:29'\n    \"%Y/%m/%d %H:%M:%S.%f\",  # '2016/09/05 20:45:29.000200'\n    \"%Y-%m-%d %H:%M:%S.%f\",  # '2016-09-05 20:45:29.000200'\n    \"%Y\u5e74%n\u6708%j\u65e5 %H:%n:%S.%f\",  # '2016\u5e749\u67085\u65e5 20:45:29.000200'\n]\n\nDECIMAL_SEPARATOR = \".\"\nTHOUSAND_SEPARATOR = \"\"\nNUMBER_GROUPING = 4",
                "filename": "django/conf/locale/zh_Hant/formats.py",
                "start_index": 0,
                "end_index": 1479,
                "start_line": 1,
                "end_line": 42,
                "max_line": 42,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "# This file is distributed under the same license as the Django package.\n#\n# The *_FORMAT strings use the Django date format syntax,\n# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATE_FORMAT = \"j E Y \u0436.\"\nTIME_FORMAT = \"G:i\"\nDATETIME_FORMAT = \"j E Y \u0436. G:i\"\nYEAR_MONTH_FORMAT = \"F Y \u0436.\"\nMONTH_DAY_FORMAT = \"j F\"\nSHORT_DATE_FORMAT = \"d.m.Y\"\nSHORT_DATETIME_FORMAT = \"d.m.Y H:i\"\nFIRST_DAY_OF_WEEK = 1  # \u0414\u04af\u0439\u0448\u04e9\u043c\u0431\u04af, Monday\n\n# The *_INPUT_FORMATS strings use the Python strftime format syntax,\n# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior\nDATE_INPUT_FORMATS = [\n    \"%d.%m.%Y\",  # '25.10.2006'\n    \"%d.%m.%y\",  # '25.10.06'\n]\nDATETIME_INPUT_FORMATS = [\n    \"%d.%m.%Y %H:%M:%S\",  # '25.10.2006 14:30:59'\n    \"%d.%m.%Y %H:%M:%S.%f\",  # '25.10.2006 14:30:59.000200'\n    \"%d.%m.%Y %H:%M\",  # '25.10.2006 14:30'\n    \"%d.%m.%Y\",  # '25.10.2006'\n    \"%d.%m.%y %H:%M:%S\",  # '25.10.06 14:30:59'\n    \"%d.%m.%y %H:%M:%S.%f\",  # '25.10.06 14:30:59.000200'\n    \"%d.%m.%y %H:%M\",  # '25.10.06 14:30'\n    \"%d.%m.%y\",  # '25.10.06'\n]\nDECIMAL_SEPARATOR = \".\"\nTHOUSAND_SEPARATOR = \"\\xa0\"  # non-breaking space\nNUMBER_GROUPING = 3",
                "filename": "django/conf/locale/ky/formats.py",
                "start_index": 0,
                "end_index": 1166,
                "start_line": 1,
                "end_line": 32,
                "max_line": 32,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "# Languages using BiDi (right-to-left) layout\nLANGUAGES_BIDI = [\"he\", \"ar\", \"ar-dz\", \"ckb\", \"fa\", \"ur\"]\n\n# If you set this to False, Django will make some optimizations so as not\n# to load the internationalization machinery.\nUSE_I18N = True\nLOCALE_PATHS = []\n\n# Settings for language cookie\nLANGUAGE_COOKIE_NAME = \"django_language\"\nLANGUAGE_COOKIE_AGE = None\nLANGUAGE_COOKIE_DOMAIN = None\nLANGUAGE_COOKIE_PATH = \"/\"\nLANGUAGE_COOKIE_SECURE = False\nLANGUAGE_COOKIE_HTTPONLY = False\nLANGUAGE_COOKIE_SAMESITE = None\n\n# Not-necessarily-technical managers of the site. They get broken link\n# notifications and other various emails.\nMANAGERS = ADMINS\n\n# Default charset to use for all HttpResponse objects, if a MIME type isn't\n# manually specified. It's used to construct the Content-Type header.\nDEFAULT_CHARSET = \"utf-8\"\n\n# Email address that error messages come from.\nSERVER_EMAIL = \"root@localhost\"\n\n# Database connection info. If left empty, will default to the dummy backend.\nDATABASES = {}\n\n# Classes used to implement DB routing behavior.\nDATABASE_ROUTERS = []\n\n# The email backend to use. For possible shortcuts see django.core.mail.\n# The default is to use the SMTP backend.\n# Third-party backends can be specified by providing a Python path\n# to a module that defines an EmailBackend class.\nEMAIL_BACKEND = \"django.core.mail.backends.smtp.EmailBackend\"\n\n# Host for sending email.\nEMAIL_HOST = \"localhost\"\n\n# Port for sending email.\nEMAIL_PORT = 25\n\n# Whether to send SMTP 'Date' header in the local time zone or in UTC.\nEMAIL_USE_LOCALTIME = False\n\n# Optional SMTP authentication information for EMAIL_HOST.\nEMAIL_HOST_USER = \"\"\nEMAIL_HOST_PASSWORD = \"\"\nEMAIL_USE_TLS = False\nEMAIL_USE_SSL = False\nEMAIL_SSL_CERTFILE = None\nEMAIL_SSL_KEYFILE = None\nEMAIL_TIMEOUT = None\n\n# List of strings representing installed apps.\nINSTALLED_APPS = []\n\nTEMPLATES = []\n\n# Default form rendering class.\nFORM_RENDERER = \"django.forms.renderers.DjangoTemplates\"\n\n# Default email address to use for various automated correspondence from\n# the site managers.\nDEFAULT_FROM_EMAIL = \"webmaster@localhost\"\n\n# Subject-line prefix for email messages send with django.core.mail.mail_admins\n# or ...mail_managers.  Make sure to include the trailing space.\nEMAIL_SUBJECT_PREFIX = \"[Django] \"\n\n# Whether to append trailing slashes to URLs.\nAPPEND_SLASH = True\n\n# Whether to prepend the \"www.\" subdomain to URLs that don't have it.\nPREPEND_WWW = False\n\n# Override the server-derived value of SCRIPT_NAME\nFORCE_SCRIPT_NAME = None\n\n# List of compiled regular expression objects representing User-Agent strings\n# that are not allowed to visit any page, systemwide. Use this for bad\n# robots/crawlers. Here are a few examples:\n#     import re\n#     DISALLOWED_USER_AGENTS = [\n#         re.compile(r'^NaverBot.*'),\n#         re.compile(r'^EmailSiphon.*'),\n#         re.compile(r'^SiteSucker.*'),\n#         re.compile(r'^sohu-search'),\n#     ]\nDISALLOWED_USER_AGENTS = []\n\nABSOLUTE_URL_OVERRIDES = {}",
                "filename": "django/conf/global_settings.py",
                "start_index": 5498,
                "end_index": 8466,
                "start_line": 152,
                "end_line": 247,
                "max_line": 667,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# This file is distributed under the same license as the Django package.\n#\n# The *_FORMAT strings use the Django date format syntax,\n# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATE_FORMAT = \"Y\ub144 n\uc6d4 j\uc77c\"\nTIME_FORMAT = \"A g:i\"\nDATETIME_FORMAT = \"Y\ub144 n\uc6d4 j\uc77c g:i A\"\nYEAR_MONTH_FORMAT = \"Y\ub144 n\uc6d4\"\nMONTH_DAY_FORMAT = \"n\uc6d4 j\uc77c\"\nSHORT_DATE_FORMAT = \"Y-n-j.\"\nSHORT_DATETIME_FORMAT = \"Y-n-j H:i\"\n# FIRST_DAY_OF_WEEK =\n\n# The *_INPUT_FORMATS strings use the Python strftime format syntax,\n# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior\n# Kept ISO formats as they are in first position\nDATE_INPUT_FORMATS = [\n    \"%Y-%m-%d\",  # '2006-10-25'\n    \"%m/%d/%Y\",  # '10/25/2006'\n    \"%m/%d/%y\",  # '10/25/06'\n    # \"%b %d %Y\",  # 'Oct 25 2006'\n    # \"%b %d, %Y\",  # 'Oct 25, 2006'\n    # \"%d %b %Y\",  # '25 Oct 2006'\n    # \"%d %b, %Y\",  #'25 Oct, 2006'\n    # \"%B %d %Y\",  # 'October 25 2006'\n    # \"%B %d, %Y\",  #'October 25, 2006'\n    # \"%d %B %Y\",  # '25 October 2006'\n    # \"%d %B, %Y\",  # '25 October, 2006'\n    \"%Y\ub144 %m\uc6d4 %d\uc77c\",  # '2006\ub144 10\uc6d4 25\uc77c', with localized suffix.\n]\nTIME_INPUT_FORMATS = [\n    \"%H:%M:%S\",  # '14:30:59'\n    \"%H:%M:%S.%f\",  # '14:30:59.000200'\n    \"%H:%M\",  # '14:30'\n    \"%H\uc2dc %M\ubd84 %S\ucd08\",  # '14\uc2dc 30\ubd84 59\ucd08'\n    \"%H\uc2dc %M\ubd84\",  # '14\uc2dc 30\ubd84'\n]\nDATETIME_INPUT_FORMATS = [\n    \"%Y-%m-%d %H:%M:%S\",  # '2006-10-25 14:30:59'\n    \"%Y-%m-%d %H:%M:%S.%f\",  # '2006-10-25 14:30:59.000200'\n    \"%Y-%m-%d %H:%M\",  # '2006-10-25 14:30'\n    \"%m/%d/%Y %H:%M:%S\",  # '10/25/2006 14:30:59'\n    \"%m/%d/%Y %H:%M:%S.%f\",  # '10/25/2006 14:30:59.000200'\n    \"%m/%d/%Y %H:%M\",  # '10/25/2006 14:30'\n    \"%m/%d/%y %H:%M:%S\",  # '10/25/06 14:30:59'\n    \"%m/%d/%y %H:%M:%S.%f\",  # '10/25/06 14:30:59.000200'\n    \"%m/%d/%y %H:%M\",  # '10/25/06 14:30'\n    \"%Y\ub144 %m\uc6d4 %d\uc77c %H\uc2dc %M\ubd84 %S\ucd08\",  # '2006\ub144 10\uc6d4 25\uc77c 14\uc2dc 30\ubd84 59\ucd08'\n    \"%Y\ub144 %m\uc6d4 %d\uc77c %H\uc2dc %M\ubd84\",  # '2006\ub144 10\uc6d4 25\uc77c 14\uc2dc 30\ubd84'\n]\n\nDECIMAL_SEPARATOR = \".\"\nTHOUSAND_SEPARATOR = \",\"\nNUMBER_GROUPING = 3",
                "filename": "django/conf/locale/ko/formats.py",
                "start_index": 0,
                "end_index": 1964,
                "start_line": 1,
                "end_line": 54,
                "max_line": 54,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "from django.conf import settings\nfrom django.utils.translation import get_supported_language_variant\nfrom django.utils.translation.trans_real import language_code_re\n\nfrom . import Error, Tags, register\n\nE001 = Error(\n    \"You have provided an invalid value for the LANGUAGE_CODE setting: {!r}.\",\n    id=\"translation.E001\",\n)\n\nE002 = Error(\n    \"You have provided an invalid language code in the LANGUAGES setting: {!r}.\",\n    id=\"translation.E002\",\n)\n\nE003 = Error(\n    \"You have provided an invalid language code in the LANGUAGES_BIDI setting: {!r}.\",\n    id=\"translation.E003\",\n)\n\nE004 = Error(\n    \"You have provided a value for the LANGUAGE_CODE setting that is not in \"\n    \"the LANGUAGES setting.\",\n    id=\"translation.E004\",\n)\n\n\n@register(Tags.translation)\ndef check_setting_language_code(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGE_CODE setting is invalid.\"\"\"\n    tag = settings.LANGUAGE_CODE\n    if not isinstance(tag, str) or not language_code_re.match(tag):\n        return [Error(E001.msg.format(tag), id=E001.id)]\n    return []\n\n\n@register(Tags.translation)\ndef check_setting_languages(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGES setting is invalid.\"\"\"\n    return [\n        Error(E002.msg.format(tag), id=E002.id)\n        for tag, _ in settings.LANGUAGES\n        if not isinstance(tag, str) or not language_code_re.match(tag)\n    ]\n\n\n@register(Tags.translation)\ndef check_setting_languages_bidi(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGES_BIDI setting is invalid.\"\"\"\n    return [\n        Error(E003.msg.format(tag), id=E003.id)\n        for tag in settings.LANGUAGES_BIDI\n        if not isinstance(tag, str) or not language_code_re.match(tag)\n    ]\n\n\n@register(Tags.translation)\ndef check_language_settings_consistent(app_configs, **kwargs):\n    \"\"\"Error if language settings are not consistent with each other.\"\"\"\n    try:\n        get_supported_language_variant(settings.LANGUAGE_CODE)\n    except LookupError:\n        return [E004]\n    else:\n        return []",
                "filename": "django/core/checks/translation.py",
                "start_index": 0,
                "end_index": 1989,
                "start_line": 1,
                "end_line": 66,
                "max_line": 66,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "# This file is distributed under the same license as the Django package.\n#\n# The *_FORMAT strings use the Django date format syntax,\n# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATE_FORMAT = \"j E Y \u0433.\"\nTIME_FORMAT = \"G:i\"\nDATETIME_FORMAT = \"j E Y \u0433. G:i\"\nYEAR_MONTH_FORMAT = \"F Y \u0433.\"\nMONTH_DAY_FORMAT = \"j F\"\nSHORT_DATE_FORMAT = \"d.m.Y\"\nSHORT_DATETIME_FORMAT = \"d.m.Y H:i\"\nFIRST_DAY_OF_WEEK = 1  # Monday\n\n# The *_INPUT_FORMATS strings use the Python strftime format syntax,\n# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior\nDATE_INPUT_FORMATS = [\n    \"%d.%m.%Y\",  # '25.10.2006'\n    \"%d.%m.%y\",  # '25.10.06'\n]\nDATETIME_INPUT_FORMATS = [\n    \"%d.%m.%Y %H:%M:%S\",  # '25.10.2006 14:30:59'\n    \"%d.%m.%Y %H:%M:%S.%f\",  # '25.10.2006 14:30:59.000200'\n    \"%d.%m.%Y %H:%M\",  # '25.10.2006 14:30'\n    \"%d.%m.%Y\",  # '25.10.2006'\n    \"%d.%m.%y %H:%M:%S\",  # '25.10.06 14:30:59'\n    \"%d.%m.%y %H:%M:%S.%f\",  # '25.10.06 14:30:59.000200'\n    \"%d.%m.%y %H:%M\",  # '25.10.06 14:30'\n    \"%d.%m.%y\",  # '25.10.06'\n]\nDECIMAL_SEPARATOR = \",\"\nTHOUSAND_SEPARATOR = \"\\xa0\"  # non-breaking space\nNUMBER_GROUPING = 3",
                "filename": "django/conf/locale/tg/formats.py",
                "start_index": 0,
                "end_index": 1156,
                "start_line": 1,
                "end_line": 32,
                "max_line": 32,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.0
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "django/utils/translation/trans_real.py": [
                {
                    "chunk": {
                        "code": "@functools.lru_cache(maxsize=1000)\ndef check_for_language(lang_code):\n    \"\"\"\n    Check whether there is a global language file for the given language\n    code. This is used to decide whether a user-provided language is\n    available.\n\n    lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n    as the provided language codes are taken from the HTTP request. See also\n    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n    \"\"\"\n    # First, a quick check to make sure lang_code is well-formed (#21458)\n    if lang_code is None or not language_code_re.search(lang_code):\n        return False\n    return any(\n        gettext_module.find(\"django\", path, [to_locale(lang_code)]) is not None\n        for path in all_locale_paths()\n    )\n\n\n@functools.lru_cache\ndef get_languages():\n    \"\"\"\n    Cache of settings.LANGUAGES in a dictionary for easy lookups by key.\n    Convert keys to lowercase as they should be treated as case-insensitive.\n    \"\"\"\n    return {key.lower(): value for key, value in dict(settings.LANGUAGES).items()}\n\n\n@functools.lru_cache(maxsize=1000)\ndef get_supported_language_variant(lang_code, strict=False):\n    \"\"\"\n    Return the language code that's listed in supported languages, possibly\n    selecting a more generic variant. Raise LookupError if nothing is found.\n\n    If `strict` is False (the default), look for a country-specific variant\n    when neither the language code nor its generic variant is found.\n\n    lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n    as the provided language codes are taken from the HTTP request. See also\n    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n    \"\"\"\n    if lang_code:\n        # If 'zh-hant-tw' is not supported, try special fallback or subsequent\n        # language codes i.e. 'zh-hant' and 'zh'.\n        possible_lang_codes = [lang_code]\n        try:\n            possible_lang_codes.extend(LANG_INFO[lang_code][\"fallback\"])\n        except KeyError:\n            pass\n        i = None\n        while (i := lang_code.rfind(\"-\", 0, i)) > -1:\n            possible_lang_codes.append(lang_code[:i])\n        generic_lang_code = possible_lang_codes[-1]\n        supported_lang_codes = get_languages()\n\n        for code in possible_lang_codes:\n            if code.lower() in supported_lang_codes and check_for_language(code):\n                return code\n        if not strict:\n            # if fr-fr is not supported, try fr-ca.\n            for supported_code in supported_lang_codes:\n                if supported_code.startswith(generic_lang_code + \"-\"):\n                    return supported_code\n    raise LookupError(lang_code)",
                        "filename": "django/utils/translation/trans_real.py",
                        "start_index": 15164,
                        "end_index": 17840,
                        "start_line": 462,
                        "end_line": 526,
                        "max_line": 639,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the get_supported_language_variant function which is responsible for selecting the language code that's listed in supported languages. It performs case-sensitive checks and is likely where the case-insensitive parsing should be implemented."
                }
            ],
            "django/middleware/locale.py": [
                {
                    "chunk": {
                        "code": "def process_response(self, request, response):\n        language = translation.get_language()\n        language_from_path = translation.get_language_from_path(request.path_info)\n        urlconf = getattr(request, \"urlconf\", settings.ROOT_URLCONF)\n        (\n            i18n_patterns_used,\n            prefixed_default_language,\n        ) = is_language_prefix_patterns_used(urlconf)\n\n        if (\n            response.status_code == 404\n            and not language_from_path\n            and i18n_patterns_used\n            and prefixed_default_language\n        ):\n            # Maybe the language code is missing in the URL? Try adding the\n            # language prefix and redirecting to that URL.\n            language_path = \"/%s%s\" % (language, request.path_info)\n            path_valid = is_valid_path(language_path, urlconf)\n            path_needs_slash = not path_valid and (\n                settings.APPEND_SLASH\n                and not language_path.endswith(\"/\")\n                and is_valid_path(\"%s/\" % language_path, urlconf)\n            )\n\n            if path_valid or path_needs_slash:\n                script_prefix = get_script_prefix()\n                # Insert language after the script prefix and before the\n                # rest of the URL\n                language_url = request.get_full_path(\n                    force_append_slash=path_needs_slash\n                ).replace(script_prefix, \"%s%s/\" % (script_prefix, language), 1)\n                # Redirect to the language-specific URL as detected by\n                # get_language_from_request(). HTTP caches may cache this\n                # redirect, so add the Vary header.\n                redirect = self.response_redirect_class(language_url)\n                patch_vary_headers(redirect, (\"Accept-Language\", \"Cookie\"))\n                return redirect\n\n        if not (i18n_patterns_used and language_from_path):\n            patch_vary_headers(response, (\"Accept-Language\",))\n        response.headers.setdefault(\"Content-Language\", language)\n        return response",
                        "filename": "django/middleware/locale.py",
                        "start_index": 1406,
                        "end_index": 3441,
                        "start_line": 38,
                        "end_line": 80,
                        "max_line": 80,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the middleware that processes the response and sets the 'Content-Language' header. It may need to be reviewed to ensure that the language detection from the Accept-Language HTTP header is case-insensitive."
                }
            ],
            "django/core/checks/translation.py": [
                {
                    "chunk": {
                        "code": "from django.conf import settings\nfrom django.utils.translation import get_supported_language_variant\nfrom django.utils.translation.trans_real import language_code_re\n\nfrom . import Error, Tags, register\n\nE001 = Error(\n    \"You have provided an invalid value for the LANGUAGE_CODE setting: {!r}.\",\n    id=\"translation.E001\",\n)\n\nE002 = Error(\n    \"You have provided an invalid language code in the LANGUAGES setting: {!r}.\",\n    id=\"translation.E002\",\n)\n\nE003 = Error(\n    \"You have provided an invalid language code in the LANGUAGES_BIDI setting: {!r}.\",\n    id=\"translation.E003\",\n)\n\nE004 = Error(\n    \"You have provided a value for the LANGUAGE_CODE setting that is not in \"\n    \"the LANGUAGES setting.\",\n    id=\"translation.E004\",\n)\n\n\n@register(Tags.translation)\ndef check_setting_language_code(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGE_CODE setting is invalid.\"\"\"\n    tag = settings.LANGUAGE_CODE\n    if not isinstance(tag, str) or not language_code_re.match(tag):\n        return [Error(E001.msg.format(tag), id=E001.id)]\n    return []\n\n\n@register(Tags.translation)\ndef check_setting_languages(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGES setting is invalid.\"\"\"\n    return [\n        Error(E002.msg.format(tag), id=E002.id)\n        for tag, _ in settings.LANGUAGES\n        if not isinstance(tag, str) or not language_code_re.match(tag)\n    ]\n\n\n@register(Tags.translation)\ndef check_setting_languages_bidi(app_configs, **kwargs):\n    \"\"\"Error if LANGUAGES_BIDI setting is invalid.\"\"\"\n    return [\n        Error(E003.msg.format(tag), id=E003.id)\n        for tag in settings.LANGUAGES_BIDI\n        if not isinstance(tag, str) or not language_code_re.match(tag)\n    ]\n\n\n@register(Tags.translation)\ndef check_language_settings_consistent(app_configs, **kwargs):\n    \"\"\"Error if language settings are not consistent with each other.\"\"\"\n    try:\n        get_supported_language_variant(settings.LANGUAGE_CODE)\n    except LookupError:\n        return [E004]\n    else:\n        return []",
                        "filename": "django/core/checks/translation.py",
                        "start_index": 0,
                        "end_index": 1989,
                        "start_line": 1,
                        "end_line": 66,
                        "max_line": 66,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains checks for the LANGUAGE_CODE setting and may be relevant to ensure that the language codes are treated in a case-insensitive manner throughout the system."
                }
            ]
        },
        "solution_task": "To address the issue of case-sensitive handling of HTTP Accept-Language headers in Django, modify the `get_supported_language_variant` function in `django/utils/translation/trans_real.py`:\n\n- Update the function to normalize the language codes to a consistent case before comparison.\n- Use the `.lower()` method to convert both the input language code and the supported language codes to lowercase before comparison.\n\n```python\ndef get_supported_language_variant(lang_code, strict=False):\n    \"\"\"\n    Return the language code that's listed in supported languages, possibly\n    selecting a more generic variant. Raise LookupError if nothing is found.\n\n    If `strict` is False (the default), look for a country-specific variant\n    when neither the language code nor its generic variant is found.\n\n    lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n    as the provided language codes are taken from the HTTP request. See also\n    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n    \"\"\"\n    if lang_code:\n        lang_code = lang_code.lower()  # Normalize input language code to lowercase\n        # If 'zh-hant-tw' is not supported, try special fallback or subsequent\n        # language codes i.e. 'zh-hant' and 'zh'.\n        possible_lang_codes = [lang_code]\n        try:\n            possible_lang_codes.extend(LANG_INFO[lang_code][\"fallback\"])\n        except KeyError:\n            pass\n        i = None\n        while (i := lang_code.rfind(\"-\", 0, i)) > -1:\n            possible_lang_codes.append(lang_code[:i])\n        generic_lang_code = possible_lang_codes[-1]\n        supported_lang_codes = get_languages()\n\n        for code in possible_lang_codes:\n            if code in supported_lang_codes and check_for_language(code):\n                return code\n        if not strict:\n            # if fr-fr is not supported, try fr-ca.\n            for supported_code in supported_lang_codes:\n                if supported_code.startswith(generic_lang_code + \"-\"):\n                    return supported_code\n    raise LookupError(lang_code)\n```\n\nAdditionally, update the documentation to reflect that language tags are treated in a case-insensitive manner.",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant hints and solutions that can directly lead to resolving the issues outlined in the PROMPT.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the problem of case-sensitive handling of HTTP Accept-Language headers in Django. It suggests modifying the `get_supported_language_variant` function to normalize language codes to lowercase before comparison, which is a direct and relevant approach to the issue described in the PROMPT. The RESPONSE also includes a code snippet with the proposed changes, which adds significant value by showing exactly where and how to implement the fix. Furthermore, the RESPONSE advises updating the documentation to reflect the case-insensitive treatment of language tags, which addresses the second part of the fix mentioned in the PROMPT. The inclusion of code snippets to check for potential case-sensitive checks in other parts of the Django framework is also valuable, as it provides a starting point for a comprehensive solution to the problem.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711716199.8185768,
        "result": "To address the issue of case-sensitive handling of HTTP Accept-Language headers in Django, modify the `get_supported_language_variant` function in `django/utils/translation/trans_real.py`:\n\n- Update the function to normalize the language codes to a consistent case before comparison.\n- Use the `.lower()` method to convert both the input language code and the supported language codes to lowercase before comparison.\n\n```python\ndef get_supported_language_variant(lang_code, strict=False):\n    \"\"\"\n    Return the language code that's listed in supported languages, possibly\n    selecting a more generic variant. Raise LookupError if nothing is found.\n\n    If `strict` is False (the default), look for a country-specific variant\n    when neither the language code nor its generic variant is found.\n\n    lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n    as the provided language codes are taken from the HTTP request. See also\n    <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n    \"\"\"\n    if lang_code:\n        lang_code = lang_code.lower()  # Normalize input language code to lowercase\n        # If 'zh-hant-tw' is not supported, try special fallback or subsequent\n        # language codes i.e. 'zh-hant' and 'zh'.\n        possible_lang_codes = [lang_code]\n        try:\n            possible_lang_codes.extend(LANG_INFO[lang_code][\"fallback\"])\n        except KeyError:\n            pass\n        i = None\n        while (i := lang_code.rfind(\"-\", 0, i)) > -1:\n            possible_lang_codes.append(lang_code[:i])\n        generic_lang_code = possible_lang_codes[-1]\n        supported_lang_codes = get_languages()\n\n        for code in possible_lang_codes:\n            if code in supported_lang_codes and check_for_language(code):\n                return code\n        if not strict:\n            # if fr-fr is not supported, try fr-ca.\n            for supported_code in supported_lang_codes:\n                if supported_code.startswith(generic_lang_code + \"-\"):\n                    return supported_code\n    raise LookupError(lang_code)\n```\n\nAdditionally, update the documentation to reflect that language tags are treated in a case-insensitive manner.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [utils](https://github.com/testbed/django__django__4.2/tree//django/utils) \u2192 [translation](https://github.com/testbed/django__django__4.2/tree//django/utils/translation)- [Lines 462 - 526](https://github.com/testbed/django__django__4.2/blob//django/utils/translation/trans_real.py#L462-L526)\n\n This snippet contains the get_supported_language_variant function which is responsible for selecting the language code that's listed in supported languages. It performs case-sensitive checks and is likely where the case-insensitive parsing should be implemented.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [middleware](https://github.com/testbed/django__django__4.2/tree//django/middleware)- [Lines 38 - 80](https://github.com/testbed/django__django__4.2/blob//django/middleware/locale.py#L38-L80)\n\n This snippet is part of the middleware that processes the response and sets the 'Content-Language' header. It may need to be reviewed to ensure that the language detection from the Accept-Language HTTP header is case-insensitive.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [core](https://github.com/testbed/django__django__4.2/tree//django/core) \u2192 [checks](https://github.com/testbed/django__django__4.2/tree//django/core/checks)- [Lines 1 - 66](https://github.com/testbed/django__django__4.2/blob//django/core/checks/translation.py#L1-L66)\n\n This snippet contains checks for the LANGUAGE_CODE setting and may be relevant to ensure that the language codes are treated in a case-insensitive manner throughout the system.",
        "context_relevance": 0.16999999999999998,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT and answer it completely to get a score of 10.\nSupporting Evidence: The RESPONSE provides a detailed solution to the issue of case-sensitive handling of HTTP Accept-Language headers in Django, which is the core problem described in the PROMPT. It includes a code snippet that normalizes language codes to lowercase, directly addressing the case sensitivity issue. Additionally, it suggests updating the documentation to reflect the case-insensitive treatment of language tags, which is another concern raised in the PROMPT. The RESPONSE also references specific code snippets in the Django repository that should be checked for case sensitivity, which is highly relevant to the discussion in the PROMPT. The RESPONSE is comprehensive, directly addresses all aspects of the PROMPT, and provides a complete answer, thus earning a score of 10."
        },
        "qa_relevance": 1.0
    }
}