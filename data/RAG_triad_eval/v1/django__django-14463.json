{
    "id": "django__django-14463",
    "repo_name": "testbed/django__django__4.2",
    "task_id": 1486532999814557027,
    "title": "Add the ability to define comments in table / columns",
    "body": "Description\n\t \n\t\t(last modified by Jared Chung)\n\t \nDatabase-level comments are valuable for database administrators, data analysts, data scientists, and others who are looking to consume data that is managed by Django. Most Django-supported databases also support table-level and column-level comments. This ticket would add functionality to Django to allow Django users to specify comments for syncdb manage.py to enter into the database.\n....\n....\nnew proposal (kimsoungryoul : 2020.03.23)\nWe will develop the code such as below\nclass AModel(models.Model):\n\t aaa = model.CharField(help_text=\"i am help_text\", db_column_comment=\"i am db_comment\",~~~)\n\t \n\t class Meta:\n\t\t db_table = \"a_model_example_name\"\n\t\t db_table_comment =\"this is a_model comment ~~~~\"\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__4.2.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature of adding comments to tables and columns in Django models, you can follow these steps:\n\n- Modify the Django model fields to accept a new argument `db_column_comment` for column comments and `db_table_comment` for table comments.\n- Update the Django ORM to handle these new arguments and include them in the appropriate SQL statements when creating or altering tables.\n- Extend the Django migration framework to detect changes in comments and generate the necessary migration operations.\n\nHere's a high-level overview of the implementation:\n\n1. **Extend Django Field class:**\n   - Modify the `Field` class in `django/db/models/fields/__init__.py` to accept a new keyword argument `db_column_comment`.\n   - Store the comment in the field instance to be used later during schema creation.\n\n2. **Handle table comments in Meta:**\n   - In the `Options` class in `django/db/models/options.py`, add support for a new attribute `db_table_comment`.\n   - Ensure that this attribute is included in the model's `_meta` options.\n\n3. **Update schema creation:**\n   - In `django/db/backends/base/schema.py`, modify the `create_model` method to include the table comment by using the `sql_create_table` template.\n   - Update the `_alter_column_comment_sql` method to generate the SQL for altering a column's comment.\n\n4. **Update migrations:**\n   - In `django/db/migrations/operations/models.py`, add a new operation `AlterModelTableComment` similar to the provided snippet.\n   - In `django/db/migrations/autodetector.py`, update the `generate_altered_db_table_comment` method to detect changes in `db_table_comment` and generate `AlterModelTableComment` operations.\n\n5. **Handle database-specific SQL:**\n   - Each database backend in `django/db/backends/` may require specific SQL syntax for adding comments. Update the `SchemaEditor` for each backend to handle the new `db_column_comment` and `db_table_comment` options.\n   - For example, in `django/db/backends/oracle/schema.py`, you might need to add or modify methods to generate the correct SQL for Oracle.\n\n6. **Update `inspectdb` command:**\n   - Modify the `inspectdb` management command to output `db_column_comment` and `db_table_comment` when reverse-engineering a database schema.\n\n7. **Testing:**\n   - Write tests for the new functionality in `tests/schema/tests.py` and `tests/model_fields/tests.py`.\n   - Ensure that the new feature works with all supported databases and that existing functionality is not broken.\n\n8. **Documentation:**\n   - Update the Django documentation to include the new `db_column_comment` and `db_table_comment` options in the model field reference.\n\nHere's an example of how the model field definition might look after the changes:\n\n```python\nclass MyModel(models.Model):\n    my_field = models.CharField(max_length=100, db_column_comment='This is a column comment')\n    \n    class Meta:\n        db_table = 'my_model_table'\n        db_table_comment = 'This is a table comment'\n```\n\nAnd an example of the migration operation:\n\n```python\n# Generated by Django A.B on YYYY-MM-DD HH:MM\nfrom django.db import migrations\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ('myapp', 'previous_migration'),\n    ]\n\n    operations = [\n        migrations.AlterModelTableComment(\n            name='MyModel',\n            table_comment='This is a table comment',\n        ),\n    ]\n```\n\nThis is a high-level overview, and the actual implementation may require more detailed changes to the Django codebase.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [migrations](https://github.com/testbed/django__django__4.2/tree//django/db/migrations) \u2192 [operations](https://github.com/testbed/django__django__4.2/tree//django/db/migrations/operations)- [Lines 589 - 624](https://github.com/testbed/django__django__4.2/blob//django/db/migrations/operations/models.py#L589-L624)\n\n This snippet defines the AlterModelTableComment operation which is directly related to adding the ability to define comments on the table level.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [migrations](https://github.com/testbed/django__django__4.2/tree//django/db/migrations)- [Lines 1552 - 1683](https://github.com/testbed/django__django__4.2/blob//django/db/migrations/autodetector.py#L1552-L1683)\n\n This snippet is part of the autodetector for migrations and includes the logic to detect changes in table comments, which is necessary for the new feature.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [backends](https://github.com/testbed/django__django__4.2/tree//django/db/backends) \u2192 [base](https://github.com/testbed/django__django__4.2/tree//django/db/backends/base)- [Lines 1387 - 1954](https://github.com/testbed/django__django__4.2/blob//django/db/backends/base/schema.py#L1387-L1954)\n\n This snippet contains the method to alter column comments in the database schema, which is relevant to adding column-level comments. \n\n\n   - [Lines 145 - 204](https://github.com/testbed/django__django__4.2/blob//django/db/backends/base/schema.py#L145-L204)\n\n This snippet includes the SQL template for altering column comments, which will be used when implementing the new feature.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [core](https://github.com/testbed/django__django__4.2/tree//django/core) \u2192 [management](https://github.com/testbed/django__django__4.2/tree//django/core/management) \u2192 [commands](https://github.com/testbed/django__django__4.2/tree//django/core/management/commands)- [Lines 221 - 243](https://github.com/testbed/django__django__4.2/blob//django/core/management/commands/inspectdb.py#L221-L243)\n\n This snippet is from the inspectdb command and shows where the new db_comment field would be used to add comments to the generated model fields.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002515,
        "snippet_processor": 0.04448,
        "issue_star_creation": 0.02864,
        "issue_star_solver": 0.05598,
        "bouncer": 0.02446
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711718474.2166872,
        "relevant_snippets": [
            {
                "code": "class AlterModelTableComment(ModelOptionOperation):\n    def __init__(self, name, table_comment):\n        self.table_comment = table_comment\n        super().__init__(name)\n\n    def deconstruct(self):\n        kwargs = {\n            \"name\": self.name,\n            \"table_comment\": self.table_comment,\n        }\n        return (self.__class__.__qualname__, [], kwargs)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label, self.name_lower, {\"db_table_comment\": self.table_comment}\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            schema_editor.alter_db_table_comment(\n                new_model,\n                old_model._meta.db_table_comment,\n                new_model._meta.db_table_comment,\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def describe(self):\n        return f\"Alter {self.name} table comment\"\n\n    @property\n    def migration_name_fragment(self):\n        return f\"alter_{self.name_lower}_table_comment\"",
                "filename": "django/db/migrations/operations/models.py",
                "start_index": 21716,
                "end_index": 23100,
                "start_line": 589,
                "end_line": 624,
                "max_line": 1219,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "def generate_altered_db_table(self):\n        models_to_check = self.kept_model_keys.union(\n            self.kept_proxy_keys, self.kept_unmanaged_keys\n        )\n        for app_label, model_name in sorted(models_to_check):\n            old_model_name = self.renamed_models.get(\n                (app_label, model_name), model_name\n            )\n            old_model_state = self.from_state.models[app_label, old_model_name]\n            new_model_state = self.to_state.models[app_label, model_name]\n            old_db_table_name = old_model_state.options.get(\"db_table\")\n            new_db_table_name = new_model_state.options.get(\"db_table\")\n            if old_db_table_name != new_db_table_name:\n                self.add_operation(\n                    app_label,\n                    operations.AlterModelTable(\n                        name=model_name,\n                        table=new_db_table_name,\n                    ),\n                )\n\n    def generate_altered_db_table_comment(self):\n        models_to_check = self.kept_model_keys.union(\n            self.kept_proxy_keys, self.kept_unmanaged_keys\n        )\n        for app_label, model_name in sorted(models_to_check):\n            old_model_name = self.renamed_models.get(\n                (app_label, model_name), model_name\n            )\n            old_model_state = self.from_state.models[app_label, old_model_name]\n            new_model_state = self.to_state.models[app_label, model_name]\n\n            old_db_table_comment = old_model_state.options.get(\"db_table_comment\")\n            new_db_table_comment = new_model_state.options.get(\"db_table_comment\")\n            if old_db_table_comment != new_db_table_comment:\n                self.add_operation(\n                    app_label,\n                    operations.AlterModelTableComment(\n                        name=model_name,\n                        table_comment=new_db_table_comment,\n                    ),\n                )",
                "filename": "django/db/migrations/autodetector.py",
                "start_index": 69874,
                "end_index": 71815,
                "start_line": 1552,
                "end_line": 1683,
                "max_line": 1776,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else self.normalize_table_name(ref_db_table)\n                        )\n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n                        if rel_to in used_relations:\n                            extra_params[\"related_name\"] = \"%s_%s_set\" % (\n                                model_name.lower(),\n                                att_name,\n                            )\n                        used_relations.add(rel_to)\n                    else:\n                        # Calling `get_field_type` to get the field type string and any\n                        # additional parameters and notes.\n                        field_type, field_params, field_notes = self.get_field_type(\n                            connection, table_name, row\n                        )\n                        extra_params.update(field_params)\n                        comment_notes.extend(field_notes)\n\n                        field_type += \"(\"\n\n                    # Don't output 'id = meta.AutoField(primary_key=True)', because\n                    # that's assumed if it doesn't exist.\n                    if att_name == \"id\" and extra_params == {\"primary_key\": True}:\n                        if field_type == \"AutoField(\":\n                            continue\n                        elif (\n                            field_type\n                            == connection.features.introspected_field_types[\"AutoField\"]\n                            + \"(\"\n                        ):\n                            comment_notes.append(\"AutoField?\")\n\n                    # Add 'null' and 'blank', if the 'null_ok' flag was present in the\n                    # table description.\n                    if row.null_ok:  # If it's NULL...\n                        extra_params[\"blank\"] = True\n                        extra_params[\"null\"] = True",
                "filename": "django/core/management/commands/inspectdb.py",
                "start_index": 6783,
                "end_index": 9707,
                "start_line": 162,
                "end_line": 219,
                "max_line": 414,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _alter_column_comment_sql(self, model, new_field, new_type, new_db_comment):\n        return (\n            self.sql_alter_column_comment\n            % {\n                \"table\": self.quote_name(model._meta.db_table),\n                \"column\": self.quote_name(new_field.column),\n                \"comment\": self._comment_sql(new_db_comment),\n            },\n            [],\n        )\n\n    def _comment_sql(self, comment):\n        return self.quote_value(comment or \"\")\n\n    def _alter_many_to_many(self, model, old_field, new_field, strict):\n        \"\"\"Alter M2Ms to repoint their to= endpoints.\"\"\"\n        # Rename the through table\n        if (\n            old_field.remote_field.through._meta.db_table\n            != new_field.remote_field.through._meta.db_table\n        ):\n            self.alter_db_table(\n                old_field.remote_field.through,\n                old_field.remote_field.through._meta.db_table,\n                new_field.remote_field.through._meta.db_table,\n            )\n        # Repoint the FK to the other side\n        self.alter_field(\n            new_field.remote_field.through,\n            # The field that points to the target model is needed, so we can\n            # tell alter_field to change it - this is m2m_reverse_field_name()\n            # (as opposed to m2m_field_name(), which points to our model).\n            old_field.remote_field.through._meta.get_field(\n                old_field.m2m_reverse_field_name()\n            ),\n            new_field.remote_field.through._meta.get_field(\n                new_field.m2m_reverse_field_name()\n            ),\n        )\n        self.alter_field(\n            new_field.remote_field.through,\n            # for self-referential models we need to alter field from the other end too\n            old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),\n            new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),\n        )",
                "filename": "django/db/backends/base/schema.py",
                "start_index": 56966,
                "end_index": 58913,
                "start_line": 1387,
                "end_line": 1954,
                "max_line": 1967,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "sql_create_column = \"ALTER TABLE %(table)s ADD %(column)s %(definition)s\"\n    sql_alter_column_type = \"MODIFY %(column)s %(type)s%(collation)s\"\n    sql_alter_column_null = \"MODIFY %(column)s NULL\"\n    sql_alter_column_not_null = \"MODIFY %(column)s NOT NULL\"\n    sql_alter_column_default = \"MODIFY %(column)s DEFAULT %(default)s\"\n    sql_alter_column_no_default = \"MODIFY %(column)s DEFAULT NULL\"\n    sql_alter_column_no_default_null = sql_alter_column_no_default\n\n    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s\"\n    sql_create_column_inline_fk = (\n        \"CONSTRAINT %(name)s REFERENCES %(to_table)s(%(to_column)s)%(deferrable)s\"\n    )\n    sql_delete_table = \"DROP TABLE %(table)s CASCADE CONSTRAINTS\"\n    sql_create_index = \"CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s\"\n\n    def quote_value(self, value):\n        if isinstance(value, (datetime.date, datetime.time, datetime.datetime)):\n            return \"'%s'\" % value\n        elif isinstance(value, datetime.timedelta):\n            return \"'%s'\" % duration_iso_string(value)\n        elif isinstance(value, str):\n            return \"'%s'\" % value.replace(\"'\", \"''\")\n        elif isinstance(value, (bytes, bytearray, memoryview)):\n            return \"'%s'\" % value.hex()\n        elif isinstance(value, bool):\n            return \"1\" if value else \"0\"\n        else:\n            return str(value)\n\n    def remove_field(self, model, field):\n        # If the column is an identity column, drop the identity before\n        # removing the field.\n        if self._is_identity_column(model._meta.db_table, field.column):\n            self._drop_identity(model._meta.db_table, field.column)\n        super().remove_field(model, field)\n\n    def delete_model(self, model):\n        # Run superclass action\n        super().delete_model(model)\n        # Clean up manually created sequence.\n        self.execute(\n            \"\"\"\n            DECLARE\n                i INTEGER;\n            BEGIN\n                SELECT COUNT(1) INTO i FROM USER_SEQUENCES\n                    WHERE SEQUENCE_NAME = '%(sq_name)s';\n                IF i = 1 THEN\n                    EXECUTE IMMEDIATE 'DROP SEQUENCE \"%(sq_name)s\"';\n                END IF;\n            END;\n        /\"\"\"\n            % {\n                \"sq_name\": self.connection.ops._get_no_autofield_sequence_name(\n                    model._meta.db_table\n                )\n            }\n        )",
                "filename": "django/db/backends/oracle/schema.py",
                "start_index": 296,
                "end_index": 2708,
                "start_line": 14,
                "end_line": 246,
                "max_line": 252,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "comment = None\n                if info := table_info.get(table_name):\n                    is_view = info.type == \"v\"\n                    is_partition = info.type == \"p\"\n                    if connection.features.supports_comments:\n                        comment = info.comment\n                else:\n                    is_view = False\n                    is_partition = False\n                yield from self.get_meta(\n                    table_name,\n                    constraints,\n                    column_to_field_name,\n                    is_view,\n                    is_partition,\n                    comment,\n                )",
                "filename": "django/core/management/commands/inspectdb.py",
                "start_index": 10804,
                "end_index": 11439,
                "start_line": 244,
                "end_line": 394,
                "max_line": 414,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "sql_alter_column_comment = \"COMMENT ON COLUMN %(table)s.%(column)s IS %(comment)s\"\n\n    def __init__(self, connection, collect_sql=False, atomic=True):\n        self.connection = connection\n        self.collect_sql = collect_sql\n        if self.collect_sql:\n            self.collected_sql = []\n        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n\n    # State-managing methods\n\n    def __enter__(self):\n        self.deferred_sql = []\n        if self.atomic_migration:\n            self.atomic = atomic(self.connection.alias)\n            self.atomic.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is None:\n            for sql in self.deferred_sql:\n                self.execute(sql)\n        if self.atomic_migration:\n            self.atomic.__exit__(exc_type, exc_value, traceback)\n\n    # Core utility functions\n\n    def execute(self, sql, params=()):\n        \"\"\"Execute the given SQL statement, with optional parameters.\"\"\"\n        # Don't perform the transactional DDL check if SQL is being collected\n        # as it's not going to be executed anyway.\n        if (\n            not self.collect_sql\n            and self.connection.in_atomic_block\n            and not self.connection.features.can_rollback_ddl\n        ):\n            raise TransactionManagementError(\n                \"Executing DDL statements while in a transaction on databases \"\n                \"that can't perform a rollback is prohibited.\"\n            )\n        # Account for non-string statement objects.\n        sql = str(sql)\n        # Log the command we're running, then run it\n        logger.debug(\n            \"%s; (params %r)\", sql, params, extra={\"params\": params, \"sql\": sql}\n        )\n        if self.collect_sql:\n            ending = \"\" if sql.rstrip().endswith(\";\") else \";\"\n            if params is not None:\n                self.collected_sql.append(\n                    (sql % tuple(map(self.quote_value, params))) + ending\n                )\n            else:\n                self.collected_sql.append(sql + ending)\n        else:\n            with self.connection.cursor() as cursor:\n                cursor.execute(sql, params)\n\n    def quote_name(self, name):\n        return self.connection.ops.quote_name(name)",
                "filename": "django/db/backends/base/schema.py",
                "start_index": 5162,
                "end_index": 7448,
                "start_line": 145,
                "end_line": 204,
                "max_line": 1967,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "field_desc = \"%s = %s%s\" % (\n                        att_name,\n                        # Custom fields will have a dotted path\n                        \"\" if \".\" in field_type else \"models.\",\n                        field_type,\n                    )\n                    if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                        field_desc += \", models.DO_NOTHING\"\n\n                    # Add comment.\n                    if connection.features.supports_comments and row.comment:\n                        extra_params[\"db_comment\"] = row.comment\n\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n                    field_desc += \")\"\n                    if comment_notes:\n                        field_desc += \"  # \" + \" \".join(comment_notes)\n                    yield \"    %s\" % field_desc",
                "filename": "django/core/management/commands/inspectdb.py",
                "start_index": 9729,
                "end_index": 10787,
                "start_line": 221,
                "end_line": 243,
                "max_line": 414,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "from django.db import migrations, models\n\n\ndef add_legacy_name(apps, schema_editor):\n    alias = schema_editor.connection.alias\n    ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n    for ct in ContentType.objects.using(alias):\n        try:\n            ct.name = apps.get_model(ct.app_label, ct.model)._meta.object_name\n        except LookupError:\n            ct.name = ct.model\n        ct.save()\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"contenttypes\", \"0001_initial\"),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name=\"contenttype\",\n            options={\n                \"verbose_name\": \"content type\",\n                \"verbose_name_plural\": \"content types\",\n            },\n        ),\n        migrations.AlterField(\n            model_name=\"contenttype\",\n            name=\"name\",\n            field=models.CharField(max_length=100, null=True),\n        ),\n        migrations.RunPython(\n            migrations.RunPython.noop,\n            add_legacy_name,\n            hints={\"model_name\": \"contenttype\"},\n        ),\n        migrations.RemoveField(\n            model_name=\"contenttype\",\n            name=\"name\",\n        ),\n    ]",
                "filename": "django/contrib/contenttypes/migrations/0002_remove_content_type_name.py",
                "start_index": 0,
                "end_index": 1198,
                "start_line": 1,
                "end_line": 42,
                "max_line": 42,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "comment_notes = (\n                        []\n                    )  # Holds Field notes, to be displayed in a Python comment.\n                    extra_params = {}  # Holds Field parameters such as 'db_column'.\n                    column_name = row.name\n                    is_relation = column_name in relations\n\n                    att_name, params, notes = self.normalize_col_name(\n                        column_name, used_column_names, is_relation\n                    )\n                    extra_params.update(params)\n                    comment_notes.extend(notes)\n\n                    used_column_names.append(att_name)\n                    column_to_field_name[column_name] = att_name\n\n                    # Add primary_key and unique, if necessary.\n                    if column_name == primary_key_column:\n                        extra_params[\"primary_key\"] = True\n                        if len(primary_key_columns) > 1:\n                            comment_notes.append(\n                                \"The composite primary key (%s) found, that is not \"\n                                \"supported. The first column is selected.\"\n                                % \", \".join(primary_key_columns)\n                            )\n                    elif column_name in unique_columns:\n                        extra_params[\"unique\"] = True",
                "filename": "django/core/management/commands/inspectdb.py",
                "start_index": 5416,
                "end_index": 6761,
                "start_line": 134,
                "end_line": 160,
                "max_line": 414,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.2",
                "sha": "",
                "context_relevance": 0.7
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/db/migrations/operations/models.py": [
                {
                    "chunk": {
                        "code": "class AlterModelTableComment(ModelOptionOperation):\n    def __init__(self, name, table_comment):\n        self.table_comment = table_comment\n        super().__init__(name)\n\n    def deconstruct(self):\n        kwargs = {\n            \"name\": self.name,\n            \"table_comment\": self.table_comment,\n        }\n        return (self.__class__.__qualname__, [], kwargs)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label, self.name_lower, {\"db_table_comment\": self.table_comment}\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            schema_editor.alter_db_table_comment(\n                new_model,\n                old_model._meta.db_table_comment,\n                new_model._meta.db_table_comment,\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def describe(self):\n        return f\"Alter {self.name} table comment\"\n\n    @property\n    def migration_name_fragment(self):\n        return f\"alter_{self.name_lower}_table_comment\"",
                        "filename": "django/db/migrations/operations/models.py",
                        "start_index": 21716,
                        "end_index": 23100,
                        "start_line": 589,
                        "end_line": 624,
                        "max_line": 1219,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the AlterModelTableComment operation which is directly related to adding the ability to define comments on the table level."
                }
            ],
            "django/db/migrations/autodetector.py": [
                {
                    "chunk": {
                        "code": "def generate_altered_db_table(self):\n        models_to_check = self.kept_model_keys.union(\n            self.kept_proxy_keys, self.kept_unmanaged_keys\n        )\n        for app_label, model_name in sorted(models_to_check):\n            old_model_name = self.renamed_models.get(\n                (app_label, model_name), model_name\n            )\n            old_model_state = self.from_state.models[app_label, old_model_name]\n            new_model_state = self.to_state.models[app_label, model_name]\n            old_db_table_name = old_model_state.options.get(\"db_table\")\n            new_db_table_name = new_model_state.options.get(\"db_table\")\n            if old_db_table_name != new_db_table_name:\n                self.add_operation(\n                    app_label,\n                    operations.AlterModelTable(\n                        name=model_name,\n                        table=new_db_table_name,\n                    ),\n                )\n\n    def generate_altered_db_table_comment(self):\n        models_to_check = self.kept_model_keys.union(\n            self.kept_proxy_keys, self.kept_unmanaged_keys\n        )\n        for app_label, model_name in sorted(models_to_check):\n            old_model_name = self.renamed_models.get(\n                (app_label, model_name), model_name\n            )\n            old_model_state = self.from_state.models[app_label, old_model_name]\n            new_model_state = self.to_state.models[app_label, model_name]\n\n            old_db_table_comment = old_model_state.options.get(\"db_table_comment\")\n            new_db_table_comment = new_model_state.options.get(\"db_table_comment\")\n            if old_db_table_comment != new_db_table_comment:\n                self.add_operation(\n                    app_label,\n                    operations.AlterModelTableComment(\n                        name=model_name,\n                        table_comment=new_db_table_comment,\n                    ),\n                )",
                        "filename": "django/db/migrations/autodetector.py",
                        "start_index": 69874,
                        "end_index": 71815,
                        "start_line": 1552,
                        "end_line": 1683,
                        "max_line": 1776,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the autodetector for migrations and includes the logic to detect changes in table comments, which is necessary for the new feature."
                }
            ],
            "django/db/backends/base/schema.py": [
                {
                    "chunk": {
                        "code": "def _alter_column_comment_sql(self, model, new_field, new_type, new_db_comment):\n        return (\n            self.sql_alter_column_comment\n            % {\n                \"table\": self.quote_name(model._meta.db_table),\n                \"column\": self.quote_name(new_field.column),\n                \"comment\": self._comment_sql(new_db_comment),\n            },\n            [],\n        )\n\n    def _comment_sql(self, comment):\n        return self.quote_value(comment or \"\")\n\n    def _alter_many_to_many(self, model, old_field, new_field, strict):\n        \"\"\"Alter M2Ms to repoint their to= endpoints.\"\"\"\n        # Rename the through table\n        if (\n            old_field.remote_field.through._meta.db_table\n            != new_field.remote_field.through._meta.db_table\n        ):\n            self.alter_db_table(\n                old_field.remote_field.through,\n                old_field.remote_field.through._meta.db_table,\n                new_field.remote_field.through._meta.db_table,\n            )\n        # Repoint the FK to the other side\n        self.alter_field(\n            new_field.remote_field.through,\n            # The field that points to the target model is needed, so we can\n            # tell alter_field to change it - this is m2m_reverse_field_name()\n            # (as opposed to m2m_field_name(), which points to our model).\n            old_field.remote_field.through._meta.get_field(\n                old_field.m2m_reverse_field_name()\n            ),\n            new_field.remote_field.through._meta.get_field(\n                new_field.m2m_reverse_field_name()\n            ),\n        )\n        self.alter_field(\n            new_field.remote_field.through,\n            # for self-referential models we need to alter field from the other end too\n            old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),\n            new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),\n        )",
                        "filename": "django/db/backends/base/schema.py",
                        "start_index": 56966,
                        "end_index": 58913,
                        "start_line": 1387,
                        "end_line": 1954,
                        "max_line": 1967,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the method to alter column comments in the database schema, which is relevant to adding column-level comments."
                },
                {
                    "chunk": {
                        "code": "sql_alter_column_comment = \"COMMENT ON COLUMN %(table)s.%(column)s IS %(comment)s\"\n\n    def __init__(self, connection, collect_sql=False, atomic=True):\n        self.connection = connection\n        self.collect_sql = collect_sql\n        if self.collect_sql:\n            self.collected_sql = []\n        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n\n    # State-managing methods\n\n    def __enter__(self):\n        self.deferred_sql = []\n        if self.atomic_migration:\n            self.atomic = atomic(self.connection.alias)\n            self.atomic.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is None:\n            for sql in self.deferred_sql:\n                self.execute(sql)\n        if self.atomic_migration:\n            self.atomic.__exit__(exc_type, exc_value, traceback)\n\n    # Core utility functions\n\n    def execute(self, sql, params=()):\n        \"\"\"Execute the given SQL statement, with optional parameters.\"\"\"\n        # Don't perform the transactional DDL check if SQL is being collected\n        # as it's not going to be executed anyway.\n        if (\n            not self.collect_sql\n            and self.connection.in_atomic_block\n            and not self.connection.features.can_rollback_ddl\n        ):\n            raise TransactionManagementError(\n                \"Executing DDL statements while in a transaction on databases \"\n                \"that can't perform a rollback is prohibited.\"\n            )\n        # Account for non-string statement objects.\n        sql = str(sql)\n        # Log the command we're running, then run it\n        logger.debug(\n            \"%s; (params %r)\", sql, params, extra={\"params\": params, \"sql\": sql}\n        )\n        if self.collect_sql:\n            ending = \"\" if sql.rstrip().endswith(\";\") else \";\"\n            if params is not None:\n                self.collected_sql.append(\n                    (sql % tuple(map(self.quote_value, params))) + ending\n                )\n            else:\n                self.collected_sql.append(sql + ending)\n        else:\n            with self.connection.cursor() as cursor:\n                cursor.execute(sql, params)\n\n    def quote_name(self, name):\n        return self.connection.ops.quote_name(name)",
                        "filename": "django/db/backends/base/schema.py",
                        "start_index": 5162,
                        "end_index": 7448,
                        "start_line": 145,
                        "end_line": 204,
                        "max_line": 1967,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the SQL template for altering column comments, which will be used when implementing the new feature."
                }
            ],
            "django/core/management/commands/inspectdb.py": [
                {
                    "chunk": {
                        "code": "field_desc = \"%s = %s%s\" % (\n                        att_name,\n                        # Custom fields will have a dotted path\n                        \"\" if \".\" in field_type else \"models.\",\n                        field_type,\n                    )\n                    if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                        field_desc += \", models.DO_NOTHING\"\n\n                    # Add comment.\n                    if connection.features.supports_comments and row.comment:\n                        extra_params[\"db_comment\"] = row.comment\n\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n                    field_desc += \")\"\n                    if comment_notes:\n                        field_desc += \"  # \" + \" \".join(comment_notes)\n                    yield \"    %s\" % field_desc",
                        "filename": "django/core/management/commands/inspectdb.py",
                        "start_index": 9729,
                        "end_index": 10787,
                        "start_line": 221,
                        "end_line": 243,
                        "max_line": 414,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.2",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is from the inspectdb command and shows where the new db_comment field would be used to add comments to the generated model fields."
                }
            ]
        },
        "solution_task": "To implement the feature of adding comments to tables and columns in Django models, you can follow these steps:\n\n- Modify the Django model fields to accept a new argument `db_column_comment` for column comments and `db_table_comment` for table comments.\n- Update the Django ORM to handle these new arguments and include them in the appropriate SQL statements when creating or altering tables.\n- Extend the Django migration framework to detect changes in comments and generate the necessary migration operations.\n\nHere's a high-level overview of the implementation:\n\n1. **Extend Django Field class:**\n   - Modify the `Field` class in `django/db/models/fields/__init__.py` to accept a new keyword argument `db_column_comment`.\n   - Store the comment in the field instance to be used later during schema creation.\n\n2. **Handle table comments in Meta:**\n   - In the `Options` class in `django/db/models/options.py`, add support for a new attribute `db_table_comment`.\n   - Ensure that this attribute is included in the model's `_meta` options.\n\n3. **Update schema creation:**\n   - In `django/db/backends/base/schema.py`, modify the `create_model` method to include the table comment by using the `sql_create_table` template.\n   - Update the `_alter_column_comment_sql` method to generate the SQL for altering a column's comment.\n\n4. **Update migrations:**\n   - In `django/db/migrations/operations/models.py`, add a new operation `AlterModelTableComment` similar to the provided snippet.\n   - In `django/db/migrations/autodetector.py`, update the `generate_altered_db_table_comment` method to detect changes in `db_table_comment` and generate `AlterModelTableComment` operations.\n\n5. **Handle database-specific SQL:**\n   - Each database backend in `django/db/backends/` may require specific SQL syntax for adding comments. Update the `SchemaEditor` for each backend to handle the new `db_column_comment` and `db_table_comment` options.\n   - For example, in `django/db/backends/oracle/schema.py`, you might need to add or modify methods to generate the correct SQL for Oracle.\n\n6. **Update `inspectdb` command:**\n   - Modify the `inspectdb` management command to output `db_column_comment` and `db_table_comment` when reverse-engineering a database schema.\n\n7. **Testing:**\n   - Write tests for the new functionality in `tests/schema/tests.py` and `tests/model_fields/tests.py`.\n   - Ensure that the new feature works with all supported databases and that existing functionality is not broken.\n\n8. **Documentation:**\n   - Update the Django documentation to include the new `db_column_comment` and `db_table_comment` options in the model field reference.\n\nHere's an example of how the model field definition might look after the changes:\n\n```python\nclass MyModel(models.Model):\n    my_field = models.CharField(max_length=100, db_column_comment='This is a column comment')\n    \n    class Meta:\n        db_table = 'my_model_table'\n        db_table_comment = 'This is a table comment'\n```\n\nAnd an example of the migration operation:\n\n```python\n# Generated by Django A.B on YYYY-MM-DD HH:MM\nfrom django.db import migrations\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ('myapp', 'previous_migration'),\n    ]\n\n    operations = [\n        migrations.AlterModelTableComment(\n            name='MyModel',\n            table_comment='This is a table comment',\n        ),\n    ]\n```\n\nThis is a high-level overview, and the actual implementation may require more detailed changes to the Django codebase.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a comprehensive and detailed plan for implementing the feature of adding comments to tables and columns in Django models. It outlines specific steps to modify the Django model fields, update the ORM and migration framework, and handle database-specific SQL. The RESPONSE also includes high-level code snippets and examples of how the feature would be used, which adds to its utility. Furthermore, it addresses the need for documentation and testing, ensuring that the feature is well-integrated and functional. The only reason it does not score a 10 is that it does not explicitly mention how to handle potential backward compatibility issues or how to integrate this feature with existing Django projects that may require migrations to add comments to existing tables and columns.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711718579.773367,
        "result": "To implement the feature of adding comments to tables and columns in Django models, you can follow these steps:\n\n- Modify the Django model fields to accept a new argument `db_column_comment` for column comments and `db_table_comment` for table comments.\n- Update the Django ORM to handle these new arguments and include them in the appropriate SQL statements when creating or altering tables.\n- Extend the Django migration framework to detect changes in comments and generate the necessary migration operations.\n\nHere's a high-level overview of the implementation:\n\n1. **Extend Django Field class:**\n   - Modify the `Field` class in `django/db/models/fields/__init__.py` to accept a new keyword argument `db_column_comment`.\n   - Store the comment in the field instance to be used later during schema creation.\n\n2. **Handle table comments in Meta:**\n   - In the `Options` class in `django/db/models/options.py`, add support for a new attribute `db_table_comment`.\n   - Ensure that this attribute is included in the model's `_meta` options.\n\n3. **Update schema creation:**\n   - In `django/db/backends/base/schema.py`, modify the `create_model` method to include the table comment by using the `sql_create_table` template.\n   - Update the `_alter_column_comment_sql` method to generate the SQL for altering a column's comment.\n\n4. **Update migrations:**\n   - In `django/db/migrations/operations/models.py`, add a new operation `AlterModelTableComment` similar to the provided snippet.\n   - In `django/db/migrations/autodetector.py`, update the `generate_altered_db_table_comment` method to detect changes in `db_table_comment` and generate `AlterModelTableComment` operations.\n\n5. **Handle database-specific SQL:**\n   - Each database backend in `django/db/backends/` may require specific SQL syntax for adding comments. Update the `SchemaEditor` for each backend to handle the new `db_column_comment` and `db_table_comment` options.\n   - For example, in `django/db/backends/oracle/schema.py`, you might need to add or modify methods to generate the correct SQL for Oracle.\n\n6. **Update `inspectdb` command:**\n   - Modify the `inspectdb` management command to output `db_column_comment` and `db_table_comment` when reverse-engineering a database schema.\n\n7. **Testing:**\n   - Write tests for the new functionality in `tests/schema/tests.py` and `tests/model_fields/tests.py`.\n   - Ensure that the new feature works with all supported databases and that existing functionality is not broken.\n\n8. **Documentation:**\n   - Update the Django documentation to include the new `db_column_comment` and `db_table_comment` options in the model field reference.\n\nHere's an example of how the model field definition might look after the changes:\n\n```python\nclass MyModel(models.Model):\n    my_field = models.CharField(max_length=100, db_column_comment='This is a column comment')\n    \n    class Meta:\n        db_table = 'my_model_table'\n        db_table_comment = 'This is a table comment'\n```\n\nAnd an example of the migration operation:\n\n```python\n# Generated by Django A.B on YYYY-MM-DD HH:MM\nfrom django.db import migrations\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ('myapp', 'previous_migration'),\n    ]\n\n    operations = [\n        migrations.AlterModelTableComment(\n            name='MyModel',\n            table_comment='This is a table comment',\n        ),\n    ]\n```\n\nThis is a high-level overview, and the actual implementation may require more detailed changes to the Django codebase.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [migrations](https://github.com/testbed/django__django__4.2/tree//django/db/migrations) \u2192 [operations](https://github.com/testbed/django__django__4.2/tree//django/db/migrations/operations)- [Lines 589 - 624](https://github.com/testbed/django__django__4.2/blob//django/db/migrations/operations/models.py#L589-L624)\n\n This snippet defines the AlterModelTableComment operation which is directly related to adding the ability to define comments on the table level.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [migrations](https://github.com/testbed/django__django__4.2/tree//django/db/migrations)- [Lines 1552 - 1683](https://github.com/testbed/django__django__4.2/blob//django/db/migrations/autodetector.py#L1552-L1683)\n\n This snippet is part of the autodetector for migrations and includes the logic to detect changes in table comments, which is necessary for the new feature.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [db](https://github.com/testbed/django__django__4.2/tree//django/db) \u2192 [backends](https://github.com/testbed/django__django__4.2/tree//django/db/backends) \u2192 [base](https://github.com/testbed/django__django__4.2/tree//django/db/backends/base)- [Lines 1387 - 1954](https://github.com/testbed/django__django__4.2/blob//django/db/backends/base/schema.py#L1387-L1954)\n\n This snippet contains the method to alter column comments in the database schema, which is relevant to adding column-level comments. \n\n\n   - [Lines 145 - 204](https://github.com/testbed/django__django__4.2/blob//django/db/backends/base/schema.py#L145-L204)\n\n This snippet includes the SQL template for altering column comments, which will be used when implementing the new feature.\n-  \u2192 [django](https://github.com/testbed/django__django__4.2/tree//django) \u2192 [core](https://github.com/testbed/django__django__4.2/tree//django/core) \u2192 [management](https://github.com/testbed/django__django__4.2/tree//django/core/management) \u2192 [commands](https://github.com/testbed/django__django__4.2/tree//django/core/management/commands)- [Lines 221 - 243](https://github.com/testbed/django__django__4.2/blob//django/core/management/commands/inspectdb.py#L221-L243)\n\n This snippet is from the inspectdb command and shows where the new db_comment field would be used to add comments to the generated model fields.",
        "context_relevance": 0.67,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation of how to implement the feature of adding comments to tables and columns in Django models, which is exactly what the PROMPT is requesting. It includes steps for modifying the Django model fields, updating the ORM and migration framework, and even provides code snippets and examples. The RESPONSE is directly related to the PROMPT's request for a proposal on how to develop the code to allow Django users to specify comments for tables and columns."
        },
        "qa_relevance": 1.0
    }
}