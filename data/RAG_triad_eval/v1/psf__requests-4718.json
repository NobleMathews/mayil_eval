{
    "id": "psf__requests-4718",
    "repo_name": "testbed/psf__requests__2.19",
    "task_id": 2880176704263922195,
    "title": "Should Authorization header be cleared in https -> http redirect?",
    "body": "This may be considered intentional behaviour (in which case feel free to close this), but if a request is made to an https endpoint with authorization and it redirects to http on the same host, the Authorization header is not stripped and will be exposed on the wire.\r\n\r\n## Expected Result\r\n\r\nrebuild_auth would strip the Authorization header if the scheme is changed from https to http.\r\n\r\n## Actual Result\r\n\r\nThe credentials that were intended to be sent over TLS were transmitted in plaintext with the redirected request.\r\n\r\n## Reproduction Steps\r\n\r\nRun an HTTPS server on localhost:4443 that replies with a 302 redirect to `http://localhost:8000`, and a plain HTTP server (or netcat) on localhost:8000. Then run\r\n```python\r\nimport requests\r\nrequests.get('https://localhost:4443', auth=('hello', 'world'), verify=False)\r\n```\r\nThe basic auth credentials are sent in plaintext to `http://localhost:8000` (the `verify=False` is just because I had a self-signed cert).\r\n\r\nHere's the code I used for the SSL server:\r\n```python\r\nimport BaseHTTPServer\r\nimport ssl\r\n\r\nclass Handler(BaseHTTPServer.BaseHTTPRequestHandler):\r\n    def do_GET(self):\r\n        self.send_response(302)\r\n        self.send_header('Location', 'http://localhost:8000/')\r\n        self.end_headers()\r\n        self.wfile.write('')\r\n\r\nhttpd = BaseHTTPServer.HTTPServer(('localhost', 4443), Handler)\r\nhttpd.socket = ssl.wrap_socket (httpd.socket, server_side=True,\r\n                                certfile='yourpemfile.pem')\r\nhttpd.serve_forever()\r\n```\r\n\r\n## System Information\r\n\r\n```\r\n{\r\n  \"chardet\": {\r\n    \"version\": \"3.0.4\"\r\n  }, \r\n  \"cryptography\": {\r\n    \"version\": \"2.2.2\"\r\n  }, \r\n  \"idna\": {\r\n    \"version\": \"2.7\"\r\n  }, \r\n  \"implementation\": {\r\n    \"name\": \"CPython\", \r\n    \"version\": \"2.7.12\"\r\n  }, \r\n  \"platform\": {\r\n    \"release\": \"4.15.0-23-generic\", \r\n    \"system\": \"Linux\"\r\n  }, \r\n  \"pyOpenSSL\": {\r\n    \"openssl_version\": \"1010008f\", \r\n    \"version\": \"18.0.0\"\r\n  }, \r\n  \"requests\": {\r\n    \"version\": \"2.19.1\"\r\n  }, \r\n  \"system_ssl\": {\r\n    \"version\": \"1000207f\"\r\n  }, \r\n  \"urllib3\": {\r\n    \"version\": \"1.23\"\r\n  }, \r\n  \"using_pyopenssl\": true\r\n}\r\n```\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/psf__requests__2.19.git",
    "requested_commit": "",
    "mayil_response": "- Modify the `should_strip_auth` method in `requests/sessions.py` to ensure that the `Authorization` header is stripped when redirecting from `https` to `http`.\n- The current implementation allows `http` to `https` redirects on the same host without stripping the `Authorization` header. This behavior should be reversed to strip the header when changing from `https` to `http`.\n- Update the `should_strip_auth` method to return `True` when the scheme changes from `https` to `http`, regardless of the port numbers.\n\n```python\ndef should_strip_auth(self, old_url, new_url):\n    \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n    old_parsed = urlparse(old_url)\n    new_parsed = urlparse(new_url)\n    if old_parsed.hostname != new_parsed.hostname:\n        return True\n\n    # Change: Strip auth when redirecting from https to http\n    if old_parsed.scheme == \"https\" and new_parsed.scheme == \"http\":\n        return True\n\n    # Handle default port usage corresponding to scheme.\n    changed_port = old_parsed.port != new_parsed.port\n    changed_scheme = old_parsed.scheme != new_parsed.scheme\n    default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n    if (\n        not changed_scheme\n        and old_parsed.port in default_port\n        and new_parsed.port in default_port\n    ):\n        return False\n\n    # Standard case: root URI must match\n    return changed_port or changed_scheme\n```\n\n- Ensure that the `rebuild_auth` method in `requests/sessions.py` calls `should_strip_auth` and strips the `Authorization` header if the method returns `True`.\n\n```python\ndef rebuild_auth(self, prepared_request, response):\n    \"\"\"When being redirected we may want to strip authentication from the\n    request to avoid leaking credentials. This method intelligently removes\n    and reapplies authentication where possible to avoid credential loss.\n    \"\"\"\n    headers = prepared_request.headers\n    url = prepared_request.url\n\n    if \"Authorization\" in headers and self.should_strip_auth(\n        response.request.url, url\n    ):\n        del headers[\"Authorization\"]\n\n    # Existing code for handling .netrc and proxies remains unchanged\n    # ...\n```\n\n- These changes will ensure that the `Authorization` header is not sent over an unencrypted connection when a redirect from `https` to `http` occurs.\n\n### Code snippets to check\n\n-  \u2192 [requests](https://github.com/testbed/psf__requests__2.19/tree//requests)- [Lines 283 - 332](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L283-L332)\n\n This snippet contains the 'rebuild_auth' function which is responsible for stripping the Authorization header during redirects. The issue is related to the Authorization header not being stripped when redirecting from https to http, so this function is likely where the fix needs to be implemented. \n\n\n   - [Lines 107 - 157](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L107-L157)\n\n This snippet contains the 'should_strip_auth' function which determines whether the Authorization header should be removed when redirecting. It is directly related to the issue and may need to be modified to handle the https to http redirect case. \n\n\n   - [Lines 178 - 245](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L178-L245)\n\n This snippet is part of the redirect handling process in the 'Session' class. It shows how the 'rebuild_auth' and 'rebuild_method' functions are called during a redirect. It is necessary to understand how the redirect process works to address the issue. \n\n\n   - [Lines 159 - 520](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L159-L520)\n\n This snippet defines the 'resolve_redirects' function, which is the main loop for handling redirection. It is relevant to understand the overall redirection process and how the 'rebuild_auth' function is integrated into it.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000404,
        "snippet_processor": 0.059480000000000005,
        "issue_star_creation": 0.02412,
        "issue_star_solver": 0.06203,
        "bouncer": 0.02842
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711760687.8352268,
        "relevant_snippets": [
            {
                "code": "def rebuild_auth(self, prepared_request, response):\n        \"\"\"When being redirected we may want to strip authentication from the\n        request to avoid leaking credentials. This method intelligently removes\n        and reapplies authentication where possible to avoid credential loss.\n        \"\"\"\n        headers = prepared_request.headers\n        url = prepared_request.url\n\n        if \"Authorization\" in headers and self.should_strip_auth(\n            response.request.url, url\n        ):\n            # If we get redirected to a new host, we should strip out any\n            # authentication headers.\n            del headers[\"Authorization\"]\n\n        # .netrc might have more auth for us on our new host.\n        new_auth = get_netrc_auth(url) if self.trust_env else None\n        if new_auth is not None:\n            prepared_request.prepare_auth(new_auth)\n\n    def rebuild_proxies(self, prepared_request, proxies):\n        \"\"\"This method re-evaluates the proxy configuration by considering the\n        environment variables. If we are redirected to a URL covered by\n        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n        proxy keys for this URL (in case they were stripped by a previous\n        redirect).\n\n        This method also replaces the Proxy-Authorization header where\n        necessary.\n\n        :rtype: dict\n        \"\"\"\n        headers = prepared_request.headers\n        scheme = urlparse(prepared_request.url).scheme\n        new_proxies = resolve_proxies(prepared_request, proxies, self.trust_env)\n\n        if \"Proxy-Authorization\" in headers:\n            del headers[\"Proxy-Authorization\"]\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        # urllib3 handles proxy authorization for us in the standard adapter.\n        # Avoid appending this to TLS tunneled requests where it may be leaked.\n        if not scheme.startswith(\"https\") and username and password:\n            headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)\n\n        return new_proxies",
                "filename": "requests/sessions.py",
                "start_index": 10248,
                "end_index": 12379,
                "start_line": 283,
                "end_line": 332,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "def rebuild_method(self, prepared_request, response):\n        \"\"\"When being redirected we may want to change the method of the request\n        based on certain specs or browser behavior.\n        \"\"\"\n        method = prepared_request.method\n\n        # https://tools.ietf.org/html/rfc7231#section-6.4.4\n        if response.status_code == codes.see_other and method != \"HEAD\":\n            method = \"GET\"\n\n        # Do what the browsers do, despite standards...\n        # First, turn 302s into GETs.\n        if response.status_code == codes.found and method != \"HEAD\":\n            method = \"GET\"\n\n        # Second, if a POST is responded to with a 301, turn it into a GET.\n        # This bizarre behaviour is explained in Issue 1704.\n        if response.status_code == codes.moved and method == \"POST\":\n            method = \"GET\"\n\n        prepared_request.method = method",
                "filename": "requests/sessions.py",
                "start_index": 12385,
                "end_index": 13252,
                "start_line": 334,
                "end_line": 354,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def check_header_validity(header):\n    \"\"\"Verifies that header parts don't contain leading whitespace\n    reserved characters, or return characters.\n\n    :param header: tuple, in the format (name, value).\n    \"\"\"\n    name, value = header\n    _validate_header_part(header, name, 0)\n    _validate_header_part(header, value, 1)\n\n\ndef _validate_header_part(header, header_part, header_validator_index):\n    if isinstance(header_part, str):\n        validator = _HEADER_VALIDATORS_STR[header_validator_index]\n    elif isinstance(header_part, bytes):\n        validator = _HEADER_VALIDATORS_BYTE[header_validator_index]\n    else:\n        raise InvalidHeader(\n            f\"Header part ({header_part!r}) from {header} \"\n            f\"must be of type str or bytes, not {type(header_part)}\"\n        )\n\n    if not validator.match(header_part):\n        header_kind = \"name\" if header_validator_index == 0 else \"value\"\n        raise InvalidHeader(\n            f\"Invalid leading whitespace, reserved character(s), or return\"\n            f\"character(s) in header {header_kind}: {header_part!r}\"\n        )\n\n\ndef urldefragauth(url):\n    \"\"\"\n    Given a url remove the fragment and the authentication part.\n\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, params, query, fragment = urlparse(url)\n\n    # see func:`prepend_scheme_if_needed`\n    if not netloc:\n        netloc, path = path, netloc\n\n    netloc = netloc.rsplit(\"@\", 1)[-1]\n\n    return urlunparse((scheme, netloc, path, params, query, \"\"))\n\n\ndef rewind_body(prepared_request):\n    \"\"\"Move file pointer back to its recorded starting position\n    so it can be read again on redirect.\n    \"\"\"\n    body_seek = getattr(prepared_request.body, \"seek\", None)\n    if body_seek is not None and isinstance(\n        prepared_request._body_position, integer_types\n    ):\n        try:\n            body_seek(prepared_request._body_position)\n        except OSError:\n            raise UnrewindableBodyError(\n                \"An error occurred when rewinding request body for redirect.\"\n            )\n    else:\n        raise UnrewindableBodyError(\"Unable to rewind request body for redirect.\")",
                "filename": "requests/utils.py",
                "start_index": 31299,
                "end_index": 33417,
                "start_line": 1028,
                "end_line": 1090,
                "max_line": 1090,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "self.rebuild_auth(prepared_request, resp)\n\n            # A failed tell() sets `_body_position` to `object()`. This non-None\n            # value ensures `rewindable` will be True, allowing us to raise an\n            # UnrewindableBodyError, instead of hanging the connection.\n            rewindable = prepared_request._body_position is not None and (\n                \"Content-Length\" in headers or \"Transfer-Encoding\" in headers\n            )\n\n            # Attempt to rewind consumed file-like object.\n            if rewindable:\n                rewind_body(prepared_request)\n\n            # Override the original request.\n            req = prepared_request\n\n            if yield_requests:\n                yield req\n            else:\n\n                resp = self.send(\n                    req,\n                    stream=stream,\n                    timeout=timeout,\n                    verify=verify,\n                    cert=cert,\n                    proxies=proxies,\n                    allow_redirects=False,\n                    **adapter_kwargs,\n                )\n\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n                # extract redirect url, if any, for the next loop\n                url = self.get_redirect_target(resp)\n                yield resp",
                "filename": "requests/sessions.py",
                "start_index": 8948,
                "end_index": 10242,
                "start_line": 246,
                "end_line": 281,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)",
                "filename": "requests/sessions.py",
                "start_index": 5959,
                "end_index": 8935,
                "start_line": 178,
                "end_line": 245,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\nrequests.auth\n~~~~~~~~~~~~~\n\nThis module contains the authentication handlers for Requests.\n\"\"\"\n\nimport hashlib\nimport os\nimport re\nimport threading\nimport time\nimport warnings\nfrom base64 import b64encode\n\nfrom ._internal_utils import to_native_string\nfrom .compat import basestring, str, urlparse\nfrom .cookies import extract_cookies_to_jar\nfrom .utils import parse_dict_header\n\nCONTENT_TYPE_FORM_URLENCODED = \"application/x-www-form-urlencoded\"\nCONTENT_TYPE_MULTI_PART = \"multipart/form-data\"\n\n\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n    #\n    # These are here solely to maintain backwards compatibility\n    # for things like ints. This will be removed in 3.0.0.\n    if not isinstance(username, basestring):\n        warnings.warn(\n            \"Non-string usernames will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(username),\n            category=DeprecationWarning,\n        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n        username = username.encode(\"latin1\")\n\n    if isinstance(password, str):\n        password = password.encode(\"latin1\")\n\n    authstr = \"Basic \" + to_native_string(\n        b64encode(b\":\".join((username, password))).strip()\n    )\n\n    return authstr\n\n\nclass AuthBase:\n    \"\"\"Base class that all auth implementations derive from\"\"\"\n\n    def __call__(self, r):\n        raise NotImplementedError(\"Auth hooks must be callable.\")\n\n\nclass HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),\n            ]\n        )\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __call__(self, r):\n        r.headers[\"Authorization\"] = _basic_auth_str(self.username, self.password)\n        return r",
                "filename": "requests/auth.py",
                "start_index": 0,
                "end_index": 2848,
                "start_line": 1,
                "end_line": 304,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:\n            location = resp.headers[\"location\"]\n            # Currently the underlying http module on py3 decode headers\n            # in latin1, but empirical evidence suggests that latin1 is very\n            # rarely used with non-ASCII characters in HTTP headers.\n            # It is more likely to get UTF8 header rather than latin1.\n            # This causes incorrect handling of UTF8 encoded location headers.\n            # To solve this, we re-encode the location in latin1.\n            location = location.encode(\"latin1\")\n            return to_native_string(location, \"utf8\")\n        return None\n\n    def should_strip_auth(self, old_url, new_url):\n        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n        # breaking backwards compatibility with older versions of requests\n        # that allowed any redirects on the same host.\n        if (\n            old_parsed.scheme == \"http\"\n            and old_parsed.port in (80, None)\n            and new_parsed.scheme == \"https\"\n            and new_parsed.port in (443, None)\n        ):\n            return False\n\n        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (\n            not changed_scheme\n            and old_parsed.port in default_port\n            and new_parsed.port in default_port\n        ):\n            return False\n\n        # Standard case: root URI must match\n        return changed_port or changed_scheme",
                "filename": "requests/sessions.py",
                "start_index": 2997,
                "end_index": 5463,
                "start_line": 107,
                "end_line": 157,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "# .-. .-. .-. . . .-. .-. .-. .-.\n# |(  |-  |.| | | |-  `-.  |  `-.\n# ' ' `-' `-`.`-' `-' `-'  '  `-'\n\n__title__ = \"requests\"\n__description__ = \"Python HTTP for Humans.\"\n__url__ = \"https://requests.readthedocs.io\"\n__version__ = \"2.31.0\"\n__build__ = 0x023100\n__author__ = \"Kenneth Reitz\"\n__author_email__ = \"me@kennethreitz.org\"\n__license__ = \"Apache 2.0\"\n__copyright__ = \"Copyright Kenneth Reitz\"\n__cake__ = \"\\u2728 \\U0001f370 \\u2728\"",
                "filename": "requests/__version__.py",
                "start_index": 0,
                "end_index": 434,
                "start_line": 1,
                "end_line": 14,
                "max_line": 14,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):",
                "filename": "requests/sessions.py",
                "start_index": 5469,
                "end_index": 5701,
                "start_line": 159,
                "end_line": 520,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def handle_redirect(self, r, **kwargs):\n        \"\"\"Reset num_401_calls counter on redirects.\"\"\"\n        if r.is_redirect:\n            self._thread_local.num_401_calls = 1\n\n    def handle_401(self, r, **kwargs):\n        \"\"\"\n        Takes the given response and tries digest-auth, if needed.\n\n        :rtype: requests.Response\n        \"\"\"\n\n        # If response is not 4xx, do not auth\n        # See https://github.com/psf/requests/issues/3772\n        if not 400 <= r.status_code < 500:\n            self._thread_local.num_401_calls = 1\n            return r\n\n        if self._thread_local.pos is not None:\n            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get(\"www-authenticate\", \"\")\n\n        if \"digest\" in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n            self._thread_local.num_401_calls += 1\n            pat = re.compile(r\"digest \", flags=re.IGNORECASE)\n            self._thread_local.chal = parse_dict_header(pat.sub(\"\", s_auth, count=1))\n\n            # Consume content and release the original connection\n            # to allow our new request to reuse the same one.\n            r.content\n            r.close()\n            prep = r.request.copy()\n            extract_cookies_to_jar(prep._cookies, r.request, r.raw)\n            prep.prepare_cookies(prep._cookies)\n\n            prep.headers[\"Authorization\"] = self.build_digest_header(\n                prep.method, prep.url\n            )\n            _r = r.connection.send(prep, **kwargs)\n            _r.history.append(r)\n            _r.request = prep\n\n            return _r\n\n        self._thread_local.num_401_calls = 1\n        return r\n\n    def __call__(self, r):\n        # Initialize per-thread state, if needed\n        self.init_per_thread_state()\n        # If we have a saved nonce, skip the 401\n        if self._thread_local.last_nonce:\n            r.headers[\"Authorization\"] = self.build_digest_header(r.method, r.url)\n        try:\n            self._thread_local.pos = r.body.tell()\n        except AttributeError:\n            # In the case of HTTPDigestAuth being reused and the body of\n            # the previous request was a file-like object, pos has the\n            # file position of the previous body. Ensure it's set to\n            # None.\n            self._thread_local.pos = None\n        r.register_hook(\"response\", self.handle_401)\n        r.register_hook(\"response\", self.handle_redirect)\n        self._thread_local.num_401_calls = 1\n\n        return r\n\n    def __eq__(self, other):\n        return all(\n            [\n                self.username == getattr(other, \"username\", None),\n                self.password == getattr(other, \"password\", None),\n            ]\n        )\n\n    def __ne__(self, other):\n        return not self == other",
                "filename": "requests/auth.py",
                "start_index": 7314,
                "end_index": 10186,
                "start_line": 236,
                "end_line": 315,
                "max_line": 315,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__2.19",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "bug",
        "snippet_processor_task": {
            "requests/sessions.py": [
                {
                    "chunk": {
                        "code": "def rebuild_auth(self, prepared_request, response):\n        \"\"\"When being redirected we may want to strip authentication from the\n        request to avoid leaking credentials. This method intelligently removes\n        and reapplies authentication where possible to avoid credential loss.\n        \"\"\"\n        headers = prepared_request.headers\n        url = prepared_request.url\n\n        if \"Authorization\" in headers and self.should_strip_auth(\n            response.request.url, url\n        ):\n            # If we get redirected to a new host, we should strip out any\n            # authentication headers.\n            del headers[\"Authorization\"]\n\n        # .netrc might have more auth for us on our new host.\n        new_auth = get_netrc_auth(url) if self.trust_env else None\n        if new_auth is not None:\n            prepared_request.prepare_auth(new_auth)\n\n    def rebuild_proxies(self, prepared_request, proxies):\n        \"\"\"This method re-evaluates the proxy configuration by considering the\n        environment variables. If we are redirected to a URL covered by\n        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n        proxy keys for this URL (in case they were stripped by a previous\n        redirect).\n\n        This method also replaces the Proxy-Authorization header where\n        necessary.\n\n        :rtype: dict\n        \"\"\"\n        headers = prepared_request.headers\n        scheme = urlparse(prepared_request.url).scheme\n        new_proxies = resolve_proxies(prepared_request, proxies, self.trust_env)\n\n        if \"Proxy-Authorization\" in headers:\n            del headers[\"Proxy-Authorization\"]\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        # urllib3 handles proxy authorization for us in the standard adapter.\n        # Avoid appending this to TLS tunneled requests where it may be leaked.\n        if not scheme.startswith(\"https\") and username and password:\n            headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)\n\n        return new_proxies",
                        "filename": "requests/sessions.py",
                        "start_index": 10248,
                        "end_index": 12379,
                        "start_line": 283,
                        "end_line": 332,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.19",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'rebuild_auth' function which is responsible for stripping the Authorization header during redirects. The issue is related to the Authorization header not being stripped when redirecting from https to http, so this function is likely where the fix needs to be implemented."
                },
                {
                    "chunk": {
                        "code": "def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n        # attribute.\n        if resp.is_redirect:\n            location = resp.headers[\"location\"]\n            # Currently the underlying http module on py3 decode headers\n            # in latin1, but empirical evidence suggests that latin1 is very\n            # rarely used with non-ASCII characters in HTTP headers.\n            # It is more likely to get UTF8 header rather than latin1.\n            # This causes incorrect handling of UTF8 encoded location headers.\n            # To solve this, we re-encode the location in latin1.\n            location = location.encode(\"latin1\")\n            return to_native_string(location, \"utf8\")\n        return None\n\n    def should_strip_auth(self, old_url, new_url):\n        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n        # breaking backwards compatibility with older versions of requests\n        # that allowed any redirects on the same host.\n        if (\n            old_parsed.scheme == \"http\"\n            and old_parsed.port in (80, None)\n            and new_parsed.scheme == \"https\"\n            and new_parsed.port in (443, None)\n        ):\n            return False\n\n        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (\n            not changed_scheme\n            and old_parsed.port in default_port\n            and new_parsed.port in default_port\n        ):\n            return False\n\n        # Standard case: root URI must match\n        return changed_port or changed_scheme",
                        "filename": "requests/sessions.py",
                        "start_index": 2997,
                        "end_index": 5463,
                        "start_line": 107,
                        "end_line": 157,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.19",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'should_strip_auth' function which determines whether the Authorization header should be removed when redirecting. It is directly related to the issue and may need to be modified to handle the https to http redirect case."
                },
                {
                    "chunk": {
                        "code": "prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n\n            try:\n                resp.content  # Consume socket so it can be released\n            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):\n                resp.raw.read(decode_content=False)\n\n            if len(resp.history) >= self.max_redirects:\n                raise TooManyRedirects(\n                    f\"Exceeded {self.max_redirects} redirects.\", response=resp\n                )\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            # Handle redirection without scheme (see: RFC 1808 Section 4)\n            if url.startswith(\"//\"):\n                parsed_rurl = urlparse(resp.url)\n                url = \":\".join([to_native_string(parsed_rurl.scheme), url])\n\n            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)\n            parsed = urlparse(url)\n            if parsed.fragment == \"\" and previous_fragment:\n                parsed = parsed._replace(fragment=previous_fragment)\n            elif parsed.fragment:\n                previous_fragment = parsed.fragment\n            url = parsed.geturl()\n\n            # Facilitate relative 'location' headers, as allowed by RFC 7231.\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not parsed.netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            self.rebuild_method(prepared_request, resp)\n\n            # https://github.com/psf/requests/issues/1084\n            if resp.status_code not in (\n                codes.temporary_redirect,\n                codes.permanent_redirect,\n            ):\n                # https://github.com/psf/requests/issues/3490\n                purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            headers.pop(\"Cookie\", None)\n\n            # Extract any cookies sent on the response to the cookiejar\n            # in the new request. Because we've mutated our copied prepared\n            # request, use the old one that we haven't yet touched.\n            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)\n            merge_cookies(prepared_request._cookies, self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxy information.\n            proxies = self.rebuild_proxies(prepared_request, proxies)",
                        "filename": "requests/sessions.py",
                        "start_index": 5959,
                        "end_index": 8935,
                        "start_line": 178,
                        "end_line": 245,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.19",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is part of the redirect handling process in the 'Session' class. It shows how the 'rebuild_auth' and 'rebuild_method' functions are called during a redirect. It is necessary to understand how the redirect process works to address the issue."
                },
                {
                    "chunk": {
                        "code": "def resolve_redirects(\n        self,\n        resp,\n        req,\n        stream=False,\n        timeout=None,\n        verify=True,\n        cert=None,\n        proxies=None,\n        yield_requests=False,\n        **adapter_kwargs,\n    ):",
                        "filename": "requests/sessions.py",
                        "start_index": 5469,
                        "end_index": 5701,
                        "start_line": 159,
                        "end_line": 520,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__2.19",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the 'resolve_redirects' function, which is the main loop for handling redirection. It is relevant to understand the overall redirection process and how the 'rebuild_auth' function is integrated into it."
                }
            ]
        },
        "solution_task": "- Modify the `should_strip_auth` method in `requests/sessions.py` to ensure that the `Authorization` header is stripped when redirecting from `https` to `http`.\n- The current implementation allows `http` to `https` redirects on the same host without stripping the `Authorization` header. This behavior should be reversed to strip the header when changing from `https` to `http`.\n- Update the `should_strip_auth` method to return `True` when the scheme changes from `https` to `http`, regardless of the port numbers.\n\n```python\ndef should_strip_auth(self, old_url, new_url):\n    \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n    old_parsed = urlparse(old_url)\n    new_parsed = urlparse(new_url)\n    if old_parsed.hostname != new_parsed.hostname:\n        return True\n\n    # Change: Strip auth when redirecting from https to http\n    if old_parsed.scheme == \"https\" and new_parsed.scheme == \"http\":\n        return True\n\n    # Handle default port usage corresponding to scheme.\n    changed_port = old_parsed.port != new_parsed.port\n    changed_scheme = old_parsed.scheme != new_parsed.scheme\n    default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n    if (\n        not changed_scheme\n        and old_parsed.port in default_port\n        and new_parsed.port in default_port\n    ):\n        return False\n\n    # Standard case: root URI must match\n    return changed_port or changed_scheme\n```\n\n- Ensure that the `rebuild_auth` method in `requests/sessions.py` calls `should_strip_auth` and strips the `Authorization` header if the method returns `True`.\n\n```python\ndef rebuild_auth(self, prepared_request, response):\n    \"\"\"When being redirected we may want to strip authentication from the\n    request to avoid leaking credentials. This method intelligently removes\n    and reapplies authentication where possible to avoid credential loss.\n    \"\"\"\n    headers = prepared_request.headers\n    url = prepared_request.url\n\n    if \"Authorization\" in headers and self.should_strip_auth(\n        response.request.url, url\n    ):\n        del headers[\"Authorization\"]\n\n    # Existing code for handling .netrc and proxies remains unchanged\n    # ...\n```\n\n- These changes will ensure that the `Authorization` header is not sent over an unencrypted connection when a redirect from `https` to `http` occurs.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described bug to facilitate its resolution.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the issue described in the PROMPT. It suggests modifying the 'should_strip_auth' method to ensure the 'Authorization' header is stripped when redirecting from 'https' to 'http'. The RESPONSE includes a code snippet with the necessary changes, which is directly relevant to the bug. Additionally, it advises updating the 'rebuild_auth' method to call 'should_strip_auth' and act accordingly. The RESPONSE also references specific lines of code in the 'requests' library that are relevant to the issue, demonstrating a clear understanding of where the changes need to be made. The RESPONSE is comprehensive and addresses all aspects of the bug, providing a near-complete solution for resolving the issue.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711760746.678677,
        "result": "- Modify the `should_strip_auth` method in `requests/sessions.py` to ensure that the `Authorization` header is stripped when redirecting from `https` to `http`.\n- The current implementation allows `http` to `https` redirects on the same host without stripping the `Authorization` header. This behavior should be reversed to strip the header when changing from `https` to `http`.\n- Update the `should_strip_auth` method to return `True` when the scheme changes from `https` to `http`, regardless of the port numbers.\n\n```python\ndef should_strip_auth(self, old_url, new_url):\n    \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n    old_parsed = urlparse(old_url)\n    new_parsed = urlparse(new_url)\n    if old_parsed.hostname != new_parsed.hostname:\n        return True\n\n    # Change: Strip auth when redirecting from https to http\n    if old_parsed.scheme == \"https\" and new_parsed.scheme == \"http\":\n        return True\n\n    # Handle default port usage corresponding to scheme.\n    changed_port = old_parsed.port != new_parsed.port\n    changed_scheme = old_parsed.scheme != new_parsed.scheme\n    default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n    if (\n        not changed_scheme\n        and old_parsed.port in default_port\n        and new_parsed.port in default_port\n    ):\n        return False\n\n    # Standard case: root URI must match\n    return changed_port or changed_scheme\n```\n\n- Ensure that the `rebuild_auth` method in `requests/sessions.py` calls `should_strip_auth` and strips the `Authorization` header if the method returns `True`.\n\n```python\ndef rebuild_auth(self, prepared_request, response):\n    \"\"\"When being redirected we may want to strip authentication from the\n    request to avoid leaking credentials. This method intelligently removes\n    and reapplies authentication where possible to avoid credential loss.\n    \"\"\"\n    headers = prepared_request.headers\n    url = prepared_request.url\n\n    if \"Authorization\" in headers and self.should_strip_auth(\n        response.request.url, url\n    ):\n        del headers[\"Authorization\"]\n\n    # Existing code for handling .netrc and proxies remains unchanged\n    # ...\n```\n\n- These changes will ensure that the `Authorization` header is not sent over an unencrypted connection when a redirect from `https` to `http` occurs.\n\n### Code snippets to check\n\n-  \u2192 [requests](https://github.com/testbed/psf__requests__2.19/tree//requests)- [Lines 283 - 332](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L283-L332)\n\n This snippet contains the 'rebuild_auth' function which is responsible for stripping the Authorization header during redirects. The issue is related to the Authorization header not being stripped when redirecting from https to http, so this function is likely where the fix needs to be implemented. \n\n\n   - [Lines 107 - 157](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L107-L157)\n\n This snippet contains the 'should_strip_auth' function which determines whether the Authorization header should be removed when redirecting. It is directly related to the issue and may need to be modified to handle the https to http redirect case. \n\n\n   - [Lines 178 - 245](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L178-L245)\n\n This snippet is part of the redirect handling process in the 'Session' class. It shows how the 'rebuild_auth' and 'rebuild_method' functions are called during a redirect. It is necessary to understand how the redirect process works to address the issue. \n\n\n   - [Lines 159 - 520](https://github.com/testbed/psf__requests__2.19/blob//requests/sessions.py#L159-L520)\n\n This snippet defines the 'resolve_redirects' function, which is the main loop for handling redirection. It is relevant to understand the overall redirection process and how the 'rebuild_auth' function is integrated into it.",
        "context_relevance": 0.36000000000000004,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed solution to the issue described in the PROMPT, including code modifications and explanations for the changes. It addresses the expected result by suggesting a modification to the `should_strip_auth` method to strip the `Authorization` header when redirecting from `https` to `http`. The RESPONSE also includes a review of the relevant code snippets, directly tying the solution to the actual codebase in question, which is a critical part of the PROMPT. The RESPONSE is comprehensive and directly relevant to all aspects of the PROMPT, thus earning the highest score."
        },
        "qa_relevance": 1.0
    }
}