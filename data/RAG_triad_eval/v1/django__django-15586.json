{
    "id": "django__django-15586",
    "repo_name": "testbed/django__django__4.1",
    "task_id": 4365065603692211167,
    "title": "Enable cached template loader in development.",
    "body": "Description\n\t \n\t\t(last modified by Carlton Gibson)\n\t \nFollowing the changes to allow auto-reloading cached templates in #25791, there was discussion on \u200bPR 15140 to enable the cached template loader by default even in development. \n(Folks not wanting that would specify loaders.)\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__4.1.git",
    "requested_commit": "",
    "mayil_response": "To enable the cached template loader by default in development for a Django project, you can modify the settings to use the cached loader. Here's how you can implement this feature:\n\n- Modify the `TEMPLATES` configuration in your `settings.py` file to include the cached template loader.\n- Ensure that the `OPTIONS` dictionary within the `TEMPLATES` setting includes a `'loaders'` key with the cached loader and the loaders you want to cache.\n\nHere's an example of how you might configure the `TEMPLATES` setting:\n\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                # ... your context processors\n            ],\n            'loaders': [\n                ('django.template.loaders.cached.Loader', [\n                    'django.template.loaders.filesystem.Loader',\n                    'django.template.loaders.app_directories.Loader',\n                ]),\n            ],\n        },\n    },\n]\n```\n\n- In the above configuration, the `cached.Loader` is wrapping the `filesystem.Loader` and `app_directories.Loader`. This means that templates will be loaded from the filesystem and app directories and then cached.\n- Developers who do not want to use the cached loader in development can override the `loaders` option in their local settings or specify a different setting for development.\n\nRemember to test the changes thoroughly, as caching templates in development can sometimes hide changes made to templates until the server is restarted or the cache is cleared.\n\nFor further research, you can look into Django's documentation on template loaders:\n- [Django Template Loaders](https://docs.djangoproject.com/en/stable/ref/templates/api/#loader-types)\n- [Django Cached Template Loader](https://docs.djangoproject.com/en/stable/ref/templates/api/#django.template.loaders.cached.Loader)\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__4.1/tree//django/template) \u2192 [loaders](https://github.com/testbed/django__django__4.1/tree//django/template/loaders)- [Lines 15 - 70](https://github.com/testbed/django__django__4.1/blob//django/template/loaders/cached.py#L15-L70)\n\n This snippet is from the cached template loader implementation, which is directly related to the issue of enabling the cached template loader by default in development.\n-  \u2192 [django](https://github.com/testbed/django__django__4.1/tree//django) \u2192 [forms](https://github.com/testbed/django__django__4.1/tree//django/forms)- [Lines 103 - 110](https://github.com/testbed/django__django__4.1/blob//django/forms/renderers.py#L103-L110)\n\n This snippet shows the use of the template loader in the forms rendering context, which may need to be reviewed if changes to the template loading mechanism are made. \n\n\n   - [Lines 1 - 100](https://github.com/testbed/django__django__4.1/blob//django/forms/renderers.py#L1-L100)\n\n This snippet includes the default form renderer settings and may be relevant if the default template loading behavior is being modified as part of the issue.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.000368,
        "snippet_processor": 0.05754,
        "issue_star_creation": 0.017099999999999997,
        "issue_star_solver": 0.05033,
        "bouncer": 0.02452
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711718625.028238,
        "relevant_snippets": [
            {
                "code": "def __init__(self, engine, loaders):\n        self.get_template_cache = {}\n        self.loaders = engine.get_template_loaders(loaders)\n        super().__init__(engine)\n\n    def get_dirs(self):\n        for loader in self.loaders:\n            if hasattr(loader, \"get_dirs\"):\n                yield from loader.get_dirs()\n\n    def get_contents(self, origin):\n        return origin.loader.get_contents(origin)\n\n    def get_template(self, template_name, skip=None):\n        \"\"\"\n        Perform the caching that gives this loader its name. Often many of the\n        templates attempted will be missing, so memory use is of concern here.\n        To keep it in check, caching behavior is a little complicated when a\n        template is not found. See ticket #26306 for more details.\n\n        With template debugging disabled, cache the TemplateDoesNotExist class\n        for every missing template and raise a new instance of it after\n        fetching it from the cache.\n\n        With template debugging enabled, a unique TemplateDoesNotExist object\n        is cached for each missing template to preserve debug data. When\n        raising an exception, Python sets __traceback__, __context__, and\n        __cause__ attributes on it. Those attributes can contain references to\n        all sorts of objects up the call chain and caching them creates a\n        memory leak. Thus, unraised copies of the exceptions are cached and\n        copies of those copies are raised after they're fetched from the cache.\n        \"\"\"\n        key = self.cache_key(template_name, skip)\n        cached = self.get_template_cache.get(key)\n        if cached:\n            if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):\n                raise cached(template_name)\n            elif isinstance(cached, TemplateDoesNotExist):\n                raise copy_exception(cached)\n            return cached\n\n        try:\n            template = super().get_template(template_name, skip)\n        except TemplateDoesNotExist as e:\n            self.get_template_cache[key] = (\n                copy_exception(e) if self.engine.debug else TemplateDoesNotExist\n            )\n            raise\n        else:\n            self.get_template_cache[key] = template\n\n        return template\n\n    def get_template_sources(self, template_name):\n        for loader in self.loaders:\n            yield from loader.get_template_sources(template_name)",
                "filename": "django/template/loaders/cached.py",
                "start_index": 343,
                "end_index": 2753,
                "start_line": 15,
                "end_line": 70,
                "max_line": 100,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.8
            },
            {
                "code": "special: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
                "filename": "django/contrib/admin/static/admin/js/vendor/jquery/jquery.js",
                "start_index": 149955,
                "end_index": 151873,
                "start_line": 5578,
                "end_line": 10965,
                "max_line": 10965,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "'use strict';\n{\n    window.addEventListener('load', function(e) {\n\n        function setTheme(mode) {\n            if (mode !== \"light\" && mode !== \"dark\" && mode !== \"auto\") {\n                console.error(`Got invalid theme mode: ${mode}. Resetting to auto.`);\n                mode = \"auto\";\n            }\n            document.documentElement.dataset.theme = mode;\n            localStorage.setItem(\"theme\", mode);\n        }\n\n        function cycleTheme() {\n            const currentTheme = localStorage.getItem(\"theme\") || \"auto\";\n            const prefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n\n            if (prefersDark) {\n                // Auto (dark) -> Light -> Dark\n                if (currentTheme === \"auto\") {\n                    setTheme(\"light\");\n                } else if (currentTheme === \"light\") {\n                    setTheme(\"dark\");\n                } else {\n                    setTheme(\"auto\");\n                }\n            } else {\n                // Auto (light) -> Dark -> Light\n                if (currentTheme === \"auto\") {\n                    setTheme(\"dark\");\n                } else if (currentTheme === \"dark\") {\n                    setTheme(\"light\");\n                } else {\n                    setTheme(\"auto\");\n                }\n            }\n        }\n\n        function initTheme() {\n            // set theme defined in localStorage if there is one, or fallback to auto mode\n            const currentTheme = localStorage.getItem(\"theme\");\n            currentTheme ? setTheme(currentTheme) : setTheme(\"auto\");\n        }\n\n        function setupTheme() {\n            // Attach event handlers for toggling themes\n            const buttons = document.getElementsByClassName(\"theme-toggle\");\n            Array.from(buttons).forEach((btn) => {\n                btn.addEventListener(\"click\", cycleTheme);\n            });\n            initTheme();\n        }\n\n        setupTheme();\n    });\n}",
                "filename": "django/contrib/admin/static/admin/js/theme.js",
                "start_index": 0,
                "end_index": 1942,
                "start_line": 1,
                "end_line": 56,
                "max_line": 56,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "{\n  // This is needed so we can catch the AMD loader configuration and use it\n  // The inner file should be wrapped (by `banner.start.js`) in a function that\n  // returns the AMD loader references.",
                "filename": "django/contrib/admin/static/admin/js/vendor/select2/select2.full.js",
                "start_index": 1026,
                "end_index": 1223,
                "start_line": 8,
                "end_line": 37,
                "max_line": 6820,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "class TemplatesSetting(BaseRenderer):\n    \"\"\"\n    Load templates using template.loader.get_template() which is configured\n    based on settings.TEMPLATES.\n    \"\"\"\n\n    def get_template(self, template_name):\n        return get_template(template_name)",
                "filename": "django/forms/renderers.py",
                "start_index": 2953,
                "end_index": 3202,
                "start_line": 103,
                "end_line": 110,
                "max_line": 110,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import functools\nimport warnings\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.template.backends.django import DjangoTemplates\nfrom django.template.loader import get_template\nfrom django.utils.deprecation import RemovedInDjango60Warning\nfrom django.utils.functional import cached_property\nfrom django.utils.module_loading import import_string\n\n\n@functools.lru_cache\ndef get_default_renderer():\n    renderer_class = import_string(settings.FORM_RENDERER)\n    return renderer_class()\n\n\nclass BaseRenderer:\n    form_template_name = \"django/forms/div.html\"\n    formset_template_name = \"django/forms/formsets/div.html\"\n    field_template_name = \"django/forms/field.html\"\n\n    def get_template(self, template_name):\n        raise NotImplementedError(\"subclasses must implement get_template()\")\n\n    def render(self, template_name, context, request=None):\n        template = self.get_template(template_name)\n        return template.render(context, request=request).strip()\n\n\nclass EngineMixin:\n    def get_template(self, template_name):\n        return self.engine.get_template(template_name)\n\n    @cached_property\n    def engine(self):\n        return self.backend(\n            {\n                \"APP_DIRS\": True,\n                \"DIRS\": [Path(__file__).parent / self.backend.app_dirname],\n                \"NAME\": \"djangoforms\",\n                \"OPTIONS\": {},\n            }\n        )\n\n\nclass DjangoTemplates(EngineMixin, BaseRenderer):\n    \"\"\"\n    Load Django templates from the built-in widget templates in\n    django/forms/templates and from apps' 'templates' directory.\n    \"\"\"\n\n    backend = DjangoTemplates\n\n\nclass Jinja2(EngineMixin, BaseRenderer):\n    \"\"\"\n    Load Jinja2 templates from the built-in widget templates in\n    django/forms/jinja2 and from apps' 'jinja2' directory.\n    \"\"\"\n\n    @cached_property\n    def backend(self):\n        from django.template.backends.jinja2 import Jinja2\n\n        return Jinja2\n\n\n# RemovedInDjango60Warning.\nclass DjangoDivFormRenderer(DjangoTemplates):\n    \"\"\"\n    Load Django templates from django/forms/templates and from apps'\n    'templates' directory and use the 'div.html' template to render forms and\n    formsets.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"The DjangoDivFormRenderer transitional form renderer is deprecated. Use \"\n            \"DjangoTemplates instead.\",\n            RemovedInDjango60Warning,\n        )\n        super().__init__(*args, **kwargs)\n\n\n# RemovedInDjango60Warning.\nclass Jinja2DivFormRenderer(Jinja2):\n    \"\"\"\n    Load Jinja2 templates from the built-in widget templates in\n    django/forms/jinja2 and from apps' 'jinja2' directory.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"The Jinja2DivFormRenderer transitional form renderer is deprecated. Use \"\n            \"Jinja2 instead.\",\n            RemovedInDjango60Warning,\n        )\n        super().__init__(*args, **kwargs)",
                "filename": "django/forms/renderers.py",
                "start_index": 0,
                "end_index": 2950,
                "start_line": 1,
                "end_line": 100,
                "max_line": 110,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "var\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// trac-7653, trac-8125, trac-8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\noriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}",
                "filename": "django/contrib/admin/static/admin/js/vendor/jquery/jquery.js",
                "start_index": 242788,
                "end_index": 245768,
                "start_line": 25,
                "end_line": 10965,
                "max_line": 10965,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "{\n  // Restore the Select2 AMD loader so it can be used\n  // Needed mostly in the language files, where the loader is not inserted\n  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {\n    var S2 = jQuery.fn.select2.amd;\n  }\nvar S2;",
                "filename": "django/contrib/admin/static/admin/js/vendor/select2/select2.full.js",
                "start_index": 1247,
                "end_index": 1500,
                "start_line": 8,
                "end_line": 44,
                "max_line": 6820,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests",
                "filename": "django/contrib/admin/static/admin/js/vendor/jquery/jquery.js",
                "start_index": 271710,
                "end_index": 273600,
                "start_line": 10213,
                "end_line": 10294,
                "max_line": 10965,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "{\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method",
                "filename": "django/contrib/admin/static/admin/js/vendor/jquery/jquery.js",
                "start_index": 250212,
                "end_index": 252243,
                "start_line": 14,
                "end_line": 9459,
                "max_line": 10965,
                "git_instance": "github",
                "repo_name": "testbed/django__django__4.1",
                "sha": "",
                "context_relevance": 0.0
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/template/loaders/cached.py": [
                {
                    "chunk": {
                        "code": "def __init__(self, engine, loaders):\n        self.get_template_cache = {}\n        self.loaders = engine.get_template_loaders(loaders)\n        super().__init__(engine)\n\n    def get_dirs(self):\n        for loader in self.loaders:\n            if hasattr(loader, \"get_dirs\"):\n                yield from loader.get_dirs()\n\n    def get_contents(self, origin):\n        return origin.loader.get_contents(origin)\n\n    def get_template(self, template_name, skip=None):\n        \"\"\"\n        Perform the caching that gives this loader its name. Often many of the\n        templates attempted will be missing, so memory use is of concern here.\n        To keep it in check, caching behavior is a little complicated when a\n        template is not found. See ticket #26306 for more details.\n\n        With template debugging disabled, cache the TemplateDoesNotExist class\n        for every missing template and raise a new instance of it after\n        fetching it from the cache.\n\n        With template debugging enabled, a unique TemplateDoesNotExist object\n        is cached for each missing template to preserve debug data. When\n        raising an exception, Python sets __traceback__, __context__, and\n        __cause__ attributes on it. Those attributes can contain references to\n        all sorts of objects up the call chain and caching them creates a\n        memory leak. Thus, unraised copies of the exceptions are cached and\n        copies of those copies are raised after they're fetched from the cache.\n        \"\"\"\n        key = self.cache_key(template_name, skip)\n        cached = self.get_template_cache.get(key)\n        if cached:\n            if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):\n                raise cached(template_name)\n            elif isinstance(cached, TemplateDoesNotExist):\n                raise copy_exception(cached)\n            return cached\n\n        try:\n            template = super().get_template(template_name, skip)\n        except TemplateDoesNotExist as e:\n            self.get_template_cache[key] = (\n                copy_exception(e) if self.engine.debug else TemplateDoesNotExist\n            )\n            raise\n        else:\n            self.get_template_cache[key] = template\n\n        return template\n\n    def get_template_sources(self, template_name):\n        for loader in self.loaders:\n            yield from loader.get_template_sources(template_name)",
                        "filename": "django/template/loaders/cached.py",
                        "start_index": 343,
                        "end_index": 2753,
                        "start_line": 15,
                        "end_line": 70,
                        "max_line": 100,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet is from the cached template loader implementation, which is directly related to the issue of enabling the cached template loader by default in development."
                }
            ],
            "django/forms/renderers.py": [
                {
                    "chunk": {
                        "code": "class TemplatesSetting(BaseRenderer):\n    \"\"\"\n    Load templates using template.loader.get_template() which is configured\n    based on settings.TEMPLATES.\n    \"\"\"\n\n    def get_template(self, template_name):\n        return get_template(template_name)",
                        "filename": "django/forms/renderers.py",
                        "start_index": 2953,
                        "end_index": 3202,
                        "start_line": 103,
                        "end_line": 110,
                        "max_line": 110,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the use of the template loader in the forms rendering context, which may need to be reviewed if changes to the template loading mechanism are made."
                },
                {
                    "chunk": {
                        "code": "import functools\nimport warnings\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.template.backends.django import DjangoTemplates\nfrom django.template.loader import get_template\nfrom django.utils.deprecation import RemovedInDjango60Warning\nfrom django.utils.functional import cached_property\nfrom django.utils.module_loading import import_string\n\n\n@functools.lru_cache\ndef get_default_renderer():\n    renderer_class = import_string(settings.FORM_RENDERER)\n    return renderer_class()\n\n\nclass BaseRenderer:\n    form_template_name = \"django/forms/div.html\"\n    formset_template_name = \"django/forms/formsets/div.html\"\n    field_template_name = \"django/forms/field.html\"\n\n    def get_template(self, template_name):\n        raise NotImplementedError(\"subclasses must implement get_template()\")\n\n    def render(self, template_name, context, request=None):\n        template = self.get_template(template_name)\n        return template.render(context, request=request).strip()\n\n\nclass EngineMixin:\n    def get_template(self, template_name):\n        return self.engine.get_template(template_name)\n\n    @cached_property\n    def engine(self):\n        return self.backend(\n            {\n                \"APP_DIRS\": True,\n                \"DIRS\": [Path(__file__).parent / self.backend.app_dirname],\n                \"NAME\": \"djangoforms\",\n                \"OPTIONS\": {},\n            }\n        )\n\n\nclass DjangoTemplates(EngineMixin, BaseRenderer):\n    \"\"\"\n    Load Django templates from the built-in widget templates in\n    django/forms/templates and from apps' 'templates' directory.\n    \"\"\"\n\n    backend = DjangoTemplates\n\n\nclass Jinja2(EngineMixin, BaseRenderer):\n    \"\"\"\n    Load Jinja2 templates from the built-in widget templates in\n    django/forms/jinja2 and from apps' 'jinja2' directory.\n    \"\"\"\n\n    @cached_property\n    def backend(self):\n        from django.template.backends.jinja2 import Jinja2\n\n        return Jinja2\n\n\n# RemovedInDjango60Warning.\nclass DjangoDivFormRenderer(DjangoTemplates):\n    \"\"\"\n    Load Django templates from django/forms/templates and from apps'\n    'templates' directory and use the 'div.html' template to render forms and\n    formsets.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"The DjangoDivFormRenderer transitional form renderer is deprecated. Use \"\n            \"DjangoTemplates instead.\",\n            RemovedInDjango60Warning,\n        )\n        super().__init__(*args, **kwargs)\n\n\n# RemovedInDjango60Warning.\nclass Jinja2DivFormRenderer(Jinja2):\n    \"\"\"\n    Load Jinja2 templates from the built-in widget templates in\n    django/forms/jinja2 and from apps' 'jinja2' directory.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"The Jinja2DivFormRenderer transitional form renderer is deprecated. Use \"\n            \"Jinja2 instead.\",\n            RemovedInDjango60Warning,\n        )\n        super().__init__(*args, **kwargs)",
                        "filename": "django/forms/renderers.py",
                        "start_index": 0,
                        "end_index": 2950,
                        "start_line": 1,
                        "end_line": 100,
                        "max_line": 110,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__4.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the default form renderer settings and may be relevant if the default template loading behavior is being modified as part of the issue."
                }
            ]
        },
        "solution_task": "To enable the cached template loader by default in development for a Django project, you can modify the settings to use the cached loader. Here's how you can implement this feature:\n\n- Modify the `TEMPLATES` configuration in your `settings.py` file to include the cached template loader.\n- Ensure that the `OPTIONS` dictionary within the `TEMPLATES` setting includes a `'loaders'` key with the cached loader and the loaders you want to cache.\n\nHere's an example of how you might configure the `TEMPLATES` setting:\n\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                # ... your context processors\n            ],\n            'loaders': [\n                ('django.template.loaders.cached.Loader', [\n                    'django.template.loaders.filesystem.Loader',\n                    'django.template.loaders.app_directories.Loader',\n                ]),\n            ],\n        },\n    },\n]\n```\n\n- In the above configuration, the `cached.Loader` is wrapping the `filesystem.Loader` and `app_directories.Loader`. This means that templates will be loaded from the filesystem and app directories and then cached.\n- Developers who do not want to use the cached loader in development can override the `loaders` option in their local settings or specify a different setting for development.\n\nRemember to test the changes thoroughly, as caching templates in development can sometimes hide changes made to templates until the server is restarted or the cache is cleared.\n\nFor further research, you can look into Django's documentation on template loaders:\n- [Django Template Loaders](https://docs.djangoproject.com/en/stable/ref/templates/api/#loader-types)\n- [Django Cached Template Loader](https://docs.djangoproject.com/en/stable/ref/templates/api/#django.template.loaders.cached.Loader)",
        "bouncer_response": {
            "score": 8,
            "criteria": "The RESPONSE delivers precise, actionable, and highly relevant suggestions that can directly lead to the successful implementation or improvement of the requested feature.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable guide on how to enable the cached template loader by default in a Django project's development environment. It includes a detailed example of how to modify the `TEMPLATES` configuration in the `settings.py` file, which is directly relevant to the feature request. Additionally, the RESPONSE offers guidance on how developers can opt out of using the cached loader, which is a thoughtful consideration of different user preferences. The inclusion of links to Django's documentation and specific code snippets to check adds value by pointing to further resources for understanding and implementing the feature. The RESPONSE does not address all aspects of the feature request, such as the implications of enabling the cached loader by default and how to handle auto-reloading of cached templates, which were mentioned in the PROMPT. However, it does provide a substantial amount of actionable advice that is highly relevant to the feature request.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711718706.4125938,
        "result": "To enable the cached template loader by default in development for a Django project, you can modify the settings to use the cached loader. Here's how you can implement this feature:\n\n- Modify the `TEMPLATES` configuration in your `settings.py` file to include the cached template loader.\n- Ensure that the `OPTIONS` dictionary within the `TEMPLATES` setting includes a `'loaders'` key with the cached loader and the loaders you want to cache.\n\nHere's an example of how you might configure the `TEMPLATES` setting:\n\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                # ... your context processors\n            ],\n            'loaders': [\n                ('django.template.loaders.cached.Loader', [\n                    'django.template.loaders.filesystem.Loader',\n                    'django.template.loaders.app_directories.Loader',\n                ]),\n            ],\n        },\n    },\n]\n```\n\n- In the above configuration, the `cached.Loader` is wrapping the `filesystem.Loader` and `app_directories.Loader`. This means that templates will be loaded from the filesystem and app directories and then cached.\n- Developers who do not want to use the cached loader in development can override the `loaders` option in their local settings or specify a different setting for development.\n\nRemember to test the changes thoroughly, as caching templates in development can sometimes hide changes made to templates until the server is restarted or the cache is cleared.\n\nFor further research, you can look into Django's documentation on template loaders:\n- [Django Template Loaders](https://docs.djangoproject.com/en/stable/ref/templates/api/#loader-types)\n- [Django Cached Template Loader](https://docs.djangoproject.com/en/stable/ref/templates/api/#django.template.loaders.cached.Loader)\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__4.1/tree//django) \u2192 [template](https://github.com/testbed/django__django__4.1/tree//django/template) \u2192 [loaders](https://github.com/testbed/django__django__4.1/tree//django/template/loaders)- [Lines 15 - 70](https://github.com/testbed/django__django__4.1/blob//django/template/loaders/cached.py#L15-L70)\n\n This snippet is from the cached template loader implementation, which is directly related to the issue of enabling the cached template loader by default in development.\n-  \u2192 [django](https://github.com/testbed/django__django__4.1/tree//django) \u2192 [forms](https://github.com/testbed/django__django__4.1/tree//django/forms)- [Lines 103 - 110](https://github.com/testbed/django__django__4.1/blob//django/forms/renderers.py#L103-L110)\n\n This snippet shows the use of the template loader in the forms rendering context, which may need to be reviewed if changes to the template loading mechanism are made. \n\n\n   - [Lines 1 - 100](https://github.com/testbed/django__django__4.1/blob//django/forms/renderers.py#L1-L100)\n\n This snippet includes the default form renderer settings and may be relevant if the default template loading behavior is being modified as part of the issue.",
        "context_relevance": 0.15,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers it completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation of how to enable the cached template loader in a Django project, which is the main focus of the PROMPT. It includes a step-by-step guide and a code example that directly addresses the task described in the PROMPT. Additionally, the RESPONSE provides links to relevant sections of the Django documentation and GitHub code snippets, which are pertinent to the discussion of enabling the cached template loader by default in development. The RESPONSE is comprehensive and directly relevant to all aspects of the PROMPT, thus earning a score of 10."
        },
        "qa_relevance": 1.0
    }
}