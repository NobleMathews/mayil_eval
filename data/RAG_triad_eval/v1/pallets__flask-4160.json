{
    "id": "pallets__flask-4160",
    "repo_name": "testbed/pallets__flask__2.0",
    "task_id": 1058923485681305000,
    "title": "handle Decimal in json encoder",
    "body": "The `simplejson` removal (#3555) decreased the flask encoding capabilities as the built-in `json` doesn't cover cases like `Decimal` types. The solution seems to be: overwrite the flask app encoder with `JSONEnconder` from `simplejson`, but this incorporates a problem for users that relies on both `Decimal` and `datetimes` as `simplejon` doesn't handle `datetimes`, while flask encoder does. The solution I found is to build a custom encoder that tests if the value is `Decimal` and gives it to `simplejson`, otherwise, handles it with the default flask app encoder. My suggestion is to incorporate a simple test in the flask encoder to add `Decimal` coverage, that would remove any residual dependency on `simplejson`. The str(decimal) was taken from: [simplejson/encoder.py#L511](https://github.com/simplejson/simplejson/blob/8bef979ad8272cbc2903970f4b9992f603d50973/simplejson/encoder.py#L511)  \r\n\r\n```python\r\nfrom flask import json as fjson\r\nfrom flask.json import JSONEncoder\r\nimport simplejson as sjson\r\nimport decimal\r\nfrom datetime import datetime\r\n\r\nrdatetime = datetime.strptime('1/1/2008 1:30 PM', '%m/%d/%Y %I:%M %p')\r\nrdecimal = decimal.Decimal(10)\r\n\r\nobj = {'datetime':rdatetime,'decimal':rdecimal}\r\n\r\nfjson.dumps(obj) #Doesn't work because of decimal\r\nsjson.dumps(obj) #Doesn't work because of datetimes\r\n```  \r\nThe custom encoder:  \r\n```python\r\nclass CustomJSONEncoder(JSONEncoder):\r\n    '''\r\n    Add Decimal coverage\r\n    '''\r\n    def default(self, o):\r\n        if isinstance(o, decimal.Decimal):\r\n            return str(o)\r\n        return super().default(o)\r\n\r\napp.json_encoder = CustomJSONEncoder\r\n```  \r\n\r\nThe expected behavior is to work with both `Decimal` and `datetimes`  as it used to work on Flask version 1.1.2\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.8.10\r\n- Flask version: 2.0.1 and 1.1.2\r\n- Simplejson(Optional) version: 3.17.2\r\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/pallets__flask__2.0.git",
    "requested_commit": "",
    "mayil_response": "- Extend the `CustomJSONEncoder` class from Flask's `JSONEncoder` instead of `simplejson`'s `JSONEncoder`.\n- Implement the `default` method to handle both `decimal.Decimal` and `datetime.datetime` types.\n- Set the `app.json_encoder` to the new `CustomJSONEncoder` class.\n\n```python\nfrom flask.json import JSONEncoder\nimport decimal\nfrom datetime import datetime\n\nclass CustomJSONEncoder(JSONEncoder):\n    def default(self, o):\n        if isinstance(o, decimal.Decimal):\n            return str(o)\n        elif isinstance(o, datetime):\n            return o.isoformat()\n        return super().default(o)\n\napp.json_encoder = CustomJSONEncoder\n```\n\n### Code snippets to check\n\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.0/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.0/tree//src/flask) \u2192 [json](https://github.com/testbed/pallets__flask__2.0/tree//src/flask/json)- [Lines 107 - 120](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/provider.py#L107-L120)\n\n This snippet contains the '_default' function which is used to handle serialization of non-standard JSON types like 'Decimal' and 'UUID'. It is directly related to the issue of handling 'Decimal' types in JSON encoding. \n\n\n   - [Lines 19 - 86](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/provider.py#L19-L86)\n\n This snippet defines the 'JSONProvider' class which is the base class for JSON operations in Flask. Since the issue involves creating a custom JSON encoder, this class is relevant as it may need to be extended or modified. \n\n\n   - [Lines 124 - 188](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/provider.py#L124-L188)\n\n This snippet provides details on the default JSON operations using Python's built-in 'json' library and mentions additional data types that are serialized. It is relevant as it may need to be updated to include 'Decimal' type serialization.\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.0/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.0/tree//src/flask) \u2192 [json](https://github.com/testbed/pallets__flask__2.0/tree//src/flask/json)- [Lines 1 - 74](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/__init__.py#L1-L74)\n\n This snippet contains the 'dumps' function which serializes data as JSON. It is relevant because the issue is related to the serialization process and this function may need to be modified to use the custom JSON encoder.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0003915,
        "snippet_processor": 0.04809,
        "issue_star_creation": 0.02512,
        "issue_star_solver": 0.05501,
        "bouncer": 0.02568
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711742964.497376,
        "relevant_snippets": [
            {
                "code": "from __future__ import annotations\n\nimport dataclasses\nimport decimal\nimport json\nimport typing as t\nimport uuid\nimport weakref\nfrom datetime import date\n\nfrom werkzeug.http import http_date\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from ..sansio.app import App\n    from ..wrappers import Response",
                "filename": "src/flask/json/provider.py",
                "start_index": 0,
                "end_index": 300,
                "start_line": 1,
                "end_line": 15,
                "max_line": 216,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import Request as Request\nfrom .wrappers import Response as Response\n\n__version__ = \"3.0.0.dev\"",
                "filename": "src/flask/__init__.py",
                "start_index": 0,
                "end_index": 2098,
                "start_line": 1,
                "end_line": 41,
                "max_line": 41,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\nTagged JSON\n~~~~~~~~~~~\n\nA compact representation for lossless serialization of non-standard JSON\ntypes. :class:`~flask.sessions.SecureCookieSessionInterface` uses this\nto serialize the session data, but it may be useful in other places. It\ncan be extended to support other types.\n\n.. autoclass:: TaggedJSONSerializer\n    :members:\n\n.. autoclass:: JSONTag\n    :members:\n\nLet's see an example that adds support for\n:class:`~collections.OrderedDict`. Dicts don't have an order in JSON, so\nto handle this we will dump the items as a list of ``[key, value]``\npairs. Subclass :class:`JSONTag` and give it the new key ``' od'`` to\nidentify the type. The session serializer processes dicts first, so\ninsert the new tag at the front of the order since ``OrderedDict`` must\nbe processed before ``dict``.\n\n.. code-block:: python\n\n    from flask.json.tag import JSONTag\n\n    class TagOrderedDict(JSONTag):\n        __slots__ = ('serializer',)\n        key = ' od'\n\n        def check(self, value):\n            return isinstance(value, OrderedDict)\n\n        def to_json(self, value):\n            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]\n\n        def to_python(self, value):\n            return OrderedDict(value)\n\n    app.session_interface.serializer.register(TagOrderedDict, index=0)\n\"\"\"\nfrom __future__ import annotations\n\nimport typing as t\nfrom base64 import b64decode\nfrom base64 import b64encode\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom markupsafe import Markup\nfrom werkzeug.http import http_date\nfrom werkzeug.http import parse_date\n\nfrom ..json import dumps\nfrom ..json import loads\n\n\nclass JSONTag:\n    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n\n    __slots__ = (\"serializer\",)\n\n    #: The tag to mark the serialized object with. If ``None``, this tag is\n    #: only used as an intermediate step during tagging.\n    key: str | None = None\n\n    def __init__(self, serializer: TaggedJSONSerializer) -> None:\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer\n\n    def check(self, value: t.Any) -> bool:\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError\n\n    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n\n    def to_python(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n\n    def tag(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}",
                "filename": "src/flask/json/tag.py",
                "start_index": 0,
                "end_index": 2800,
                "start_line": 1,
                "end_line": 89,
                "max_line": 314,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from __future__ import annotations\n\nimport json as _json\nimport typing as t\n\nfrom ..globals import current_app\nfrom .provider import _default\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from ..wrappers import Response\n\n\ndef dumps(obj: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Serialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n    method, otherwise it will use :func:`json.dumps`.\n\n    :param obj: The data to serialize.\n    :param kwargs: Arguments passed to the ``dumps`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dumps``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.dumps(obj, **kwargs)\n\n    kwargs.setdefault(\"default\", _default)\n    return _json.dumps(obj, **kwargs)\n\n\ndef dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n    \"\"\"Serialize data as JSON and write to a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\n    method, otherwise it will use :func:`json.dump`.\n\n    :param obj: The data to serialize.\n    :param fp: A file opened for writing text. Should use the UTF-8\n        encoding to be valid JSON.\n    :param kwargs: Arguments passed to the ``dump`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dump``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        Writing to a binary file, and the ``encoding`` argument, will be\n        removed in Flask 2.1.\n    \"\"\"\n    if current_app:\n        current_app.json.dump(obj, fp, **kwargs)\n    else:\n        kwargs.setdefault(\"default\", _default)\n        _json.dump(obj, fp, **kwargs)",
                "filename": "src/flask/json/__init__.py",
                "start_index": 0,
                "end_index": 2279,
                "start_line": 1,
                "end_line": 74,
                "max_line": 170,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.9
            },
            {
                "code": "\"\"\"A standard set of JSON operations for an application. Subclasses\n    of this can be used to customize JSON behavior or use different\n    JSON libraries.\n\n    To implement a provider for a specific library, subclass this base\n    class and implement at least :meth:`dumps` and :meth:`loads`. All\n    other methods have default implementations.\n\n    To use a different provider, either subclass ``Flask`` and set\n    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n\n    :param app: An application instance. This will be stored as a\n        :class:`weakref.proxy` on the :attr:`_app` attribute.\n\n    .. versionadded:: 2.2\n    \"\"\"\n\n    def __init__(self, app: App) -> None:\n        self._app = weakref.proxy(app)\n\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON.\n\n        :param obj: The data to serialize.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n\n    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n        \"\"\"Serialize data as JSON and write to a file.\n\n        :param obj: The data to serialize.\n        :param fp: A file opened for writing text. Should use the UTF-8\n            encoding to be valid JSON.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        fp.write(self.dumps(obj, **kwargs))\n\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n\n    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON read from a file.\n\n        :param fp: A file opened for reading text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        return self.loads(fp.read(), **kwargs)\n\n    def _prepare_response_obj(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> t.Any:\n        if args and kwargs:\n            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n\n        if not args and not kwargs:\n            return None\n\n        if len(args) == 1:\n            return args[0]\n\n        return args or kwargs",
                "filename": "src/flask/json/provider.py",
                "start_index": 327,
                "end_index": 2736,
                "start_line": 19,
                "end_line": 86,
                "max_line": 216,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _default(o: t.Any) -> t.Any:\n    if isinstance(o, date):\n        return http_date(o)\n\n    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n        return str(o)\n\n    if dataclasses and dataclasses.is_dataclass(o):\n        return dataclasses.asdict(o)\n\n    if hasattr(o, \"__html__\"):\n        return str(o.__html__())\n\n    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")",
                "filename": "src/flask/json/provider.py",
                "start_index": 3515,
                "end_index": 3917,
                "start_line": 107,
                "end_line": 120,
                "max_line": 216,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "permanent_session_lifetime = ConfigAttribute(\n        \"PERMANENT_SESSION_LIFETIME\", get_converter=_make_timedelta\n    )\n\n    json_provider_class: type[JSONProvider] = DefaultJSONProvider\n    \"\"\"A subclass of :class:`~flask.json.provider.JSONProvider`. An\n    instance is created and assigned to :attr:`app.json` when creating\n    the app.\n\n    The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses\n    Python's built-in :mod:`json` library. A different provider can use\n    a different JSON library.\n\n    .. versionadded:: 2.2\n    \"\"\"\n\n    #: Options that are passed to the Jinja environment in\n    #: :meth:`create_jinja_environment`. Changing these options after\n    #: the environment is created (accessing :attr:`jinja_env`) will\n    #: have no effect.\n    #:\n    #: .. versionchanged:: 1.1.0\n    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow\n    #:     easier configuration.\n    #:\n    jinja_options: dict = {}\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: The map object to use for storing the URL rules and routing\n    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.\n    #:\n    #: .. versionadded:: 1.1.0\n    url_map_class = Map\n\n    #: The :meth:`test_client` method creates an instance of this test\n    #: client class. Defaults to :class:`~flask.testing.FlaskClient`.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class: type[FlaskClient] | None = None\n\n    #: The :class:`~click.testing.CliRunner` subclass, by default\n    #: :class:`~flask.testing.FlaskCliRunner` that is used by\n    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a\n    #: Flask app object as the first argument.\n    #:\n    #: .. versionadded:: 1.0\n    test_cli_runner_class: type[FlaskCliRunner] | None = None\n\n    default_config: dict\n    response_class: type[Response]",
                "filename": "src/flask/sansio/app.py",
                "start_index": 9676,
                "end_index": 11678,
                "start_line": 224,
                "end_line": 278,
                "max_line": 964,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def loads(s: str | bytes, **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\n    method, otherwise it will use :func:`json.loads`.\n\n    :param s: Text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``loads`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.loads``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The data must be a\n        string or UTF-8 bytes.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.loads(s, **kwargs)\n\n    return _json.loads(s, **kwargs)\n\n\ndef load(fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON read from a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\n    method, otherwise it will use :func:`json.load`.\n\n    :param fp: A file opened for reading text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``load`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.load``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.2\n        The ``app`` parameter will be removed in Flask 2.3.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The file must be text\n        mode, or binary mode with UTF-8 bytes.\n    \"\"\"\n    if current_app:\n        return current_app.json.load(fp, **kwargs)\n\n    return _json.load(fp, **kwargs)",
                "filename": "src/flask/json/__init__.py",
                "start_index": 2282,
                "end_index": 4206,
                "start_line": 77,
                "end_line": 135,
                "max_line": 170,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"Provide JSON operations using Python's built-in :mod:`json`\n    library. Serializes the following additional data types:\n\n    -   :class:`datetime.datetime` and :class:`datetime.date` are\n        serialized to :rfc:`822` strings. This is the same as the HTTP\n        date format.\n    -   :class:`uuid.UUID` is serialized to a string.\n    -   :class:`dataclasses.dataclass` is passed to\n        :func:`dataclasses.asdict`.\n    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n        method) will call the ``__html__`` method to get a string.\n    \"\"\"\n\n    default: t.Callable[[t.Any], t.Any] = staticmethod(\n        _default\n    )  # type: ignore[assignment]\n    \"\"\"Apply this function to any object that :meth:`json.dumps` does\n    not know how to serialize. It should return a valid JSON type or\n    raise a ``TypeError``.\n    \"\"\"\n\n    ensure_ascii = True\n    \"\"\"Replace non-ASCII characters with escape sequences. This may be\n    more compatible with some clients, but can be disabled for better\n    performance and size.\n    \"\"\"\n\n    sort_keys = True\n    \"\"\"Sort the keys in any serialized dicts. This may be useful for\n    some caching situations, but can be disabled for better performance.\n    When enabled, keys must all be strings, they are not converted\n    before sorting.\n    \"\"\"\n\n    compact: bool | None = None\n    \"\"\"If ``True``, or ``None`` out of debug mode, the :meth:`response`\n    output will not add indentation, newlines, or spaces. If ``False``,\n    or ``None`` in debug mode, it will use a non-compact representation.\n    \"\"\"\n\n    mimetype = \"application/json\"\n    \"\"\"The mimetype set in :meth:`response`.\"\"\"\n\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON to a string.\n\n        Keyword arguments are passed to :func:`json.dumps`. Sets some\n        parameter defaults from the :attr:`default`,\n        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.\n\n        :param obj: The data to serialize.\n        :param kwargs: Passed to :func:`json.dumps`.\n        \"\"\"\n        kwargs.setdefault(\"default\", self.default)\n        kwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)\n        kwargs.setdefault(\"sort_keys\", self.sort_keys)\n        return json.dumps(obj, **kwargs)\n\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON from a string or bytes.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: Passed to :func:`json.loads`.\n        \"\"\"\n        return json.loads(s, **kwargs)",
                "filename": "src/flask/json/provider.py",
                "start_index": 3965,
                "end_index": 6495,
                "start_line": 124,
                "end_line": 188,
                "max_line": 216,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "from flask import jsonify\nfrom flask import render_template\nfrom flask import request\n\nfrom js_example import app\n\n\n@app.route(\"/\", defaults={\"js\": \"fetch\"})\n@app.route(\"/<any(xhr, jquery, fetch):js>\")\ndef index(js):\n    return render_template(f\"{js}.html\", js=js)\n\n\n@app.route(\"/add\", methods=[\"POST\"])\ndef add():\n    a = request.form.get(\"a\", 0, type=float)\n    b = request.form.get(\"b\", 0, type=float)\n    return jsonify(result=a + b)",
                "filename": "examples/javascript/js_example/views.py",
                "start_index": 0,
                "end_index": 437,
                "start_line": 1,
                "end_line": 18,
                "max_line": 18,
                "git_instance": "github",
                "repo_name": "testbed/pallets__flask__2.0",
                "sha": "",
                "context_relevance": 0.2
            }
        ],
        "classification": "other",
        "snippet_processor_task": {
            "src/flask/json/provider.py": [
                {
                    "chunk": {
                        "code": "def _default(o: t.Any) -> t.Any:\n    if isinstance(o, date):\n        return http_date(o)\n\n    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n        return str(o)\n\n    if dataclasses and dataclasses.is_dataclass(o):\n        return dataclasses.asdict(o)\n\n    if hasattr(o, \"__html__\"):\n        return str(o.__html__())\n\n    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")",
                        "filename": "src/flask/json/provider.py",
                        "start_index": 3515,
                        "end_index": 3917,
                        "start_line": 107,
                        "end_line": 120,
                        "max_line": 216,
                        "git_instance": "github",
                        "repo_name": "testbed/pallets__flask__2.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the '_default' function which is used to handle serialization of non-standard JSON types like 'Decimal' and 'UUID'. It is directly related to the issue of handling 'Decimal' types in JSON encoding."
                },
                {
                    "chunk": {
                        "code": "\"\"\"A standard set of JSON operations for an application. Subclasses\n    of this can be used to customize JSON behavior or use different\n    JSON libraries.\n\n    To implement a provider for a specific library, subclass this base\n    class and implement at least :meth:`dumps` and :meth:`loads`. All\n    other methods have default implementations.\n\n    To use a different provider, either subclass ``Flask`` and set\n    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n\n    :param app: An application instance. This will be stored as a\n        :class:`weakref.proxy` on the :attr:`_app` attribute.\n\n    .. versionadded:: 2.2\n    \"\"\"\n\n    def __init__(self, app: App) -> None:\n        self._app = weakref.proxy(app)\n\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON.\n\n        :param obj: The data to serialize.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n\n    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n        \"\"\"Serialize data as JSON and write to a file.\n\n        :param obj: The data to serialize.\n        :param fp: A file opened for writing text. Should use the UTF-8\n            encoding to be valid JSON.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        fp.write(self.dumps(obj, **kwargs))\n\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n\n    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON read from a file.\n\n        :param fp: A file opened for reading text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        return self.loads(fp.read(), **kwargs)\n\n    def _prepare_response_obj(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> t.Any:\n        if args and kwargs:\n            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n\n        if not args and not kwargs:\n            return None\n\n        if len(args) == 1:\n            return args[0]\n\n        return args or kwargs",
                        "filename": "src/flask/json/provider.py",
                        "start_index": 327,
                        "end_index": 2736,
                        "start_line": 19,
                        "end_line": 86,
                        "max_line": 216,
                        "git_instance": "github",
                        "repo_name": "testbed/pallets__flask__2.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines the 'JSONProvider' class which is the base class for JSON operations in Flask. Since the issue involves creating a custom JSON encoder, this class is relevant as it may need to be extended or modified."
                },
                {
                    "chunk": {
                        "code": "\"\"\"Provide JSON operations using Python's built-in :mod:`json`\n    library. Serializes the following additional data types:\n\n    -   :class:`datetime.datetime` and :class:`datetime.date` are\n        serialized to :rfc:`822` strings. This is the same as the HTTP\n        date format.\n    -   :class:`uuid.UUID` is serialized to a string.\n    -   :class:`dataclasses.dataclass` is passed to\n        :func:`dataclasses.asdict`.\n    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n        method) will call the ``__html__`` method to get a string.\n    \"\"\"\n\n    default: t.Callable[[t.Any], t.Any] = staticmethod(\n        _default\n    )  # type: ignore[assignment]\n    \"\"\"Apply this function to any object that :meth:`json.dumps` does\n    not know how to serialize. It should return a valid JSON type or\n    raise a ``TypeError``.\n    \"\"\"\n\n    ensure_ascii = True\n    \"\"\"Replace non-ASCII characters with escape sequences. This may be\n    more compatible with some clients, but can be disabled for better\n    performance and size.\n    \"\"\"\n\n    sort_keys = True\n    \"\"\"Sort the keys in any serialized dicts. This may be useful for\n    some caching situations, but can be disabled for better performance.\n    When enabled, keys must all be strings, they are not converted\n    before sorting.\n    \"\"\"\n\n    compact: bool | None = None\n    \"\"\"If ``True``, or ``None`` out of debug mode, the :meth:`response`\n    output will not add indentation, newlines, or spaces. If ``False``,\n    or ``None`` in debug mode, it will use a non-compact representation.\n    \"\"\"\n\n    mimetype = \"application/json\"\n    \"\"\"The mimetype set in :meth:`response`.\"\"\"\n\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON to a string.\n\n        Keyword arguments are passed to :func:`json.dumps`. Sets some\n        parameter defaults from the :attr:`default`,\n        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.\n\n        :param obj: The data to serialize.\n        :param kwargs: Passed to :func:`json.dumps`.\n        \"\"\"\n        kwargs.setdefault(\"default\", self.default)\n        kwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)\n        kwargs.setdefault(\"sort_keys\", self.sort_keys)\n        return json.dumps(obj, **kwargs)\n\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON from a string or bytes.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: Passed to :func:`json.loads`.\n        \"\"\"\n        return json.loads(s, **kwargs)",
                        "filename": "src/flask/json/provider.py",
                        "start_index": 3965,
                        "end_index": 6495,
                        "start_line": 124,
                        "end_line": 188,
                        "max_line": 216,
                        "git_instance": "github",
                        "repo_name": "testbed/pallets__flask__2.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet provides details on the default JSON operations using Python's built-in 'json' library and mentions additional data types that are serialized. It is relevant as it may need to be updated to include 'Decimal' type serialization."
                }
            ],
            "src/flask/json/__init__.py": [
                {
                    "chunk": {
                        "code": "from __future__ import annotations\n\nimport json as _json\nimport typing as t\n\nfrom ..globals import current_app\nfrom .provider import _default\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from ..wrappers import Response\n\n\ndef dumps(obj: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Serialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n    method, otherwise it will use :func:`json.dumps`.\n\n    :param obj: The data to serialize.\n    :param kwargs: Arguments passed to the ``dumps`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dumps``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.dumps(obj, **kwargs)\n\n    kwargs.setdefault(\"default\", _default)\n    return _json.dumps(obj, **kwargs)\n\n\ndef dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n    \"\"\"Serialize data as JSON and write to a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\n    method, otherwise it will use :func:`json.dump`.\n\n    :param obj: The data to serialize.\n    :param fp: A file opened for writing text. Should use the UTF-8\n        encoding to be valid JSON.\n    :param kwargs: Arguments passed to the ``dump`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dump``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        Writing to a binary file, and the ``encoding`` argument, will be\n        removed in Flask 2.1.\n    \"\"\"\n    if current_app:\n        current_app.json.dump(obj, fp, **kwargs)\n    else:\n        kwargs.setdefault(\"default\", _default)\n        _json.dump(obj, fp, **kwargs)",
                        "filename": "src/flask/json/__init__.py",
                        "start_index": 0,
                        "end_index": 2279,
                        "start_line": 1,
                        "end_line": 74,
                        "max_line": 170,
                        "git_instance": "github",
                        "repo_name": "testbed/pallets__flask__2.0",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'dumps' function which serializes data as JSON. It is relevant because the issue is related to the serialization process and this function may need to be modified to use the custom JSON encoder."
                }
            ]
        },
        "solution_task": "- Extend the `CustomJSONEncoder` class from Flask's `JSONEncoder` instead of `simplejson`'s `JSONEncoder`.\n- Implement the `default` method to handle both `decimal.Decimal` and `datetime.datetime` types.\n- Set the `app.json_encoder` to the new `CustomJSONEncoder` class.\n\n```python\nfrom flask.json import JSONEncoder\nimport decimal\nfrom datetime import datetime\n\nclass CustomJSONEncoder(JSONEncoder):\n    def default(self, o):\n        if isinstance(o, decimal.Decimal):\n            return str(o)\n        elif isinstance(o, datetime):\n            return o.isoformat()\n        return super().default(o)\n\napp.json_encoder = CustomJSONEncoder\n```",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described bug to facilitate its resolution.",
            "supporting_evidence": "The RESPONSE provides a clear and actionable solution to the problem described in the PROMPT. It suggests extending the `CustomJSONEncoder` class from Flask's `JSONEncoder` and implementing the `default` method to handle both `decimal.Decimal` and `datetime.datetime` types. This directly addresses the issue of encoding `Decimal` and `datetime` objects in JSON after the removal of `simplejson`. The code snippet provided is relevant and would resolve the issue as described. Additionally, the RESPONSE includes references to the Flask GitHub repository, which could be useful for further understanding the Flask JSON encoding system. The only reason it does not score a 10 is that it does not explicitly mention testing the solution to ensure it works as expected, which is a minor detail but important for a complete solution.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711743030.4126668,
        "result": "- Extend the `CustomJSONEncoder` class from Flask's `JSONEncoder` instead of `simplejson`'s `JSONEncoder`.\n- Implement the `default` method to handle both `decimal.Decimal` and `datetime.datetime` types.\n- Set the `app.json_encoder` to the new `CustomJSONEncoder` class.\n\n```python\nfrom flask.json import JSONEncoder\nimport decimal\nfrom datetime import datetime\n\nclass CustomJSONEncoder(JSONEncoder):\n    def default(self, o):\n        if isinstance(o, decimal.Decimal):\n            return str(o)\n        elif isinstance(o, datetime):\n            return o.isoformat()\n        return super().default(o)\n\napp.json_encoder = CustomJSONEncoder\n```\n\n### Code snippets to check\n\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.0/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.0/tree//src/flask) \u2192 [json](https://github.com/testbed/pallets__flask__2.0/tree//src/flask/json)- [Lines 107 - 120](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/provider.py#L107-L120)\n\n This snippet contains the '_default' function which is used to handle serialization of non-standard JSON types like 'Decimal' and 'UUID'. It is directly related to the issue of handling 'Decimal' types in JSON encoding. \n\n\n   - [Lines 19 - 86](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/provider.py#L19-L86)\n\n This snippet defines the 'JSONProvider' class which is the base class for JSON operations in Flask. Since the issue involves creating a custom JSON encoder, this class is relevant as it may need to be extended or modified. \n\n\n   - [Lines 124 - 188](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/provider.py#L124-L188)\n\n This snippet provides details on the default JSON operations using Python's built-in 'json' library and mentions additional data types that are serialized. It is relevant as it may need to be updated to include 'Decimal' type serialization.\n-  \u2192 [src](https://github.com/testbed/pallets__flask__2.0/tree//src) \u2192 [flask](https://github.com/testbed/pallets__flask__2.0/tree//src/flask) \u2192 [json](https://github.com/testbed/pallets__flask__2.0/tree//src/flask/json)- [Lines 1 - 74](https://github.com/testbed/pallets__flask__2.0/blob//src/flask/json/__init__.py#L1-L74)\n\n This snippet contains the 'dumps' function which serializes data as JSON. It is relevant because the issue is related to the serialization process and this function may need to be modified to use the custom JSON encoder.",
        "context_relevance": 0.35000000000000003,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant and answers the entire PROMPT completely.\nSupporting Evidence: The RESPONSE provides a solution to the problem described in the PROMPT by extending the `CustomJSONEncoder` class from Flask's `JSONEncoder` and implementing the `default` method to handle both `decimal.Decimal` and `datetime.datetime` types. It then sets the `app.json_encoder` to the new `CustomJSONEncoder` class, which is the expected behavior described in the PROMPT. The code snippet is directly related to the issue of handling `Decimal` types in JSON encoding, as well as providing a solution for `datetimes`. The RESPONSE is fully relevant to the entire PROMPT and addresses all parts of the problem, including the environment specifications and the expected behavior."
        },
        "qa_relevance": 1.0
    }
}