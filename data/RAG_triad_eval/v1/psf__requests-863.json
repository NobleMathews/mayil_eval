{
    "id": "psf__requests-863",
    "repo_name": "testbed/psf__requests__0.14",
    "task_id": 3906245583173586036,
    "title": "Allow lists in the dict values of the hooks argument",
    "body": "Currently the Request class has a .register_hook() method but it parses the dictionary it expects from it's hooks argument weirdly: the argument can only specify one hook function per hook.  If you pass in a list of hook functions per hook the code in Request.**init**() will wrap the list in a list which then fails when the hooks are consumed (since a list is not callable).  This is especially annoying since you can not use multiple hooks from a session.  The only way to get multiple hooks now is to create the request object without sending it, then call .register_hook() multiple times and then finally call .send().\n\nThis would all be much easier if Request.**init**() parsed the hooks parameter in a way that it accepts lists as it's values.\n\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/psf__requests__0.14.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature that allows lists in the dict values of the hooks argument in the `Request` class, you need to modify the `Request.__init__` method to correctly handle lists of hook functions. Here's how you can do it:\n\n- Modify the `Request.__init__` method to accept lists of hook functions and register them properly.\n- Update the `RequestHooksMixin.register_hook` method to handle lists of hooks correctly.\n\nHere's the updated code for the `Request` class and the `RequestHooksMixin`:\n\n```python\n# In requests/models.py\n\nclass RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            # Extend the list with the iterable if it contains callables\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n        else:\n            raise ValueError(\"Hook must be callable or an iterable of callables\")\n\nclass Request(RequestHooksMixin):\n    # ... other parts of the class ...\n\n    def __init__(\n        self,\n        # ... other parameters ...\n        hooks=None,\n        # ... other parameters ...\n    ):\n        # ... existing initialization code ...\n\n        self.hooks = default_hooks()\n        if hooks:\n            for event, hook in hooks.items():\n                if isinstance(hook, list):\n                    # If the hook is a list, extend the list of hooks for the event\n                    for h in hook:\n                        self.register_hook(event, h)\n                else:\n                    # If the hook is not a list, register it directly\n                    self.register_hook(event, hook)\n\n        # ... rest of the __init__ method ...\n```\n\nWith these changes, the `Request` class will now be able to handle a dictionary of hooks where the values are lists of callable functions. Each function in the list will be registered as a hook for the corresponding event.\n\nRemember to add appropriate unit tests to ensure that the new functionality works as expected and does not introduce regressions.\n\n### Code snippets to check\n\n-  \u2192 [requests](https://github.com/testbed/psf__requests__0.14/tree//requests)- [Lines 206 - 767](https://github.com/testbed/psf__requests__0.14/blob//requests/models.py#L206-L767)\n\n This snippet contains the 'register_hook' method which is directly related to how hooks are registered and is likely where the logic needs to be updated to handle lists of hooks properly. \n\n\n   - [Lines 230 - 392](https://github.com/testbed/psf__requests__0.14/blob//requests/models.py#L230-L392)\n\n This snippet shows the '__init__' method of the 'Request' class where the 'hooks' parameter is processed and 'register_hook' is called, which is relevant to the issue. \n\n\n   - [Lines 573 - 638](https://github.com/testbed/psf__requests__0.14/blob//requests/models.py#L573-L638)\n\n This snippet contains the 'prepare_hooks' method in the 'PreparedRequest' class which is called during request preparation and may need to be checked for proper handling of lists of hooks.\n-  \u2192 [requests](https://github.com/testbed/psf__requests__0.14/tree//requests)- [Lines 1 - 103](https://github.com/testbed/psf__requests__0.14/blob//requests/sessions.py#L1-L103)\n\n This snippet includes the 'merge_hooks' function which merges request and session hooks and may need to be reviewed to ensure it handles lists of hooks correctly.\n-  \u2192 [requests](https://github.com/testbed/psf__requests__0.14/tree//requests)- [Lines 1 - 33](https://github.com/testbed/psf__requests__0.14/blob//requests/hooks.py#L1-L33)\n\n This snippet defines available hooks and the 'dispatch_hook' function which may need to be checked to ensure it can handle a list of hooks.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0002385,
        "snippet_processor": 0.0502,
        "issue_star_creation": 0.01576,
        "issue_star_solver": 0.0533,
        "bouncer": 0.025370000000000004
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711762024.3734012,
        "relevant_snippets": [
            {
                "code": "class RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n\n    def deregister_hook(self, event, hook):\n        \"\"\"Deregister a previously registered hook.\n        Returns True if the hook existed, False if not.\n        \"\"\"\n\n        try:\n            self.hooks[event].remove(hook)\n            return True\n        except ValueError:\n            return False",
                "filename": "requests/models.py",
                "start_index": 6054,
                "end_index": 6787,
                "start_line": 206,
                "end_line": 767,
                "max_line": 1034,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "\"\"\"\nrequests.hooks\n~~~~~~~~~~~~~~\n\nThis module provides the capabilities for the Requests hooks system.\n\nAvailable hooks:\n\n``response``:\n    The response generated from a Request.\n\"\"\"\nHOOKS = [\"response\"]\n\n\ndef default_hooks():\n    return {event: [] for event in HOOKS}\n\n\n# TODO: response is the only one\n\n\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if _hook_data is not None:\n                hook_data = _hook_data\n    return hook_data",
                "filename": "requests/hooks.py",
                "start_index": 0,
                "end_index": 732,
                "start_line": 1,
                "end_line": 33,
                "max_line": 33,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):",
                "filename": "requests/models.py",
                "start_index": 9463,
                "end_index": 9526,
                "start_line": 314,
                "end_line": 314,
                "max_line": 1034,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "\"\"\"\nrequests.sessions\n~~~~~~~~~~~~~~~~~\n\nThis module provides a Session object to manage and persist settings across\nrequests (cookies, auth, proxies).\n\"\"\"\nimport os\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom datetime import timedelta\n\nfrom ._internal_utils import to_native_string\nfrom .adapters import HTTPAdapter\nfrom .auth import _basic_auth_str\nfrom .compat import Mapping, cookielib, urljoin, urlparse\nfrom .cookies import (\n    RequestsCookieJar,\n    cookiejar_from_dict,\n    extract_cookies_to_jar,\n    merge_cookies,\n)\nfrom .exceptions import (\n    ChunkedEncodingError,\n    ContentDecodingError,\n    InvalidSchema,\n    TooManyRedirects,\n)\nfrom .hooks import default_hooks, dispatch_hook\n\n# formerly defined here, reexposed here for backward compatibility\nfrom .models import (  # noqa: F401\n    DEFAULT_REDIRECT_LIMIT,\n    REDIRECT_STATI,\n    PreparedRequest,\n    Request,\n)\nfrom .status_codes import codes\nfrom .structures import CaseInsensitiveDict\nfrom .utils import (  # noqa: F401\n    DEFAULT_PORTS,\n    default_headers,\n    get_auth_from_url,\n    get_environ_proxies,\n    get_netrc_auth,\n    requote_uri,\n    resolve_proxies,\n    rewind_body,\n    should_bypass_proxies,\n    to_key_val_list,\n)\n\n# Preferred clock, based on which one is more accurate on a given system.\nif sys.platform == \"win32\":\n    preferred_clock = time.perf_counter\nelse:\n    preferred_clock = time.time\n\n\ndef merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"Determines appropriate setting for a given request, taking into account\n    the explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n\n    if session_setting is None:\n        return request_setting\n\n    if request_setting is None:\n        return session_setting\n\n    # Bypass if not a dictionary (e.g. verify)\n    if not (\n        isinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)\n    ):\n        return request_setting\n\n    merged_setting = dict_class(to_key_val_list(session_setting))\n    merged_setting.update(to_key_val_list(request_setting))\n\n    # Remove keys that are set to None. Extract keys first to avoid altering\n    # the dictionary during iteration.\n    none_keys = [k for (k, v) in merged_setting.items() if v is None]\n    for key in none_keys:\n        del merged_setting[key]\n\n    return merged_setting\n\n\ndef merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n    \"\"\"Properly merges both requests and session hooks.\n\n    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get(\"response\") == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get(\"response\") == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)",
                "filename": "requests/sessions.py",
                "start_index": 0,
                "end_index": 2962,
                "start_line": 1,
                "end_line": 103,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "class Request(RequestHooksMixin):\n    \"\"\"A user-created :class:`Request <Request>` object.\n\n    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n    :param method: HTTP method to use.\n    :param url: URL to send.\n    :param headers: dictionary of headers to send.\n    :param files: dictionary of {filename: fileobject} files to multipart upload.\n    :param data: the body to attach to the request. If a dictionary or\n        list of tuples ``[(key, value)]`` is provided, form-encoding will\n        take place.\n    :param json: json for the body to attach to the request (if files or data is not specified).\n    :param params: URL parameters to append to the URL. If a dictionary or\n        list of tuples ``[(key, value)]`` is provided, form-encoding will\n        take place.\n    :param auth: Auth handler or (user, pass) tuple.\n    :param cookies: dictionary or CookieJar of cookies to attach to this request.\n    :param hooks: dictionary of callback hooks, for internal usage.\n\n    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n\n    def __init__(\n        self,\n        method=None,\n        url=None,\n        headers=None,\n        files=None,\n        data=None,\n        params=None,\n        auth=None,\n        cookies=None,\n        hooks=None,\n        json=None,\n    ):\n\n        # Default empty dicts for dict params.\n        data = [] if data is None else data\n        files = [] if files is None else files\n        headers = {} if headers is None else headers\n        params = {} if params is None else params\n        hooks = {} if hooks is None else hooks\n\n        self.hooks = default_hooks()\n        for (k, v) in list(hooks.items()):\n            self.register_hook(event=k, hook=v)\n\n        self.method = method\n        self.url = url\n        self.headers = headers\n        self.files = files\n        self.data = data\n        self.json = json\n        self.params = params\n        self.auth = auth\n        self.cookies = cookies\n\n    def __repr__(self):\n        return f\"<Request [{self.method}]>\"\n\n    def prepare(self):\n        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.\"\"\"\n        p = PreparedRequest()\n        p.prepare(\n            method=self.method,\n            url=self.url,\n            headers=self.headers,\n            files=self.files,\n            data=self.data,\n            json=self.json,\n            params=self.params,\n            auth=self.auth,\n            cookies=self.cookies,\n            hooks=self.hooks,\n        )\n        return p",
                "filename": "requests/models.py",
                "start_index": 6790,
                "end_index": 9460,
                "start_line": 230,
                "end_line": 392,
                "max_line": 1034,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.7
            },
            {
                "code": "def request(\n        self,\n        method,\n        url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None,\n    ):",
                "filename": "requests/sessions.py",
                "start_index": 18168,
                "end_index": 18527,
                "start_line": 502,
                "end_line": 520,
                "max_line": 835,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def prepare_content_length(self, body):\n        \"\"\"Prepare Content-Length header based on request method and body\"\"\"\n        if body is not None:\n            length = super_len(body)\n            if length:\n                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers[\"Content-Length\"] = builtin_str(length)\n        elif (\n            self.method not in (\"GET\", \"HEAD\")\n            and self.headers.get(\"Content-Length\") is None\n        ):\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers[\"Content-Length\"] = \"0\"\n\n    def prepare_auth(self, auth, url=\"\"):\n        \"\"\"Prepares the given HTTP auth data.\"\"\"\n\n        # If no Auth is explicitly provided, extract it from the URL first.\n        if auth is None:\n            url_auth = get_auth_from_url(self.url)\n            auth = url_auth if any(url_auth) else None\n\n        if auth:\n            if isinstance(auth, tuple) and len(auth) == 2:\n                # special-case basic HTTP auth\n                auth = HTTPBasicAuth(*auth)\n\n            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n            self.prepare_content_length(self.body)\n\n    def prepare_cookies(self, cookies):\n        \"\"\"Prepares the given HTTP cookie data.\n\n        This function eventually generates a ``Cookie`` header from the\n        given cookies using cookielib. Due to cookielib's design, the header\n        will not be regenerated if it already exists, meaning this function\n        can only be called once for the life of the\n        :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls\n        to ``prepare_cookies`` will have no actual effect, unless the \"Cookie\"\n        header is removed beforehand.\n        \"\"\"\n        if isinstance(cookies, cookielib.CookieJar):\n            self._cookies = cookies\n        else:\n            self._cookies = cookiejar_from_dict(cookies)\n\n        cookie_header = get_cookie_header(self._cookies, self)\n        if cookie_header is not None:\n            self.headers[\"Cookie\"] = cookie_header\n\n    def prepare_hooks(self, hooks):\n        \"\"\"Prepares the given hooks.\"\"\"\n        # hooks can be passed as None to the prepare method and to this\n        # method. To prevent iterating over None, simply use an empty list\n        # if hooks is False-y\n        hooks = hooks or []\n        for event in hooks:\n            self.register_hook(event, hooks[event])",
                "filename": "requests/models.py",
                "start_index": 18265,
                "end_index": 20952,
                "start_line": 573,
                "end_line": 638,
                "max_line": 1034,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 1.0
            },
            {
                "code": "class RequestEncodingMixin:",
                "filename": "requests/models.py",
                "start_index": 2127,
                "end_index": 2154,
                "start_line": 84,
                "end_line": 84,
                "max_line": 1034,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "def to_key_val_list(value):\n    \"\"\"Take an object and test to see if it can be represented as a\n    dictionary. If it can be, return a list of tuples, e.g.,\n\n    ::\n\n        >>> to_key_val_list([('key', 'val')])\n        [('key', 'val')]\n        >>> to_key_val_list({'key': 'val'})\n        [('key', 'val')]\n        >>> to_key_val_list('string')\n        Traceback (most recent call last):\n        ...\n        ValueError: cannot encode objects that are not 2-tuples\n\n    :rtype: list\n    \"\"\"\n    if value is None:\n        return None\n\n    if isinstance(value, (str, bytes, bool, int)):\n        raise ValueError(\"cannot encode objects that are not 2-tuples\")\n\n    if isinstance(value, Mapping):\n        value = value.items()\n\n    return list(value)\n\n\n# From mitsuhiko/werkzeug (used with permission).\ndef parse_list_header(value):\n    \"\"\"Parse lists as described by RFC 2068 Section 2.\n\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Quotes are removed automatically after parsing.\n\n    It basically works like :func:`parse_set_header` just that items\n    may appear multiple times and case sensitivity is preserved.\n\n    The return value is a standard :class:`list`:\n\n    >>> parse_list_header('token, \"quoted value\"')\n    ['token', 'quoted value']\n\n    To create a header from the :class:`list` again, use the\n    :func:`dump_header` function.\n\n    :param value: a string with a list header.\n    :return: :class:`list`\n    :rtype: list\n    \"\"\"\n    result = []\n    for item in _parse_list_header(value):\n        if item[:1] == item[-1:] == '\"':\n            item = unquote_header_value(item[1:-1])\n        result.append(item)\n    return result\n\n\n# From mitsuhiko/werkzeug (used with permission).\ndef parse_dict_header(value):\n    \"\"\"Parse lists of key, value pairs as described by RFC 2068 Section 2 and\n    convert them into a python dict:\n\n    >>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n    >>> type(d) is dict\n    True\n    >>> sorted(d.items())\n    [('bar', 'as well'), ('foo', 'is a fish')]\n\n    If there is no value for a key it will be `None`:\n\n    >>> parse_dict_header('key_without_value')\n    {'key_without_value': None}\n\n    To create a header from the :class:`dict` again, use the\n    :func:`dump_header` function.\n\n    :param value: a string with a dict header.\n    :return: :class:`dict`\n    :rtype: dict\n    \"\"\"\n    result = {}\n    for item in _parse_list_header(value):\n        if \"=\" not in item:\n            result[item] = None\n            continue\n        name, value = item.split(\"=\", 1)\n        if value[:1] == value[-1:] == '\"':\n            value = unquote_header_value(value[1:-1])\n        result[name] = value\n    return result\n\n\n# From mitsuhiko/werkzeug (used with permission).",
                "filename": "requests/utils.py",
                "start_index": 10907,
                "end_index": 13788,
                "start_line": 340,
                "end_line": 436,
                "max_line": 1090,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.1
            },
            {
                "code": "if sys.platform == \"win32\":\n    # provide a proxy_bypass version on Windows without DNS lookups\n\n    def proxy_bypass_registry(host):\n        try:\n            import winreg\n        except ImportError:\n            return False\n\n        try:\n            internetSettings = winreg.OpenKey(\n                winreg.HKEY_CURRENT_USER,\n                r\"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\",\n            )\n            # ProxyEnable could be REG_SZ or REG_DWORD, normalizing it\n            proxyEnable = int(winreg.QueryValueEx(internetSettings, \"ProxyEnable\")[0])\n            # ProxyOverride is almost always a string\n            proxyOverride = winreg.QueryValueEx(internetSettings, \"ProxyOverride\")[0]\n        except (OSError, ValueError):\n            return False\n        if not proxyEnable or not proxyOverride:\n            return False\n\n        # make a check value list from the registry entry: replace the\n        # '<local>' string by the localhost entry and the corresponding\n        # canonical entry.\n        proxyOverride = proxyOverride.split(\";\")\n        # now check if we match one of the registry values.\n        for test in proxyOverride:\n            if test == \"<local>\":\n                if \".\" not in host:\n                    return True\n            test = test.replace(\".\", r\"\\.\")  # mask dots\n            test = test.replace(\"*\", r\".*\")  # change glob sequence\n            test = test.replace(\"?\", r\".\")  # change glob char\n            if re.match(test, host, re.I):\n                return True\n        return False\n\n    def proxy_bypass(host):  # noqa\n        \"\"\"Return True, if the host should be bypassed.\n\n        Checks proxy settings gathered from the environment, if specified,\n        or the registry.\n        \"\"\"\n        if getproxies_environment():\n            return proxy_bypass_environment(host)\n        else:\n            return proxy_bypass_registry(host)\n\n\ndef dict_to_sequence(d):\n    \"\"\"Returns an internal sequence dictionary update.\"\"\"\n\n    if hasattr(d, \"items\"):\n        d = d.items()\n\n    return d",
                "filename": "requests/utils.py",
                "start_index": 1502,
                "end_index": 3560,
                "start_line": 73,
                "end_line": 130,
                "max_line": 1090,
                "git_instance": "github",
                "repo_name": "testbed/psf__requests__0.14",
                "sha": "",
                "context_relevance": 0.0
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "requests/models.py": [
                {
                    "chunk": {
                        "code": "class RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n\n    def deregister_hook(self, event, hook):\n        \"\"\"Deregister a previously registered hook.\n        Returns True if the hook existed, False if not.\n        \"\"\"\n\n        try:\n            self.hooks[event].remove(hook)\n            return True\n        except ValueError:\n            return False",
                        "filename": "requests/models.py",
                        "start_index": 6054,
                        "end_index": 6787,
                        "start_line": 206,
                        "end_line": 767,
                        "max_line": 1034,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__0.14",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'register_hook' method which is directly related to how hooks are registered and is likely where the logic needs to be updated to handle lists of hooks properly."
                },
                {
                    "chunk": {
                        "code": "class Request(RequestHooksMixin):\n    \"\"\"A user-created :class:`Request <Request>` object.\n\n    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.\n\n    :param method: HTTP method to use.\n    :param url: URL to send.\n    :param headers: dictionary of headers to send.\n    :param files: dictionary of {filename: fileobject} files to multipart upload.\n    :param data: the body to attach to the request. If a dictionary or\n        list of tuples ``[(key, value)]`` is provided, form-encoding will\n        take place.\n    :param json: json for the body to attach to the request (if files or data is not specified).\n    :param params: URL parameters to append to the URL. If a dictionary or\n        list of tuples ``[(key, value)]`` is provided, form-encoding will\n        take place.\n    :param auth: Auth handler or (user, pass) tuple.\n    :param cookies: dictionary or CookieJar of cookies to attach to this request.\n    :param hooks: dictionary of callback hooks, for internal usage.\n\n    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n\n    def __init__(\n        self,\n        method=None,\n        url=None,\n        headers=None,\n        files=None,\n        data=None,\n        params=None,\n        auth=None,\n        cookies=None,\n        hooks=None,\n        json=None,\n    ):\n\n        # Default empty dicts for dict params.\n        data = [] if data is None else data\n        files = [] if files is None else files\n        headers = {} if headers is None else headers\n        params = {} if params is None else params\n        hooks = {} if hooks is None else hooks\n\n        self.hooks = default_hooks()\n        for (k, v) in list(hooks.items()):\n            self.register_hook(event=k, hook=v)\n\n        self.method = method\n        self.url = url\n        self.headers = headers\n        self.files = files\n        self.data = data\n        self.json = json\n        self.params = params\n        self.auth = auth\n        self.cookies = cookies\n\n    def __repr__(self):\n        return f\"<Request [{self.method}]>\"\n\n    def prepare(self):\n        \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.\"\"\"\n        p = PreparedRequest()\n        p.prepare(\n            method=self.method,\n            url=self.url,\n            headers=self.headers,\n            files=self.files,\n            data=self.data,\n            json=self.json,\n            params=self.params,\n            auth=self.auth,\n            cookies=self.cookies,\n            hooks=self.hooks,\n        )\n        return p",
                        "filename": "requests/models.py",
                        "start_index": 6790,
                        "end_index": 9460,
                        "start_line": 230,
                        "end_line": 392,
                        "max_line": 1034,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__0.14",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet shows the '__init__' method of the 'Request' class where the 'hooks' parameter is processed and 'register_hook' is called, which is relevant to the issue."
                },
                {
                    "chunk": {
                        "code": "def prepare_content_length(self, body):\n        \"\"\"Prepare Content-Length header based on request method and body\"\"\"\n        if body is not None:\n            length = super_len(body)\n            if length:\n                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers[\"Content-Length\"] = builtin_str(length)\n        elif (\n            self.method not in (\"GET\", \"HEAD\")\n            and self.headers.get(\"Content-Length\") is None\n        ):\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers[\"Content-Length\"] = \"0\"\n\n    def prepare_auth(self, auth, url=\"\"):\n        \"\"\"Prepares the given HTTP auth data.\"\"\"\n\n        # If no Auth is explicitly provided, extract it from the URL first.\n        if auth is None:\n            url_auth = get_auth_from_url(self.url)\n            auth = url_auth if any(url_auth) else None\n\n        if auth:\n            if isinstance(auth, tuple) and len(auth) == 2:\n                # special-case basic HTTP auth\n                auth = HTTPBasicAuth(*auth)\n\n            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n            self.prepare_content_length(self.body)\n\n    def prepare_cookies(self, cookies):\n        \"\"\"Prepares the given HTTP cookie data.\n\n        This function eventually generates a ``Cookie`` header from the\n        given cookies using cookielib. Due to cookielib's design, the header\n        will not be regenerated if it already exists, meaning this function\n        can only be called once for the life of the\n        :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls\n        to ``prepare_cookies`` will have no actual effect, unless the \"Cookie\"\n        header is removed beforehand.\n        \"\"\"\n        if isinstance(cookies, cookielib.CookieJar):\n            self._cookies = cookies\n        else:\n            self._cookies = cookiejar_from_dict(cookies)\n\n        cookie_header = get_cookie_header(self._cookies, self)\n        if cookie_header is not None:\n            self.headers[\"Cookie\"] = cookie_header\n\n    def prepare_hooks(self, hooks):\n        \"\"\"Prepares the given hooks.\"\"\"\n        # hooks can be passed as None to the prepare method and to this\n        # method. To prevent iterating over None, simply use an empty list\n        # if hooks is False-y\n        hooks = hooks or []\n        for event in hooks:\n            self.register_hook(event, hooks[event])",
                        "filename": "requests/models.py",
                        "start_index": 18265,
                        "end_index": 20952,
                        "start_line": 573,
                        "end_line": 638,
                        "max_line": 1034,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__0.14",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains the 'prepare_hooks' method in the 'PreparedRequest' class which is called during request preparation and may need to be checked for proper handling of lists of hooks."
                }
            ],
            "requests/sessions.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\nrequests.sessions\n~~~~~~~~~~~~~~~~~\n\nThis module provides a Session object to manage and persist settings across\nrequests (cookies, auth, proxies).\n\"\"\"\nimport os\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom datetime import timedelta\n\nfrom ._internal_utils import to_native_string\nfrom .adapters import HTTPAdapter\nfrom .auth import _basic_auth_str\nfrom .compat import Mapping, cookielib, urljoin, urlparse\nfrom .cookies import (\n    RequestsCookieJar,\n    cookiejar_from_dict,\n    extract_cookies_to_jar,\n    merge_cookies,\n)\nfrom .exceptions import (\n    ChunkedEncodingError,\n    ContentDecodingError,\n    InvalidSchema,\n    TooManyRedirects,\n)\nfrom .hooks import default_hooks, dispatch_hook\n\n# formerly defined here, reexposed here for backward compatibility\nfrom .models import (  # noqa: F401\n    DEFAULT_REDIRECT_LIMIT,\n    REDIRECT_STATI,\n    PreparedRequest,\n    Request,\n)\nfrom .status_codes import codes\nfrom .structures import CaseInsensitiveDict\nfrom .utils import (  # noqa: F401\n    DEFAULT_PORTS,\n    default_headers,\n    get_auth_from_url,\n    get_environ_proxies,\n    get_netrc_auth,\n    requote_uri,\n    resolve_proxies,\n    rewind_body,\n    should_bypass_proxies,\n    to_key_val_list,\n)\n\n# Preferred clock, based on which one is more accurate on a given system.\nif sys.platform == \"win32\":\n    preferred_clock = time.perf_counter\nelse:\n    preferred_clock = time.time\n\n\ndef merge_setting(request_setting, session_setting, dict_class=OrderedDict):\n    \"\"\"Determines appropriate setting for a given request, taking into account\n    the explicit setting on that request, and the setting in the session. If a\n    setting is a dictionary, they will be merged together using `dict_class`\n    \"\"\"\n\n    if session_setting is None:\n        return request_setting\n\n    if request_setting is None:\n        return session_setting\n\n    # Bypass if not a dictionary (e.g. verify)\n    if not (\n        isinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)\n    ):\n        return request_setting\n\n    merged_setting = dict_class(to_key_val_list(session_setting))\n    merged_setting.update(to_key_val_list(request_setting))\n\n    # Remove keys that are set to None. Extract keys first to avoid altering\n    # the dictionary during iteration.\n    none_keys = [k for (k, v) in merged_setting.items() if v is None]\n    for key in none_keys:\n        del merged_setting[key]\n\n    return merged_setting\n\n\ndef merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n    \"\"\"Properly merges both requests and session hooks.\n\n    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get(\"response\") == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get(\"response\") == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)",
                        "filename": "requests/sessions.py",
                        "start_index": 0,
                        "end_index": 2962,
                        "start_line": 1,
                        "end_line": 103,
                        "max_line": 835,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__0.14",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet includes the 'merge_hooks' function which merges request and session hooks and may need to be reviewed to ensure it handles lists of hooks correctly."
                }
            ],
            "requests/hooks.py": [
                {
                    "chunk": {
                        "code": "\"\"\"\nrequests.hooks\n~~~~~~~~~~~~~~\n\nThis module provides the capabilities for the Requests hooks system.\n\nAvailable hooks:\n\n``response``:\n    The response generated from a Request.\n\"\"\"\nHOOKS = [\"response\"]\n\n\ndef default_hooks():\n    return {event: [] for event in HOOKS}\n\n\n# TODO: response is the only one\n\n\ndef dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if _hook_data is not None:\n                hook_data = _hook_data\n    return hook_data",
                        "filename": "requests/hooks.py",
                        "start_index": 0,
                        "end_index": 732,
                        "start_line": 1,
                        "end_line": 33,
                        "max_line": 33,
                        "git_instance": "github",
                        "repo_name": "testbed/psf__requests__0.14",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet defines available hooks and the 'dispatch_hook' function which may need to be checked to ensure it can handle a list of hooks."
                }
            ]
        },
        "solution_task": "To implement the feature that allows lists in the dict values of the hooks argument in the `Request` class, you need to modify the `Request.__init__` method to correctly handle lists of hook functions. Here's how you can do it:\n\n- Modify the `Request.__init__` method to accept lists of hook functions and register them properly.\n- Update the `RequestHooksMixin.register_hook` method to handle lists of hooks correctly.\n\nHere's the updated code for the `Request` class and the `RequestHooksMixin`:\n\n```python\n# In requests/models.py\n\nclass RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            # Extend the list with the iterable if it contains callables\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n        else:\n            raise ValueError(\"Hook must be callable or an iterable of callables\")\n\nclass Request(RequestHooksMixin):\n    # ... other parts of the class ...\n\n    def __init__(\n        self,\n        # ... other parameters ...\n        hooks=None,\n        # ... other parameters ...\n    ):\n        # ... existing initialization code ...\n\n        self.hooks = default_hooks()\n        if hooks:\n            for event, hook in hooks.items():\n                if isinstance(hook, list):\n                    # If the hook is a list, extend the list of hooks for the event\n                    for h in hook:\n                        self.register_hook(event, h)\n                else:\n                    # If the hook is not a list, register it directly\n                    self.register_hook(event, hook)\n\n        # ... rest of the __init__ method ...\n```\n\nWith these changes, the `Request` class will now be able to handle a dictionary of hooks where the values are lists of callable functions. Each function in the list will be registered as a hook for the corresponding event.\n\nRemember to add appropriate unit tests to ensure that the new functionality works as expected and does not introduce regressions.",
        "bouncer_response": {
            "score": 9,
            "criteria": "The RESPONSE must provide precise, actionable guidance and directly address all aspects of the described feature request to facilitate its successful implementation or improvement.",
            "supporting_evidence": "The RESPONSE provides a detailed and actionable solution to the feature request of allowing lists in the dict values of the hooks argument in the `Request` class. It includes specific code modifications for the `Request.__init__` method and the `RequestHooksMixin.register_hook` method, which are directly relevant to the feature request. The RESPONSE also suggests adding unit tests to ensure the new functionality works correctly, which is a valuable addition to the implementation process. Furthermore, the RESPONSE includes references to code snippets that should be checked, which is helpful for developers to locate the relevant sections of the codebase quickly. The only reason it does not score a 10 is that it does not explicitly mention updating documentation or providing examples of how to use the new feature, which would be the final touches to fully round out the feature's implementation.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711762060.668566,
        "result": "To implement the feature that allows lists in the dict values of the hooks argument in the `Request` class, you need to modify the `Request.__init__` method to correctly handle lists of hook functions. Here's how you can do it:\n\n- Modify the `Request.__init__` method to accept lists of hook functions and register them properly.\n- Update the `RequestHooksMixin.register_hook` method to handle lists of hooks correctly.\n\nHere's the updated code for the `Request` class and the `RequestHooksMixin`:\n\n```python\n# In requests/models.py\n\nclass RequestHooksMixin:\n    def register_hook(self, event, hook):\n        \"\"\"Properly register a hook.\"\"\"\n        if event not in self.hooks:\n            raise ValueError(f'Unsupported event specified, with event name \"{event}\"')\n\n        if isinstance(hook, Callable):\n            self.hooks[event].append(hook)\n        elif hasattr(hook, \"__iter__\"):\n            # Extend the list with the iterable if it contains callables\n            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))\n        else:\n            raise ValueError(\"Hook must be callable or an iterable of callables\")\n\nclass Request(RequestHooksMixin):\n    # ... other parts of the class ...\n\n    def __init__(\n        self,\n        # ... other parameters ...\n        hooks=None,\n        # ... other parameters ...\n    ):\n        # ... existing initialization code ...\n\n        self.hooks = default_hooks()\n        if hooks:\n            for event, hook in hooks.items():\n                if isinstance(hook, list):\n                    # If the hook is a list, extend the list of hooks for the event\n                    for h in hook:\n                        self.register_hook(event, h)\n                else:\n                    # If the hook is not a list, register it directly\n                    self.register_hook(event, hook)\n\n        # ... rest of the __init__ method ...\n```\n\nWith these changes, the `Request` class will now be able to handle a dictionary of hooks where the values are lists of callable functions. Each function in the list will be registered as a hook for the corresponding event.\n\nRemember to add appropriate unit tests to ensure that the new functionality works as expected and does not introduce regressions.\n\n### Code snippets to check\n\n-  \u2192 [requests](https://github.com/testbed/psf__requests__0.14/tree//requests)- [Lines 206 - 767](https://github.com/testbed/psf__requests__0.14/blob//requests/models.py#L206-L767)\n\n This snippet contains the 'register_hook' method which is directly related to how hooks are registered and is likely where the logic needs to be updated to handle lists of hooks properly. \n\n\n   - [Lines 230 - 392](https://github.com/testbed/psf__requests__0.14/blob//requests/models.py#L230-L392)\n\n This snippet shows the '__init__' method of the 'Request' class where the 'hooks' parameter is processed and 'register_hook' is called, which is relevant to the issue. \n\n\n   - [Lines 573 - 638](https://github.com/testbed/psf__requests__0.14/blob//requests/models.py#L573-L638)\n\n This snippet contains the 'prepare_hooks' method in the 'PreparedRequest' class which is called during request preparation and may need to be checked for proper handling of lists of hooks.\n-  \u2192 [requests](https://github.com/testbed/psf__requests__0.14/tree//requests)- [Lines 1 - 103](https://github.com/testbed/psf__requests__0.14/blob//requests/sessions.py#L1-L103)\n\n This snippet includes the 'merge_hooks' function which merges request and session hooks and may need to be reviewed to ensure it handles lists of hooks correctly.\n-  \u2192 [requests](https://github.com/testbed/psf__requests__0.14/tree//requests)- [Lines 1 - 33](https://github.com/testbed/psf__requests__0.14/blob//requests/hooks.py#L1-L33)\n\n This snippet defines available hooks and the 'dispatch_hook' function which may need to be checked to ensure it can handle a list of hooks.",
        "context_relevance": 0.37,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE must be relevant to the entire PROMPT and answer the entire PROMPT completely to get a score of 10.\nSupporting Evidence: The RESPONSE provides a detailed explanation and code modifications necessary to allow lists in the dict values of the hooks argument in the `Request` class, which is exactly what the PROMPT is asking for. It addresses the specific issue with the `Request.__init__` method and provides a solution to parse the hooks parameter to accept lists as its values. The RESPONSE also includes the update of the `RequestHooksMixin.register_hook` method to handle lists of hooks correctly, which is relevant to the PROMPT's request for handling multiple hooks. Additionally, the RESPONSE suggests adding unit tests to ensure the new functionality works as expected, which is a relevant and complete approach to the problem described in the PROMPT. The RESPONSE is therefore fully relevant to the entire PROMPT and deserves the highest score."
        },
        "qa_relevance": 1.0
    }
}