{
    "id": "django__django-12733",
    "repo_name": "testbed/django__django__3.1",
    "task_id": 2648323542994826098,
    "title": "Use PostgreSQL TRUNCATE \u2026 RESTART IDENTITY keyword to reset sequences in sql_flush()",
    "body": "Description\n\t\nRather than executing an additional query per truncated table, can truncate and reset sequences in a single query by using the RESTART IDENTITY syntax.\nMy project uses the sql_flush() operation internally and profiling shows that it can consume a large percentage of the runtime. Reducing the number of queries to one should help provide a small performance improvement.\n",
    "state": "closed",
    "repo_link": "https://github.com/testbed/django__django__3.1.git",
    "requested_commit": "",
    "mayil_response": "To implement the feature request to use PostgreSQL's `TRUNCATE \u2026 RESTART IDENTITY` keyword to reset sequences in `sql_flush()`, you need to modify the PostgreSQL backend operations in Django. Here's how you can do it:\n\n- Locate the `sql_flush` method in the `django/db/backends/postgresql/operations.py` file.\n- Modify the method to include the `RESTART IDENTITY` clause when `reset_sequences` is `True`.\n- Ensure that the `TRUNCATE` command is used instead of `DELETE` when `reset_sequences` is `True`.\n\nHere's a code snippet that demonstrates the changes:\n\n```python\n# django/db/backends/postgresql/operations.py\n\ndef sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):\n    if not tables:\n        return []\n\n    sql = []\n    if reset_sequences:\n        # Use TRUNCATE with RESTART IDENTITY to reset sequences\n        sql.extend(\n            \"%s %s %s;\"\n            % (\n                style.SQL_KEYWORD(\"TRUNCATE\"),\n                style.SQL_FIELD(self.quote_name(table_name)),\n                style.SQL_KEYWORD(\"RESTART IDENTITY\"),\n            )\n            for table_name in tables\n        )\n    else:\n        # Otherwise issue a simple DELETE since it's faster than TRUNCATE\n        # and preserves sequences.\n        sql.extend(\n            \"%s %s %s;\"\n            % (\n                style.SQL_KEYWORD(\"DELETE\"),\n                style.SQL_KEYWORD(\"FROM\"),\n                style.SQL_FIELD(self.quote_name(table_name)),\n            )\n            for table_name in tables\n        )\n    # Add CASCADE option if allow_cascade is True\n    if allow_cascade:\n        sql = [command.replace(';', ' CASCADE;') for command in sql]\n\n    return sql\n```\n\nMake sure to test the changes thoroughly, especially with respect to the `allow_cascade` option, as the behavior of `TRUNCATE ... CASCADE` is different from `DELETE ... CASCADE`.\n\nThis change should reduce the number of queries executed when flushing the database, which can lead to a performance improvement as requested in the ticket.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [db](https://github.com/testbed/django__django__3.1/tree//django/db) \u2192 [backends](https://github.com/testbed/django__django__3.1/tree//django/db/backends) \u2192 [postgresql](https://github.com/testbed/django__django__3.1/tree//django/db/backends/postgresql)- [Lines 227 - 287](https://github.com/testbed/django__django__3.1/blob//django/db/backends/postgresql/operations.py#L227-L287)\n\n This snippet contains PostgreSQL-specific sequence reset logic which is relevant to the issue of using TRUNCATE ... RESTART IDENTITY to reset sequences.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [management](https://github.com/testbed/django__django__3.1/tree//django/core/management)- [Lines 1 - 59](https://github.com/testbed/django__django__3.1/blob//django/core/management/sql.py#L1-L59)\n\n This snippet calls the sql_flush() function which is relevant to the issue as it is the operation that needs to be optimized.",
    "ai_cost": {
        "search_embedding": 1.3e-07,
        "issue_classifier": 0.0005205,
        "snippet_processor": 0.056010000000000004,
        "issue_star_creation": 0.02105,
        "issue_star_solver": 0.06346,
        "bouncer": 0.02602
    },
    "mayil_collected_data": {
        "status": "completed",
        "start_time": 1711731137.217217,
        "relevant_snippets": [
            {
                "code": "def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):\n        if not tables:\n            return []\n\n        sql = [\"SET FOREIGN_KEY_CHECKS = 0;\"]\n        if reset_sequences:\n            # It's faster to TRUNCATE tables that require a sequence reset\n            # since ALTER TABLE AUTO_INCREMENT is slower than TRUNCATE.\n            sql.extend(\n                \"%s %s;\"\n                % (\n                    style.SQL_KEYWORD(\"TRUNCATE\"),\n                    style.SQL_FIELD(self.quote_name(table_name)),\n                )\n                for table_name in tables\n            )\n        else:\n            # Otherwise issue a simple DELETE since it's faster than TRUNCATE\n            # and preserves sequences.\n            sql.extend(\n                \"%s %s %s;\"\n                % (\n                    style.SQL_KEYWORD(\"DELETE\"),\n                    style.SQL_KEYWORD(\"FROM\"),\n                    style.SQL_FIELD(self.quote_name(table_name)),\n                )\n                for table_name in tables\n            )\n        sql.append(\"SET FOREIGN_KEY_CHECKS = 1;\")\n        return sql\n\n    def sequence_reset_by_name_sql(self, style, sequences):\n        return [\n            \"%s %s %s %s = 1;\"\n            % (\n                style.SQL_KEYWORD(\"ALTER\"),\n                style.SQL_KEYWORD(\"TABLE\"),\n                style.SQL_FIELD(self.quote_name(sequence_info[\"table\"])),\n                style.SQL_FIELD(\"AUTO_INCREMENT\"),\n            )\n            for sequence_info in sequences\n        ]\n\n    def validate_autopk_value(self, value):\n        # Zero in AUTO_INCREMENT field does not work without the\n        # NO_AUTO_VALUE_ON_ZERO SQL mode.\n        if value == 0 and not self.connection.features.allows_auto_pk_0:\n            raise ValueError(\n                \"The database backend does not accept 0 as a value for AutoField.\"\n            )\n        return value\n\n    def adapt_datetimefield_value(self, value):\n        if value is None:\n            return None\n\n        # Expression values are adapted by the database.\n        if hasattr(value, \"resolve_expression\"):\n            return value\n\n        # MySQL doesn't support tz-aware datetimes\n        if timezone.is_aware(value):\n            if settings.USE_TZ:\n                value = timezone.make_naive(value, self.connection.timezone)\n            else:\n                raise ValueError(\n                    \"MySQL backend does not support timezone-aware datetimes when \"\n                    \"USE_TZ is False.\"\n                )\n        return str(value)\n\n    def adapt_timefield_value(self, value):\n        if value is None:\n            return None\n\n        # Expression values are adapted by the database.\n        if hasattr(value, \"resolve_expression\"):\n            return value\n\n        # MySQL doesn't support tz-aware times\n        if timezone.is_aware(value):\n            raise ValueError(\"MySQL backend does not support timezone-aware times.\")\n\n        return value.isoformat(timespec=\"microseconds\")",
                "filename": "django/db/backends/mysql/operations.py",
                "start_index": 8299,
                "end_index": 11294,
                "start_line": 203,
                "end_line": 286,
                "max_line": 464,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def sequence_reset_by_name_sql(self, style, sequences):\n        # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements\n        # to reset sequence indices\n        sql = []\n        for sequence_info in sequences:\n            table_name = sequence_info[\"table\"]\n            # 'id' will be the case if it's an m2m using an autogenerated\n            # intermediate table (see BaseDatabaseIntrospection.sequence_list).\n            column_name = sequence_info[\"column\"] or \"id\"\n            sql.append(\n                \"%s setval(pg_get_serial_sequence('%s','%s'), 1, false);\"\n                % (\n                    style.SQL_KEYWORD(\"SELECT\"),\n                    style.SQL_TABLE(self.quote_name(table_name)),\n                    style.SQL_FIELD(column_name),\n                )\n            )\n        return sql\n\n    def tablespace_sql(self, tablespace, inline=False):\n        if inline:\n            return \"USING INDEX TABLESPACE %s\" % self.quote_name(tablespace)\n        else:\n            return \"TABLESPACE %s\" % self.quote_name(tablespace)\n\n    def sequence_reset_sql(self, style, model_list):\n        from django.db import models\n\n        output = []\n        qn = self.quote_name\n        for model in model_list:\n            # Use `coalesce` to set the sequence for each model to the max pk\n            # value if there are records, or 1 if there are none. Set the\n            # `is_called` property (the third argument to `setval`) to true if\n            # there are records (as the max pk value is already in use),\n            # otherwise set it to false. Use pg_get_serial_sequence to get the\n            # underlying sequence name from the table name and column name.\n\n            for f in model._meta.local_fields:\n                if isinstance(f, models.AutoField):\n                    output.append(\n                        \"%s setval(pg_get_serial_sequence('%s','%s'), \"\n                        \"coalesce(max(%s), 1), max(%s) %s null) %s %s;\"\n                        % (\n                            style.SQL_KEYWORD(\"SELECT\"),\n                            style.SQL_TABLE(qn(model._meta.db_table)),\n                            style.SQL_FIELD(f.column),\n                            style.SQL_FIELD(qn(f.column)),\n                            style.SQL_FIELD(qn(f.column)),\n                            style.SQL_KEYWORD(\"IS NOT\"),\n                            style.SQL_KEYWORD(\"FROM\"),\n                            style.SQL_TABLE(qn(model._meta.db_table)),\n                        )\n                    )\n                    # Only one AutoField is allowed per model, so don't bother\n                    # continuing.\n                    break\n        return output\n\n    def prep_for_iexact_query(self, x):\n        return x",
                "filename": "django/db/backends/postgresql/operations.py",
                "start_index": 8229,
                "end_index": 10975,
                "start_line": 227,
                "end_line": 287,
                "max_line": 426,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.8
            },
            {
                "code": "def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):\n        if not tables:\n            return []\n\n        truncated_tables = {table.upper() for table in tables}\n        constraints = set()\n        # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE foreign\n        # keys which Django doesn't define. Emulate the PostgreSQL behavior\n        # which truncates all dependent tables by manually retrieving all\n        # foreign key constraints and resolving dependencies.\n        for table in tables:\n            for foreign_table, constraint in self._foreign_key_constraints(\n                table, recursive=allow_cascade\n            ):\n                if allow_cascade:\n                    truncated_tables.add(foreign_table)\n                constraints.add((foreign_table, constraint))\n        sql = (\n            [\n                \"%s %s %s %s %s %s %s %s;\"\n                % (\n                    style.SQL_KEYWORD(\"ALTER\"),\n                    style.SQL_KEYWORD(\"TABLE\"),\n                    style.SQL_FIELD(self.quote_name(table)),\n                    style.SQL_KEYWORD(\"DISABLE\"),\n                    style.SQL_KEYWORD(\"CONSTRAINT\"),\n                    style.SQL_FIELD(self.quote_name(constraint)),\n                    style.SQL_KEYWORD(\"KEEP\"),\n                    style.SQL_KEYWORD(\"INDEX\"),\n                )\n                for table, constraint in constraints\n            ]\n            + [\n                \"%s %s %s;\"\n                % (\n                    style.SQL_KEYWORD(\"TRUNCATE\"),\n                    style.SQL_KEYWORD(\"TABLE\"),\n                    style.SQL_FIELD(self.quote_name(table)),\n                )\n                for table in truncated_tables\n            ]\n            + [\n                \"%s %s %s %s %s %s;\"\n                % (\n                    style.SQL_KEYWORD(\"ALTER\"),\n                    style.SQL_KEYWORD(\"TABLE\"),\n                    style.SQL_FIELD(self.quote_name(table)),\n                    style.SQL_KEYWORD(\"ENABLE\"),\n                    style.SQL_KEYWORD(\"CONSTRAINT\"),\n                    style.SQL_FIELD(self.quote_name(constraint)),\n                )\n                for table, constraint in constraints\n            ]\n        )\n        if reset_sequences:\n            sequences = [\n                sequence\n                for sequence in self.connection.introspection.sequence_list()\n                if sequence[\"table\"].upper() in truncated_tables\n            ]\n            # Since we've just deleted all the rows, running our sequence ALTER\n            # code will reset the sequence to 0.\n            sql.extend(self.sequence_reset_by_name_sql(style, sequences))\n        return sql",
                "filename": "django/db/backends/oracle/operations.py",
                "start_index": 18420,
                "end_index": 21099,
                "start_line": 451,
                "end_line": 532,
                "max_line": 722,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "@cached_property\n    def _references_graph(self):\n        # 512 is large enough to fit the ~330 tables (as of this writing) in\n        # Django's test suite.\n        return lru_cache(maxsize=512)(self.__references_graph)\n\n    def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):\n        if tables and allow_cascade:\n            # Simulate TRUNCATE CASCADE by recursively collecting the tables\n            # referencing the tables to be flushed.\n            tables = set(\n                chain.from_iterable(self._references_graph(table) for table in tables)\n            )\n        sql = [\n            \"%s %s %s;\"\n            % (\n                style.SQL_KEYWORD(\"DELETE\"),\n                style.SQL_KEYWORD(\"FROM\"),\n                style.SQL_FIELD(self.quote_name(table)),\n            )\n            for table in tables\n        ]\n        if reset_sequences:\n            sequences = [{\"table\": table} for table in tables]\n            sql.extend(self.sequence_reset_by_name_sql(style, sequences))\n        return sql\n\n    def sequence_reset_by_name_sql(self, style, sequences):\n        if not sequences:\n            return []\n        return [\n            \"%s %s %s %s = 0 %s %s %s (%s);\"\n            % (\n                style.SQL_KEYWORD(\"UPDATE\"),\n                style.SQL_TABLE(self.quote_name(\"sqlite_sequence\")),\n                style.SQL_KEYWORD(\"SET\"),\n                style.SQL_FIELD(self.quote_name(\"seq\")),\n                style.SQL_KEYWORD(\"WHERE\"),\n                style.SQL_FIELD(self.quote_name(\"name\")),\n                style.SQL_KEYWORD(\"IN\"),\n                \", \".join(\n                    [\"'%s'\" % sequence_info[\"table\"] for sequence_info in sequences]\n                ),\n            ),\n        ]\n\n    def adapt_datetimefield_value(self, value):\n        if value is None:\n            return None\n\n        # Expression values are adapted by the database.\n        if hasattr(value, \"resolve_expression\"):\n            return value\n\n        # SQLite doesn't support tz-aware datetimes\n        if timezone.is_aware(value):\n            if settings.USE_TZ:\n                value = timezone.make_naive(value, self.connection.timezone)\n            else:\n                raise ValueError(\n                    \"SQLite backend does not support timezone-aware datetimes when \"\n                    \"USE_TZ is False.\"\n                )\n\n        return str(value)\n\n    def adapt_timefield_value(self, value):\n        if value is None:\n            return None\n\n        # Expression values are adapted by the database.\n        if hasattr(value, \"resolve_expression\"):\n            return value\n\n        # SQLite doesn't support tz-aware datetimes\n        if timezone.is_aware(value):\n            raise ValueError(\"SQLite backend does not support timezone-aware times.\")\n\n        return str(value)",
                "filename": "django/db/backends/sqlite3/operations.py",
                "start_index": 8325,
                "end_index": 11147,
                "start_line": 214,
                "end_line": 292,
                "max_line": 441,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "import sys\n\nfrom django.apps import apps\nfrom django.db import models\n\n\ndef sql_flush(style, connection, reset_sequences=True, allow_cascade=False):\n    \"\"\"\n    Return a list of the SQL statements used to flush the database.\n    \"\"\"\n    tables = connection.introspection.django_table_names(\n        only_existing=True, include_views=False\n    )\n    return connection.ops.sql_flush(\n        style,\n        tables,\n        reset_sequences=reset_sequences,\n        allow_cascade=allow_cascade,\n    )\n\n\ndef emit_pre_migrate_signal(verbosity, interactive, db, **kwargs):\n    # Emit the pre_migrate signal for every application.\n    for app_config in apps.get_app_configs():\n        if app_config.models_module is None:\n            continue\n        if verbosity >= 2:\n            stdout = kwargs.get(\"stdout\", sys.stdout)\n            stdout.write(\n                \"Running pre-migrate handlers for application %s\" % app_config.label\n            )\n        models.signals.pre_migrate.send(\n            sender=app_config,\n            app_config=app_config,\n            verbosity=verbosity,\n            interactive=interactive,\n            using=db,\n            **kwargs,\n        )\n\n\ndef emit_post_migrate_signal(verbosity, interactive, db, **kwargs):\n    # Emit the post_migrate signal for every application.\n    for app_config in apps.get_app_configs():\n        if app_config.models_module is None:\n            continue\n        if verbosity >= 2:\n            stdout = kwargs.get(\"stdout\", sys.stdout)\n            stdout.write(\n                \"Running post-migrate handlers for application %s\" % app_config.label\n            )\n        models.signals.post_migrate.send(\n            sender=app_config,\n            app_config=app_config,\n            verbosity=verbosity,\n            interactive=interactive,\n            using=db,\n            **kwargs,\n        )",
                "filename": "django/core/management/sql.py",
                "start_index": 0,
                "end_index": 1850,
                "start_line": 1,
                "end_line": 59,
                "max_line": 59,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.5
            },
            {
                "code": "def sequence_reset_by_name_sql(self, style, sequences):\n        sql = []\n        for sequence_info in sequences:\n            no_autofield_sequence_name = self._get_no_autofield_sequence_name(\n                sequence_info[\"table\"]\n            )\n            table = self.quote_name(sequence_info[\"table\"])\n            column = self.quote_name(sequence_info[\"column\"] or \"id\")\n            query = self._sequence_reset_sql % {\n                \"no_autofield_sequence_name\": no_autofield_sequence_name,\n                \"table\": table,\n                \"column\": column,\n                \"table_name\": strip_quotes(table),\n                \"column_name\": strip_quotes(column),\n            }\n            sql.append(query)\n        return sql\n\n    def sequence_reset_sql(self, style, model_list):\n        output = []\n        query = self._sequence_reset_sql\n        for model in model_list:\n            for f in model._meta.local_fields:\n                if isinstance(f, AutoField):\n                    no_autofield_sequence_name = self._get_no_autofield_sequence_name(\n                        model._meta.db_table\n                    )\n                    table = self.quote_name(model._meta.db_table)\n                    column = self.quote_name(f.column)\n                    output.append(\n                        query\n                        % {\n                            \"no_autofield_sequence_name\": no_autofield_sequence_name,\n                            \"table\": table,\n                            \"column\": column,\n                            \"table_name\": strip_quotes(table),\n                            \"column_name\": strip_quotes(column),\n                        }\n                    )\n                    # Only one AutoField is allowed per model, so don't\n                    # continue to loop\n                    break\n        return output\n\n    def start_transaction_sql(self):\n        return \"\"\n\n    def tablespace_sql(self, tablespace, inline=False):\n        if inline:\n            return \"USING INDEX TABLESPACE %s\" % self.quote_name(tablespace)\n        else:\n            return \"TABLESPACE %s\" % self.quote_name(tablespace)\n\n    def adapt_datefield_value(self, value):\n        \"\"\"\n        Transform a date value to an object compatible with what is expected\n        by the backend driver for date columns.\n        The default implementation transforms the date to text, but that is not\n        necessary for Oracle.\n        \"\"\"\n        return value",
                "filename": "django/db/backends/oracle/operations.py",
                "start_index": 21105,
                "end_index": 23567,
                "start_line": 516,
                "end_line": 627,
                "max_line": 722,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "integer_field_ranges = {\n        \"SmallIntegerField\": (-99999999999, 99999999999),\n        \"IntegerField\": (-99999999999, 99999999999),\n        \"BigIntegerField\": (-9999999999999999999, 9999999999999999999),\n        \"PositiveBigIntegerField\": (0, 9999999999999999999),\n        \"PositiveSmallIntegerField\": (0, 99999999999),\n        \"PositiveIntegerField\": (0, 99999999999),\n        \"SmallAutoField\": (-99999, 99999),\n        \"AutoField\": (-99999999999, 99999999999),\n        \"BigAutoField\": (-9999999999999999999, 9999999999999999999),\n    }\n    set_operators = {**BaseDatabaseOperations.set_operators, \"difference\": \"MINUS\"}\n\n    # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.\n    _sequence_reset_sql = \"\"\"\nDECLARE\n    table_value integer;\n    seq_value integer;\n    seq_name user_tab_identity_cols.sequence_name%%TYPE;\nBEGIN\n    BEGIN\n        SELECT sequence_name INTO seq_name FROM user_tab_identity_cols\n        WHERE  table_name = '%(table_name)s' AND\n               column_name = '%(column_name)s';\n        EXCEPTION WHEN NO_DATA_FOUND THEN\n            seq_name := '%(no_autofield_sequence_name)s';\n    END;\n\n    SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;\n    SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences\n           WHERE sequence_name = seq_name;\n    WHILE table_value > seq_value LOOP\n        EXECUTE IMMEDIATE 'SELECT \"'||seq_name||'\".nextval FROM DUAL'\n        INTO seq_value;\n    END LOOP;\nEND;\n/\"\"\"\n\n    # Oracle doesn't support string without precision; use the max string size.\n    cast_char_field_without_max_length = \"NVARCHAR2(2000)\"\n    cast_data_types = {\n        \"AutoField\": \"NUMBER(11)\",\n        \"BigAutoField\": \"NUMBER(19)\",\n        \"SmallAutoField\": \"NUMBER(5)\",\n        \"TextField\": cast_char_field_without_max_length,\n    }\n\n    def cache_key_culling_sql(self):\n        cache_key = self.quote_name(\"cache_key\")\n        return (\n            f\"SELECT {cache_key} \"\n            f\"FROM %s \"\n            f\"ORDER BY {cache_key} OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY\"\n        )\n\n    # EXTRACT format cannot be passed in parameters.\n    _extract_format_re = _lazy_re_compile(r\"[A-Z_]+\")",
                "filename": "django/db/backends/oracle/operations.py",
                "start_index": 1034,
                "end_index": 3206,
                "start_line": 25,
                "end_line": 81,
                "max_line": 722,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.0
            },
            {
                "code": "from django.core.management.base import AppCommand\nfrom django.db import DEFAULT_DB_ALIAS, connections\n\n\nclass Command(AppCommand):\n    help = (\n        \"Prints the SQL statements for resetting sequences for the given app name(s).\"\n    )\n\n    output_transaction = True\n\n    def add_arguments(self, parser):\n        super().add_arguments(parser)\n        parser.add_argument(\n            \"--database\",\n            default=DEFAULT_DB_ALIAS,\n            help=(\n                'Nominates a database to print the SQL for. Defaults to the \"default\" '\n                \"database.\"\n            ),\n        )\n\n    def handle_app_config(self, app_config, **options):\n        if app_config.models_module is None:\n            return\n        connection = connections[options[\"database\"]]\n        models = app_config.get_models(include_auto_created=True)\n        statements = connection.ops.sequence_reset_sql(self.style, models)\n        if not statements and options[\"verbosity\"] >= 1:\n            self.stderr.write(\"No sequences found.\")\n        return \"\\n\".join(statements)",
                "filename": "django/core/management/commands/sqlsequencereset.py",
                "start_index": 0,
                "end_index": 1060,
                "start_line": 1,
                "end_line": 31,
                "max_line": 31,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def _prepare_tzname_delta(self, tzname):\n        tzname, sign, offset = split_tzname_delta(tzname)\n        if offset:\n            sign = \"-\" if sign == \"+\" else \"+\"\n            return f\"{tzname}{sign}{offset}\"\n        return tzname\n\n    def _convert_sql_to_tz(self, sql, params, tzname):\n        if tzname and settings.USE_TZ:\n            tzname_param = self._prepare_tzname_delta(tzname)\n            return f\"{sql} AT TIME ZONE %s\", (*params, tzname_param)\n        return sql, params\n\n    def datetime_cast_date_sql(self, sql, params, tzname):\n        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n        return f\"({sql})::date\", params\n\n    def datetime_cast_time_sql(self, sql, params, tzname):\n        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n        return f\"({sql})::time\", params\n\n    def datetime_extract_sql(self, lookup_type, sql, params, tzname):\n        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n        if lookup_type == \"second\":\n            # Truncate fractional seconds.\n            return f\"EXTRACT(SECOND FROM DATE_TRUNC(%s, {sql}))\", (\"second\", *params)\n        return self.date_extract_sql(lookup_type, sql, params)\n\n    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):\n        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n        # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC\n        return f\"DATE_TRUNC(%s, {sql})\", (lookup_type, *params)\n\n    def time_extract_sql(self, lookup_type, sql, params):\n        if lookup_type == \"second\":\n            # Truncate fractional seconds.\n            return f\"EXTRACT(SECOND FROM DATE_TRUNC(%s, {sql}))\", (\"second\", *params)\n        return self.date_extract_sql(lookup_type, sql, params)\n\n    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):\n        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n        return f\"DATE_TRUNC(%s, {sql})::time\", (lookup_type, *params)\n\n    def deferrable_sql(self):\n        return \" DEFERRABLE INITIALLY DEFERRED\"\n\n    def fetch_returned_insert_rows(self, cursor):\n        \"\"\"\n        Given a cursor object that has just performed an INSERT...RETURNING\n        statement into a table, return the tuple of returned data.\n        \"\"\"\n        return cursor.fetchall()",
                "filename": "django/db/backends/postgresql/operations.py",
                "start_index": 3561,
                "end_index": 5868,
                "start_line": 102,
                "end_line": 153,
                "max_line": 426,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.2
            },
            {
                "code": "def handle(self, **options):\n        database = options[\"database\"]\n        connection = connections[database]\n        verbosity = options[\"verbosity\"]\n        interactive = options[\"interactive\"]\n        # The following are stealth options used by Django's internals.\n        reset_sequences = options.get(\"reset_sequences\", True)\n        allow_cascade = options.get(\"allow_cascade\", False)\n        inhibit_post_migrate = options.get(\"inhibit_post_migrate\", False)\n\n        self.style = no_style()\n\n        # Import the 'management' module within each installed app, to register\n        # dispatcher events.\n        for app_config in apps.get_app_configs():\n            try:\n                import_module(\".management\", app_config.name)\n            except ImportError:\n                pass\n\n        sql_list = sql_flush(\n            self.style,\n            connection,\n            reset_sequences=reset_sequences,\n            allow_cascade=allow_cascade,\n        )\n\n        if interactive:\n            confirm = input(\n                \"\"\"You have requested a flush of the database.\nThis will IRREVERSIBLY DESTROY all data currently in the \"%s\" database,\nand return each table to an empty state.\nAre you sure you want to do this?\n\n    Type 'yes' to continue, or 'no' to cancel: \"\"\"\n                % connection.settings_dict[\"NAME\"]\n            )\n        else:\n            confirm = \"yes\"\n\n        if confirm == \"yes\":\n            try:\n                connection.ops.execute_sql_flush(sql_list)\n            except Exception as exc:\n                raise CommandError(\n                    \"Database %s couldn't be flushed. Possible reasons:\\n\"\n                    \"  * The database isn't running or isn't configured correctly.\\n\"\n                    \"  * At least one of the expected database tables doesn't exist.\\n\"\n                    \"  * The SQL was invalid.\\n\"\n                    \"Hint: Look at the output of 'django-admin sqlflush'. \"\n                    \"That's the SQL this command wasn't able to run.\"\n                    % (connection.settings_dict[\"NAME\"],)\n                ) from exc\n\n            # Empty sql_list may signify an empty database and post_migrate\n            # would then crash.\n            if sql_list and not inhibit_post_migrate:\n                # Emit the post migrate signal. This allows individual applications to\n                # respond as if the database had been migrated from scratch.\n                emit_post_migrate_signal(verbosity, interactive, database)\n        else:\n            self.stdout.write(\"Flush cancelled.\")",
                "filename": "django/core/management/commands/flush.py",
                "start_index": 1048,
                "end_index": 3610,
                "start_line": 31,
                "end_line": 92,
                "max_line": 92,
                "git_instance": "github",
                "repo_name": "testbed/django__django__3.1",
                "sha": "",
                "context_relevance": 0.7
            }
        ],
        "classification": "feature request",
        "snippet_processor_task": {
            "django/db/backends/postgresql/operations.py": [
                {
                    "chunk": {
                        "code": "def sequence_reset_by_name_sql(self, style, sequences):\n        # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements\n        # to reset sequence indices\n        sql = []\n        for sequence_info in sequences:\n            table_name = sequence_info[\"table\"]\n            # 'id' will be the case if it's an m2m using an autogenerated\n            # intermediate table (see BaseDatabaseIntrospection.sequence_list).\n            column_name = sequence_info[\"column\"] or \"id\"\n            sql.append(\n                \"%s setval(pg_get_serial_sequence('%s','%s'), 1, false);\"\n                % (\n                    style.SQL_KEYWORD(\"SELECT\"),\n                    style.SQL_TABLE(self.quote_name(table_name)),\n                    style.SQL_FIELD(column_name),\n                )\n            )\n        return sql\n\n    def tablespace_sql(self, tablespace, inline=False):\n        if inline:\n            return \"USING INDEX TABLESPACE %s\" % self.quote_name(tablespace)\n        else:\n            return \"TABLESPACE %s\" % self.quote_name(tablespace)\n\n    def sequence_reset_sql(self, style, model_list):\n        from django.db import models\n\n        output = []\n        qn = self.quote_name\n        for model in model_list:\n            # Use `coalesce` to set the sequence for each model to the max pk\n            # value if there are records, or 1 if there are none. Set the\n            # `is_called` property (the third argument to `setval`) to true if\n            # there are records (as the max pk value is already in use),\n            # otherwise set it to false. Use pg_get_serial_sequence to get the\n            # underlying sequence name from the table name and column name.\n\n            for f in model._meta.local_fields:\n                if isinstance(f, models.AutoField):\n                    output.append(\n                        \"%s setval(pg_get_serial_sequence('%s','%s'), \"\n                        \"coalesce(max(%s), 1), max(%s) %s null) %s %s;\"\n                        % (\n                            style.SQL_KEYWORD(\"SELECT\"),\n                            style.SQL_TABLE(qn(model._meta.db_table)),\n                            style.SQL_FIELD(f.column),\n                            style.SQL_FIELD(qn(f.column)),\n                            style.SQL_FIELD(qn(f.column)),\n                            style.SQL_KEYWORD(\"IS NOT\"),\n                            style.SQL_KEYWORD(\"FROM\"),\n                            style.SQL_TABLE(qn(model._meta.db_table)),\n                        )\n                    )\n                    # Only one AutoField is allowed per model, so don't bother\n                    # continuing.\n                    break\n        return output\n\n    def prep_for_iexact_query(self, x):\n        return x",
                        "filename": "django/db/backends/postgresql/operations.py",
                        "start_index": 8229,
                        "end_index": 10975,
                        "start_line": 227,
                        "end_line": 287,
                        "max_line": 426,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet contains PostgreSQL-specific sequence reset logic which is relevant to the issue of using TRUNCATE ... RESTART IDENTITY to reset sequences."
                }
            ],
            "django/core/management/sql.py": [
                {
                    "chunk": {
                        "code": "import sys\n\nfrom django.apps import apps\nfrom django.db import models\n\n\ndef sql_flush(style, connection, reset_sequences=True, allow_cascade=False):\n    \"\"\"\n    Return a list of the SQL statements used to flush the database.\n    \"\"\"\n    tables = connection.introspection.django_table_names(\n        only_existing=True, include_views=False\n    )\n    return connection.ops.sql_flush(\n        style,\n        tables,\n        reset_sequences=reset_sequences,\n        allow_cascade=allow_cascade,\n    )\n\n\ndef emit_pre_migrate_signal(verbosity, interactive, db, **kwargs):\n    # Emit the pre_migrate signal for every application.\n    for app_config in apps.get_app_configs():\n        if app_config.models_module is None:\n            continue\n        if verbosity >= 2:\n            stdout = kwargs.get(\"stdout\", sys.stdout)\n            stdout.write(\n                \"Running pre-migrate handlers for application %s\" % app_config.label\n            )\n        models.signals.pre_migrate.send(\n            sender=app_config,\n            app_config=app_config,\n            verbosity=verbosity,\n            interactive=interactive,\n            using=db,\n            **kwargs,\n        )\n\n\ndef emit_post_migrate_signal(verbosity, interactive, db, **kwargs):\n    # Emit the post_migrate signal for every application.\n    for app_config in apps.get_app_configs():\n        if app_config.models_module is None:\n            continue\n        if verbosity >= 2:\n            stdout = kwargs.get(\"stdout\", sys.stdout)\n            stdout.write(\n                \"Running post-migrate handlers for application %s\" % app_config.label\n            )\n        models.signals.post_migrate.send(\n            sender=app_config,\n            app_config=app_config,\n            verbosity=verbosity,\n            interactive=interactive,\n            using=db,\n            **kwargs,\n        )",
                        "filename": "django/core/management/sql.py",
                        "start_index": 0,
                        "end_index": 1850,
                        "start_line": 1,
                        "end_line": 59,
                        "max_line": 59,
                        "git_instance": "github",
                        "repo_name": "testbed/django__django__3.1",
                        "sha": ""
                    },
                    "reason_for_relevance": "This snippet calls the sql_flush() function which is relevant to the issue as it is the operation that needs to be optimized."
                }
            ]
        },
        "solution_task": "To implement the feature request to use PostgreSQL's `TRUNCATE \u2026 RESTART IDENTITY` keyword to reset sequences in `sql_flush()`, you need to modify the PostgreSQL backend operations in Django. Here's how you can do it:\n\n- Locate the `sql_flush` method in the `django/db/backends/postgresql/operations.py` file.\n- Modify the method to include the `RESTART IDENTITY` clause when `reset_sequences` is `True`.\n- Ensure that the `TRUNCATE` command is used instead of `DELETE` when `reset_sequences` is `True`.\n\nHere's a code snippet that demonstrates the changes:\n\n```python\n# django/db/backends/postgresql/operations.py\n\ndef sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):\n    if not tables:\n        return []\n\n    sql = []\n    if reset_sequences:\n        # Use TRUNCATE with RESTART IDENTITY to reset sequences\n        sql.extend(\n            \"%s %s %s;\"\n            % (\n                style.SQL_KEYWORD(\"TRUNCATE\"),\n                style.SQL_FIELD(self.quote_name(table_name)),\n                style.SQL_KEYWORD(\"RESTART IDENTITY\"),\n            )\n            for table_name in tables\n        )\n    else:\n        # Otherwise issue a simple DELETE since it's faster than TRUNCATE\n        # and preserves sequences.\n        sql.extend(\n            \"%s %s %s;\"\n            % (\n                style.SQL_KEYWORD(\"DELETE\"),\n                style.SQL_KEYWORD(\"FROM\"),\n                style.SQL_FIELD(self.quote_name(table_name)),\n            )\n            for table_name in tables\n        )\n    # Add CASCADE option if allow_cascade is True\n    if allow_cascade:\n        sql = [command.replace(';', ' CASCADE;') for command in sql]\n\n    return sql\n```\n\nMake sure to test the changes thoroughly, especially with respect to the `allow_cascade` option, as the behavior of `TRUNCATE ... CASCADE` is different from `DELETE ... CASCADE`.\n\nThis change should reduce the number of queries executed when flushing the database, which can lead to a performance improvement as requested in the ticket.",
        "bouncer_response": {
            "score": 9,
            "criteria": "RESPONSES that are highly relevant, offering clear and comprehensive suggestions or solutions for the described feature request, should score between 7 and 9.",
            "supporting_evidence": "The RESPONSE provides a clear and detailed solution to the feature request of using PostgreSQL's TRUNCATE \nRESTART IDENTITY keyword to reset sequences in sql_flush(). It offers a step-by-step guide on how to modify the PostgreSQL backend operations in Django, including a code snippet that demonstrates the necessary changes. The RESPONSE also addresses the potential impact of the allow_cascade option and advises thorough testing, which shows a deep understanding of the subject matter. The inclusion of links to the relevant code snippets in the Django repository adds to the utility of the RESPONSE. The only reason it does not score a 10 is that it does not explicitly mention the potential need to handle any exceptions or edge cases that might arise from the changes, which would be part of a fully comprehensive solution.",
            "clarification_questions": "NONE"
        },
        "end_time": 1711731281.714184,
        "result": "To implement the feature request to use PostgreSQL's `TRUNCATE \u2026 RESTART IDENTITY` keyword to reset sequences in `sql_flush()`, you need to modify the PostgreSQL backend operations in Django. Here's how you can do it:\n\n- Locate the `sql_flush` method in the `django/db/backends/postgresql/operations.py` file.\n- Modify the method to include the `RESTART IDENTITY` clause when `reset_sequences` is `True`.\n- Ensure that the `TRUNCATE` command is used instead of `DELETE` when `reset_sequences` is `True`.\n\nHere's a code snippet that demonstrates the changes:\n\n```python\n# django/db/backends/postgresql/operations.py\n\ndef sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):\n    if not tables:\n        return []\n\n    sql = []\n    if reset_sequences:\n        # Use TRUNCATE with RESTART IDENTITY to reset sequences\n        sql.extend(\n            \"%s %s %s;\"\n            % (\n                style.SQL_KEYWORD(\"TRUNCATE\"),\n                style.SQL_FIELD(self.quote_name(table_name)),\n                style.SQL_KEYWORD(\"RESTART IDENTITY\"),\n            )\n            for table_name in tables\n        )\n    else:\n        # Otherwise issue a simple DELETE since it's faster than TRUNCATE\n        # and preserves sequences.\n        sql.extend(\n            \"%s %s %s;\"\n            % (\n                style.SQL_KEYWORD(\"DELETE\"),\n                style.SQL_KEYWORD(\"FROM\"),\n                style.SQL_FIELD(self.quote_name(table_name)),\n            )\n            for table_name in tables\n        )\n    # Add CASCADE option if allow_cascade is True\n    if allow_cascade:\n        sql = [command.replace(';', ' CASCADE;') for command in sql]\n\n    return sql\n```\n\nMake sure to test the changes thoroughly, especially with respect to the `allow_cascade` option, as the behavior of `TRUNCATE ... CASCADE` is different from `DELETE ... CASCADE`.\n\nThis change should reduce the number of queries executed when flushing the database, which can lead to a performance improvement as requested in the ticket.\n\n### Code snippets to check\n\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [db](https://github.com/testbed/django__django__3.1/tree//django/db) \u2192 [backends](https://github.com/testbed/django__django__3.1/tree//django/db/backends) \u2192 [postgresql](https://github.com/testbed/django__django__3.1/tree//django/db/backends/postgresql)- [Lines 227 - 287](https://github.com/testbed/django__django__3.1/blob//django/db/backends/postgresql/operations.py#L227-L287)\n\n This snippet contains PostgreSQL-specific sequence reset logic which is relevant to the issue of using TRUNCATE ... RESTART IDENTITY to reset sequences.\n-  \u2192 [django](https://github.com/testbed/django__django__3.1/tree//django) \u2192 [core](https://github.com/testbed/django__django__3.1/tree//django/core) \u2192 [management](https://github.com/testbed/django__django__3.1/tree//django/core/management)- [Lines 1 - 59](https://github.com/testbed/django__django__3.1/blob//django/core/management/sql.py#L1-L59)\n\n This snippet calls the sql_flush() function which is relevant to the issue as it is the operation that needs to be optimized.",
        "context_relevance": 0.32,
        "hypotheses": [],
        "groundedness_score": 1.0,
        "qa_relevance_reasons": {
            "reason": "Criteria: The RESPONSE is relevant to the entire PROMPT and answers the PROMPT completely.\nSupporting Evidence: The RESPONSE provides a detailed explanation of how to implement the `TRUNCATE \u2026 RESTART IDENTITY` keyword in the `sql_flush()` method, which is exactly what the PROMPT is requesting. It includes a step-by-step guide, a code snippet, and even addresses potential concerns with the `allow_cascade` option. Additionally, it provides links to the relevant code snippets for further reference. The RESPONSE is directly related to the performance improvement mentioned in the PROMPT by reducing the number of queries executed."
        },
        "qa_relevance": 1.0
    }
}